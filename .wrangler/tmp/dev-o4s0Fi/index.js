var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod4) => function __require() {
  return mod4 || (0, cb[__getOwnPropNames(cb)[0]])((mod4 = { exports: {} }).exports, mod4), mod4.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod4, isNodeMode, target) => (target = mod4 != null ? __create(__getProtoOf(mod4)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod4 || !mod4.__esModule ? __defProp(target, "default", { value: mod4, enumerable: true }) : target,
  mod4
));
var __toCommonJS = (mod4) => __copyProps(__defProp({}, "__esModule", { value: true }), mod4);

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/_internal/utils.mjs
// @__NO_SIDE_EFFECTS__
function rawHeaders(headers) {
  const rawHeaders2 = [];
  for (const key in headers) {
    if (Array.isArray(headers[key])) {
      for (const h of headers[key]) {
        rawHeaders2.push(key, h);
      }
    } else {
      rawHeaders2.push(key, headers[key]);
    }
  }
  return rawHeaders2;
}
// @__NO_SIDE_EFFECTS__
function createNotImplementedError(name) {
  return new Error(`[unenv] ${name} is not implemented yet!`);
}
// @__NO_SIDE_EFFECTS__
function notImplemented(name) {
  const fn = /* @__PURE__ */ __name(() => {
    throw /* @__PURE__ */ createNotImplementedError(name);
  }, "fn");
  return Object.assign(fn, { __unenv__: true });
}
// @__NO_SIDE_EFFECTS__
function notImplementedAsync(name) {
  const fn = /* @__PURE__ */ notImplemented(name);
  fn.__promisify__ = () => /* @__PURE__ */ notImplemented(name + ".__promisify__");
  fn.native = fn;
  return fn;
}
// @__NO_SIDE_EFFECTS__
function notImplementedClass(name) {
  return class {
    __unenv__ = true;
    constructor() {
      throw new Error(`[unenv] ${name} is not implemented yet!`);
    }
  };
}
var init_utils = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/_internal/utils.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(rawHeaders, "rawHeaders");
    __name(createNotImplementedError, "createNotImplementedError");
    __name(notImplemented, "notImplemented");
    __name(notImplementedAsync, "notImplementedAsync");
    __name(notImplementedClass, "notImplementedClass");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs
var _timeOrigin, _performanceNow, nodeTiming, PerformanceEntry, PerformanceMark, PerformanceMeasure, PerformanceResourceTiming, PerformanceObserverEntryList, Performance, PerformanceObserver, performance;
var init_performance = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/perf_hooks/performance.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    _timeOrigin = globalThis.performance?.timeOrigin ?? Date.now();
    _performanceNow = globalThis.performance?.now ? globalThis.performance.now.bind(globalThis.performance) : () => Date.now() - _timeOrigin;
    nodeTiming = {
      name: "node",
      entryType: "node",
      startTime: 0,
      duration: 0,
      nodeStart: 0,
      v8Start: 0,
      bootstrapComplete: 0,
      environment: 0,
      loopStart: 0,
      loopExit: 0,
      idleTime: 0,
      uvMetricsInfo: {
        loopCount: 0,
        events: 0,
        eventsWaiting: 0
      },
      detail: void 0,
      toJSON() {
        return this;
      }
    };
    PerformanceEntry = class {
      static {
        __name(this, "PerformanceEntry");
      }
      __unenv__ = true;
      detail;
      entryType = "event";
      name;
      startTime;
      constructor(name, options) {
        this.name = name;
        this.startTime = options?.startTime || _performanceNow();
        this.detail = options?.detail;
      }
      get duration() {
        return _performanceNow() - this.startTime;
      }
      toJSON() {
        return {
          name: this.name,
          entryType: this.entryType,
          startTime: this.startTime,
          duration: this.duration,
          detail: this.detail
        };
      }
    };
    PerformanceMark = class PerformanceMark2 extends PerformanceEntry {
      static {
        __name(this, "PerformanceMark");
      }
      entryType = "mark";
      constructor() {
        super(...arguments);
      }
      get duration() {
        return 0;
      }
    };
    PerformanceMeasure = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceMeasure");
      }
      entryType = "measure";
    };
    PerformanceResourceTiming = class extends PerformanceEntry {
      static {
        __name(this, "PerformanceResourceTiming");
      }
      entryType = "resource";
      serverTiming = [];
      connectEnd = 0;
      connectStart = 0;
      decodedBodySize = 0;
      domainLookupEnd = 0;
      domainLookupStart = 0;
      encodedBodySize = 0;
      fetchStart = 0;
      initiatorType = "";
      name = "";
      nextHopProtocol = "";
      redirectEnd = 0;
      redirectStart = 0;
      requestStart = 0;
      responseEnd = 0;
      responseStart = 0;
      secureConnectionStart = 0;
      startTime = 0;
      transferSize = 0;
      workerStart = 0;
      responseStatus = 0;
    };
    PerformanceObserverEntryList = class {
      static {
        __name(this, "PerformanceObserverEntryList");
      }
      __unenv__ = true;
      getEntries() {
        return [];
      }
      getEntriesByName(_name, _type) {
        return [];
      }
      getEntriesByType(type2) {
        return [];
      }
    };
    Performance = class {
      static {
        __name(this, "Performance");
      }
      __unenv__ = true;
      timeOrigin = _timeOrigin;
      eventCounts = /* @__PURE__ */ new Map();
      _entries = [];
      _resourceTimingBufferSize = 0;
      navigation = void 0;
      timing = void 0;
      timerify(_fn, _options) {
        throw createNotImplementedError("Performance.timerify");
      }
      get nodeTiming() {
        return nodeTiming;
      }
      eventLoopUtilization() {
        return {};
      }
      markResourceTiming() {
        return new PerformanceResourceTiming("");
      }
      onresourcetimingbufferfull = null;
      now() {
        if (this.timeOrigin === _timeOrigin) {
          return _performanceNow();
        }
        return Date.now() - this.timeOrigin;
      }
      clearMarks(markName) {
        this._entries = markName ? this._entries.filter((e) => e.name !== markName) : this._entries.filter((e) => e.entryType !== "mark");
      }
      clearMeasures(measureName) {
        this._entries = measureName ? this._entries.filter((e) => e.name !== measureName) : this._entries.filter((e) => e.entryType !== "measure");
      }
      clearResourceTimings() {
        this._entries = this._entries.filter((e) => e.entryType !== "resource" || e.entryType !== "navigation");
      }
      getEntries() {
        return this._entries;
      }
      getEntriesByName(name, type2) {
        return this._entries.filter((e) => e.name === name && (!type2 || e.entryType === type2));
      }
      getEntriesByType(type2) {
        return this._entries.filter((e) => e.entryType === type2);
      }
      mark(name, options) {
        const entry = new PerformanceMark(name, options);
        this._entries.push(entry);
        return entry;
      }
      measure(measureName, startOrMeasureOptions, endMark) {
        let start;
        let end;
        if (typeof startOrMeasureOptions === "string") {
          start = this.getEntriesByName(startOrMeasureOptions, "mark")[0]?.startTime;
          end = this.getEntriesByName(endMark, "mark")[0]?.startTime;
        } else {
          start = Number.parseFloat(startOrMeasureOptions?.start) || this.now();
          end = Number.parseFloat(startOrMeasureOptions?.end) || this.now();
        }
        const entry = new PerformanceMeasure(measureName, {
          startTime: start,
          detail: {
            start,
            end
          }
        });
        this._entries.push(entry);
        return entry;
      }
      setResourceTimingBufferSize(maxSize) {
        this._resourceTimingBufferSize = maxSize;
      }
      addEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.addEventListener");
      }
      removeEventListener(type2, listener, options) {
        throw createNotImplementedError("Performance.removeEventListener");
      }
      dispatchEvent(event) {
        throw createNotImplementedError("Performance.dispatchEvent");
      }
      toJSON() {
        return this;
      }
    };
    PerformanceObserver = class {
      static {
        __name(this, "PerformanceObserver");
      }
      __unenv__ = true;
      static supportedEntryTypes = [];
      _callback = null;
      constructor(callback) {
        this._callback = callback;
      }
      takeRecords() {
        return [];
      }
      disconnect() {
        throw createNotImplementedError("PerformanceObserver.disconnect");
      }
      observe(options) {
        throw createNotImplementedError("PerformanceObserver.observe");
      }
      bind(fn) {
        return fn;
      }
      runInAsyncScope(fn, thisArg, ...args) {
        return fn.call(thisArg, ...args);
      }
      asyncId() {
        return 0;
      }
      triggerAsyncId() {
        return 0;
      }
      emitDestroy() {
        return this;
      }
    };
    performance = globalThis.performance && "addEventListener" in globalThis.performance ? globalThis.performance : new Performance();
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/perf_hooks.mjs
var init_perf_hooks = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/perf_hooks.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_performance();
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs
var init_performance2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/polyfill/performance.mjs"() {
    init_perf_hooks();
    globalThis.performance = performance;
    globalThis.Performance = Performance;
    globalThis.PerformanceEntry = PerformanceEntry;
    globalThis.PerformanceMark = PerformanceMark;
    globalThis.PerformanceMeasure = PerformanceMeasure;
    globalThis.PerformanceObserver = PerformanceObserver;
    globalThis.PerformanceObserverEntryList = PerformanceObserverEntryList;
    globalThis.PerformanceResourceTiming = PerformanceResourceTiming;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/mock/noop.mjs
var noop_default;
var init_noop = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/mock/noop.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop_default = Object.assign(() => {
    }, { __unenv__: true });
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/console.mjs
import { Writable } from "node:stream";
var _console, _ignoreErrors, _stderr, _stdout, log, info, trace, debug, table, error, warn, createTask, clear, count, countReset, dir, dirxml, group, groupEnd, groupCollapsed, profile, profileEnd, time, timeEnd, timeLog, timeStamp, Console, _times, _stdoutErrorHandler, _stderrErrorHandler;
var init_console = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_noop();
    init_utils();
    _console = globalThis.console;
    _ignoreErrors = true;
    _stderr = new Writable();
    _stdout = new Writable();
    log = _console?.log ?? noop_default;
    info = _console?.info ?? log;
    trace = _console?.trace ?? info;
    debug = _console?.debug ?? log;
    table = _console?.table ?? log;
    error = _console?.error ?? log;
    warn = _console?.warn ?? error;
    createTask = _console?.createTask ?? /* @__PURE__ */ notImplemented("console.createTask");
    clear = _console?.clear ?? noop_default;
    count = _console?.count ?? noop_default;
    countReset = _console?.countReset ?? noop_default;
    dir = _console?.dir ?? noop_default;
    dirxml = _console?.dirxml ?? noop_default;
    group = _console?.group ?? noop_default;
    groupEnd = _console?.groupEnd ?? noop_default;
    groupCollapsed = _console?.groupCollapsed ?? noop_default;
    profile = _console?.profile ?? noop_default;
    profileEnd = _console?.profileEnd ?? noop_default;
    time = _console?.time ?? noop_default;
    timeEnd = _console?.timeEnd ?? noop_default;
    timeLog = _console?.timeLog ?? noop_default;
    timeStamp = _console?.timeStamp ?? noop_default;
    Console = _console?.Console ?? /* @__PURE__ */ notImplementedClass("console.Console");
    _times = /* @__PURE__ */ new Map();
    _stdoutErrorHandler = noop_default;
    _stderrErrorHandler = noop_default;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs
var workerdConsole, assert, clear2, context, count2, countReset2, createTask2, debug2, dir2, dirxml2, error2, group2, groupCollapsed2, groupEnd2, info2, log2, profile2, profileEnd2, table2, time2, timeEnd2, timeLog2, timeStamp2, trace2, warn2, console_default;
var init_console2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/console.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_console();
    workerdConsole = globalThis["console"];
    ({
      assert,
      clear: clear2,
      context: (
        // @ts-expect-error undocumented public API
        context
      ),
      count: count2,
      countReset: countReset2,
      createTask: (
        // @ts-expect-error undocumented public API
        createTask2
      ),
      debug: debug2,
      dir: dir2,
      dirxml: dirxml2,
      error: error2,
      group: group2,
      groupCollapsed: groupCollapsed2,
      groupEnd: groupEnd2,
      info: info2,
      log: log2,
      profile: profile2,
      profileEnd: profileEnd2,
      table: table2,
      time: time2,
      timeEnd: timeEnd2,
      timeLog: timeLog2,
      timeStamp: timeStamp2,
      trace: trace2,
      warn: warn2
    } = workerdConsole);
    Object.assign(workerdConsole, {
      Console,
      _ignoreErrors,
      _stderr,
      _stderrErrorHandler,
      _stdout,
      _stdoutErrorHandler,
      _times
    });
    console_default = workerdConsole;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-console"() {
    init_console2();
    globalThis.console = console_default;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs
var hrtime;
var init_hrtime = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/hrtime.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    hrtime = /* @__PURE__ */ Object.assign(/* @__PURE__ */ __name(function hrtime2(startTime) {
      const now = Date.now();
      const seconds = Math.trunc(now / 1e3);
      const nanos = now % 1e3 * 1e6;
      if (startTime) {
        let diffSeconds = seconds - startTime[0];
        let diffNanos = nanos - startTime[0];
        if (diffNanos < 0) {
          diffSeconds = diffSeconds - 1;
          diffNanos = 1e9 + diffNanos;
        }
        return [diffSeconds, diffNanos];
      }
      return [seconds, nanos];
    }, "hrtime"), { bigint: /* @__PURE__ */ __name(function bigint() {
      return BigInt(Date.now() * 1e6);
    }, "bigint") });
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs
var WriteStream;
var init_write_stream = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/write-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    WriteStream = class {
      static {
        __name(this, "WriteStream");
      }
      fd;
      columns = 80;
      rows = 24;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      clearLine(dir3, callback) {
        callback && callback();
        return false;
      }
      clearScreenDown(callback) {
        callback && callback();
        return false;
      }
      cursorTo(x, y, callback) {
        callback && typeof callback === "function" && callback();
        return false;
      }
      moveCursor(dx, dy, callback) {
        callback && callback();
        return false;
      }
      getColorDepth(env2) {
        return 1;
      }
      hasColors(count3, env2) {
        return false;
      }
      getWindowSize() {
        return [this.columns, this.rows];
      }
      write(str, encoding, cb) {
        if (str instanceof Uint8Array) {
          str = new TextDecoder().decode(str);
        }
        try {
          console.log(str);
        } catch {
        }
        cb && typeof cb === "function" && cb();
        return false;
      }
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs
var ReadStream;
var init_read_stream = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tty/read-stream.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ReadStream = class {
      static {
        __name(this, "ReadStream");
      }
      fd;
      isRaw = false;
      isTTY = false;
      constructor(fd) {
        this.fd = fd;
      }
      setRawMode(mode) {
        this.isRaw = mode;
        return this;
      }
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tty.mjs
var init_tty = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tty.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_read_stream();
    init_write_stream();
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/process.mjs
import { EventEmitter } from "node:events";
var Process;
var init_process = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/process/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tty();
    init_utils();
    Process = class _Process extends EventEmitter {
      static {
        __name(this, "Process");
      }
      env;
      hrtime;
      nextTick;
      constructor(impl) {
        super();
        this.env = impl.env;
        this.hrtime = impl.hrtime;
        this.nextTick = impl.nextTick;
        for (const prop of [...Object.getOwnPropertyNames(_Process.prototype), ...Object.getOwnPropertyNames(EventEmitter.prototype)]) {
          const value = this[prop];
          if (typeof value === "function") {
            this[prop] = value.bind(this);
          }
        }
      }
      emitWarning(warning, type2, code) {
        console.warn(`${code ? `[${code}] ` : ""}${type2 ? `${type2}: ` : ""}${warning}`);
      }
      emit(...args) {
        return super.emit(...args);
      }
      listeners(eventName) {
        return super.listeners(eventName);
      }
      #stdin;
      #stdout;
      #stderr;
      get stdin() {
        return this.#stdin ??= new ReadStream(0);
      }
      get stdout() {
        return this.#stdout ??= new WriteStream(1);
      }
      get stderr() {
        return this.#stderr ??= new WriteStream(2);
      }
      #cwd = "/";
      chdir(cwd2) {
        this.#cwd = cwd2;
      }
      cwd() {
        return this.#cwd;
      }
      arch = "";
      platform = "";
      argv = [];
      argv0 = "";
      execArgv = [];
      execPath = "";
      title = "";
      pid = 200;
      ppid = 100;
      get version() {
        return "";
      }
      get versions() {
        return {};
      }
      get allowedNodeEnvironmentFlags() {
        return /* @__PURE__ */ new Set();
      }
      get sourceMapsEnabled() {
        return false;
      }
      get debugPort() {
        return 0;
      }
      get throwDeprecation() {
        return false;
      }
      get traceDeprecation() {
        return false;
      }
      get features() {
        return {};
      }
      get release() {
        return {};
      }
      get connected() {
        return false;
      }
      get config() {
        return {};
      }
      get moduleLoadList() {
        return [];
      }
      constrainedMemory() {
        return 0;
      }
      availableMemory() {
        return 0;
      }
      uptime() {
        return 0;
      }
      resourceUsage() {
        return {};
      }
      ref() {
      }
      unref() {
      }
      umask() {
        throw createNotImplementedError("process.umask");
      }
      getBuiltinModule() {
        return void 0;
      }
      getActiveResourcesInfo() {
        throw createNotImplementedError("process.getActiveResourcesInfo");
      }
      exit() {
        throw createNotImplementedError("process.exit");
      }
      reallyExit() {
        throw createNotImplementedError("process.reallyExit");
      }
      kill() {
        throw createNotImplementedError("process.kill");
      }
      abort() {
        throw createNotImplementedError("process.abort");
      }
      dlopen() {
        throw createNotImplementedError("process.dlopen");
      }
      setSourceMapsEnabled() {
        throw createNotImplementedError("process.setSourceMapsEnabled");
      }
      loadEnvFile() {
        throw createNotImplementedError("process.loadEnvFile");
      }
      disconnect() {
        throw createNotImplementedError("process.disconnect");
      }
      cpuUsage() {
        throw createNotImplementedError("process.cpuUsage");
      }
      setUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.setUncaughtExceptionCaptureCallback");
      }
      hasUncaughtExceptionCaptureCallback() {
        throw createNotImplementedError("process.hasUncaughtExceptionCaptureCallback");
      }
      initgroups() {
        throw createNotImplementedError("process.initgroups");
      }
      openStdin() {
        throw createNotImplementedError("process.openStdin");
      }
      assert() {
        throw createNotImplementedError("process.assert");
      }
      binding() {
        throw createNotImplementedError("process.binding");
      }
      permission = { has: /* @__PURE__ */ notImplemented("process.permission.has") };
      report = {
        directory: "",
        filename: "",
        signal: "SIGUSR2",
        compact: false,
        reportOnFatalError: false,
        reportOnSignal: false,
        reportOnUncaughtException: false,
        getReport: /* @__PURE__ */ notImplemented("process.report.getReport"),
        writeReport: /* @__PURE__ */ notImplemented("process.report.writeReport")
      };
      finalization = {
        register: /* @__PURE__ */ notImplemented("process.finalization.register"),
        unregister: /* @__PURE__ */ notImplemented("process.finalization.unregister"),
        registerBeforeExit: /* @__PURE__ */ notImplemented("process.finalization.registerBeforeExit")
      };
      memoryUsage = Object.assign(() => ({
        arrayBuffers: 0,
        rss: 0,
        external: 0,
        heapTotal: 0,
        heapUsed: 0
      }), { rss: /* @__PURE__ */ __name(() => 0, "rss") });
      mainModule = void 0;
      domain = void 0;
      send = void 0;
      exitCode = void 0;
      channel = void 0;
      getegid = void 0;
      geteuid = void 0;
      getgid = void 0;
      getgroups = void 0;
      getuid = void 0;
      setegid = void 0;
      seteuid = void 0;
      setgid = void 0;
      setgroups = void 0;
      setuid = void 0;
      _events = void 0;
      _eventsCount = void 0;
      _exiting = void 0;
      _maxListeners = void 0;
      _debugEnd = void 0;
      _debugProcess = void 0;
      _fatalException = void 0;
      _getActiveHandles = void 0;
      _getActiveRequests = void 0;
      _kill = void 0;
      _preload_modules = void 0;
      _rawDebug = void 0;
      _startProfilerIdleNotifier = void 0;
      _stopProfilerIdleNotifier = void 0;
      _tickCallback = void 0;
      _disconnect = void 0;
      _handleQueue = void 0;
      _pendingMessage = void 0;
      _channel = void 0;
      _send = void 0;
      _linkedBinding = void 0;
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs
var globalProcess, getBuiltinModule, exit, platform, nextTick, unenvProcess, abort, addListener, allowedNodeEnvironmentFlags, hasUncaughtExceptionCaptureCallback, setUncaughtExceptionCaptureCallback, loadEnvFile, sourceMapsEnabled, arch, argv, argv0, chdir, config, connected, constrainedMemory, availableMemory, cpuUsage, cwd, debugPort, dlopen, disconnect, emit, emitWarning, env, eventNames, execArgv, execPath, finalization, features, getActiveResourcesInfo, getMaxListeners, hrtime3, kill, listeners, listenerCount, memoryUsage, on, off, once, pid, ppid, prependListener, prependOnceListener, rawListeners, release, removeAllListeners, removeListener, report, resourceUsage, setMaxListeners, setSourceMapsEnabled, stderr, stdin, stdout, title, throwDeprecation, traceDeprecation, umask, uptime, version, versions, domain, initgroups, moduleLoadList, reallyExit, openStdin, assert2, binding, send, exitCode, channel, getegid, geteuid, getgid, getgroups, getuid, setegid, seteuid, setgid, setgroups, setuid, permission, mainModule, _events, _eventsCount, _exiting, _maxListeners, _debugEnd, _debugProcess, _fatalException, _getActiveHandles, _getActiveRequests, _kill, _preload_modules, _rawDebug, _startProfilerIdleNotifier, _stopProfilerIdleNotifier, _tickCallback, _disconnect, _handleQueue, _pendingMessage, _channel, _send, _linkedBinding, _process, process_default;
var init_process2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_hrtime();
    init_process();
    globalProcess = globalThis["process"];
    getBuiltinModule = globalProcess.getBuiltinModule;
    ({ exit, platform, nextTick } = getBuiltinModule(
      "node:process"
    ));
    unenvProcess = new Process({
      env: globalProcess.env,
      hrtime,
      nextTick
    });
    ({
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      finalization,
      features,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      on,
      off,
      once,
      pid,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    } = unenvProcess);
    _process = {
      abort,
      addListener,
      allowedNodeEnvironmentFlags,
      hasUncaughtExceptionCaptureCallback,
      setUncaughtExceptionCaptureCallback,
      loadEnvFile,
      sourceMapsEnabled,
      arch,
      argv,
      argv0,
      chdir,
      config,
      connected,
      constrainedMemory,
      availableMemory,
      cpuUsage,
      cwd,
      debugPort,
      dlopen,
      disconnect,
      emit,
      emitWarning,
      env,
      eventNames,
      execArgv,
      execPath,
      exit,
      finalization,
      features,
      getBuiltinModule,
      getActiveResourcesInfo,
      getMaxListeners,
      hrtime: hrtime3,
      kill,
      listeners,
      listenerCount,
      memoryUsage,
      nextTick,
      on,
      off,
      once,
      pid,
      platform,
      ppid,
      prependListener,
      prependOnceListener,
      rawListeners,
      release,
      removeAllListeners,
      removeListener,
      report,
      resourceUsage,
      setMaxListeners,
      setSourceMapsEnabled,
      stderr,
      stdin,
      stdout,
      title,
      throwDeprecation,
      traceDeprecation,
      umask,
      uptime,
      version,
      versions,
      // @ts-expect-error old API
      domain,
      initgroups,
      moduleLoadList,
      reallyExit,
      openStdin,
      assert: assert2,
      binding,
      send,
      exitCode,
      channel,
      getegid,
      geteuid,
      getgid,
      getgroups,
      getuid,
      setegid,
      seteuid,
      setgid,
      setgroups,
      setuid,
      permission,
      mainModule,
      _events,
      _eventsCount,
      _exiting,
      _maxListeners,
      _debugEnd,
      _debugProcess,
      _fatalException,
      _getActiveHandles,
      _getActiveRequests,
      _kill,
      _preload_modules,
      _rawDebug,
      _startProfilerIdleNotifier,
      _stopProfilerIdleNotifier,
      _tickCallback,
      _disconnect,
      _handleQueue,
      _pendingMessage,
      _channel,
      _send,
      _linkedBinding
    };
    process_default = _process;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process
var init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/_virtual_unenv_global_polyfill-@cloudflare-unenv-preset-node-process"() {
    init_process2();
    globalThis.process = process_default;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs
var access, copyFile, cp, open, opendir, rename, truncate, rm, rmdir, mkdir, readdir, readlink, symlink, lstat, stat, link, unlink, chmod, lchmod, lchown, chown, utimes, lutimes, realpath, mkdtemp, writeFile, appendFile, readFile, watch, statfs, glob;
var init_promises = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/promises.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    access = /* @__PURE__ */ notImplemented("fs.access");
    copyFile = /* @__PURE__ */ notImplemented("fs.copyFile");
    cp = /* @__PURE__ */ notImplemented("fs.cp");
    open = /* @__PURE__ */ notImplemented("fs.open");
    opendir = /* @__PURE__ */ notImplemented("fs.opendir");
    rename = /* @__PURE__ */ notImplemented("fs.rename");
    truncate = /* @__PURE__ */ notImplemented("fs.truncate");
    rm = /* @__PURE__ */ notImplemented("fs.rm");
    rmdir = /* @__PURE__ */ notImplemented("fs.rmdir");
    mkdir = /* @__PURE__ */ notImplemented("fs.mkdir");
    readdir = /* @__PURE__ */ notImplemented("fs.readdir");
    readlink = /* @__PURE__ */ notImplemented("fs.readlink");
    symlink = /* @__PURE__ */ notImplemented("fs.symlink");
    lstat = /* @__PURE__ */ notImplemented("fs.lstat");
    stat = /* @__PURE__ */ notImplemented("fs.stat");
    link = /* @__PURE__ */ notImplemented("fs.link");
    unlink = /* @__PURE__ */ notImplemented("fs.unlink");
    chmod = /* @__PURE__ */ notImplemented("fs.chmod");
    lchmod = /* @__PURE__ */ notImplemented("fs.lchmod");
    lchown = /* @__PURE__ */ notImplemented("fs.lchown");
    chown = /* @__PURE__ */ notImplemented("fs.chown");
    utimes = /* @__PURE__ */ notImplemented("fs.utimes");
    lutimes = /* @__PURE__ */ notImplemented("fs.lutimes");
    realpath = /* @__PURE__ */ notImplemented("fs.realpath");
    mkdtemp = /* @__PURE__ */ notImplemented("fs.mkdtemp");
    writeFile = /* @__PURE__ */ notImplemented("fs.writeFile");
    appendFile = /* @__PURE__ */ notImplemented("fs.appendFile");
    readFile = /* @__PURE__ */ notImplemented("fs.readFile");
    watch = /* @__PURE__ */ notImplemented("fs.watch");
    statfs = /* @__PURE__ */ notImplemented("fs.statfs");
    glob = /* @__PURE__ */ notImplemented("fs.glob");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs
var constants_exports = {};
__export(constants_exports, {
  COPYFILE_EXCL: () => COPYFILE_EXCL,
  COPYFILE_FICLONE: () => COPYFILE_FICLONE,
  COPYFILE_FICLONE_FORCE: () => COPYFILE_FICLONE_FORCE,
  EXTENSIONLESS_FORMAT_JAVASCRIPT: () => EXTENSIONLESS_FORMAT_JAVASCRIPT,
  EXTENSIONLESS_FORMAT_WASM: () => EXTENSIONLESS_FORMAT_WASM,
  F_OK: () => F_OK,
  O_APPEND: () => O_APPEND,
  O_CREAT: () => O_CREAT,
  O_DIRECT: () => O_DIRECT,
  O_DIRECTORY: () => O_DIRECTORY,
  O_DSYNC: () => O_DSYNC,
  O_EXCL: () => O_EXCL,
  O_NOATIME: () => O_NOATIME,
  O_NOCTTY: () => O_NOCTTY,
  O_NOFOLLOW: () => O_NOFOLLOW,
  O_NONBLOCK: () => O_NONBLOCK,
  O_RDONLY: () => O_RDONLY,
  O_RDWR: () => O_RDWR,
  O_SYNC: () => O_SYNC,
  O_TRUNC: () => O_TRUNC,
  O_WRONLY: () => O_WRONLY,
  R_OK: () => R_OK,
  S_IFBLK: () => S_IFBLK,
  S_IFCHR: () => S_IFCHR,
  S_IFDIR: () => S_IFDIR,
  S_IFIFO: () => S_IFIFO,
  S_IFLNK: () => S_IFLNK,
  S_IFMT: () => S_IFMT,
  S_IFREG: () => S_IFREG,
  S_IFSOCK: () => S_IFSOCK,
  S_IRGRP: () => S_IRGRP,
  S_IROTH: () => S_IROTH,
  S_IRUSR: () => S_IRUSR,
  S_IRWXG: () => S_IRWXG,
  S_IRWXO: () => S_IRWXO,
  S_IRWXU: () => S_IRWXU,
  S_IWGRP: () => S_IWGRP,
  S_IWOTH: () => S_IWOTH,
  S_IWUSR: () => S_IWUSR,
  S_IXGRP: () => S_IXGRP,
  S_IXOTH: () => S_IXOTH,
  S_IXUSR: () => S_IXUSR,
  UV_DIRENT_BLOCK: () => UV_DIRENT_BLOCK,
  UV_DIRENT_CHAR: () => UV_DIRENT_CHAR,
  UV_DIRENT_DIR: () => UV_DIRENT_DIR,
  UV_DIRENT_FIFO: () => UV_DIRENT_FIFO,
  UV_DIRENT_FILE: () => UV_DIRENT_FILE,
  UV_DIRENT_LINK: () => UV_DIRENT_LINK,
  UV_DIRENT_SOCKET: () => UV_DIRENT_SOCKET,
  UV_DIRENT_UNKNOWN: () => UV_DIRENT_UNKNOWN,
  UV_FS_COPYFILE_EXCL: () => UV_FS_COPYFILE_EXCL,
  UV_FS_COPYFILE_FICLONE: () => UV_FS_COPYFILE_FICLONE,
  UV_FS_COPYFILE_FICLONE_FORCE: () => UV_FS_COPYFILE_FICLONE_FORCE,
  UV_FS_O_FILEMAP: () => UV_FS_O_FILEMAP,
  UV_FS_SYMLINK_DIR: () => UV_FS_SYMLINK_DIR,
  UV_FS_SYMLINK_JUNCTION: () => UV_FS_SYMLINK_JUNCTION,
  W_OK: () => W_OK,
  X_OK: () => X_OK
});
var UV_FS_SYMLINK_DIR, UV_FS_SYMLINK_JUNCTION, O_RDONLY, O_WRONLY, O_RDWR, UV_DIRENT_UNKNOWN, UV_DIRENT_FILE, UV_DIRENT_DIR, UV_DIRENT_LINK, UV_DIRENT_FIFO, UV_DIRENT_SOCKET, UV_DIRENT_CHAR, UV_DIRENT_BLOCK, EXTENSIONLESS_FORMAT_JAVASCRIPT, EXTENSIONLESS_FORMAT_WASM, S_IFMT, S_IFREG, S_IFDIR, S_IFCHR, S_IFBLK, S_IFIFO, S_IFLNK, S_IFSOCK, O_CREAT, O_EXCL, UV_FS_O_FILEMAP, O_NOCTTY, O_TRUNC, O_APPEND, O_DIRECTORY, O_NOATIME, O_NOFOLLOW, O_SYNC, O_DSYNC, O_DIRECT, O_NONBLOCK, S_IRWXU, S_IRUSR, S_IWUSR, S_IXUSR, S_IRWXG, S_IRGRP, S_IWGRP, S_IXGRP, S_IRWXO, S_IROTH, S_IWOTH, S_IXOTH, F_OK, R_OK, W_OK, X_OK, UV_FS_COPYFILE_EXCL, COPYFILE_EXCL, UV_FS_COPYFILE_FICLONE, COPYFILE_FICLONE, UV_FS_COPYFILE_FICLONE_FORCE, COPYFILE_FICLONE_FORCE;
var init_constants = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_FS_SYMLINK_DIR = 1;
    UV_FS_SYMLINK_JUNCTION = 2;
    O_RDONLY = 0;
    O_WRONLY = 1;
    O_RDWR = 2;
    UV_DIRENT_UNKNOWN = 0;
    UV_DIRENT_FILE = 1;
    UV_DIRENT_DIR = 2;
    UV_DIRENT_LINK = 3;
    UV_DIRENT_FIFO = 4;
    UV_DIRENT_SOCKET = 5;
    UV_DIRENT_CHAR = 6;
    UV_DIRENT_BLOCK = 7;
    EXTENSIONLESS_FORMAT_JAVASCRIPT = 0;
    EXTENSIONLESS_FORMAT_WASM = 1;
    S_IFMT = 61440;
    S_IFREG = 32768;
    S_IFDIR = 16384;
    S_IFCHR = 8192;
    S_IFBLK = 24576;
    S_IFIFO = 4096;
    S_IFLNK = 40960;
    S_IFSOCK = 49152;
    O_CREAT = 64;
    O_EXCL = 128;
    UV_FS_O_FILEMAP = 0;
    O_NOCTTY = 256;
    O_TRUNC = 512;
    O_APPEND = 1024;
    O_DIRECTORY = 65536;
    O_NOATIME = 262144;
    O_NOFOLLOW = 131072;
    O_SYNC = 1052672;
    O_DSYNC = 4096;
    O_DIRECT = 16384;
    O_NONBLOCK = 2048;
    S_IRWXU = 448;
    S_IRUSR = 256;
    S_IWUSR = 128;
    S_IXUSR = 64;
    S_IRWXG = 56;
    S_IRGRP = 32;
    S_IWGRP = 16;
    S_IXGRP = 8;
    S_IRWXO = 7;
    S_IROTH = 4;
    S_IWOTH = 2;
    S_IXOTH = 1;
    F_OK = 0;
    R_OK = 4;
    W_OK = 2;
    X_OK = 1;
    UV_FS_COPYFILE_EXCL = 1;
    COPYFILE_EXCL = 1;
    UV_FS_COPYFILE_FICLONE = 2;
    COPYFILE_FICLONE = 2;
    UV_FS_COPYFILE_FICLONE_FORCE = 4;
    COPYFILE_FICLONE_FORCE = 4;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/fs/promises.mjs
var promises_default;
var init_promises2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/fs/promises.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises();
    init_constants();
    init_promises();
    promises_default = {
      constants: constants_exports,
      access,
      appendFile,
      chmod,
      chown,
      copyFile,
      cp,
      glob,
      lchmod,
      lchown,
      link,
      lstat,
      lutimes,
      mkdir,
      mkdtemp,
      open,
      opendir,
      readFile,
      readdir,
      readlink,
      realpath,
      rename,
      rm,
      rmdir,
      stat,
      statfs,
      symlink,
      truncate,
      unlink,
      utimes,
      watch,
      writeFile
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs
var Dir, Dirent, Stats, ReadStream2, WriteStream2, FileReadStream, FileWriteStream;
var init_classes = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/classes.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    Dir = /* @__PURE__ */ notImplementedClass("fs.Dir");
    Dirent = /* @__PURE__ */ notImplementedClass("fs.Dirent");
    Stats = /* @__PURE__ */ notImplementedClass("fs.Stats");
    ReadStream2 = /* @__PURE__ */ notImplementedClass("fs.ReadStream");
    WriteStream2 = /* @__PURE__ */ notImplementedClass("fs.WriteStream");
    FileReadStream = ReadStream2;
    FileWriteStream = WriteStream2;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs
function callbackify(fn) {
  const fnc = /* @__PURE__ */ __name(function(...args) {
    const cb = args.pop();
    fn().catch((error3) => cb(error3)).then((val) => cb(void 0, val));
  }, "fnc");
  fnc.__promisify__ = fn;
  fnc.native = fnc;
  return fnc;
}
var access2, appendFile2, chown2, chmod2, copyFile2, cp2, lchown2, lchmod2, link2, lstat2, lutimes2, mkdir2, mkdtemp2, realpath2, open2, opendir2, readdir2, readFile2, readlink2, rename2, rm2, rmdir2, stat2, symlink2, truncate2, unlink2, utimes2, writeFile2, statfs2, close, createReadStream, createWriteStream, exists, fchown, fchmod, fdatasync, fstat, fsync, ftruncate, futimes, lstatSync, read, readv, realpathSync, statSync, unwatchFile, watch2, watchFile, write, writev, _toUnixTimestamp, openAsBlob, glob2, appendFileSync, accessSync, chownSync, chmodSync, closeSync, copyFileSync, cpSync, existsSync, fchownSync, fchmodSync, fdatasyncSync, fstatSync, fsyncSync, ftruncateSync, futimesSync, lchownSync, lchmodSync, linkSync, lutimesSync, mkdirSync, mkdtempSync, openSync, opendirSync, readdirSync, readSync, readvSync, readFileSync, readlinkSync, renameSync, rmSync, rmdirSync, symlinkSync, truncateSync, unlinkSync, utimesSync, writeFileSync, writeSync, writevSync, statfsSync, globSync;
var init_fs = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/fs/fs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_promises();
    __name(callbackify, "callbackify");
    access2 = callbackify(access);
    appendFile2 = callbackify(appendFile);
    chown2 = callbackify(chown);
    chmod2 = callbackify(chmod);
    copyFile2 = callbackify(copyFile);
    cp2 = callbackify(cp);
    lchown2 = callbackify(lchown);
    lchmod2 = callbackify(lchmod);
    link2 = callbackify(link);
    lstat2 = callbackify(lstat);
    lutimes2 = callbackify(lutimes);
    mkdir2 = callbackify(mkdir);
    mkdtemp2 = callbackify(mkdtemp);
    realpath2 = callbackify(realpath);
    open2 = callbackify(open);
    opendir2 = callbackify(opendir);
    readdir2 = callbackify(readdir);
    readFile2 = callbackify(readFile);
    readlink2 = callbackify(readlink);
    rename2 = callbackify(rename);
    rm2 = callbackify(rm);
    rmdir2 = callbackify(rmdir);
    stat2 = callbackify(stat);
    symlink2 = callbackify(symlink);
    truncate2 = callbackify(truncate);
    unlink2 = callbackify(unlink);
    utimes2 = callbackify(utimes);
    writeFile2 = callbackify(writeFile);
    statfs2 = callbackify(statfs);
    close = /* @__PURE__ */ notImplementedAsync("fs.close");
    createReadStream = /* @__PURE__ */ notImplementedAsync("fs.createReadStream");
    createWriteStream = /* @__PURE__ */ notImplementedAsync("fs.createWriteStream");
    exists = /* @__PURE__ */ notImplementedAsync("fs.exists");
    fchown = /* @__PURE__ */ notImplementedAsync("fs.fchown");
    fchmod = /* @__PURE__ */ notImplementedAsync("fs.fchmod");
    fdatasync = /* @__PURE__ */ notImplementedAsync("fs.fdatasync");
    fstat = /* @__PURE__ */ notImplementedAsync("fs.fstat");
    fsync = /* @__PURE__ */ notImplementedAsync("fs.fsync");
    ftruncate = /* @__PURE__ */ notImplementedAsync("fs.ftruncate");
    futimes = /* @__PURE__ */ notImplementedAsync("fs.futimes");
    lstatSync = /* @__PURE__ */ notImplementedAsync("fs.lstatSync");
    read = /* @__PURE__ */ notImplementedAsync("fs.read");
    readv = /* @__PURE__ */ notImplementedAsync("fs.readv");
    realpathSync = /* @__PURE__ */ notImplementedAsync("fs.realpathSync");
    statSync = /* @__PURE__ */ notImplementedAsync("fs.statSync");
    unwatchFile = /* @__PURE__ */ notImplementedAsync("fs.unwatchFile");
    watch2 = /* @__PURE__ */ notImplementedAsync("fs.watch");
    watchFile = /* @__PURE__ */ notImplementedAsync("fs.watchFile");
    write = /* @__PURE__ */ notImplementedAsync("fs.write");
    writev = /* @__PURE__ */ notImplementedAsync("fs.writev");
    _toUnixTimestamp = /* @__PURE__ */ notImplementedAsync("fs._toUnixTimestamp");
    openAsBlob = /* @__PURE__ */ notImplementedAsync("fs.openAsBlob");
    glob2 = /* @__PURE__ */ notImplementedAsync("fs.glob");
    appendFileSync = /* @__PURE__ */ notImplemented("fs.appendFileSync");
    accessSync = /* @__PURE__ */ notImplemented("fs.accessSync");
    chownSync = /* @__PURE__ */ notImplemented("fs.chownSync");
    chmodSync = /* @__PURE__ */ notImplemented("fs.chmodSync");
    closeSync = /* @__PURE__ */ notImplemented("fs.closeSync");
    copyFileSync = /* @__PURE__ */ notImplemented("fs.copyFileSync");
    cpSync = /* @__PURE__ */ notImplemented("fs.cpSync");
    existsSync = /* @__PURE__ */ __name(() => false, "existsSync");
    fchownSync = /* @__PURE__ */ notImplemented("fs.fchownSync");
    fchmodSync = /* @__PURE__ */ notImplemented("fs.fchmodSync");
    fdatasyncSync = /* @__PURE__ */ notImplemented("fs.fdatasyncSync");
    fstatSync = /* @__PURE__ */ notImplemented("fs.fstatSync");
    fsyncSync = /* @__PURE__ */ notImplemented("fs.fsyncSync");
    ftruncateSync = /* @__PURE__ */ notImplemented("fs.ftruncateSync");
    futimesSync = /* @__PURE__ */ notImplemented("fs.futimesSync");
    lchownSync = /* @__PURE__ */ notImplemented("fs.lchownSync");
    lchmodSync = /* @__PURE__ */ notImplemented("fs.lchmodSync");
    linkSync = /* @__PURE__ */ notImplemented("fs.linkSync");
    lutimesSync = /* @__PURE__ */ notImplemented("fs.lutimesSync");
    mkdirSync = /* @__PURE__ */ notImplemented("fs.mkdirSync");
    mkdtempSync = /* @__PURE__ */ notImplemented("fs.mkdtempSync");
    openSync = /* @__PURE__ */ notImplemented("fs.openSync");
    opendirSync = /* @__PURE__ */ notImplemented("fs.opendirSync");
    readdirSync = /* @__PURE__ */ notImplemented("fs.readdirSync");
    readSync = /* @__PURE__ */ notImplemented("fs.readSync");
    readvSync = /* @__PURE__ */ notImplemented("fs.readvSync");
    readFileSync = /* @__PURE__ */ notImplemented("fs.readFileSync");
    readlinkSync = /* @__PURE__ */ notImplemented("fs.readlinkSync");
    renameSync = /* @__PURE__ */ notImplemented("fs.renameSync");
    rmSync = /* @__PURE__ */ notImplemented("fs.rmSync");
    rmdirSync = /* @__PURE__ */ notImplemented("fs.rmdirSync");
    symlinkSync = /* @__PURE__ */ notImplemented("fs.symlinkSync");
    truncateSync = /* @__PURE__ */ notImplemented("fs.truncateSync");
    unlinkSync = /* @__PURE__ */ notImplemented("fs.unlinkSync");
    utimesSync = /* @__PURE__ */ notImplemented("fs.utimesSync");
    writeFileSync = /* @__PURE__ */ notImplemented("fs.writeFileSync");
    writeSync = /* @__PURE__ */ notImplemented("fs.writeSync");
    writevSync = /* @__PURE__ */ notImplemented("fs.writevSync");
    statfsSync = /* @__PURE__ */ notImplemented("fs.statfsSync");
    globSync = /* @__PURE__ */ notImplemented("fs.globSync");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/fs.mjs
var fs_default;
var init_fs2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/fs.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_promises2();
    init_classes();
    init_fs();
    init_constants();
    init_constants();
    init_fs();
    init_classes();
    fs_default = {
      F_OK,
      R_OK,
      W_OK,
      X_OK,
      constants: constants_exports,
      promises: promises_default,
      Dir,
      Dirent,
      FileReadStream,
      FileWriteStream,
      ReadStream: ReadStream2,
      Stats,
      WriteStream: WriteStream2,
      _toUnixTimestamp,
      access: access2,
      accessSync,
      appendFile: appendFile2,
      appendFileSync,
      chmod: chmod2,
      chmodSync,
      chown: chown2,
      chownSync,
      close,
      closeSync,
      copyFile: copyFile2,
      copyFileSync,
      cp: cp2,
      cpSync,
      createReadStream,
      createWriteStream,
      exists,
      existsSync,
      fchmod,
      fchmodSync,
      fchown,
      fchownSync,
      fdatasync,
      fdatasyncSync,
      fstat,
      fstatSync,
      fsync,
      fsyncSync,
      ftruncate,
      ftruncateSync,
      futimes,
      futimesSync,
      glob: glob2,
      lchmod: lchmod2,
      globSync,
      lchmodSync,
      lchown: lchown2,
      lchownSync,
      link: link2,
      linkSync,
      lstat: lstat2,
      lstatSync,
      lutimes: lutimes2,
      lutimesSync,
      mkdir: mkdir2,
      mkdirSync,
      mkdtemp: mkdtemp2,
      mkdtempSync,
      open: open2,
      openAsBlob,
      openSync,
      opendir: opendir2,
      opendirSync,
      read,
      readFile: readFile2,
      readFileSync,
      readSync,
      readdir: readdir2,
      readdirSync,
      readlink: readlink2,
      readlinkSync,
      readv,
      readvSync,
      realpath: realpath2,
      realpathSync,
      rename: rename2,
      renameSync,
      rm: rm2,
      rmSync,
      rmdir: rmdir2,
      rmdirSync,
      stat: stat2,
      statSync,
      statfs: statfs2,
      statfsSync,
      symlink: symlink2,
      symlinkSync,
      truncate: truncate2,
      truncateSync,
      unlink: unlink2,
      unlinkSync,
      unwatchFile,
      utimes: utimes2,
      utimesSync,
      watch: watch2,
      watchFile,
      write,
      writeFile: writeFile2,
      writeFileSync,
      writeSync,
      writev,
      writevSync
    };
  }
});

// node-built-in-modules:fs
var require_fs = __commonJS({
  "node-built-in-modules:fs"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fs2();
    module.exports = fs_default;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/child_process.mjs
var ChildProcess, _forkChild, exec, execFile, execFileSync, execSync, fork, spawn, spawnSync, child_process_default;
var init_child_process = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/child_process.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    ChildProcess = /* @__PURE__ */ notImplementedClass("child_process.ChildProcess");
    _forkChild = /* @__PURE__ */ notImplemented("child_process.ChildProcess");
    exec = /* @__PURE__ */ notImplemented("child_process.exec");
    execFile = /* @__PURE__ */ notImplemented("child_process.execFile");
    execFileSync = /* @__PURE__ */ notImplemented("child_process.execFileSync");
    execSync = /* @__PURE__ */ notImplemented("child_process.execSyn");
    fork = /* @__PURE__ */ notImplemented("child_process.fork");
    spawn = /* @__PURE__ */ notImplemented("child_process.spawn");
    spawnSync = /* @__PURE__ */ notImplemented("child_process.spawnSync");
    child_process_default = {
      ChildProcess,
      _forkChild,
      exec,
      execFile,
      execFileSync,
      execSync,
      fork,
      spawn,
      spawnSync
    };
  }
});

// node-built-in-modules:child_process
var require_child_process = __commonJS({
  "node-built-in-modules:child_process"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_child_process();
    module.exports = child_process_default;
  }
});

// node_modules/extend/index.js
var require_extend = __commonJS({
  "node_modules/extend/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var hasOwn = Object.prototype.hasOwnProperty;
    var toStr = Object.prototype.toString;
    var defineProperty = Object.defineProperty;
    var gOPD = Object.getOwnPropertyDescriptor;
    var isArray2 = /* @__PURE__ */ __name(function isArray3(arr) {
      if (typeof Array.isArray === "function") {
        return Array.isArray(arr);
      }
      return toStr.call(arr) === "[object Array]";
    }, "isArray");
    var isPlainObject = /* @__PURE__ */ __name(function isPlainObject2(obj) {
      if (!obj || toStr.call(obj) !== "[object Object]") {
        return false;
      }
      var hasOwnConstructor = hasOwn.call(obj, "constructor");
      var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, "isPrototypeOf");
      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }
      var key;
      for (key in obj) {
      }
      return typeof key === "undefined" || hasOwn.call(obj, key);
    }, "isPlainObject");
    var setProperty = /* @__PURE__ */ __name(function setProperty2(target, options) {
      if (defineProperty && options.name === "__proto__") {
        defineProperty(target, options.name, {
          enumerable: true,
          configurable: true,
          value: options.newValue,
          writable: true
        });
      } else {
        target[options.name] = options.newValue;
      }
    }, "setProperty");
    var getProperty = /* @__PURE__ */ __name(function getProperty2(obj, name) {
      if (name === "__proto__") {
        if (!hasOwn.call(obj, name)) {
          return void 0;
        } else if (gOPD) {
          return gOPD(obj, name).value;
        }
      }
      return obj[name];
    }, "getProperty");
    module.exports = /* @__PURE__ */ __name(function extend() {
      var options, name, src, copy, copyIsArray, clone2;
      var target = arguments[0];
      var i = 1;
      var length = arguments.length;
      var deep = false;
      if (typeof target === "boolean") {
        deep = target;
        target = arguments[1] || {};
        i = 2;
      }
      if (target == null || typeof target !== "object" && typeof target !== "function") {
        target = {};
      }
      for (; i < length; ++i) {
        options = arguments[i];
        if (options != null) {
          for (name in options) {
            src = getProperty(target, name);
            copy = getProperty(options, name);
            if (target !== copy) {
              if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray2(copy)))) {
                if (copyIsArray) {
                  copyIsArray = false;
                  clone2 = src && isArray2(src) ? src : [];
                } else {
                  clone2 = src && isPlainObject(src) ? src : {};
                }
                setProperty(target, { name, newValue: extend(deep, clone2, copy) });
              } else if (typeof copy !== "undefined") {
                setProperty(target, { name, newValue: copy });
              }
            }
          }
        }
      }
      return target;
    }, "extend");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/agent.mjs
import { EventEmitter as EventEmitter2 } from "node:events";
var Agent;
var init_agent = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/agent.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Agent = class extends EventEmitter2 {
      static {
        __name(this, "Agent");
      }
      __unenv__ = {};
      maxFreeSockets = 256;
      maxSockets = Infinity;
      maxTotalSockets = Infinity;
      freeSockets = {};
      sockets = {};
      requests = {};
      destroy() {
      }
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/https.mjs
var Server, Agent2, globalAgent, get, createServer, request, https_default;
var init_https = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/https.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_agent();
    Server = /* @__PURE__ */ notImplementedClass("https.Server");
    Agent2 = Agent;
    globalAgent = /* @__PURE__ */ new Agent2();
    get = /* @__PURE__ */ notImplemented("https.get");
    createServer = /* @__PURE__ */ notImplemented("https.createServer");
    request = /* @__PURE__ */ notImplemented("https.request");
    https_default = {
      Server,
      Agent: Agent2,
      globalAgent,
      get,
      createServer,
      request
    };
  }
});

// node-built-in-modules:https
var require_https = __commonJS({
  "node-built-in-modules:https"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_https();
    module.exports = https_default;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/npm/node-fetch.mjs
var node_fetch_exports = {};
__export(node_fetch_exports, {
  AbortController: () => AbortController2,
  AbortError: () => AbortError,
  FetchError: () => FetchError,
  Headers: () => Headers,
  Request: () => Request,
  Response: () => Response2,
  default: () => node_fetch_default,
  fetch: () => fetch2,
  isRedirect: () => isRedirect
});
var fetch2, Headers, Request, Response2, AbortController2, FetchError, AbortError, redirectStatus, isRedirect, node_fetch_default;
var init_node_fetch = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/npm/node-fetch.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    fetch2 = /* @__PURE__ */ __name((...args) => globalThis.fetch(...args), "fetch");
    Headers = globalThis.Headers;
    Request = globalThis.Request;
    Response2 = globalThis.Response;
    AbortController2 = globalThis.AbortController;
    FetchError = Error;
    AbortError = Error;
    redirectStatus = /* @__PURE__ */ new Set([
      301,
      302,
      303,
      307,
      308
    ]);
    isRedirect = /* @__PURE__ */ __name((code) => redirectStatus.has(code), "isRedirect");
    fetch2.Promise = globalThis.Promise;
    fetch2.isRedirect = isRedirect;
    node_fetch_default = fetch2;
  }
});

// required-unenv-alias:node-fetch
var require_node_fetch = __commonJS({
  "required-unenv-alias:node-fetch"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_node_fetch();
    module.exports = Object.entries(node_fetch_exports).filter(([k]) => k !== "default").reduce(
      (cjs, [k, value]) => Object.defineProperty(cjs, k, { value, enumerable: true }),
      "default" in node_fetch_exports ? node_fetch_default : {}
    );
  }
});

// node-built-in-modules:querystring
import libDefault from "querystring";
var require_querystring = __commonJS({
  "node-built-in-modules:querystring"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault;
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var isStream = /* @__PURE__ */ __name((stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function", "isStream");
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module.exports = isStream;
  }
});

// node-built-in-modules:url
import libDefault2 from "url";
var require_url = __commonJS({
  "node-built-in-modules:url"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault2;
  }
});

// node_modules/gaxios/package.json
var require_package = __commonJS({
  "node_modules/gaxios/package.json"(exports, module) {
    module.exports = {
      name: "gaxios",
      version: "6.7.1",
      description: "A simple common HTTP client specifically for Google APIs and services.",
      main: "build/src/index.js",
      types: "build/src/index.d.ts",
      files: [
        "build/src"
      ],
      scripts: {
        lint: "gts check",
        test: "c8 mocha build/test",
        "presystem-test": "npm run compile",
        "system-test": "mocha build/system-test --timeout 80000",
        compile: "tsc -p .",
        fix: "gts fix",
        prepare: "npm run compile",
        pretest: "npm run compile",
        webpack: "webpack",
        "prebrowser-test": "npm run compile",
        "browser-test": "node build/browser-test/browser-test-runner.js",
        docs: "compodoc src/",
        "docs-test": "linkinator docs",
        "predocs-test": "npm run docs",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        prelint: "cd samples; npm link ../; npm install",
        clean: "gts clean",
        precompile: "gts clean"
      },
      repository: "googleapis/gaxios",
      keywords: [
        "google"
      ],
      engines: {
        node: ">=14"
      },
      author: "Google, LLC",
      license: "Apache-2.0",
      devDependencies: {
        "@babel/plugin-proposal-private-methods": "^7.18.6",
        "@compodoc/compodoc": "1.1.19",
        "@types/cors": "^2.8.6",
        "@types/express": "^4.16.1",
        "@types/extend": "^3.0.1",
        "@types/mocha": "^9.0.0",
        "@types/multiparty": "0.0.36",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^20.0.0",
        "@types/node-fetch": "^2.5.7",
        "@types/sinon": "^17.0.0",
        "@types/tmp": "0.2.6",
        "@types/uuid": "^10.0.0",
        "abort-controller": "^3.0.0",
        assert: "^2.0.0",
        browserify: "^17.0.0",
        c8: "^8.0.0",
        cheerio: "1.0.0-rc.10",
        cors: "^2.8.5",
        execa: "^5.0.0",
        express: "^4.16.4",
        "form-data": "^4.0.0",
        gts: "^5.0.0",
        "is-docker": "^2.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-remap-coverage": "^0.1.5",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "5.0.0",
        linkinator: "^3.0.0",
        mocha: "^8.0.0",
        multiparty: "^4.2.1",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^13.0.0",
        "null-loader": "^4.0.0",
        puppeteer: "^19.0.0",
        sinon: "^18.0.0",
        "stream-browserify": "^3.0.0",
        tmp: "0.2.3",
        "ts-loader": "^8.0.0",
        typescript: "^5.1.6",
        webpack: "^5.35.0",
        "webpack-cli": "^4.0.0"
      },
      dependencies: {
        extend: "^3.0.2",
        "https-proxy-agent": "^7.0.1",
        "is-stream": "^2.0.0",
        "node-fetch": "^2.6.9",
        uuid: "^9.0.1"
      }
    };
  }
});

// node_modules/gaxios/build/src/util.js
var require_util = __commonJS({
  "node_modules/gaxios/build/src/util.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pkg = void 0;
    exports.pkg = require_package();
  }
});

// node_modules/gaxios/build/src/common.js
var require_common = __commonJS({
  "node_modules/gaxios/build/src/common.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    var _a;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaxiosError = exports.GAXIOS_ERROR_SYMBOL = void 0;
    exports.defaultErrorRedactor = defaultErrorRedactor;
    var url_1 = require_url();
    var util_1 = require_util();
    var extend_1 = __importDefault(require_extend());
    exports.GAXIOS_ERROR_SYMBOL = Symbol.for(`${util_1.pkg.name}-gaxios-error`);
    var GaxiosError = class _GaxiosError extends Error {
      static {
        __name(this, "GaxiosError");
      }
      /**
       * Support `instanceof` operator for `GaxiosError` across builds/duplicated files.
       *
       * @see {@link GAXIOS_ERROR_SYMBOL}
       * @see {@link GaxiosError[GAXIOS_ERROR_SYMBOL]}
       */
      static [(_a = exports.GAXIOS_ERROR_SYMBOL, Symbol.hasInstance)](instance) {
        if (instance && typeof instance === "object" && exports.GAXIOS_ERROR_SYMBOL in instance && instance[exports.GAXIOS_ERROR_SYMBOL] === util_1.pkg.version) {
          return true;
        }
        return Function.prototype[Symbol.hasInstance].call(_GaxiosError, instance);
      }
      constructor(message2, config2, response, error3) {
        var _b;
        super(message2);
        this.config = config2;
        this.response = response;
        this.error = error3;
        this[_a] = util_1.pkg.version;
        this.config = (0, extend_1.default)(true, {}, config2);
        if (this.response) {
          this.response.config = (0, extend_1.default)(true, {}, this.response.config);
        }
        if (this.response) {
          try {
            this.response.data = translateData(this.config.responseType, (_b = this.response) === null || _b === void 0 ? void 0 : _b.data);
          } catch (_c) {
          }
          this.status = this.response.status;
        }
        if (error3 && "code" in error3 && error3.code) {
          this.code = error3.code;
        }
        if (config2.errorRedactor) {
          config2.errorRedactor({
            config: this.config,
            response: this.response
          });
        }
      }
    };
    exports.GaxiosError = GaxiosError;
    function translateData(responseType, data) {
      switch (responseType) {
        case "stream":
          return data;
        case "json":
          return JSON.parse(JSON.stringify(data));
        case "arraybuffer":
          return JSON.parse(Buffer.from(data).toString("utf8"));
        case "blob":
          return JSON.parse(data.text());
        default:
          return data;
      }
    }
    __name(translateData, "translateData");
    function defaultErrorRedactor(data) {
      const REDACT = "<<REDACTED> - See `errorRedactor` option in `gaxios` for configuration>.";
      function redactHeaders(headers) {
        if (!headers)
          return;
        for (const key of Object.keys(headers)) {
          if (/^authentication$/i.test(key)) {
            headers[key] = REDACT;
          }
          if (/^authorization$/i.test(key)) {
            headers[key] = REDACT;
          }
          if (/secret/i.test(key)) {
            headers[key] = REDACT;
          }
        }
      }
      __name(redactHeaders, "redactHeaders");
      function redactString(obj, key) {
        if (typeof obj === "object" && obj !== null && typeof obj[key] === "string") {
          const text = obj[key];
          if (/grant_type=/i.test(text) || /assertion=/i.test(text) || /secret/i.test(text)) {
            obj[key] = REDACT;
          }
        }
      }
      __name(redactString, "redactString");
      function redactObject(obj) {
        if (typeof obj === "object" && obj !== null) {
          if ("grant_type" in obj) {
            obj["grant_type"] = REDACT;
          }
          if ("assertion" in obj) {
            obj["assertion"] = REDACT;
          }
          if ("client_secret" in obj) {
            obj["client_secret"] = REDACT;
          }
        }
      }
      __name(redactObject, "redactObject");
      if (data.config) {
        redactHeaders(data.config.headers);
        redactString(data.config, "data");
        redactObject(data.config.data);
        redactString(data.config, "body");
        redactObject(data.config.body);
        try {
          const url = new url_1.URL("", data.config.url);
          if (url.searchParams.has("token")) {
            url.searchParams.set("token", REDACT);
          }
          if (url.searchParams.has("client_secret")) {
            url.searchParams.set("client_secret", REDACT);
          }
          data.config.url = url.toString();
        } catch (_b) {
        }
      }
      if (data.response) {
        defaultErrorRedactor({ config: data.response.config });
        redactHeaders(data.response.headers);
        redactString(data.response, "data");
        redactObject(data.response.data);
      }
      return data;
    }
    __name(defaultErrorRedactor, "defaultErrorRedactor");
  }
});

// node_modules/gaxios/build/src/retry.js
var require_retry = __commonJS({
  "node_modules/gaxios/build/src/retry.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getRetryConfig = getRetryConfig;
    async function getRetryConfig(err) {
      let config2 = getConfig(err);
      if (!err || !err.config || !config2 && !err.config.retry) {
        return { shouldRetry: false };
      }
      config2 = config2 || {};
      config2.currentRetryAttempt = config2.currentRetryAttempt || 0;
      config2.retry = config2.retry === void 0 || config2.retry === null ? 3 : config2.retry;
      config2.httpMethodsToRetry = config2.httpMethodsToRetry || [
        "GET",
        "HEAD",
        "PUT",
        "OPTIONS",
        "DELETE"
      ];
      config2.noResponseRetries = config2.noResponseRetries === void 0 || config2.noResponseRetries === null ? 2 : config2.noResponseRetries;
      config2.retryDelayMultiplier = config2.retryDelayMultiplier ? config2.retryDelayMultiplier : 2;
      config2.timeOfFirstRequest = config2.timeOfFirstRequest ? config2.timeOfFirstRequest : Date.now();
      config2.totalTimeout = config2.totalTimeout ? config2.totalTimeout : Number.MAX_SAFE_INTEGER;
      config2.maxRetryDelay = config2.maxRetryDelay ? config2.maxRetryDelay : Number.MAX_SAFE_INTEGER;
      const retryRanges = [
        // https://en.wikipedia.org/wiki/List_of_HTTP_status_codes
        // 1xx - Retry (Informational, request still processing)
        // 2xx - Do not retry (Success)
        // 3xx - Do not retry (Redirect)
        // 4xx - Do not retry (Client errors)
        // 408 - Retry ("Request Timeout")
        // 429 - Retry ("Too Many Requests")
        // 5xx - Retry (Server errors)
        [100, 199],
        [408, 408],
        [429, 429],
        [500, 599]
      ];
      config2.statusCodesToRetry = config2.statusCodesToRetry || retryRanges;
      err.config.retryConfig = config2;
      const shouldRetryFn = config2.shouldRetry || shouldRetryRequest;
      if (!await shouldRetryFn(err)) {
        return { shouldRetry: false, config: err.config };
      }
      const delay = getNextRetryDelay(config2);
      err.config.retryConfig.currentRetryAttempt += 1;
      const backoff = config2.retryBackoff ? config2.retryBackoff(err, delay) : new Promise((resolve) => {
        setTimeout(resolve, delay);
      });
      if (config2.onRetryAttempt) {
        config2.onRetryAttempt(err);
      }
      await backoff;
      return { shouldRetry: true, config: err.config };
    }
    __name(getRetryConfig, "getRetryConfig");
    function shouldRetryRequest(err) {
      var _a;
      const config2 = getConfig(err);
      if (err.name === "AbortError" || ((_a = err.error) === null || _a === void 0 ? void 0 : _a.name) === "AbortError") {
        return false;
      }
      if (!config2 || config2.retry === 0) {
        return false;
      }
      if (!err.response && (config2.currentRetryAttempt || 0) >= config2.noResponseRetries) {
        return false;
      }
      if (!err.config.method || config2.httpMethodsToRetry.indexOf(err.config.method.toUpperCase()) < 0) {
        return false;
      }
      if (err.response && err.response.status) {
        let isInRange = false;
        for (const [min, max] of config2.statusCodesToRetry) {
          const status = err.response.status;
          if (status >= min && status <= max) {
            isInRange = true;
            break;
          }
        }
        if (!isInRange) {
          return false;
        }
      }
      config2.currentRetryAttempt = config2.currentRetryAttempt || 0;
      if (config2.currentRetryAttempt >= config2.retry) {
        return false;
      }
      return true;
    }
    __name(shouldRetryRequest, "shouldRetryRequest");
    function getConfig(err) {
      if (err && err.config && err.config.retryConfig) {
        return err.config.retryConfig;
      }
      return;
    }
    __name(getConfig, "getConfig");
    function getNextRetryDelay(config2) {
      var _a;
      const retryDelay = config2.currentRetryAttempt ? 0 : (_a = config2.retryDelay) !== null && _a !== void 0 ? _a : 100;
      const calculatedDelay = retryDelay + (Math.pow(config2.retryDelayMultiplier, config2.currentRetryAttempt) - 1) / 2 * 1e3;
      const maxAllowableDelay = config2.totalTimeout - (Date.now() - config2.timeOfFirstRequest);
      return Math.min(calculatedDelay, maxAllowableDelay, config2.maxRetryDelay);
    }
    __name(getNextRetryDelay, "getNextRetryDelay");
  }
});

// node-built-in-modules:stream
import libDefault3 from "stream";
var require_stream = __commonJS({
  "node-built-in-modules:stream"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault3;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/rng.js
var require_rng = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/rng.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = rng;
    var getRandomValues2;
    var rnds8 = new Uint8Array(16);
    function rng() {
      if (!getRandomValues2) {
        getRandomValues2 = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
        if (!getRandomValues2) {
          throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
        }
      }
      return getRandomValues2(rnds8);
    }
    __name(rng, "rng");
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/regex.js
var require_regex = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/regex.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/validate.js
var require_validate = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/validate.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _regex = _interopRequireDefault(require_regex());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function validate(uuid) {
      return typeof uuid === "string" && _regex.default.test(uuid);
    }
    __name(validate, "validate");
    var _default = validate;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/stringify.js
var require_stringify = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/stringify.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    exports.unsafeStringify = unsafeStringify;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    function unsafeStringify(arr, offset = 0) {
      return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];
    }
    __name(unsafeStringify, "unsafeStringify");
    function stringify(arr, offset = 0) {
      const uuid = unsafeStringify(arr, offset);
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Stringified UUID is invalid");
      }
      return uuid;
    }
    __name(stringify, "stringify");
    var _default = stringify;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v1.js
var require_v1 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v1.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var _nodeId;
    var _clockseq;
    var _lastMSecs = 0;
    var _lastNSecs = 0;
    function v1(options, buf, offset) {
      let i = buf && offset || 0;
      const b2 = buf || new Array(16);
      options = options || {};
      let node = options.node || _nodeId;
      let clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
      if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || _rng.default)();
        if (node == null) {
          node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
        }
        if (clockseq == null) {
          clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
        }
      }
      let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
      let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
      const dt2 = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
      if (dt2 < 0 && options.clockseq === void 0) {
        clockseq = clockseq + 1 & 16383;
      }
      if ((dt2 < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
        nsecs = 0;
      }
      if (nsecs >= 1e4) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
      }
      _lastMSecs = msecs;
      _lastNSecs = nsecs;
      _clockseq = clockseq;
      msecs += 122192928e5;
      const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
      b2[i++] = tl >>> 24 & 255;
      b2[i++] = tl >>> 16 & 255;
      b2[i++] = tl >>> 8 & 255;
      b2[i++] = tl & 255;
      const tmh = msecs / 4294967296 * 1e4 & 268435455;
      b2[i++] = tmh >>> 8 & 255;
      b2[i++] = tmh & 255;
      b2[i++] = tmh >>> 24 & 15 | 16;
      b2[i++] = tmh >>> 16 & 255;
      b2[i++] = clockseq >>> 8 | 128;
      b2[i++] = clockseq & 255;
      for (let n = 0; n < 6; ++n) {
        b2[i + n] = node[n];
      }
      return buf || (0, _stringify.unsafeStringify)(b2);
    }
    __name(v1, "v1");
    var _default = v1;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/parse.js
var require_parse = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/parse.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function parse2(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      let v2;
      const arr = new Uint8Array(16);
      arr[0] = (v2 = parseInt(uuid.slice(0, 8), 16)) >>> 24;
      arr[1] = v2 >>> 16 & 255;
      arr[2] = v2 >>> 8 & 255;
      arr[3] = v2 & 255;
      arr[4] = (v2 = parseInt(uuid.slice(9, 13), 16)) >>> 8;
      arr[5] = v2 & 255;
      arr[6] = (v2 = parseInt(uuid.slice(14, 18), 16)) >>> 8;
      arr[7] = v2 & 255;
      arr[8] = (v2 = parseInt(uuid.slice(19, 23), 16)) >>> 8;
      arr[9] = v2 & 255;
      arr[10] = (v2 = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
      arr[11] = v2 / 4294967296 & 255;
      arr[12] = v2 >>> 24 & 255;
      arr[13] = v2 >>> 16 & 255;
      arr[14] = v2 >>> 8 & 255;
      arr[15] = v2 & 255;
      return arr;
    }
    __name(parse2, "parse");
    var _default = parse2;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v35.js
var require_v35 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v35.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.URL = exports.DNS = void 0;
    exports.default = v35;
    var _stringify = require_stringify();
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function stringToBytes(str) {
      str = unescape(encodeURIComponent(str));
      const bytes = [];
      for (let i = 0; i < str.length; ++i) {
        bytes.push(str.charCodeAt(i));
      }
      return bytes;
    }
    __name(stringToBytes, "stringToBytes");
    var DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    exports.DNS = DNS;
    var URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    exports.URL = URL2;
    function v35(name, version3, hashfunc) {
      function generateUUID(value, namespace, buf, offset) {
        var _namespace;
        if (typeof value === "string") {
          value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
          namespace = (0, _parse.default)(namespace);
        }
        if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
          throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        }
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 15 | version3;
        bytes[8] = bytes[8] & 63 | 128;
        if (buf) {
          offset = offset || 0;
          for (let i = 0; i < 16; ++i) {
            buf[offset + i] = bytes[i];
          }
          return buf;
        }
        return (0, _stringify.unsafeStringify)(bytes);
      }
      __name(generateUUID, "generateUUID");
      try {
        generateUUID.name = name;
      } catch (err) {
      }
      generateUUID.DNS = DNS;
      generateUUID.URL = URL2;
      return generateUUID;
    }
    __name(v35, "v35");
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/md5.js
var require_md5 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/md5.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function md5(bytes) {
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = new Uint8Array(msg.length);
        for (let i = 0; i < msg.length; ++i) {
          bytes[i] = msg.charCodeAt(i);
        }
      }
      return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
    }
    __name(md5, "md5");
    function md5ToHexEncodedArray(input) {
      const output = [];
      const length32 = input.length * 32;
      const hexTab = "0123456789abcdef";
      for (let i = 0; i < length32; i += 8) {
        const x = input[i >> 5] >>> i % 32 & 255;
        const hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
        output.push(hex);
      }
      return output;
    }
    __name(md5ToHexEncodedArray, "md5ToHexEncodedArray");
    function getOutputLength(inputLength8) {
      return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;
    }
    __name(getOutputLength, "getOutputLength");
    function wordsToMd5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[getOutputLength(len) - 1] = len;
      let a2 = 1732584193;
      let b2 = -271733879;
      let c = -1732584194;
      let d2 = 271733878;
      for (let i = 0; i < x.length; i += 16) {
        const olda = a2;
        const oldb = b2;
        const oldc = c;
        const oldd = d2;
        a2 = md5ff(a2, b2, c, d2, x[i], 7, -680876936);
        d2 = md5ff(d2, a2, b2, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d2, a2, b2, x[i + 2], 17, 606105819);
        b2 = md5ff(b2, c, d2, a2, x[i + 3], 22, -1044525330);
        a2 = md5ff(a2, b2, c, d2, x[i + 4], 7, -176418897);
        d2 = md5ff(d2, a2, b2, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d2, a2, b2, x[i + 6], 17, -1473231341);
        b2 = md5ff(b2, c, d2, a2, x[i + 7], 22, -45705983);
        a2 = md5ff(a2, b2, c, d2, x[i + 8], 7, 1770035416);
        d2 = md5ff(d2, a2, b2, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d2, a2, b2, x[i + 10], 17, -42063);
        b2 = md5ff(b2, c, d2, a2, x[i + 11], 22, -1990404162);
        a2 = md5ff(a2, b2, c, d2, x[i + 12], 7, 1804603682);
        d2 = md5ff(d2, a2, b2, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d2, a2, b2, x[i + 14], 17, -1502002290);
        b2 = md5ff(b2, c, d2, a2, x[i + 15], 22, 1236535329);
        a2 = md5gg(a2, b2, c, d2, x[i + 1], 5, -165796510);
        d2 = md5gg(d2, a2, b2, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d2, a2, b2, x[i + 11], 14, 643717713);
        b2 = md5gg(b2, c, d2, a2, x[i], 20, -373897302);
        a2 = md5gg(a2, b2, c, d2, x[i + 5], 5, -701558691);
        d2 = md5gg(d2, a2, b2, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d2, a2, b2, x[i + 15], 14, -660478335);
        b2 = md5gg(b2, c, d2, a2, x[i + 4], 20, -405537848);
        a2 = md5gg(a2, b2, c, d2, x[i + 9], 5, 568446438);
        d2 = md5gg(d2, a2, b2, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d2, a2, b2, x[i + 3], 14, -187363961);
        b2 = md5gg(b2, c, d2, a2, x[i + 8], 20, 1163531501);
        a2 = md5gg(a2, b2, c, d2, x[i + 13], 5, -1444681467);
        d2 = md5gg(d2, a2, b2, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d2, a2, b2, x[i + 7], 14, 1735328473);
        b2 = md5gg(b2, c, d2, a2, x[i + 12], 20, -1926607734);
        a2 = md5hh(a2, b2, c, d2, x[i + 5], 4, -378558);
        d2 = md5hh(d2, a2, b2, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d2, a2, b2, x[i + 11], 16, 1839030562);
        b2 = md5hh(b2, c, d2, a2, x[i + 14], 23, -35309556);
        a2 = md5hh(a2, b2, c, d2, x[i + 1], 4, -1530992060);
        d2 = md5hh(d2, a2, b2, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d2, a2, b2, x[i + 7], 16, -155497632);
        b2 = md5hh(b2, c, d2, a2, x[i + 10], 23, -1094730640);
        a2 = md5hh(a2, b2, c, d2, x[i + 13], 4, 681279174);
        d2 = md5hh(d2, a2, b2, c, x[i], 11, -358537222);
        c = md5hh(c, d2, a2, b2, x[i + 3], 16, -722521979);
        b2 = md5hh(b2, c, d2, a2, x[i + 6], 23, 76029189);
        a2 = md5hh(a2, b2, c, d2, x[i + 9], 4, -640364487);
        d2 = md5hh(d2, a2, b2, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d2, a2, b2, x[i + 15], 16, 530742520);
        b2 = md5hh(b2, c, d2, a2, x[i + 2], 23, -995338651);
        a2 = md5ii(a2, b2, c, d2, x[i], 6, -198630844);
        d2 = md5ii(d2, a2, b2, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d2, a2, b2, x[i + 14], 15, -1416354905);
        b2 = md5ii(b2, c, d2, a2, x[i + 5], 21, -57434055);
        a2 = md5ii(a2, b2, c, d2, x[i + 12], 6, 1700485571);
        d2 = md5ii(d2, a2, b2, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d2, a2, b2, x[i + 10], 15, -1051523);
        b2 = md5ii(b2, c, d2, a2, x[i + 1], 21, -2054922799);
        a2 = md5ii(a2, b2, c, d2, x[i + 8], 6, 1873313359);
        d2 = md5ii(d2, a2, b2, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d2, a2, b2, x[i + 6], 15, -1560198380);
        b2 = md5ii(b2, c, d2, a2, x[i + 13], 21, 1309151649);
        a2 = md5ii(a2, b2, c, d2, x[i + 4], 6, -145523070);
        d2 = md5ii(d2, a2, b2, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d2, a2, b2, x[i + 2], 15, 718787259);
        b2 = md5ii(b2, c, d2, a2, x[i + 9], 21, -343485551);
        a2 = safeAdd(a2, olda);
        b2 = safeAdd(b2, oldb);
        c = safeAdd(c, oldc);
        d2 = safeAdd(d2, oldd);
      }
      return [a2, b2, c, d2];
    }
    __name(wordsToMd5, "wordsToMd5");
    function bytesToWords(input) {
      if (input.length === 0) {
        return [];
      }
      const length8 = input.length * 8;
      const output = new Uint32Array(getOutputLength(length8));
      for (let i = 0; i < length8; i += 8) {
        output[i >> 5] |= (input[i / 8] & 255) << i % 32;
      }
      return output;
    }
    __name(bytesToWords, "bytesToWords");
    function safeAdd(x, y) {
      const lsw = (x & 65535) + (y & 65535);
      const msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    __name(safeAdd, "safeAdd");
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    __name(bitRotateLeft, "bitRotateLeft");
    function md5cmn(q, a2, b2, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a2, q), safeAdd(x, t)), s), b2);
    }
    __name(md5cmn, "md5cmn");
    function md5ff(a2, b2, c, d2, x, s, t) {
      return md5cmn(b2 & c | ~b2 & d2, a2, b2, x, s, t);
    }
    __name(md5ff, "md5ff");
    function md5gg(a2, b2, c, d2, x, s, t) {
      return md5cmn(b2 & d2 | c & ~d2, a2, b2, x, s, t);
    }
    __name(md5gg, "md5gg");
    function md5hh(a2, b2, c, d2, x, s, t) {
      return md5cmn(b2 ^ c ^ d2, a2, b2, x, s, t);
    }
    __name(md5hh, "md5hh");
    function md5ii(a2, b2, c, d2, x, s, t) {
      return md5cmn(c ^ (b2 | ~d2), a2, b2, x, s, t);
    }
    __name(md5ii, "md5ii");
    var _default = md5;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v3.js
var require_v3 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v3.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _md = _interopRequireDefault(require_md5());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v3 = (0, _v.default)("v3", 48, _md.default);
    var _default = v3;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/native.js
var require_native = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/native.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var randomUUID2 = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
    var _default = {
      randomUUID: randomUUID2
    };
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v4.js
var require_v4 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v4.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _native = _interopRequireDefault(require_native());
    var _rng = _interopRequireDefault(require_rng());
    var _stringify = require_stringify();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function v4(options, buf, offset) {
      if (_native.default.randomUUID && !buf && !options) {
        return _native.default.randomUUID();
      }
      options = options || {};
      const rnds = options.random || (options.rng || _rng.default)();
      rnds[6] = rnds[6] & 15 | 64;
      rnds[8] = rnds[8] & 63 | 128;
      if (buf) {
        offset = offset || 0;
        for (let i = 0; i < 16; ++i) {
          buf[offset + i] = rnds[i];
        }
        return buf;
      }
      return (0, _stringify.unsafeStringify)(rnds);
    }
    __name(v4, "v4");
    var _default = v4;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/sha1.js
var require_sha1 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/sha1.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    function f(s, x, y, z2) {
      switch (s) {
        case 0:
          return x & y ^ ~x & z2;
        case 1:
          return x ^ y ^ z2;
        case 2:
          return x & y ^ x & z2 ^ y & z2;
        case 3:
          return x ^ y ^ z2;
      }
    }
    __name(f, "f");
    function ROTL(x, n) {
      return x << n | x >>> 32 - n;
    }
    __name(ROTL, "ROTL");
    function sha1(bytes) {
      const K = [1518500249, 1859775393, 2400959708, 3395469782];
      const H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
      if (typeof bytes === "string") {
        const msg = unescape(encodeURIComponent(bytes));
        bytes = [];
        for (let i = 0; i < msg.length; ++i) {
          bytes.push(msg.charCodeAt(i));
        }
      } else if (!Array.isArray(bytes)) {
        bytes = Array.prototype.slice.call(bytes);
      }
      bytes.push(128);
      const l = bytes.length / 4 + 2;
      const N = Math.ceil(l / 16);
      const M = new Array(N);
      for (let i = 0; i < N; ++i) {
        const arr = new Uint32Array(16);
        for (let j = 0; j < 16; ++j) {
          arr[j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
        }
        M[i] = arr;
      }
      M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
      M[N - 1][14] = Math.floor(M[N - 1][14]);
      M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
      for (let i = 0; i < N; ++i) {
        const W = new Uint32Array(80);
        for (let t = 0; t < 16; ++t) {
          W[t] = M[i][t];
        }
        for (let t = 16; t < 80; ++t) {
          W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
        }
        let a2 = H[0];
        let b2 = H[1];
        let c = H[2];
        let d2 = H[3];
        let e = H[4];
        for (let t = 0; t < 80; ++t) {
          const s = Math.floor(t / 20);
          const T = ROTL(a2, 5) + f(s, b2, c, d2) + e + K[s] + W[t] >>> 0;
          e = d2;
          d2 = c;
          c = ROTL(b2, 30) >>> 0;
          b2 = a2;
          a2 = T;
        }
        H[0] = H[0] + a2 >>> 0;
        H[1] = H[1] + b2 >>> 0;
        H[2] = H[2] + c >>> 0;
        H[3] = H[3] + d2 >>> 0;
        H[4] = H[4] + e >>> 0;
      }
      return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
    }
    __name(sha1, "sha1");
    var _default = sha1;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v5.js
var require_v5 = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/v5.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _v = _interopRequireDefault(require_v35());
    var _sha = _interopRequireDefault(require_sha1());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    var v5 = (0, _v.default)("v5", 80, _sha.default);
    var _default = v5;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/nil.js
var require_nil = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/nil.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _default = "00000000-0000-0000-0000-000000000000";
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/version.js
var require_version = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/version.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.default = void 0;
    var _validate = _interopRequireDefault(require_validate());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function version3(uuid) {
      if (!(0, _validate.default)(uuid)) {
        throw TypeError("Invalid UUID");
      }
      return parseInt(uuid.slice(14, 15), 16);
    }
    __name(version3, "version");
    var _default = version3;
    exports.default = _default;
  }
});

// node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/index.js
var require_commonjs_browser = __commonJS({
  "node_modules/gaxios/node_modules/uuid/dist/commonjs-browser/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "NIL", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _nil.default;
      }, "get")
    });
    Object.defineProperty(exports, "parse", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _parse.default;
      }, "get")
    });
    Object.defineProperty(exports, "stringify", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _stringify.default;
      }, "get")
    });
    Object.defineProperty(exports, "v1", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _v.default;
      }, "get")
    });
    Object.defineProperty(exports, "v3", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _v2.default;
      }, "get")
    });
    Object.defineProperty(exports, "v4", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _v3.default;
      }, "get")
    });
    Object.defineProperty(exports, "v5", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _v4.default;
      }, "get")
    });
    Object.defineProperty(exports, "validate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _validate.default;
      }, "get")
    });
    Object.defineProperty(exports, "version", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function get3() {
        return _version.default;
      }, "get")
    });
    var _v = _interopRequireDefault(require_v1());
    var _v2 = _interopRequireDefault(require_v3());
    var _v3 = _interopRequireDefault(require_v4());
    var _v4 = _interopRequireDefault(require_v5());
    var _nil = _interopRequireDefault(require_nil());
    var _version = _interopRequireDefault(require_version());
    var _validate = _interopRequireDefault(require_validate());
    var _stringify = _interopRequireDefault(require_stringify());
    var _parse = _interopRequireDefault(require_parse());
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
  }
});

// node_modules/gaxios/build/src/interceptor.js
var require_interceptor = __commonJS({
  "node_modules/gaxios/build/src/interceptor.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GaxiosInterceptorManager = void 0;
    var GaxiosInterceptorManager = class extends Set {
      static {
        __name(this, "GaxiosInterceptorManager");
      }
    };
    exports.GaxiosInterceptorManager = GaxiosInterceptorManager;
  }
});

// node-built-in-modules:net
import libDefault4 from "net";
var require_net = __commonJS({
  "node-built-in-modules:net"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault4;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/server.mjs
import { Server as _Server } from "node:net";
var Server2;
var init_server = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/server.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    Server2 = class extends _Server {
      static {
        __name(this, "Server");
      }
      constructor(arg1, arg2) {
        super(arg1, arg2);
      }
      addContext(hostname2, context2) {
      }
      setSecureContext(options) {
      }
      setTicketKeys(_keys) {
        throw createNotImplementedError("Server.setTicketKeys");
      }
      getTicketKeys() {
        throw createNotImplementedError("Server.getTicketKeys");
      }
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/constants.mjs
var CLIENT_RENEG_LIMIT, CLIENT_RENEG_WINDOW, DEFAULT_CIPHERS, DEFAULT_ECDH_CURVE, DEFAULT_MIN_VERSION, DEFAULT_MAX_VERSION;
var init_constants2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/tls/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    CLIENT_RENEG_LIMIT = 3;
    CLIENT_RENEG_WINDOW = 600;
    DEFAULT_CIPHERS = "";
    DEFAULT_ECDH_CURVE = "auto";
    DEFAULT_MIN_VERSION = "TLSv1.2";
    DEFAULT_MAX_VERSION = "TLSv1.3";
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tls.mjs
var createServer2, convertALPNProtocols, createSecurePair, getCiphers, rootCertificates;
var init_tls = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/tls.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_server();
    init_constants2();
    init_server();
    createServer2 = /* @__PURE__ */ __name(function createServer3() {
      return new Server2();
    }, "createServer");
    convertALPNProtocols = /* @__PURE__ */ notImplemented("tls.convertALPNProtocols");
    createSecurePair = /* @__PURE__ */ notImplemented("tls.createSecurePair");
    getCiphers = /* @__PURE__ */ notImplemented("tls.getCiphers");
    rootCertificates = [];
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/tls.mjs
var workerdTls, checkServerIdentity, connect, createSecureContext, SecureContext, TLSSocket, tls_default;
var init_tls2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/tls.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tls();
    workerdTls = process.getBuiltinModule("node:tls");
    ({
      checkServerIdentity,
      connect,
      createSecureContext,
      SecureContext: (
        // @ts-expect-error Node typings wrongly declare `SecureContext` as an interface
        SecureContext
      ),
      TLSSocket
    } = workerdTls);
    tls_default = {
      CLIENT_RENEG_LIMIT,
      CLIENT_RENEG_WINDOW,
      DEFAULT_CIPHERS,
      DEFAULT_ECDH_CURVE,
      DEFAULT_MAX_VERSION,
      DEFAULT_MIN_VERSION,
      // @ts-expect-error
      SecureContext,
      Server: Server2,
      TLSSocket,
      checkServerIdentity,
      connect,
      convertALPNProtocols,
      createSecureContext,
      createSecurePair,
      createServer: createServer2,
      getCiphers,
      rootCertificates
    };
  }
});

// node-built-in-modules:tls
var require_tls = __commonJS({
  "node-built-in-modules:tls"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_tls2();
    module.exports = tls_default;
  }
});

// node-built-in-modules:assert
import libDefault5 from "assert";
var require_assert = __commonJS({
  "node-built-in-modules:assert"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault5;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/npm/debug.mjs
var debug_exports = {};
__export(debug_exports, {
  default: () => debug_default
});
var noop, debug3, debug_default;
var init_debug = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/npm/debug.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    noop = /* @__PURE__ */ __name(() => {
    }, "noop");
    debug3 = /* @__PURE__ */ __name(() => console.debug, "debug");
    Object.assign(debug3, {
      default: debug3,
      coerce: noop,
      disable: noop,
      enable: noop,
      enabled: noop,
      extend: debug3,
      humanize: noop,
      destroy: noop,
      init: noop,
      log: console.debug,
      formatArgs: noop,
      save: noop,
      load: noop,
      useColors: noop,
      colors: [],
      inspectOpts: {},
      names: [],
      skips: [],
      formatters: {},
      selectColors: noop
    });
    debug_default = debug3;
  }
});

// required-unenv-alias:debug
var require_debug = __commonJS({
  "required-unenv-alias:debug"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_debug();
    module.exports = Object.entries(debug_exports).filter(([k]) => k !== "default").reduce(
      (cjs, [k, value]) => Object.defineProperty(cjs, k, { value, enumerable: true }),
      "default" in debug_exports ? debug_default : {}
    );
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/request.mjs
import { Socket } from "node:net";
import { Readable } from "node:stream";
function _distinct(obj) {
  const d2 = {};
  for (const [key, value] of Object.entries(obj)) {
    if (key) {
      d2[key] = (Array.isArray(value) ? value : [value]).filter(Boolean);
    }
  }
  return d2;
}
var IncomingMessage;
var init_request = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/request.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    IncomingMessage = class extends Readable {
      static {
        __name(this, "IncomingMessage");
      }
      __unenv__ = {};
      aborted = false;
      httpVersion = "1.1";
      httpVersionMajor = 1;
      httpVersionMinor = 1;
      complete = true;
      connection;
      socket;
      headers = {};
      trailers = {};
      method = "GET";
      url = "/";
      statusCode = 200;
      statusMessage = "";
      closed = false;
      errored = null;
      readable = false;
      constructor(socket) {
        super();
        this.socket = this.connection = socket || new Socket();
      }
      get rawHeaders() {
        return rawHeaders(this.headers);
      }
      get rawTrailers() {
        return [];
      }
      setTimeout(_msecs, _callback) {
        return this;
      }
      get headersDistinct() {
        return _distinct(this.headers);
      }
      get trailersDistinct() {
        return _distinct(this.trailers);
      }
      _read() {
      }
    };
    __name(_distinct, "_distinct");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/response.mjs
import { Writable as Writable2 } from "node:stream";
var ServerResponse;
var init_response = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/response.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    ServerResponse = class extends Writable2 {
      static {
        __name(this, "ServerResponse");
      }
      __unenv__ = true;
      statusCode = 200;
      statusMessage = "";
      upgrading = false;
      chunkedEncoding = false;
      shouldKeepAlive = false;
      useChunkedEncodingByDefault = false;
      sendDate = false;
      finished = false;
      headersSent = false;
      strictContentLength = false;
      connection = null;
      socket = null;
      req;
      _headers = {};
      constructor(req) {
        super();
        this.req = req;
      }
      assignSocket(socket) {
        socket._httpMessage = this;
        this.socket = socket;
        this.connection = socket;
        this.emit("socket", socket);
        this._flush();
      }
      _flush() {
        this.flushHeaders();
      }
      detachSocket(_socket) {
      }
      writeContinue(_callback) {
      }
      writeHead(statusCode, arg1, arg2) {
        if (statusCode) {
          this.statusCode = statusCode;
        }
        if (typeof arg1 === "string") {
          this.statusMessage = arg1;
          arg1 = void 0;
        }
        const headers = arg2 || arg1;
        if (headers) {
          if (Array.isArray(headers)) {
          } else {
            for (const key in headers) {
              this.setHeader(key, headers[key]);
            }
          }
        }
        this.headersSent = true;
        return this;
      }
      writeProcessing() {
      }
      setTimeout(_msecs, _callback) {
        return this;
      }
      appendHeader(name, value) {
        name = name.toLowerCase();
        const current = this._headers[name];
        const all = [...Array.isArray(current) ? current : [current], ...Array.isArray(value) ? value : [value]].filter(Boolean);
        this._headers[name] = all.length > 1 ? all : all[0];
        return this;
      }
      setHeader(name, value) {
        this._headers[name.toLowerCase()] = Array.isArray(value) ? [...value] : value;
        return this;
      }
      setHeaders(headers) {
        for (const [key, value] of headers.entries()) {
          this.setHeader(key, value);
        }
        return this;
      }
      getHeader(name) {
        return this._headers[name.toLowerCase()];
      }
      getHeaders() {
        return this._headers;
      }
      getHeaderNames() {
        return Object.keys(this._headers);
      }
      hasHeader(name) {
        return name.toLowerCase() in this._headers;
      }
      removeHeader(name) {
        delete this._headers[name.toLowerCase()];
      }
      addTrailers(_headers) {
      }
      flushHeaders() {
      }
      writeEarlyHints(_headers, cb) {
        if (typeof cb === "function") {
          cb();
        }
      }
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/constants.mjs
var METHODS, STATUS_CODES, maxHeaderSize;
var init_constants3 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    METHODS = [
      "ACL",
      "BIND",
      "CHECKOUT",
      "CONNECT",
      "COPY",
      "DELETE",
      "GET",
      "HEAD",
      "LINK",
      "LOCK",
      "M-SEARCH",
      "MERGE",
      "MKACTIVITY",
      "MKCALENDAR",
      "MKCOL",
      "MOVE",
      "NOTIFY",
      "OPTIONS",
      "PATCH",
      "POST",
      "PRI",
      "PROPFIND",
      "PROPPATCH",
      "PURGE",
      "PUT",
      "REBIND",
      "REPORT",
      "SEARCH",
      "SOURCE",
      "SUBSCRIBE",
      "TRACE",
      "UNBIND",
      "UNLINK",
      "UNLOCK",
      "UNSUBSCRIBE"
    ];
    STATUS_CODES = {
      100: "Continue",
      101: "Switching Protocols",
      102: "Processing",
      103: "Early Hints",
      200: "OK",
      201: "Created",
      202: "Accepted",
      203: "Non-Authoritative Information",
      204: "No Content",
      205: "Reset Content",
      206: "Partial Content",
      207: "Multi-Status",
      208: "Already Reported",
      226: "IM Used",
      300: "Multiple Choices",
      301: "Moved Permanently",
      302: "Found",
      303: "See Other",
      304: "Not Modified",
      305: "Use Proxy",
      307: "Temporary Redirect",
      308: "Permanent Redirect",
      400: "Bad Request",
      401: "Unauthorized",
      402: "Payment Required",
      403: "Forbidden",
      404: "Not Found",
      405: "Method Not Allowed",
      406: "Not Acceptable",
      407: "Proxy Authentication Required",
      408: "Request Timeout",
      409: "Conflict",
      410: "Gone",
      411: "Length Required",
      412: "Precondition Failed",
      413: "Payload Too Large",
      414: "URI Too Long",
      415: "Unsupported Media Type",
      416: "Range Not Satisfiable",
      417: "Expectation Failed",
      418: "I'm a Teapot",
      421: "Misdirected Request",
      422: "Unprocessable Entity",
      423: "Locked",
      424: "Failed Dependency",
      425: "Too Early",
      426: "Upgrade Required",
      428: "Precondition Required",
      429: "Too Many Requests",
      431: "Request Header Fields Too Large",
      451: "Unavailable For Legal Reasons",
      500: "Internal Server Error",
      501: "Not Implemented",
      502: "Bad Gateway",
      503: "Service Unavailable",
      504: "Gateway Timeout",
      505: "HTTP Version Not Supported",
      506: "Variant Also Negotiates",
      507: "Insufficient Storage",
      508: "Loop Detected",
      509: "Bandwidth Limit Exceeded",
      510: "Not Extended",
      511: "Network Authentication Required"
    };
    maxHeaderSize = 16384;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http.mjs
var createServer4, request2, get2, Server3, OutgoingMessage, ClientRequest, globalAgent2, validateHeaderName, validateHeaderValue, setMaxIdleHTTPParsers, _connectionListener, WebSocket2, CloseEvent, MessageEvent, http_default;
var init_http = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_request();
    init_response();
    init_agent();
    init_constants3();
    init_request();
    init_response();
    createServer4 = /* @__PURE__ */ notImplemented("http.createServer");
    request2 = /* @__PURE__ */ notImplemented("http.request");
    get2 = /* @__PURE__ */ notImplemented("http.get");
    Server3 = /* @__PURE__ */ notImplementedClass("http.Server");
    OutgoingMessage = /* @__PURE__ */ notImplementedClass("http.OutgoingMessage");
    ClientRequest = /* @__PURE__ */ notImplementedClass("http.ClientRequest");
    globalAgent2 = new Agent();
    validateHeaderName = /* @__PURE__ */ notImplemented("http.validateHeaderName");
    validateHeaderValue = /* @__PURE__ */ notImplemented("http.validateHeaderValue");
    setMaxIdleHTTPParsers = /* @__PURE__ */ notImplemented("http.setMaxIdleHTTPParsers");
    _connectionListener = /* @__PURE__ */ notImplemented("http._connectionListener");
    WebSocket2 = globalThis.WebSocket || /* @__PURE__ */ notImplementedClass("WebSocket");
    CloseEvent = globalThis.CloseEvent || /* @__PURE__ */ notImplementedClass("CloseEvent");
    MessageEvent = globalThis.MessageEvent || /* @__PURE__ */ notImplementedClass("MessageEvent");
    http_default = {
      METHODS,
      STATUS_CODES,
      maxHeaderSize,
      IncomingMessage,
      ServerResponse,
      WebSocket: WebSocket2,
      CloseEvent,
      MessageEvent,
      createServer: createServer4,
      request: request2,
      get: get2,
      Server: Server3,
      OutgoingMessage,
      ClientRequest,
      Agent,
      globalAgent: globalAgent2,
      validateHeaderName,
      validateHeaderValue,
      setMaxIdleHTTPParsers,
      _connectionListener
    };
  }
});

// node-built-in-modules:http
var require_http = __commonJS({
  "node-built-in-modules:http"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_http();
    module.exports = http_default;
  }
});

// node_modules/agent-base/dist/helpers.js
var require_helpers = __commonJS({
  "node_modules/agent-base/dist/helpers.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k in mod4) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod4, k)) __createBinding(result, mod4, k);
      }
      __setModuleDefault(result, mod4);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.req = exports.json = exports.toBuffer = void 0;
    var http = __importStar(require_http());
    var https = __importStar(require_https());
    async function toBuffer(stream) {
      let length = 0;
      const chunks = [];
      for await (const chunk of stream) {
        length += chunk.length;
        chunks.push(chunk);
      }
      return Buffer.concat(chunks, length);
    }
    __name(toBuffer, "toBuffer");
    exports.toBuffer = toBuffer;
    async function json(stream) {
      const buf = await toBuffer(stream);
      const str = buf.toString("utf8");
      try {
        return JSON.parse(str);
      } catch (_err) {
        const err = _err;
        err.message += ` (input: ${str})`;
        throw err;
      }
    }
    __name(json, "json");
    exports.json = json;
    function req(url, opts = {}) {
      const href = typeof url === "string" ? url : url.href;
      const req2 = (href.startsWith("https:") ? https : http).request(url, opts);
      const promise = new Promise((resolve, reject) => {
        req2.once("response", resolve).once("error", reject).end();
      });
      req2.then = promise.then.bind(promise);
      return req2;
    }
    __name(req, "req");
    exports.req = req;
  }
});

// node_modules/agent-base/dist/index.js
var require_dist = __commonJS({
  "node_modules/agent-base/dist/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k in mod4) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod4, k)) __createBinding(result, mod4, k);
      }
      __setModuleDefault(result, mod4);
      return result;
    };
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Agent = void 0;
    var net = __importStar(require_net());
    var http = __importStar(require_http());
    var https_1 = require_https();
    __exportStar(require_helpers(), exports);
    var INTERNAL = Symbol("AgentBaseInternalState");
    var Agent3 = class extends http.Agent {
      static {
        __name(this, "Agent");
      }
      constructor(opts) {
        super(opts);
        this[INTERNAL] = {};
      }
      /**
       * Determine whether this is an `http` or `https` request.
       */
      isSecureEndpoint(options) {
        if (options) {
          if (typeof options.secureEndpoint === "boolean") {
            return options.secureEndpoint;
          }
          if (typeof options.protocol === "string") {
            return options.protocol === "https:";
          }
        }
        const { stack } = new Error();
        if (typeof stack !== "string")
          return false;
        return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
      }
      // In order to support async signatures in `connect()` and Node's native
      // connection pooling in `http.Agent`, the array of sockets for each origin
      // has to be updated synchronously. This is so the length of the array is
      // accurate when `addRequest()` is next called. We achieve this by creating a
      // fake socket and adding it to `sockets[origin]` and incrementing
      // `totalSocketCount`.
      incrementSockets(name) {
        if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
          return null;
        }
        if (!this.sockets[name]) {
          this.sockets[name] = [];
        }
        const fakeSocket = new net.Socket({ writable: false });
        this.sockets[name].push(fakeSocket);
        this.totalSocketCount++;
        return fakeSocket;
      }
      decrementSockets(name, socket) {
        if (!this.sockets[name] || socket === null) {
          return;
        }
        const sockets = this.sockets[name];
        const index = sockets.indexOf(socket);
        if (index !== -1) {
          sockets.splice(index, 1);
          this.totalSocketCount--;
          if (sockets.length === 0) {
            delete this.sockets[name];
          }
        }
      }
      // In order to properly update the socket pool, we need to call `getName()` on
      // the core `https.Agent` if it is a secureEndpoint.
      getName(options) {
        const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
        if (secureEndpoint) {
          return https_1.Agent.prototype.getName.call(this, options);
        }
        return super.getName(options);
      }
      createSocket(req, options, cb) {
        const connectOpts = {
          ...options,
          secureEndpoint: this.isSecureEndpoint(options)
        };
        const name = this.getName(connectOpts);
        const fakeSocket = this.incrementSockets(name);
        Promise.resolve().then(() => this.connect(req, connectOpts)).then((socket) => {
          this.decrementSockets(name, fakeSocket);
          if (socket instanceof http.Agent) {
            return socket.addRequest(req, connectOpts);
          }
          this[INTERNAL].currentSocket = socket;
          super.createSocket(req, options, cb);
        }, (err) => {
          this.decrementSockets(name, fakeSocket);
          cb(err);
        });
      }
      createConnection() {
        const socket = this[INTERNAL].currentSocket;
        this[INTERNAL].currentSocket = void 0;
        if (!socket) {
          throw new Error("No socket was returned in the `connect()` function");
        }
        return socket;
      }
      get defaultPort() {
        return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
      }
      set defaultPort(v2) {
        if (this[INTERNAL]) {
          this[INTERNAL].defaultPort = v2;
        }
      }
      get protocol() {
        return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
      }
      set protocol(v2) {
        if (this[INTERNAL]) {
          this[INTERNAL].protocol = v2;
        }
      }
    };
    exports.Agent = Agent3;
  }
});

// node_modules/https-proxy-agent/dist/parse-proxy-response.js
var require_parse_proxy_response = __commonJS({
  "node_modules/https-proxy-agent/dist/parse-proxy-response.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseProxyResponse = void 0;
    var debug_1 = __importDefault(require_debug());
    var debug5 = (0, debug_1.default)("https-proxy-agent:parse-proxy-response");
    function parseProxyResponse(socket) {
      return new Promise((resolve, reject) => {
        let buffersLength = 0;
        const buffers = [];
        function read2() {
          const b2 = socket.read();
          if (b2)
            ondata(b2);
          else
            socket.once("readable", read2);
        }
        __name(read2, "read");
        function cleanup() {
          socket.removeListener("end", onend);
          socket.removeListener("error", onerror);
          socket.removeListener("readable", read2);
        }
        __name(cleanup, "cleanup");
        function onend() {
          cleanup();
          debug5("onend");
          reject(new Error("Proxy connection ended before receiving CONNECT response"));
        }
        __name(onend, "onend");
        function onerror(err) {
          cleanup();
          debug5("onerror %o", err);
          reject(err);
        }
        __name(onerror, "onerror");
        function ondata(b2) {
          buffers.push(b2);
          buffersLength += b2.length;
          const buffered = Buffer.concat(buffers, buffersLength);
          const endOfHeaders = buffered.indexOf("\r\n\r\n");
          if (endOfHeaders === -1) {
            debug5("have not received end of HTTP headers yet...");
            read2();
            return;
          }
          const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
          const firstLine = headerParts.shift();
          if (!firstLine) {
            socket.destroy();
            return reject(new Error("No header received from proxy CONNECT response"));
          }
          const firstLineParts = firstLine.split(" ");
          const statusCode = +firstLineParts[1];
          const statusText = firstLineParts.slice(2).join(" ");
          const headers = {};
          for (const header of headerParts) {
            if (!header)
              continue;
            const firstColon = header.indexOf(":");
            if (firstColon === -1) {
              socket.destroy();
              return reject(new Error(`Invalid header from proxy CONNECT response: "${header}"`));
            }
            const key = header.slice(0, firstColon).toLowerCase();
            const value = header.slice(firstColon + 1).trimStart();
            const current = headers[key];
            if (typeof current === "string") {
              headers[key] = [current, value];
            } else if (Array.isArray(current)) {
              current.push(value);
            } else {
              headers[key] = value;
            }
          }
          debug5("got proxy server response: %o %o", firstLine, headers);
          cleanup();
          resolve({
            connect: {
              statusCode,
              statusText,
              headers
            },
            buffered
          });
        }
        __name(ondata, "ondata");
        socket.on("error", onerror);
        socket.on("end", onend);
        read2();
      });
    }
    __name(parseProxyResponse, "parseProxyResponse");
    exports.parseProxyResponse = parseProxyResponse;
  }
});

// node_modules/https-proxy-agent/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/https-proxy-agent/dist/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k in mod4) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod4, k)) __createBinding(result, mod4, k);
      }
      __setModuleDefault(result, mod4);
      return result;
    };
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HttpsProxyAgent = void 0;
    var net = __importStar(require_net());
    var tls = __importStar(require_tls());
    var assert_1 = __importDefault(require_assert());
    var debug_1 = __importDefault(require_debug());
    var agent_base_1 = require_dist();
    var url_1 = require_url();
    var parse_proxy_response_1 = require_parse_proxy_response();
    var debug5 = (0, debug_1.default)("https-proxy-agent");
    var HttpsProxyAgent = class extends agent_base_1.Agent {
      static {
        __name(this, "HttpsProxyAgent");
      }
      constructor(proxy, opts) {
        super(opts);
        this.options = { path: void 0 };
        this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
        this.proxyHeaders = opts?.headers ?? {};
        debug5("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
        const host = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
        const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
        this.connectOpts = {
          // Attempt to negotiate http/1.1 for proxy servers that support http/2
          ALPNProtocols: ["http/1.1"],
          ...opts ? omit(opts, "headers") : null,
          host,
          port
        };
      }
      /**
       * Called when the node-core HTTP client library is creating a
       * new HTTP request.
       */
      async connect(req, opts) {
        const { proxy } = this;
        if (!opts.host) {
          throw new TypeError('No "host" provided');
        }
        let socket;
        if (proxy.protocol === "https:") {
          debug5("Creating `tls.Socket`: %o", this.connectOpts);
          const servername = this.connectOpts.servername || this.connectOpts.host;
          socket = tls.connect({
            ...this.connectOpts,
            servername
          });
        } else {
          debug5("Creating `net.Socket`: %o", this.connectOpts);
          socket = net.connect(this.connectOpts);
        }
        const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
        const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
        let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r
`;
        if (proxy.username || proxy.password) {
          const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
          headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
        }
        headers.Host = `${host}:${opts.port}`;
        if (!headers["Proxy-Connection"]) {
          headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
        }
        for (const name of Object.keys(headers)) {
          payload += `${name}: ${headers[name]}\r
`;
        }
        const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
        socket.write(`${payload}\r
`);
        const { connect: connect3, buffered } = await proxyResponsePromise;
        req.emit("proxyConnect", connect3);
        this.emit("proxyConnect", connect3, req);
        if (connect3.statusCode === 200) {
          req.once("socket", resume);
          if (opts.secureEndpoint) {
            debug5("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            return tls.connect({
              ...omit(opts, "host", "path", "port"),
              socket,
              servername
            });
          }
          return socket;
        }
        socket.destroy();
        const fakeSocket = new net.Socket({ writable: false });
        fakeSocket.readable = true;
        req.once("socket", (s) => {
          debug5("Replaying proxy buffer for failed request");
          (0, assert_1.default)(s.listenerCount("data") > 0);
          s.push(buffered);
          s.push(null);
        });
        return fakeSocket;
      }
    };
    HttpsProxyAgent.protocols = ["http", "https"];
    exports.HttpsProxyAgent = HttpsProxyAgent;
    function resume(socket) {
      socket.resume();
    }
    __name(resume, "resume");
    function omit(obj, ...keys) {
      const ret = {};
      let key;
      for (key in obj) {
        if (!keys.includes(key)) {
          ret[key] = obj[key];
        }
      }
      return ret;
    }
    __name(omit, "omit");
  }
});

// node_modules/gaxios/build/src/gaxios.js
var require_gaxios = __commonJS({
  "node_modules/gaxios/build/src/gaxios.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v2) {
      Object.defineProperty(o, "default", { enumerable: true, value: v2 });
    } : function(o, v2) {
      o["default"] = v2;
    });
    var __importStar = exports && exports.__importStar || function(mod4) {
      if (mod4 && mod4.__esModule) return mod4;
      var result = {};
      if (mod4 != null) {
        for (var k in mod4) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod4, k)) __createBinding(result, mod4, k);
      }
      __setModuleDefault(result, mod4);
      return result;
    };
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    var _Gaxios_instances;
    var _a;
    var _Gaxios_urlMayUseProxy;
    var _Gaxios_applyRequestInterceptors;
    var _Gaxios_applyResponseInterceptors;
    var _Gaxios_prepareRequest;
    var _Gaxios_proxyAgent;
    var _Gaxios_getProxyAgent;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Gaxios = void 0;
    var extend_1 = __importDefault(require_extend());
    var https_1 = require_https();
    var node_fetch_1 = __importDefault(require_node_fetch());
    var querystring_1 = __importDefault(require_querystring());
    var is_stream_1 = __importDefault(require_is_stream());
    var url_1 = require_url();
    var common_1 = require_common();
    var retry_1 = require_retry();
    var stream_1 = require_stream();
    var uuid_1 = require_commonjs_browser();
    var interceptor_1 = require_interceptor();
    var fetch3 = hasFetch() ? window.fetch : node_fetch_1.default;
    function hasWindow() {
      return typeof window !== "undefined" && !!window;
    }
    __name(hasWindow, "hasWindow");
    function hasFetch() {
      return hasWindow() && !!window.fetch;
    }
    __name(hasFetch, "hasFetch");
    function hasBuffer() {
      return typeof Buffer !== "undefined";
    }
    __name(hasBuffer, "hasBuffer");
    function hasHeader(options, header) {
      return !!getHeader(options, header);
    }
    __name(hasHeader, "hasHeader");
    function getHeader(options, header) {
      header = header.toLowerCase();
      for (const key of Object.keys((options === null || options === void 0 ? void 0 : options.headers) || {})) {
        if (header === key.toLowerCase()) {
          return options.headers[key];
        }
      }
      return void 0;
    }
    __name(getHeader, "getHeader");
    var Gaxios = class {
      static {
        __name(this, "Gaxios");
      }
      /**
       * The Gaxios class is responsible for making HTTP requests.
       * @param defaults The default set of options to be used for this instance.
       */
      constructor(defaults) {
        _Gaxios_instances.add(this);
        this.agentCache = /* @__PURE__ */ new Map();
        this.defaults = defaults || {};
        this.interceptors = {
          request: new interceptor_1.GaxiosInterceptorManager(),
          response: new interceptor_1.GaxiosInterceptorManager()
        };
      }
      /**
       * Perform an HTTP request with the given options.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async request(opts = {}) {
        opts = await __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_prepareRequest).call(this, opts);
        opts = await __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_applyRequestInterceptors).call(this, opts);
        return __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_applyResponseInterceptors).call(this, this._request(opts));
      }
      async _defaultAdapter(opts) {
        const fetchImpl = opts.fetchImplementation || fetch3;
        const res = await fetchImpl(opts.url, opts);
        const data = await this.getResponseData(opts, res);
        return this.translateResponse(opts, res, data);
      }
      /**
       * Internal, retryable version of the `request` method.
       * @param opts Set of HTTP options that will be used for this HTTP request.
       */
      async _request(opts = {}) {
        var _b;
        try {
          let translatedResponse;
          if (opts.adapter) {
            translatedResponse = await opts.adapter(opts, this._defaultAdapter.bind(this));
          } else {
            translatedResponse = await this._defaultAdapter(opts);
          }
          if (!opts.validateStatus(translatedResponse.status)) {
            if (opts.responseType === "stream") {
              let response = "";
              await new Promise((resolve) => {
                (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("data", (chunk) => {
                  response += chunk;
                });
                (translatedResponse === null || translatedResponse === void 0 ? void 0 : translatedResponse.data).on("end", resolve);
              });
              translatedResponse.data = response;
            }
            throw new common_1.GaxiosError(`Request failed with status code ${translatedResponse.status}`, opts, translatedResponse);
          }
          return translatedResponse;
        } catch (e) {
          const err = e instanceof common_1.GaxiosError ? e : new common_1.GaxiosError(e.message, opts, void 0, e);
          const { shouldRetry, config: config2 } = await (0, retry_1.getRetryConfig)(err);
          if (shouldRetry && config2) {
            err.config.retryConfig.currentRetryAttempt = config2.retryConfig.currentRetryAttempt;
            opts.retryConfig = (_b = err.config) === null || _b === void 0 ? void 0 : _b.retryConfig;
            return this._request(opts);
          }
          throw err;
        }
      }
      async getResponseData(opts, res) {
        switch (opts.responseType) {
          case "stream":
            return res.body;
          case "json": {
            let data = await res.text();
            try {
              data = JSON.parse(data);
            } catch (_b) {
            }
            return data;
          }
          case "arraybuffer":
            return res.arrayBuffer();
          case "blob":
            return res.blob();
          case "text":
            return res.text();
          default:
            return this.getResponseDataFromContentType(res);
        }
      }
      /**
       * By default, throw for any non-2xx status code
       * @param status status code from the HTTP response
       */
      validateStatus(status) {
        return status >= 200 && status < 300;
      }
      /**
       * Encode a set of key/value pars into a querystring format (?foo=bar&baz=boo)
       * @param params key value pars to encode
       */
      paramsSerializer(params) {
        return querystring_1.default.stringify(params);
      }
      translateResponse(opts, res, data) {
        const headers = {};
        res.headers.forEach((value, key) => {
          headers[key] = value;
        });
        return {
          config: opts,
          data,
          headers,
          status: res.status,
          statusText: res.statusText,
          // XMLHttpRequestLike
          request: {
            responseURL: res.url
          }
        };
      }
      /**
       * Attempts to parse a response by looking at the Content-Type header.
       * @param {FetchResponse} response the HTTP response.
       * @returns {Promise<any>} a promise that resolves to the response data.
       */
      async getResponseDataFromContentType(response) {
        let contentType = response.headers.get("Content-Type");
        if (contentType === null) {
          return response.text();
        }
        contentType = contentType.toLowerCase();
        if (contentType.includes("application/json")) {
          let data = await response.text();
          try {
            data = JSON.parse(data);
          } catch (_b) {
          }
          return data;
        } else if (contentType.match(/^text\//)) {
          return response.text();
        } else {
          return response.blob();
        }
      }
      /**
       * Creates an async generator that yields the pieces of a multipart/related request body.
       * This implementation follows the spec: https://www.ietf.org/rfc/rfc2387.txt. However, recursive
       * multipart/related requests are not currently supported.
       *
       * @param {GaxioMultipartOptions[]} multipartOptions the pieces to turn into a multipart/related body.
       * @param {string} boundary the boundary string to be placed between each part.
       */
      async *getMultipartRequest(multipartOptions, boundary) {
        const finale = `--${boundary}--`;
        for (const currentPart of multipartOptions) {
          const partContentType = currentPart.headers["Content-Type"] || "application/octet-stream";
          const preamble = `--${boundary}\r
Content-Type: ${partContentType}\r
\r
`;
          yield preamble;
          if (typeof currentPart.content === "string") {
            yield currentPart.content;
          } else {
            yield* currentPart.content;
          }
          yield "\r\n";
        }
        yield finale;
      }
    };
    exports.Gaxios = Gaxios;
    _a = Gaxios, _Gaxios_instances = /* @__PURE__ */ new WeakSet(), _Gaxios_urlMayUseProxy = /* @__PURE__ */ __name(function _Gaxios_urlMayUseProxy2(url, noProxy = []) {
      var _b, _c;
      const candidate = new url_1.URL(url);
      const noProxyList = [...noProxy];
      const noProxyEnvList = ((_c = (_b = process.env.NO_PROXY) !== null && _b !== void 0 ? _b : process.env.no_proxy) === null || _c === void 0 ? void 0 : _c.split(",")) || [];
      for (const rule of noProxyEnvList) {
        noProxyList.push(rule.trim());
      }
      for (const rule of noProxyList) {
        if (rule instanceof RegExp) {
          if (rule.test(candidate.toString())) {
            return false;
          }
        } else if (rule instanceof url_1.URL) {
          if (rule.origin === candidate.origin) {
            return false;
          }
        } else if (rule.startsWith("*.") || rule.startsWith(".")) {
          const cleanedRule = rule.replace(/^\*\./, ".");
          if (candidate.hostname.endsWith(cleanedRule)) {
            return false;
          }
        } else if (rule === candidate.origin || rule === candidate.hostname || rule === candidate.href) {
          return false;
        }
      }
      return true;
    }, "_Gaxios_urlMayUseProxy"), _Gaxios_applyRequestInterceptors = /**
     * Applies the request interceptors. The request interceptors are applied after the
     * call to prepareRequest is completed.
     *
     * @param {GaxiosOptions} options The current set of options.
     *
     * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
     */
    /* @__PURE__ */ __name(async function _Gaxios_applyRequestInterceptors2(options) {
      let promiseChain = Promise.resolve(options);
      for (const interceptor of this.interceptors.request.values()) {
        if (interceptor) {
          promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
        }
      }
      return promiseChain;
    }, "_Gaxios_applyRequestInterceptors"), _Gaxios_applyResponseInterceptors = /**
     * Applies the response interceptors. The response interceptors are applied after the
     * call to request is made.
     *
     * @param {GaxiosOptions} options The current set of options.
     *
     * @returns {Promise<GaxiosOptions>} Promise that resolves to the set of options or response after interceptors are applied.
     */
    /* @__PURE__ */ __name(async function _Gaxios_applyResponseInterceptors2(response) {
      let promiseChain = Promise.resolve(response);
      for (const interceptor of this.interceptors.response.values()) {
        if (interceptor) {
          promiseChain = promiseChain.then(interceptor.resolved, interceptor.rejected);
        }
      }
      return promiseChain;
    }, "_Gaxios_applyResponseInterceptors"), _Gaxios_prepareRequest = /**
     * Validates the options, merges them with defaults, and prepare request.
     *
     * @param options The original options passed from the client.
     * @returns Prepared options, ready to make a request
     */
    /* @__PURE__ */ __name(async function _Gaxios_prepareRequest2(options) {
      var _b, _c, _d, _e;
      const opts = (0, extend_1.default)(true, {}, this.defaults, options);
      if (!opts.url) {
        throw new Error("URL is required.");
      }
      const baseUrl = opts.baseUrl || opts.baseURL;
      if (baseUrl) {
        opts.url = baseUrl.toString() + opts.url;
      }
      opts.paramsSerializer = opts.paramsSerializer || this.paramsSerializer;
      if (opts.params && Object.keys(opts.params).length > 0) {
        let additionalQueryParams = opts.paramsSerializer(opts.params);
        if (additionalQueryParams.startsWith("?")) {
          additionalQueryParams = additionalQueryParams.slice(1);
        }
        const prefix = opts.url.toString().includes("?") ? "&" : "?";
        opts.url = opts.url + prefix + additionalQueryParams;
      }
      if (typeof options.maxContentLength === "number") {
        opts.size = options.maxContentLength;
      }
      if (typeof options.maxRedirects === "number") {
        opts.follow = options.maxRedirects;
      }
      opts.headers = opts.headers || {};
      if (opts.multipart === void 0 && opts.data) {
        const isFormData = typeof FormData === "undefined" ? false : (opts === null || opts === void 0 ? void 0 : opts.data) instanceof FormData;
        if (is_stream_1.default.readable(opts.data)) {
          opts.body = opts.data;
        } else if (hasBuffer() && Buffer.isBuffer(opts.data)) {
          opts.body = opts.data;
          if (!hasHeader(opts, "Content-Type")) {
            opts.headers["Content-Type"] = "application/json";
          }
        } else if (typeof opts.data === "object") {
          if (!isFormData) {
            if (getHeader(opts, "content-type") === "application/x-www-form-urlencoded") {
              opts.body = opts.paramsSerializer(opts.data);
            } else {
              if (!hasHeader(opts, "Content-Type")) {
                opts.headers["Content-Type"] = "application/json";
              }
              opts.body = JSON.stringify(opts.data);
            }
          }
        } else {
          opts.body = opts.data;
        }
      } else if (opts.multipart && opts.multipart.length > 0) {
        const boundary = (0, uuid_1.v4)();
        opts.headers["Content-Type"] = `multipart/related; boundary=${boundary}`;
        const bodyStream = new stream_1.PassThrough();
        opts.body = bodyStream;
        (0, stream_1.pipeline)(this.getMultipartRequest(opts.multipart, boundary), bodyStream, () => {
        });
      }
      opts.validateStatus = opts.validateStatus || this.validateStatus;
      opts.responseType = opts.responseType || "unknown";
      if (!opts.headers["Accept"] && opts.responseType === "json") {
        opts.headers["Accept"] = "application/json";
      }
      opts.method = opts.method || "GET";
      const proxy = opts.proxy || ((_b = process === null || process === void 0 ? void 0 : process.env) === null || _b === void 0 ? void 0 : _b.HTTPS_PROXY) || ((_c = process === null || process === void 0 ? void 0 : process.env) === null || _c === void 0 ? void 0 : _c.https_proxy) || ((_d = process === null || process === void 0 ? void 0 : process.env) === null || _d === void 0 ? void 0 : _d.HTTP_PROXY) || ((_e = process === null || process === void 0 ? void 0 : process.env) === null || _e === void 0 ? void 0 : _e.http_proxy);
      const urlMayUseProxy = __classPrivateFieldGet(this, _Gaxios_instances, "m", _Gaxios_urlMayUseProxy).call(this, opts.url, opts.noProxy);
      if (opts.agent) {
      } else if (proxy && urlMayUseProxy) {
        const HttpsProxyAgent = await __classPrivateFieldGet(_a, _a, "m", _Gaxios_getProxyAgent).call(_a);
        if (this.agentCache.has(proxy)) {
          opts.agent = this.agentCache.get(proxy);
        } else {
          opts.agent = new HttpsProxyAgent(proxy, {
            cert: opts.cert,
            key: opts.key
          });
          this.agentCache.set(proxy, opts.agent);
        }
      } else if (opts.cert && opts.key) {
        if (this.agentCache.has(opts.key)) {
          opts.agent = this.agentCache.get(opts.key);
        } else {
          opts.agent = new https_1.Agent({
            cert: opts.cert,
            key: opts.key
          });
          this.agentCache.set(opts.key, opts.agent);
        }
      }
      if (typeof opts.errorRedactor !== "function" && opts.errorRedactor !== false) {
        opts.errorRedactor = common_1.defaultErrorRedactor;
      }
      return opts;
    }, "_Gaxios_prepareRequest"), _Gaxios_getProxyAgent = /* @__PURE__ */ __name(async function _Gaxios_getProxyAgent2() {
      __classPrivateFieldSet(this, _a, __classPrivateFieldGet(this, _a, "f", _Gaxios_proxyAgent) || (await Promise.resolve().then(() => __importStar(require_dist2()))).HttpsProxyAgent, "f", _Gaxios_proxyAgent);
      return __classPrivateFieldGet(this, _a, "f", _Gaxios_proxyAgent);
    }, "_Gaxios_getProxyAgent");
    _Gaxios_proxyAgent = { value: void 0 };
  }
});

// node_modules/gaxios/build/src/index.js
var require_src = __commonJS({
  "node_modules/gaxios/build/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.instance = exports.Gaxios = exports.GaxiosError = void 0;
    exports.request = request3;
    var gaxios_1 = require_gaxios();
    Object.defineProperty(exports, "Gaxios", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return gaxios_1.Gaxios;
    }, "get") });
    var common_1 = require_common();
    Object.defineProperty(exports, "GaxiosError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return common_1.GaxiosError;
    }, "get") });
    __exportStar(require_interceptor(), exports);
    exports.instance = new gaxios_1.Gaxios();
    async function request3(opts) {
      return exports.instance.request(opts);
    }
    __name(request3, "request");
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone2(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "\xA0",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v2, b2) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v2, b2);
          if (b2 == null) {
            if (v2 && v2._isBigNumber === true) {
              x.s = v2.s;
              if (!v2.c || v2.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v2.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v2.e;
                x.c = v2.c.slice();
              }
              return;
            }
            if ((isNum = typeof v2 == "number") && v2 * 0 == 0) {
              x.s = 1 / v2 < 0 ? (v2 = -v2, -1) : 1;
              if (v2 === ~~v2) {
                for (e = 0, i = v2; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v2];
                }
                return;
              }
              str = String(v2);
            } else {
              if (!isNumeric.test(str = String(v2))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b2, 2, ALPHABET.length, "Base");
            if (b2 == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v2);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v2);
            if (isNum = typeof v2 == "number") {
              if (v2 * 0 != 0) return parseNumeric(x, str, isNum, b2);
              x.s = 1 / v2 < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v2);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b2);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v2), isNum, b2);
              }
            }
            isNum = false;
            str = convertBase(str, b2, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v2 > MAX_SAFE_INTEGER || v2 !== mathfloor(v2))) {
              throw Error(tooManyDigits + x.s * v2);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        __name(BigNumber2, "BigNumber");
        BigNumber2.clone = clone2;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p2, v2;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p2 = "DECIMAL_PLACES")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                DECIMAL_PLACES = v2;
              }
              if (obj.hasOwnProperty(p2 = "ROUNDING_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 8, p2);
                ROUNDING_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "EXPONENTIAL_AT")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, 0, p2);
                  intCheck(v2[1], 0, MAX, p2);
                  TO_EXP_NEG = v2[0];
                  TO_EXP_POS = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  TO_EXP_NEG = -(TO_EXP_POS = v2 < 0 ? -v2 : v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "RANGE")) {
                v2 = obj[p2];
                if (v2 && v2.pop) {
                  intCheck(v2[0], -MAX, -1, p2);
                  intCheck(v2[1], 1, MAX, p2);
                  MIN_EXP = v2[0];
                  MAX_EXP = v2[1];
                } else {
                  intCheck(v2, -MAX, MAX, p2);
                  if (v2) {
                    MIN_EXP = -(MAX_EXP = v2 < 0 ? -v2 : v2);
                  } else {
                    throw Error(bignumberError + p2 + " cannot be zero: " + v2);
                  }
                }
              }
              if (obj.hasOwnProperty(p2 = "CRYPTO")) {
                v2 = obj[p2];
                if (v2 === !!v2) {
                  if (v2) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v2;
                    } else {
                      CRYPTO = !v2;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v2;
                  }
                } else {
                  throw Error(bignumberError + p2 + " not true or false: " + v2);
                }
              }
              if (obj.hasOwnProperty(p2 = "MODULO_MODE")) {
                v2 = obj[p2];
                intCheck(v2, 0, 9, p2);
                MODULO_MODE = v2;
              }
              if (obj.hasOwnProperty(p2 = "POW_PRECISION")) {
                v2 = obj[p2];
                intCheck(v2, 0, MAX, p2);
                POW_PRECISION = v2;
              }
              if (obj.hasOwnProperty(p2 = "FORMAT")) {
                v2 = obj[p2];
                if (typeof v2 == "object") FORMAT = v2;
                else throw Error(bignumberError + p2 + " not an object: " + v2);
              }
              if (obj.hasOwnProperty(p2 = "ALPHABET")) {
                v2 = obj[p2];
                if (typeof v2 == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v2)) {
                  alphabetHasNormalDecimalDigits = v2.slice(0, 10) == "0123456789";
                  ALPHABET = v2;
                } else {
                  throw Error(bignumberError + p2 + " invalid: " + v2);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v2) {
          if (!v2 || v2._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v2.c, e = v2.e, s = v2.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v2);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a2, b2, e, k, v2, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a2 = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v2 = a2[i] * 131072 + (a2[i + 1] >>> 11);
                  if (v2 >= 9e15) {
                    b2 = crypto.getRandomValues(new Uint32Array(2));
                    a2[i] = b2[0];
                    a2[i + 1] = b2[1];
                  } else {
                    c.push(v2 % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a2 = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v2 = (a2[i] & 31) * 281474976710656 + a2[i + 1] * 1099511627776 + a2[i + 2] * 4294967296 + a2[i + 3] * 16777216 + (a2[i + 4] << 16) + (a2[i + 5] << 8) + a2[i + 6];
                  if (v2 >= 9e15) {
                    crypto.randomBytes(7).copy(a2, i);
                  } else {
                    c.push(v2 % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v2 = random53bitInt();
                if (v2 < 9e15) c[i++] = v2 % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v2 = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v2) * v2;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v2 = c[0]; v2 >= 10; v2 /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          __name(toBaseOut, "toBaseOut");
          return function(str, baseIn, baseOut, sign3, callerIsToString) {
            var alphabet, d2, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm3 = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign3;
              x = div(x, y, dp, rm3, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d2 = e + dp + 1;
            i = xc[d2];
            k = baseOut / 2;
            r = r || d2 < 0 || xc[d2 + 1] != null;
            r = rm3 < 4 ? (i != null || r) && (rm3 == 0 || rm3 == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm3 == 4 || r || rm3 == 6 && xc[d2 - 1] & 1 || rm3 == (x.s < 0 ? 8 : 7));
            if (d2 < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d2;
              if (r) {
                for (--baseOut; ++xc[--d2] > baseOut; ) {
                  xc[d2] = 0;
                  if (!d2) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m2, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m2 = khi * xlo + xhi * klo;
              temp = klo * xlo + m2 % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m2 / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          __name(multiply, "multiply");
          function compare2(a2, b2, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a2[i] != b2[i]) {
                  cmp = a2[i] > b2[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          __name(compare2, "compare");
          function subtract(a2, b2, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a2[aL] -= i;
              i = a2[aL] < b2[aL] ? 1 : 0;
              a2[aL] = i * base + a2[aL] - b2[aL];
            }
            for (; !a2[0] && a2.length > 1; a2.splice(0, 1)) ;
          }
          __name(subtract, "subtract");
          return function(x, y, dp, rm3, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi2, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return ±0 if x is ±0 or y is ±Infinity, or return ±Infinity as y is ±0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi2 = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi2] || 0;
                } else {
                  rem = [xc[xi2]];
                  remL = 1;
                }
              } while ((xi2++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm3, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format2(n, i, rm3, id) {
          var c0, e, ne2, len, str;
          if (rm3 == null) rm3 = ROUNDING_MODE;
          else intCheck(rm3, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne2 = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne2 <= TO_EXP_NEG || ne2 >= TO_EXP_POS) ? toExponential(str, ne2) : toFixedPoint(str, ne2, "0");
          } else {
            n = round(new BigNumber2(n), i, rm3);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne2;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        __name(format2, "format");
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        __name(maxOrMin, "maxOrMin");
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        __name(normalise, "normalise");
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b2) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m2, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b2 || b2 == base ? p1 : m2;
                });
                if (b2) {
                  base = b2;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b2 ? " base " + b2 : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm3, r) {
          var d2, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d2 = 1, k = xc[0]; k >= 10; k /= 10, d2++) ;
              i = sd - d2;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d2 - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d2 = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d2 = 1; k >= 10; k /= 10, d2++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d2;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d2 - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d2 - j - 1]);
              r = rm3 < 4 ? (rd || r) && (rm3 == 0 || rm3 == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm3 == 4 || r || rm3 == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d2 - j] : 0 : xc[ni - 1]) % 10 & 1 || rm3 == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d2 - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        __name(round, "round");
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        __name(valueOf, "valueOf");
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b2) {
          return compare(this, new BigNumber2(y, b2));
        };
        P.decimalPlaces = P.dp = function(dp, rm3) {
          var c, n, v2, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm3 == null) rm3 = ROUNDING_MODE;
            else intCheck(rm3, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm3);
          }
          if (!(c = x.c)) return null;
          n = ((v2 = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v2 = c[v2]) for (; v2 % 10 == 0; v2 /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b2) {
          return div(this, new BigNumber2(y, b2), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b2) {
          return div(this, new BigNumber2(y, b2), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m2) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m2 != null) m2 = new BigNumber2(m2);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m2 ? y.mod(m2) : y;
          }
          nIsNeg = n.s < 0;
          if (m2) {
            if (m2.c ? !m2.c[0] : !m2.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m2.isInteger();
            if (isModExp) x = x.mod(m2);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m2);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m2);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m2 ? y.mod(m2) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm3) {
          var n = new BigNumber2(this);
          if (rm3 == null) rm3 = ROUNDING_MODE;
          else intCheck(rm3, 0, 8);
          return round(n, n.e + 1, rm3);
        };
        P.isEqualTo = P.eq = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b2) {
          return (b2 = compare(this, new BigNumber2(y, b2))) === 1 || b2 === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b2) {
          return compare(this, new BigNumber2(y, b2)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b2) {
          return (b2 = compare(this, new BigNumber2(y, b2))) === -1 || b2 === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b2) {
          var i, j, t, xLTy, x = this, a2 = x.s;
          y = new BigNumber2(y, b2);
          b2 = y.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y.s = -b2;
            return x.plus(y);
          }
          var xe2 = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe2 || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b2, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b2, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe2 = bitFloor(xe2);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe2 - ye) {
            if (xLTy = a2 < 0) {
              a2 = -a2;
              t = xc;
            } else {
              ye = xe2;
              t = yc;
            }
            t.reverse();
            for (b2 = a2; b2--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a2 = xc.length) < (b2 = yc.length)) ? a2 : b2;
            for (a2 = b2 = 0; b2 < j; b2++) {
              if (xc[b2] != yc[b2]) {
                xLTy = xc[b2] < yc[b2];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b2 = (j = yc.length) - (i = xc.length);
          if (b2 > 0) for (; b2--; xc[i++] = 0) ;
          b2 = BASE - 1;
          for (; j > a2; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b2) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b2) {
          var q, s, x = this;
          y = new BigNumber2(y, b2);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b2) {
          var c, e, i, j, k, m2, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b2)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m2 = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m2 % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m2 / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b2) {
          var t, x = this, a2 = x.s;
          y = new BigNumber2(y, b2);
          b2 = y.s;
          if (!a2 || !b2) return new BigNumber2(NaN);
          if (a2 != b2) {
            y.s = -b2;
            return x.minus(y);
          }
          var xe2 = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe2 || !ye) {
            if (!xc || !yc) return new BigNumber2(a2 / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a2 * 0);
          }
          xe2 = bitFloor(xe2);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a2 = xe2 - ye) {
            if (a2 > 0) {
              ye = xe2;
              t = yc;
            } else {
              a2 = -a2;
              t = xc;
            }
            t.reverse();
            for (; a2--; t.push(0)) ;
            t.reverse();
          }
          a2 = xc.length;
          b2 = yc.length;
          if (a2 - b2 < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b2 = a2;
          }
          for (a2 = 0; b2; ) {
            a2 = (xc[--b2] = xc[b2] + yc[b2] + a2) / BASE | 0;
            xc[b2] = BASE === xc[b2] ? 0 : xc[b2] % BASE;
          }
          if (a2) {
            xc = [a2].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm3) {
          var c, n, v2, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm3 == null) rm3 = ROUNDING_MODE;
            else intCheck(rm3, 0, 8);
            return round(new BigNumber2(x), sd, rm3);
          }
          if (!(c = x.c)) return null;
          v2 = c.length - 1;
          n = v2 * LOG_BASE + 1;
          if (v2 = c[v2]) {
            for (; v2 % 10 == 0; v2 /= 10, n--) ;
            for (v2 = c[0]; v2 >= 10; v2 /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m2, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m2 = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m2);
        };
        P.toExponential = function(dp, rm3) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format2(this, dp, rm3, 1);
        };
        P.toFixed = function(dp, rm3) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format2(this, dp, rm3);
        };
        P.toFormat = function(dp, rm3, format3) {
          var str, x = this;
          if (format3 == null) {
            if (dp != null && rm3 && typeof rm3 == "object") {
              format3 = rm3;
              rm3 = null;
            } else if (dp && typeof dp == "object") {
              format3 = dp;
              dp = rm3 = null;
            } else {
              format3 = FORMAT;
            }
          } else if (typeof format3 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format3);
          }
          str = x.toFixed(dp, rm3);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format3.groupSize, g2 = +format3.secondaryGroupSize, groupSeparator = format3.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format3.decimalSeparator || "") + ((g2 = +format3.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format3.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format3.prefix || "") + str + (format3.suffix || "");
        };
        P.toFraction = function(md) {
          var d2, d0, d1, d22, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d2 = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d2.e = s.length - x.e - 1;
          d2.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d2) > 0 ? e > 0 ? d2 : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d2, 0, 1);
            d22 = d0.plus(q.times(d1));
            if (d22.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d22;
            n1 = n0.plus(q.times(d22 = n1));
            n0 = d22;
            d2 = n.minus(q.times(d22 = d2));
            n = d22;
          }
          d22 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d22.times(n1));
          d0 = d0.plus(d22.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm3) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format2(this, sd, rm3, 2);
        };
        P.toString = function(b2) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b2 == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b2 === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b2, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b2, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      __name(clone2, "clone");
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      __name(bitFloor, "bitFloor");
      function coeffToString(a2) {
        var s, z2, i = 1, j = a2.length, r = a2[0] + "";
        for (; i < j; ) {
          s = a2[i++] + "";
          z2 = LOG_BASE - s.length;
          for (; z2--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      __name(coeffToString, "coeffToString");
      function compare(x, y) {
        var a2, b2, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a2 = xc && !xc[0];
        b2 = yc && !yc[0];
        if (a2 || b2) return a2 ? b2 ? 0 : -j : i;
        if (i != j) return i;
        a2 = i < 0;
        b2 = k == l;
        if (!xc || !yc) return b2 ? 0 : !xc ^ a2 ? 1 : -1;
        if (!b2) return k > l ^ a2 ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a2 ? 1 : -1;
        return k == l ? 0 : k > l ^ a2 ? 1 : -1;
      }
      __name(compare, "compare");
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      __name(intCheck, "intCheck");
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      __name(isOdd, "isOdd");
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      __name(toExponential, "toExponential");
      function toFixedPoint(str, e, z2) {
        var len, zs;
        if (e < 0) {
          for (zs = z2 + "."; ++e; zs += z2) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z2, e -= len; --e; zs += z2) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      __name(toFixedPoint, "toFixedPoint");
      BigNumber = clone2();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/json-bigint/lib/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/json-bigint/lib/stringify.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BigNumber = require_bignumber();
    var JSON2 = module.exports;
    (function() {
      "use strict";
      function f(n) {
        return n < 10 ? "0" + n : n;
      }
      __name(f, "f");
      var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g, gap, indent, meta = {
        // table of character substitutions
        "\b": "\\b",
        "	": "\\t",
        "\n": "\\n",
        "\f": "\\f",
        "\r": "\\r",
        '"': '\\"',
        "\\": "\\\\"
      }, rep;
      function quote(string) {
        escapable.lastIndex = 0;
        return escapable.test(string) ? '"' + string.replace(escapable, function(a2) {
          var c = meta[a2];
          return typeof c === "string" ? c : "\\u" + ("0000" + a2.charCodeAt(0).toString(16)).slice(-4);
        }) + '"' : '"' + string + '"';
      }
      __name(quote, "quote");
      function str(key, holder) {
        var i, k, v2, length, mind = gap, partial, value = holder[key], isBigNumber = value != null && (value instanceof BigNumber || BigNumber.isBigNumber(value));
        if (value && typeof value === "object" && typeof value.toJSON === "function") {
          value = value.toJSON(key);
        }
        if (typeof rep === "function") {
          value = rep.call(holder, key, value);
        }
        switch (typeof value) {
          case "string":
            if (isBigNumber) {
              return value;
            } else {
              return quote(value);
            }
          case "number":
            return isFinite(value) ? String(value) : "null";
          case "boolean":
          case "null":
          case "bigint":
            return String(value);
          // If the type is 'object', we might be dealing with an object or an array or
          // null.
          case "object":
            if (!value) {
              return "null";
            }
            gap += indent;
            partial = [];
            if (Object.prototype.toString.apply(value) === "[object Array]") {
              length = value.length;
              for (i = 0; i < length; i += 1) {
                partial[i] = str(i, value) || "null";
              }
              v2 = partial.length === 0 ? "[]" : gap ? "[\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "]" : "[" + partial.join(",") + "]";
              gap = mind;
              return v2;
            }
            if (rep && typeof rep === "object") {
              length = rep.length;
              for (i = 0; i < length; i += 1) {
                if (typeof rep[i] === "string") {
                  k = rep[i];
                  v2 = str(k, value);
                  if (v2) {
                    partial.push(quote(k) + (gap ? ": " : ":") + v2);
                  }
                }
              }
            } else {
              Object.keys(value).forEach(function(k2) {
                var v3 = str(k2, value);
                if (v3) {
                  partial.push(quote(k2) + (gap ? ": " : ":") + v3);
                }
              });
            }
            v2 = partial.length === 0 ? "{}" : gap ? "{\n" + gap + partial.join(",\n" + gap) + "\n" + mind + "}" : "{" + partial.join(",") + "}";
            gap = mind;
            return v2;
        }
      }
      __name(str, "str");
      if (typeof JSON2.stringify !== "function") {
        JSON2.stringify = function(value, replacer, space) {
          var i;
          gap = "";
          indent = "";
          if (typeof space === "number") {
            for (i = 0; i < space; i += 1) {
              indent += " ";
            }
          } else if (typeof space === "string") {
            indent = space;
          }
          rep = replacer;
          if (replacer && typeof replacer !== "function" && (typeof replacer !== "object" || typeof replacer.length !== "number")) {
            throw new Error("JSON.stringify");
          }
          return str("", { "": value });
        };
      }
    })();
  }
});

// node_modules/json-bigint/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/json-bigint/lib/parse.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var BigNumber = null;
    var suspectProtoRx = /(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])/;
    var suspectConstructorRx = /(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)/;
    var json_parse = /* @__PURE__ */ __name(function(options) {
      "use strict";
      var _options = {
        strict: false,
        // not being strict means do not generate syntax errors for "duplicate key"
        storeAsString: false,
        // toggles whether the values should be stored as BigNumber (default) or a string
        alwaysParseAsBig: false,
        // toggles whether all numbers should be Big
        useNativeBigInt: false,
        // toggles whether to use native BigInt instead of bignumber.js
        protoAction: "error",
        constructorAction: "error"
      };
      if (options !== void 0 && options !== null) {
        if (options.strict === true) {
          _options.strict = true;
        }
        if (options.storeAsString === true) {
          _options.storeAsString = true;
        }
        _options.alwaysParseAsBig = options.alwaysParseAsBig === true ? options.alwaysParseAsBig : false;
        _options.useNativeBigInt = options.useNativeBigInt === true ? options.useNativeBigInt : false;
        if (typeof options.constructorAction !== "undefined") {
          if (options.constructorAction === "error" || options.constructorAction === "ignore" || options.constructorAction === "preserve") {
            _options.constructorAction = options.constructorAction;
          } else {
            throw new Error(
              `Incorrect value for constructorAction option, must be "error", "ignore" or undefined but passed ${options.constructorAction}`
            );
          }
        }
        if (typeof options.protoAction !== "undefined") {
          if (options.protoAction === "error" || options.protoAction === "ignore" || options.protoAction === "preserve") {
            _options.protoAction = options.protoAction;
          } else {
            throw new Error(
              `Incorrect value for protoAction option, must be "error", "ignore" or undefined but passed ${options.protoAction}`
            );
          }
        }
      }
      var at, ch, escapee = {
        '"': '"',
        "\\": "\\",
        "/": "/",
        b: "\b",
        f: "\f",
        n: "\n",
        r: "\r",
        t: "	"
      }, text, error3 = /* @__PURE__ */ __name(function(m2) {
        throw {
          name: "SyntaxError",
          message: m2,
          at,
          text
        };
      }, "error"), next = /* @__PURE__ */ __name(function(c) {
        if (c && c !== ch) {
          error3("Expected '" + c + "' instead of '" + ch + "'");
        }
        ch = text.charAt(at);
        at += 1;
        return ch;
      }, "next"), number = /* @__PURE__ */ __name(function() {
        var number2, string2 = "";
        if (ch === "-") {
          string2 = "-";
          next("-");
        }
        while (ch >= "0" && ch <= "9") {
          string2 += ch;
          next();
        }
        if (ch === ".") {
          string2 += ".";
          while (next() && ch >= "0" && ch <= "9") {
            string2 += ch;
          }
        }
        if (ch === "e" || ch === "E") {
          string2 += ch;
          next();
          if (ch === "-" || ch === "+") {
            string2 += ch;
            next();
          }
          while (ch >= "0" && ch <= "9") {
            string2 += ch;
            next();
          }
        }
        number2 = +string2;
        if (!isFinite(number2)) {
          error3("Bad number");
        } else {
          if (BigNumber == null) BigNumber = require_bignumber();
          if (string2.length > 15)
            return _options.storeAsString ? string2 : _options.useNativeBigInt ? BigInt(string2) : new BigNumber(string2);
          else
            return !_options.alwaysParseAsBig ? number2 : _options.useNativeBigInt ? BigInt(number2) : new BigNumber(number2);
        }
      }, "number"), string = /* @__PURE__ */ __name(function() {
        var hex, i, string2 = "", uffff;
        if (ch === '"') {
          var startAt = at;
          while (next()) {
            if (ch === '"') {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              return string2;
            }
            if (ch === "\\") {
              if (at - 1 > startAt) string2 += text.substring(startAt, at - 1);
              next();
              if (ch === "u") {
                uffff = 0;
                for (i = 0; i < 4; i += 1) {
                  hex = parseInt(next(), 16);
                  if (!isFinite(hex)) {
                    break;
                  }
                  uffff = uffff * 16 + hex;
                }
                string2 += String.fromCharCode(uffff);
              } else if (typeof escapee[ch] === "string") {
                string2 += escapee[ch];
              } else {
                break;
              }
              startAt = at;
            }
          }
        }
        error3("Bad string");
      }, "string"), white = /* @__PURE__ */ __name(function() {
        while (ch && ch <= " ") {
          next();
        }
      }, "white"), word = /* @__PURE__ */ __name(function() {
        switch (ch) {
          case "t":
            next("t");
            next("r");
            next("u");
            next("e");
            return true;
          case "f":
            next("f");
            next("a");
            next("l");
            next("s");
            next("e");
            return false;
          case "n":
            next("n");
            next("u");
            next("l");
            next("l");
            return null;
        }
        error3("Unexpected '" + ch + "'");
      }, "word"), value, array = /* @__PURE__ */ __name(function() {
        var array2 = [];
        if (ch === "[") {
          next("[");
          white();
          if (ch === "]") {
            next("]");
            return array2;
          }
          while (ch) {
            array2.push(value());
            white();
            if (ch === "]") {
              next("]");
              return array2;
            }
            next(",");
            white();
          }
        }
        error3("Bad array");
      }, "array"), object = /* @__PURE__ */ __name(function() {
        var key, object2 = /* @__PURE__ */ Object.create(null);
        if (ch === "{") {
          next("{");
          white();
          if (ch === "}") {
            next("}");
            return object2;
          }
          while (ch) {
            key = string();
            white();
            next(":");
            if (_options.strict === true && Object.hasOwnProperty.call(object2, key)) {
              error3('Duplicate key "' + key + '"');
            }
            if (suspectProtoRx.test(key) === true) {
              if (_options.protoAction === "error") {
                error3("Object contains forbidden prototype property");
              } else if (_options.protoAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else if (suspectConstructorRx.test(key) === true) {
              if (_options.constructorAction === "error") {
                error3("Object contains forbidden constructor property");
              } else if (_options.constructorAction === "ignore") {
                value();
              } else {
                object2[key] = value();
              }
            } else {
              object2[key] = value();
            }
            white();
            if (ch === "}") {
              next("}");
              return object2;
            }
            next(",");
            white();
          }
        }
        error3("Bad object");
      }, "object");
      value = /* @__PURE__ */ __name(function() {
        white();
        switch (ch) {
          case "{":
            return object();
          case "[":
            return array();
          case '"':
            return string();
          case "-":
            return number();
          default:
            return ch >= "0" && ch <= "9" ? number() : word();
        }
      }, "value");
      return function(source, reviver) {
        var result;
        text = source + "";
        at = 0;
        ch = " ";
        result = value();
        white();
        if (ch) {
          error3("Syntax error");
        }
        return typeof reviver === "function" ? (/* @__PURE__ */ __name(function walk(holder, key) {
          var k, v2, value2 = holder[key];
          if (value2 && typeof value2 === "object") {
            Object.keys(value2).forEach(function(k2) {
              v2 = walk(value2, k2);
              if (v2 !== void 0) {
                value2[k2] = v2;
              } else {
                delete value2[k2];
              }
            });
          }
          return reviver.call(holder, key, value2);
        }, "walk"))({ "": result }, "") : result;
      };
    }, "json_parse");
    module.exports = json_parse;
  }
});

// node_modules/json-bigint/index.js
var require_json_bigint = __commonJS({
  "node_modules/json-bigint/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var json_stringify = require_stringify2().stringify;
    var json_parse = require_parse2();
    module.exports = function(options) {
      return {
        parse: json_parse(options),
        stringify: json_stringify
      };
    };
    module.exports.parse = json_parse();
    module.exports.stringify = json_stringify;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/os/constants.mjs
var UV_UDP_REUSEADDR, dlopen2, errno, signals, priority;
var init_constants4 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/os/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    UV_UDP_REUSEADDR = 4;
    dlopen2 = {
      RTLD_LAZY: 1,
      RTLD_NOW: 2,
      RTLD_GLOBAL: 256,
      RTLD_LOCAL: 0,
      RTLD_DEEPBIND: 8
    };
    errno = {
      E2BIG: 7,
      EACCES: 13,
      EADDRINUSE: 98,
      EADDRNOTAVAIL: 99,
      EAFNOSUPPORT: 97,
      EAGAIN: 11,
      EALREADY: 114,
      EBADF: 9,
      EBADMSG: 74,
      EBUSY: 16,
      ECANCELED: 125,
      ECHILD: 10,
      ECONNABORTED: 103,
      ECONNREFUSED: 111,
      ECONNRESET: 104,
      EDEADLK: 35,
      EDESTADDRREQ: 89,
      EDOM: 33,
      EDQUOT: 122,
      EEXIST: 17,
      EFAULT: 14,
      EFBIG: 27,
      EHOSTUNREACH: 113,
      EIDRM: 43,
      EILSEQ: 84,
      EINPROGRESS: 115,
      EINTR: 4,
      EINVAL: 22,
      EIO: 5,
      EISCONN: 106,
      EISDIR: 21,
      ELOOP: 40,
      EMFILE: 24,
      EMLINK: 31,
      EMSGSIZE: 90,
      EMULTIHOP: 72,
      ENAMETOOLONG: 36,
      ENETDOWN: 100,
      ENETRESET: 102,
      ENETUNREACH: 101,
      ENFILE: 23,
      ENOBUFS: 105,
      ENODATA: 61,
      ENODEV: 19,
      ENOENT: 2,
      ENOEXEC: 8,
      ENOLCK: 37,
      ENOLINK: 67,
      ENOMEM: 12,
      ENOMSG: 42,
      ENOPROTOOPT: 92,
      ENOSPC: 28,
      ENOSR: 63,
      ENOSTR: 60,
      ENOSYS: 38,
      ENOTCONN: 107,
      ENOTDIR: 20,
      ENOTEMPTY: 39,
      ENOTSOCK: 88,
      ENOTSUP: 95,
      ENOTTY: 25,
      ENXIO: 6,
      EOPNOTSUPP: 95,
      EOVERFLOW: 75,
      EPERM: 1,
      EPIPE: 32,
      EPROTO: 71,
      EPROTONOSUPPORT: 93,
      EPROTOTYPE: 91,
      ERANGE: 34,
      EROFS: 30,
      ESPIPE: 29,
      ESRCH: 3,
      ESTALE: 116,
      ETIME: 62,
      ETIMEDOUT: 110,
      ETXTBSY: 26,
      EWOULDBLOCK: 11,
      EXDEV: 18
    };
    signals = {
      SIGHUP: 1,
      SIGINT: 2,
      SIGQUIT: 3,
      SIGILL: 4,
      SIGTRAP: 5,
      SIGABRT: 6,
      SIGIOT: 6,
      SIGBUS: 7,
      SIGFPE: 8,
      SIGKILL: 9,
      SIGUSR1: 10,
      SIGSEGV: 11,
      SIGUSR2: 12,
      SIGPIPE: 13,
      SIGALRM: 14,
      SIGTERM: 15,
      SIGCHLD: 17,
      SIGSTKFLT: 16,
      SIGCONT: 18,
      SIGSTOP: 19,
      SIGTSTP: 20,
      SIGTTIN: 21,
      SIGTTOU: 22,
      SIGURG: 23,
      SIGXCPU: 24,
      SIGXFSZ: 25,
      SIGVTALRM: 26,
      SIGPROF: 27,
      SIGWINCH: 28,
      SIGIO: 29,
      SIGPOLL: 29,
      SIGPWR: 30,
      SIGSYS: 31
    };
    priority = {
      PRIORITY_LOW: 19,
      PRIORITY_BELOW_NORMAL: 10,
      PRIORITY_NORMAL: 0,
      PRIORITY_ABOVE_NORMAL: -7,
      PRIORITY_HIGH: -14,
      PRIORITY_HIGHEST: -20
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/os.mjs
var constants, NUM_CPUS, availableParallelism, arch2, machine, endianness, cpus, getPriority, setPriority, homedir, tmpdir, devNull, freemem, totalmem, loadavg, uptime2, hostname, networkInterfaces, platform2, type, release2, version2, userInfo, EOL, os_default;
var init_os = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/os.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_constants4();
    constants = {
      UV_UDP_REUSEADDR,
      dlopen: dlopen2,
      errno,
      signals,
      priority
    };
    NUM_CPUS = 8;
    availableParallelism = /* @__PURE__ */ __name(() => NUM_CPUS, "availableParallelism");
    arch2 = /* @__PURE__ */ __name(() => "", "arch");
    machine = /* @__PURE__ */ __name(() => "", "machine");
    endianness = /* @__PURE__ */ __name(() => "LE", "endianness");
    cpus = /* @__PURE__ */ __name(() => {
      const info3 = {
        model: "",
        speed: 0,
        times: {
          user: 0,
          nice: 0,
          sys: 0,
          idle: 0,
          irq: 0
        }
      };
      return Array.from({ length: NUM_CPUS }, () => info3);
    }, "cpus");
    getPriority = /* @__PURE__ */ __name(() => 0, "getPriority");
    setPriority = /* @__PURE__ */ notImplemented("os.setPriority");
    homedir = /* @__PURE__ */ __name(() => "/", "homedir");
    tmpdir = /* @__PURE__ */ __name(() => "/tmp", "tmpdir");
    devNull = "/dev/null";
    freemem = /* @__PURE__ */ __name(() => 0, "freemem");
    totalmem = /* @__PURE__ */ __name(() => 0, "totalmem");
    loadavg = /* @__PURE__ */ __name(() => [
      0,
      0,
      0
    ], "loadavg");
    uptime2 = /* @__PURE__ */ __name(() => 0, "uptime");
    hostname = /* @__PURE__ */ __name(() => "", "hostname");
    networkInterfaces = /* @__PURE__ */ __name(() => {
      return { lo0: [
        {
          address: "127.0.0.1",
          netmask: "255.0.0.0",
          family: "IPv4",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "127.0.0.1/8"
        },
        {
          address: "::1",
          netmask: "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "::1/128",
          scopeid: 0
        },
        {
          address: "fe80::1",
          netmask: "ffff:ffff:ffff:ffff::",
          family: "IPv6",
          mac: "00:00:00:00:00:00",
          internal: true,
          cidr: "fe80::1/64",
          scopeid: 1
        }
      ] };
    }, "networkInterfaces");
    platform2 = /* @__PURE__ */ __name(() => "linux", "platform");
    type = /* @__PURE__ */ __name(() => "Linux", "type");
    release2 = /* @__PURE__ */ __name(() => "", "release");
    version2 = /* @__PURE__ */ __name(() => "", "version");
    userInfo = /* @__PURE__ */ __name((opts) => {
      const encode3 = /* @__PURE__ */ __name((str) => {
        if (opts?.encoding) {
          const buff = Buffer.from(str);
          return opts.encoding === "buffer" ? buff : buff.toString(opts.encoding);
        }
        return str;
      }, "encode");
      return {
        gid: 1e3,
        uid: 1e3,
        homedir: encode3("/"),
        shell: encode3("/bin/sh"),
        username: encode3("root")
      };
    }, "userInfo");
    EOL = "\n";
    os_default = {
      arch: arch2,
      availableParallelism,
      constants,
      cpus,
      EOL,
      endianness,
      devNull,
      freemem,
      getPriority,
      homedir,
      hostname,
      loadavg,
      machine,
      networkInterfaces,
      platform: platform2,
      release: release2,
      setPriority,
      tmpdir,
      totalmem,
      type,
      uptime: uptime2,
      userInfo,
      version: version2
    };
  }
});

// node-built-in-modules:os
var require_os = __commonJS({
  "node-built-in-modules:os"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_os();
    module.exports = os_default;
  }
});

// node_modules/gcp-metadata/build/src/gcp-residency.js
var require_gcp_residency = __commonJS({
  "node_modules/gcp-metadata/build/src/gcp-residency.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.detectGCPResidency = exports.isGoogleComputeEngine = exports.isGoogleComputeEngineMACAddress = exports.isGoogleComputeEngineLinux = exports.isGoogleCloudServerless = exports.GCE_LINUX_BIOS_PATHS = void 0;
    var fs_1 = require_fs();
    var os_1 = require_os();
    exports.GCE_LINUX_BIOS_PATHS = {
      BIOS_DATE: "/sys/class/dmi/id/bios_date",
      BIOS_VENDOR: "/sys/class/dmi/id/bios_vendor"
    };
    var GCE_MAC_ADDRESS_REGEX = /^42:01/;
    function isGoogleCloudServerless() {
      const isGFEnvironment = process.env.CLOUD_RUN_JOB || process.env.FUNCTION_NAME || process.env.K_SERVICE;
      return !!isGFEnvironment;
    }
    __name(isGoogleCloudServerless, "isGoogleCloudServerless");
    exports.isGoogleCloudServerless = isGoogleCloudServerless;
    function isGoogleComputeEngineLinux() {
      if ((0, os_1.platform)() !== "linux")
        return false;
      try {
        (0, fs_1.statSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_DATE);
        const biosVendor = (0, fs_1.readFileSync)(exports.GCE_LINUX_BIOS_PATHS.BIOS_VENDOR, "utf8");
        return /Google/.test(biosVendor);
      } catch (_a) {
        return false;
      }
    }
    __name(isGoogleComputeEngineLinux, "isGoogleComputeEngineLinux");
    exports.isGoogleComputeEngineLinux = isGoogleComputeEngineLinux;
    function isGoogleComputeEngineMACAddress() {
      const interfaces = (0, os_1.networkInterfaces)();
      for (const item of Object.values(interfaces)) {
        if (!item)
          continue;
        for (const { mac } of item) {
          if (GCE_MAC_ADDRESS_REGEX.test(mac)) {
            return true;
          }
        }
      }
      return false;
    }
    __name(isGoogleComputeEngineMACAddress, "isGoogleComputeEngineMACAddress");
    exports.isGoogleComputeEngineMACAddress = isGoogleComputeEngineMACAddress;
    function isGoogleComputeEngine() {
      return isGoogleComputeEngineLinux() || isGoogleComputeEngineMACAddress();
    }
    __name(isGoogleComputeEngine, "isGoogleComputeEngine");
    exports.isGoogleComputeEngine = isGoogleComputeEngine;
    function detectGCPResidency() {
      return isGoogleCloudServerless() || isGoogleComputeEngine();
    }
    __name(detectGCPResidency, "detectGCPResidency");
    exports.detectGCPResidency = detectGCPResidency;
  }
});

// node_modules/gcp-metadata/build/src/index.js
var require_src2 = __commonJS({
  "node_modules/gcp-metadata/build/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc || ("get" in desc ? !m2.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: /* @__PURE__ */ __name(function() {
          return m2[k];
        }, "get") };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __exportStar = exports && exports.__exportStar || function(m2, exports2) {
      for (var p2 in m2) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding(exports2, m2, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.requestTimeout = exports.setGCPResidency = exports.getGCPResidency = exports.gcpResidencyCache = exports.resetIsAvailableCache = exports.isAvailable = exports.bulk = exports.universe = exports.project = exports.instance = exports.METADATA_SERVER_DETECTION = exports.HEADERS = exports.HEADER_VALUE = exports.HEADER_NAME = exports.SECONDARY_HOST_ADDRESS = exports.HOST_ADDRESS = exports.BASE_PATH = void 0;
    var gaxios_1 = require_src();
    var jsonBigint = require_json_bigint();
    var gcp_residency_1 = require_gcp_residency();
    exports.BASE_PATH = "/computeMetadata/v1";
    exports.HOST_ADDRESS = "http://169.254.169.254";
    exports.SECONDARY_HOST_ADDRESS = "http://metadata.google.internal.";
    exports.HEADER_NAME = "Metadata-Flavor";
    exports.HEADER_VALUE = "Google";
    exports.HEADERS = Object.freeze({ [exports.HEADER_NAME]: exports.HEADER_VALUE });
    exports.METADATA_SERVER_DETECTION = Object.freeze({
      "assume-present": "don't try to ping the metadata server, but assume it's present",
      none: "don't try to ping the metadata server, but don't try to use it either",
      "bios-only": "treat the result of a BIOS probe as canonical (don't fall back to pinging)",
      "ping-only": "skip the BIOS probe, and go straight to pinging"
    });
    function getBaseUrl(baseUrl) {
      if (!baseUrl) {
        baseUrl = process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST || exports.HOST_ADDRESS;
      }
      if (!/^https?:\/\//.test(baseUrl)) {
        baseUrl = `http://${baseUrl}`;
      }
      return new URL(exports.BASE_PATH, baseUrl).href;
    }
    __name(getBaseUrl, "getBaseUrl");
    function validate(options) {
      Object.keys(options).forEach((key) => {
        switch (key) {
          case "params":
          case "property":
          case "headers":
            break;
          case "qs":
            throw new Error("'qs' is not a valid configuration option. Please use 'params' instead.");
          default:
            throw new Error(`'${key}' is not a valid configuration option.`);
        }
      });
    }
    __name(validate, "validate");
    async function metadataAccessor(type2, options = {}, noResponseRetries = 3, fastFail = false) {
      let metadataKey = "";
      let params = {};
      let headers = {};
      if (typeof type2 === "object") {
        const metadataAccessor2 = type2;
        metadataKey = metadataAccessor2.metadataKey;
        params = metadataAccessor2.params || params;
        headers = metadataAccessor2.headers || headers;
        noResponseRetries = metadataAccessor2.noResponseRetries || noResponseRetries;
        fastFail = metadataAccessor2.fastFail || fastFail;
      } else {
        metadataKey = type2;
      }
      if (typeof options === "string") {
        metadataKey += `/${options}`;
      } else {
        validate(options);
        if (options.property) {
          metadataKey += `/${options.property}`;
        }
        headers = options.headers || headers;
        params = options.params || params;
      }
      try {
        const requestMethod = fastFail ? fastFailMetadataRequest : gaxios_1.request;
        const res = await requestMethod({
          url: `${getBaseUrl()}/${metadataKey}`,
          headers: { ...exports.HEADERS, ...headers },
          retryConfig: { noResponseRetries },
          params,
          responseType: "text",
          timeout: requestTimeout()
        });
        if (res.headers[exports.HEADER_NAME.toLowerCase()] !== exports.HEADER_VALUE) {
          throw new Error(`Invalid response from metadata service: incorrect ${exports.HEADER_NAME} header.`);
        } else if (!res.data) {
          throw new Error("Invalid response from the metadata service");
        }
        if (typeof res.data === "string") {
          try {
            return jsonBigint.parse(res.data);
          } catch (_a) {
          }
        }
        return res.data;
      } catch (e) {
        const err = e;
        if (err.response && err.response.status !== 200) {
          err.message = `Unsuccessful response status code. ${err.message}`;
        }
        throw e;
      }
    }
    __name(metadataAccessor, "metadataAccessor");
    async function fastFailMetadataRequest(options) {
      const secondaryOptions = {
        ...options,
        url: options.url.replace(getBaseUrl(), getBaseUrl(exports.SECONDARY_HOST_ADDRESS))
      };
      let responded = false;
      const r1 = (0, gaxios_1.request)(options).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r2;
        } else {
          responded = true;
          throw err;
        }
      });
      const r2 = (0, gaxios_1.request)(secondaryOptions).then((res) => {
        responded = true;
        return res;
      }).catch((err) => {
        if (responded) {
          return r1;
        } else {
          responded = true;
          throw err;
        }
      });
      return Promise.race([r1, r2]);
    }
    __name(fastFailMetadataRequest, "fastFailMetadataRequest");
    function instance(options) {
      return metadataAccessor("instance", options);
    }
    __name(instance, "instance");
    exports.instance = instance;
    function project(options) {
      return metadataAccessor("project", options);
    }
    __name(project, "project");
    exports.project = project;
    function universe(options) {
      return metadataAccessor("universe", options);
    }
    __name(universe, "universe");
    exports.universe = universe;
    async function bulk(properties) {
      const r = {};
      await Promise.all(properties.map((item) => {
        return (async () => {
          const res = await metadataAccessor(item);
          const key = item.metadataKey;
          r[key] = res;
        })();
      }));
      return r;
    }
    __name(bulk, "bulk");
    exports.bulk = bulk;
    function detectGCPAvailableRetries() {
      return process.env.DETECT_GCP_RETRIES ? Number(process.env.DETECT_GCP_RETRIES) : 0;
    }
    __name(detectGCPAvailableRetries, "detectGCPAvailableRetries");
    var cachedIsAvailableResponse;
    async function isAvailable() {
      if (process.env.METADATA_SERVER_DETECTION) {
        const value = process.env.METADATA_SERVER_DETECTION.trim().toLocaleLowerCase();
        if (!(value in exports.METADATA_SERVER_DETECTION)) {
          throw new RangeError(`Unknown \`METADATA_SERVER_DETECTION\` env variable. Got \`${value}\`, but it should be \`${Object.keys(exports.METADATA_SERVER_DETECTION).join("`, `")}\`, or unset`);
        }
        switch (value) {
          case "assume-present":
            return true;
          case "none":
            return false;
          case "bios-only":
            return getGCPResidency();
          case "ping-only":
        }
      }
      try {
        if (cachedIsAvailableResponse === void 0) {
          cachedIsAvailableResponse = metadataAccessor(
            "instance",
            void 0,
            detectGCPAvailableRetries(),
            // If the default HOST_ADDRESS has been overridden, we should not
            // make an effort to try SECONDARY_HOST_ADDRESS (as we are likely in
            // a non-GCP environment):
            !(process.env.GCE_METADATA_IP || process.env.GCE_METADATA_HOST)
          );
        }
        await cachedIsAvailableResponse;
        return true;
      } catch (e) {
        const err = e;
        if (process.env.DEBUG_AUTH) {
          console.info(err);
        }
        if (err.type === "request-timeout") {
          return false;
        }
        if (err.response && err.response.status === 404) {
          return false;
        } else {
          if (!(err.response && err.response.status === 404) && // A warning is emitted if we see an unexpected err.code, or err.code
          // is not populated:
          (!err.code || ![
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "ENETUNREACH",
            "ENOENT",
            "ENOTFOUND",
            "ECONNREFUSED"
          ].includes(err.code))) {
            let code = "UNKNOWN";
            if (err.code)
              code = err.code;
            process.emitWarning(`received unexpected error = ${err.message} code = ${code}`, "MetadataLookupWarning");
          }
          return false;
        }
      }
    }
    __name(isAvailable, "isAvailable");
    exports.isAvailable = isAvailable;
    function resetIsAvailableCache() {
      cachedIsAvailableResponse = void 0;
    }
    __name(resetIsAvailableCache, "resetIsAvailableCache");
    exports.resetIsAvailableCache = resetIsAvailableCache;
    exports.gcpResidencyCache = null;
    function getGCPResidency() {
      if (exports.gcpResidencyCache === null) {
        setGCPResidency();
      }
      return exports.gcpResidencyCache;
    }
    __name(getGCPResidency, "getGCPResidency");
    exports.getGCPResidency = getGCPResidency;
    function setGCPResidency(value = null) {
      exports.gcpResidencyCache = value !== null ? value : (0, gcp_residency_1.detectGCPResidency)();
    }
    __name(setGCPResidency, "setGCPResidency");
    exports.setGCPResidency = setGCPResidency;
    function requestTimeout() {
      return getGCPResidency() ? 0 : 3e3;
    }
    __name(requestTimeout, "requestTimeout");
    exports.requestTimeout = requestTimeout;
    __exportStar(require_gcp_residency(), exports);
  }
});

// node-built-in-modules:path
import libDefault6 from "path";
var require_path = __commonJS({
  "node-built-in-modules:path"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault6;
  }
});

// node_modules/base64-js/index.js
var require_base64_js = __commonJS({
  "node_modules/base64-js/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.byteLength = byteLength;
    exports.toByteArray = toByteArray;
    exports.fromByteArray = fromByteArray;
    var lookup = [];
    var revLookup = [];
    var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    for (i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }
    var i;
    var len;
    revLookup["-".charCodeAt(0)] = 62;
    revLookup["_".charCodeAt(0)] = 63;
    function getLens(b64) {
      var len2 = b64.length;
      if (len2 % 4 > 0) {
        throw new Error("Invalid string. Length must be a multiple of 4");
      }
      var validLen = b64.indexOf("=");
      if (validLen === -1) validLen = len2;
      var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
      return [validLen, placeHoldersLen];
    }
    __name(getLens, "getLens");
    function byteLength(b64) {
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(byteLength, "byteLength");
    function _byteLength(b64, validLen, placeHoldersLen) {
      return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
    }
    __name(_byteLength, "_byteLength");
    function toByteArray(b64) {
      var tmp;
      var lens = getLens(b64);
      var validLen = lens[0];
      var placeHoldersLen = lens[1];
      var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
      var curByte = 0;
      var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
      var i2;
      for (i2 = 0; i2 < len2; i2 += 4) {
        tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
        arr[curByte++] = tmp >> 16 & 255;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 2) {
        tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
        arr[curByte++] = tmp & 255;
      }
      if (placeHoldersLen === 1) {
        tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
        arr[curByte++] = tmp >> 8 & 255;
        arr[curByte++] = tmp & 255;
      }
      return arr;
    }
    __name(toByteArray, "toByteArray");
    function tripletToBase64(num) {
      return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
    }
    __name(tripletToBase64, "tripletToBase64");
    function encodeChunk(uint8, start, end) {
      var tmp;
      var output = [];
      for (var i2 = start; i2 < end; i2 += 3) {
        tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
        output.push(tripletToBase64(tmp));
      }
      return output.join("");
    }
    __name(encodeChunk, "encodeChunk");
    function fromByteArray(uint8) {
      var tmp;
      var len2 = uint8.length;
      var extraBytes = len2 % 3;
      var parts = [];
      var maxChunkLength = 16383;
      for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
        parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
      }
      if (extraBytes === 1) {
        tmp = uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
        );
      } else if (extraBytes === 2) {
        tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
        parts.push(
          lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
        );
      }
      return parts.join("");
    }
    __name(fromByteArray, "fromByteArray");
  }
});

// node_modules/google-auth-library/build/src/crypto/browser/crypto.js
var require_crypto = __commonJS({
  "node_modules/google-auth-library/build/src/crypto/browser/crypto.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserCrypto = void 0;
    var base64js = require_base64_js();
    var crypto_1 = require_crypto4();
    var BrowserCrypto = class _BrowserCrypto {
      static {
        __name(this, "BrowserCrypto");
      }
      constructor() {
        if (typeof window === "undefined" || window.crypto === void 0 || window.crypto.subtle === void 0) {
          throw new Error("SubtleCrypto not found. Make sure it's an https:// website.");
        }
      }
      async sha256DigestBase64(str) {
        const inputBuffer = new TextEncoder().encode(str);
        const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
        return base64js.fromByteArray(new Uint8Array(outputBuffer));
      }
      randomBytesBase64(count3) {
        const array = new Uint8Array(count3);
        window.crypto.getRandomValues(array);
        return base64js.fromByteArray(array);
      }
      static padBase64(base64) {
        while (base64.length % 4 !== 0) {
          base64 += "=";
        }
        return base64;
      }
      async verify(pubkey, data, signature) {
        const algo = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
        const dataArray = new TextEncoder().encode(data);
        const signatureArray = base64js.toByteArray(_BrowserCrypto.padBase64(signature));
        const cryptoKey = await window.crypto.subtle.importKey("jwk", pubkey, algo, true, ["verify"]);
        const result = await window.crypto.subtle.verify(algo, cryptoKey, signatureArray, dataArray);
        return result;
      }
      async sign(privateKey, data) {
        const algo = {
          name: "RSASSA-PKCS1-v1_5",
          hash: { name: "SHA-256" }
        };
        const dataArray = new TextEncoder().encode(data);
        const cryptoKey = await window.crypto.subtle.importKey("jwk", privateKey, algo, true, ["sign"]);
        const result = await window.crypto.subtle.sign(algo, cryptoKey, dataArray);
        return base64js.fromByteArray(new Uint8Array(result));
      }
      decodeBase64StringUtf8(base64) {
        const uint8array = base64js.toByteArray(_BrowserCrypto.padBase64(base64));
        const result = new TextDecoder().decode(uint8array);
        return result;
      }
      encodeBase64StringUtf8(text) {
        const uint8array = new TextEncoder().encode(text);
        const result = base64js.fromByteArray(uint8array);
        return result;
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      async sha256DigestHex(str) {
        const inputBuffer = new TextEncoder().encode(str);
        const outputBuffer = await window.crypto.subtle.digest("SHA-256", inputBuffer);
        return (0, crypto_1.fromArrayBufferToHex)(outputBuffer);
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      async signWithHmacSha256(key, msg) {
        const rawKey = typeof key === "string" ? key : String.fromCharCode(...new Uint16Array(key));
        const enc = new TextEncoder();
        const cryptoKey = await window.crypto.subtle.importKey("raw", enc.encode(rawKey), {
          name: "HMAC",
          hash: {
            name: "SHA-256"
          }
        }, false, ["sign"]);
        return window.crypto.subtle.sign("HMAC", cryptoKey, enc.encode(msg));
      }
    };
    exports.BrowserCrypto = BrowserCrypto;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs
var subtle;
var init_web = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/web.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    subtle = globalThis.crypto?.subtle;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs
var webcrypto, createCipher, createDecipher, pseudoRandomBytes, Cipher, Decipher;
var init_node = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/node.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    webcrypto = new Proxy(globalThis.crypto, { get(_, key) {
      if (key === "CryptoKey") {
        return globalThis.CryptoKey;
      }
      if (typeof globalThis.crypto[key] === "function") {
        return globalThis.crypto[key].bind(globalThis.crypto);
      }
      return globalThis.crypto[key];
    } });
    createCipher = /* @__PURE__ */ notImplemented("crypto.createCipher");
    createDecipher = /* @__PURE__ */ notImplemented("crypto.createDecipher");
    pseudoRandomBytes = /* @__PURE__ */ notImplemented("crypto.pseudoRandomBytes");
    Cipher = /* @__PURE__ */ notImplementedClass("crypto.Cipher");
    Decipher = /* @__PURE__ */ notImplementedClass("crypto.Decipher");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs
var SSL_OP_ALL, SSL_OP_ALLOW_NO_DHE_KEX, SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION, SSL_OP_CIPHER_SERVER_PREFERENCE, SSL_OP_CISCO_ANYCONNECT, SSL_OP_COOKIE_EXCHANGE, SSL_OP_CRYPTOPRO_TLSEXT_BUG, SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS, SSL_OP_LEGACY_SERVER_CONNECT, SSL_OP_NO_COMPRESSION, SSL_OP_NO_ENCRYPT_THEN_MAC, SSL_OP_NO_QUERY_MTU, SSL_OP_NO_RENEGOTIATION, SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION, SSL_OP_NO_SSLv2, SSL_OP_NO_SSLv3, SSL_OP_NO_TICKET, SSL_OP_NO_TLSv1, SSL_OP_NO_TLSv1_1, SSL_OP_NO_TLSv1_2, SSL_OP_NO_TLSv1_3, SSL_OP_PRIORITIZE_CHACHA, SSL_OP_TLS_ROLLBACK_BUG, ENGINE_METHOD_RSA, ENGINE_METHOD_DSA, ENGINE_METHOD_DH, ENGINE_METHOD_RAND, ENGINE_METHOD_EC, ENGINE_METHOD_CIPHERS, ENGINE_METHOD_DIGESTS, ENGINE_METHOD_PKEY_METHS, ENGINE_METHOD_PKEY_ASN1_METHS, ENGINE_METHOD_ALL, ENGINE_METHOD_NONE, DH_CHECK_P_NOT_SAFE_PRIME, DH_CHECK_P_NOT_PRIME, DH_UNABLE_TO_CHECK_GENERATOR, DH_NOT_SUITABLE_GENERATOR, RSA_PKCS1_PADDING, RSA_NO_PADDING, RSA_PKCS1_OAEP_PADDING, RSA_X931_PADDING, RSA_PKCS1_PSS_PADDING, RSA_PSS_SALTLEN_DIGEST, RSA_PSS_SALTLEN_MAX_SIGN, RSA_PSS_SALTLEN_AUTO, POINT_CONVERSION_COMPRESSED, POINT_CONVERSION_UNCOMPRESSED, POINT_CONVERSION_HYBRID, defaultCoreCipherList, defaultCipherList, OPENSSL_VERSION_NUMBER, TLS1_VERSION, TLS1_1_VERSION, TLS1_2_VERSION, TLS1_3_VERSION;
var init_constants5 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/crypto/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    SSL_OP_ALL = 2147485776;
    SSL_OP_ALLOW_NO_DHE_KEX = 1024;
    SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = 262144;
    SSL_OP_CIPHER_SERVER_PREFERENCE = 4194304;
    SSL_OP_CISCO_ANYCONNECT = 32768;
    SSL_OP_COOKIE_EXCHANGE = 8192;
    SSL_OP_CRYPTOPRO_TLSEXT_BUG = 2147483648;
    SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 2048;
    SSL_OP_LEGACY_SERVER_CONNECT = 4;
    SSL_OP_NO_COMPRESSION = 131072;
    SSL_OP_NO_ENCRYPT_THEN_MAC = 524288;
    SSL_OP_NO_QUERY_MTU = 4096;
    SSL_OP_NO_RENEGOTIATION = 1073741824;
    SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 65536;
    SSL_OP_NO_SSLv2 = 0;
    SSL_OP_NO_SSLv3 = 33554432;
    SSL_OP_NO_TICKET = 16384;
    SSL_OP_NO_TLSv1 = 67108864;
    SSL_OP_NO_TLSv1_1 = 268435456;
    SSL_OP_NO_TLSv1_2 = 134217728;
    SSL_OP_NO_TLSv1_3 = 536870912;
    SSL_OP_PRIORITIZE_CHACHA = 2097152;
    SSL_OP_TLS_ROLLBACK_BUG = 8388608;
    ENGINE_METHOD_RSA = 1;
    ENGINE_METHOD_DSA = 2;
    ENGINE_METHOD_DH = 4;
    ENGINE_METHOD_RAND = 8;
    ENGINE_METHOD_EC = 2048;
    ENGINE_METHOD_CIPHERS = 64;
    ENGINE_METHOD_DIGESTS = 128;
    ENGINE_METHOD_PKEY_METHS = 512;
    ENGINE_METHOD_PKEY_ASN1_METHS = 1024;
    ENGINE_METHOD_ALL = 65535;
    ENGINE_METHOD_NONE = 0;
    DH_CHECK_P_NOT_SAFE_PRIME = 2;
    DH_CHECK_P_NOT_PRIME = 1;
    DH_UNABLE_TO_CHECK_GENERATOR = 4;
    DH_NOT_SUITABLE_GENERATOR = 8;
    RSA_PKCS1_PADDING = 1;
    RSA_NO_PADDING = 3;
    RSA_PKCS1_OAEP_PADDING = 4;
    RSA_X931_PADDING = 5;
    RSA_PKCS1_PSS_PADDING = 6;
    RSA_PSS_SALTLEN_DIGEST = -1;
    RSA_PSS_SALTLEN_MAX_SIGN = -2;
    RSA_PSS_SALTLEN_AUTO = -2;
    POINT_CONVERSION_COMPRESSED = 2;
    POINT_CONVERSION_UNCOMPRESSED = 4;
    POINT_CONVERSION_HYBRID = 6;
    defaultCoreCipherList = "";
    defaultCipherList = "";
    OPENSSL_VERSION_NUMBER = 0;
    TLS1_VERSION = 0;
    TLS1_1_VERSION = 0;
    TLS1_2_VERSION = 0;
    TLS1_3_VERSION = 0;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/crypto.mjs
var constants2;
var init_crypto = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/crypto.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_constants5();
    init_web();
    init_node();
    constants2 = {
      OPENSSL_VERSION_NUMBER,
      SSL_OP_ALL,
      SSL_OP_ALLOW_NO_DHE_KEX,
      SSL_OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION,
      SSL_OP_CIPHER_SERVER_PREFERENCE,
      SSL_OP_CISCO_ANYCONNECT,
      SSL_OP_COOKIE_EXCHANGE,
      SSL_OP_CRYPTOPRO_TLSEXT_BUG,
      SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS,
      SSL_OP_LEGACY_SERVER_CONNECT,
      SSL_OP_NO_COMPRESSION,
      SSL_OP_NO_ENCRYPT_THEN_MAC,
      SSL_OP_NO_QUERY_MTU,
      SSL_OP_NO_RENEGOTIATION,
      SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION,
      SSL_OP_NO_SSLv2,
      SSL_OP_NO_SSLv3,
      SSL_OP_NO_TICKET,
      SSL_OP_NO_TLSv1,
      SSL_OP_NO_TLSv1_1,
      SSL_OP_NO_TLSv1_2,
      SSL_OP_NO_TLSv1_3,
      SSL_OP_PRIORITIZE_CHACHA,
      SSL_OP_TLS_ROLLBACK_BUG,
      ENGINE_METHOD_RSA,
      ENGINE_METHOD_DSA,
      ENGINE_METHOD_DH,
      ENGINE_METHOD_RAND,
      ENGINE_METHOD_EC,
      ENGINE_METHOD_CIPHERS,
      ENGINE_METHOD_DIGESTS,
      ENGINE_METHOD_PKEY_METHS,
      ENGINE_METHOD_PKEY_ASN1_METHS,
      ENGINE_METHOD_ALL,
      ENGINE_METHOD_NONE,
      DH_CHECK_P_NOT_SAFE_PRIME,
      DH_CHECK_P_NOT_PRIME,
      DH_UNABLE_TO_CHECK_GENERATOR,
      DH_NOT_SUITABLE_GENERATOR,
      RSA_PKCS1_PADDING,
      RSA_NO_PADDING,
      RSA_PKCS1_OAEP_PADDING,
      RSA_X931_PADDING,
      RSA_PKCS1_PSS_PADDING,
      RSA_PSS_SALTLEN_DIGEST,
      RSA_PSS_SALTLEN_MAX_SIGN,
      RSA_PSS_SALTLEN_AUTO,
      defaultCoreCipherList,
      TLS1_VERSION,
      TLS1_1_VERSION,
      TLS1_2_VERSION,
      TLS1_3_VERSION,
      POINT_CONVERSION_COMPRESSED,
      POINT_CONVERSION_UNCOMPRESSED,
      POINT_CONVERSION_HYBRID,
      defaultCipherList
    };
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs
var workerdCrypto, Certificate, checkPrime, checkPrimeSync, Cipheriv, createCipheriv, createDecipheriv, createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createHmac, createPrivateKey, createPublicKey, createSecretKey, createSign, createVerify, Decipheriv, diffieHellman, DiffieHellman, DiffieHellmanGroup, ECDH, fips, generateKey, generateKeyPair, generateKeyPairSync, generateKeySync, generatePrime, generatePrimeSync, getCipherInfo, getCiphers2, getCurves, getDiffieHellman, getFips, getHashes, getRandomValues, hash, Hash, hkdf, hkdfSync, Hmac, KeyObject, pbkdf2, pbkdf2Sync, privateDecrypt, privateEncrypt, publicDecrypt, publicEncrypt, randomBytes, randomFill, randomFillSync, randomInt, randomUUID, scrypt, scryptSync, secureHeapUsed, setEngine, setFips, sign, Sign, subtle2, timingSafeEqual, verify, Verify, X509Certificate, webcrypto2, crypto_default;
var init_crypto2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/crypto.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto();
    workerdCrypto = process.getBuiltinModule("node:crypto");
    ({
      Certificate,
      checkPrime,
      checkPrimeSync,
      Cipheriv: (
        // @ts-expect-error
        Cipheriv
      ),
      createCipheriv,
      createDecipheriv,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createECDH,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      createSign,
      createVerify,
      Decipheriv: (
        // @ts-expect-error
        Decipheriv
      ),
      diffieHellman,
      DiffieHellman,
      DiffieHellmanGroup,
      ECDH,
      fips,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCipherInfo,
      getCiphers: getCiphers2,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hash,
      Hash,
      hkdf,
      hkdfSync,
      Hmac,
      KeyObject,
      pbkdf2,
      pbkdf2Sync,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      scrypt,
      scryptSync,
      secureHeapUsed,
      setEngine,
      setFips,
      sign,
      Sign,
      subtle: subtle2,
      timingSafeEqual,
      verify,
      Verify,
      X509Certificate
    } = workerdCrypto);
    webcrypto2 = {
      // @ts-expect-error
      CryptoKey: webcrypto.CryptoKey,
      getRandomValues,
      randomUUID,
      subtle: subtle2
    };
    crypto_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      Certificate,
      Cipher,
      Cipheriv,
      Decipher,
      Decipheriv,
      ECDH,
      Sign,
      Verify,
      X509Certificate,
      // @ts-expect-error @types/node is out of date - this is a bug in typings
      constants: constants2,
      createCipheriv,
      createDecipheriv,
      createECDH,
      createSign,
      createVerify,
      diffieHellman,
      getCipherInfo,
      hash,
      privateDecrypt,
      privateEncrypt,
      publicDecrypt,
      publicEncrypt,
      scrypt,
      scryptSync,
      sign,
      verify,
      // default-only export from unenv
      // @ts-expect-error unenv has unknown type
      createCipher,
      // @ts-expect-error unenv has unknown type
      createDecipher,
      // @ts-expect-error unenv has unknown type
      pseudoRandomBytes,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      DiffieHellman,
      DiffieHellmanGroup,
      Hash,
      Hmac,
      KeyObject,
      checkPrime,
      checkPrimeSync,
      createDiffieHellman,
      createDiffieHellmanGroup,
      createHash,
      createHmac,
      createPrivateKey,
      createPublicKey,
      createSecretKey,
      generateKey,
      generateKeyPair,
      generateKeyPairSync,
      generateKeySync,
      generatePrime,
      generatePrimeSync,
      getCiphers: getCiphers2,
      getCurves,
      getDiffieHellman,
      getFips,
      getHashes,
      getRandomValues,
      hkdf,
      hkdfSync,
      pbkdf2,
      pbkdf2Sync,
      randomBytes,
      randomFill,
      randomFillSync,
      randomInt,
      randomUUID,
      secureHeapUsed,
      setEngine,
      setFips,
      subtle: subtle2,
      timingSafeEqual,
      // default-only export from workerd
      fips,
      // special-cased deep merged symbols
      webcrypto: webcrypto2
    };
  }
});

// node-built-in-modules:crypto
var require_crypto2 = __commonJS({
  "node-built-in-modules:crypto"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_crypto2();
    module.exports = crypto_default;
  }
});

// node_modules/google-auth-library/build/src/crypto/node/crypto.js
var require_crypto3 = __commonJS({
  "node_modules/google-auth-library/build/src/crypto/node/crypto.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeCrypto = void 0;
    var crypto2 = require_crypto2();
    var NodeCrypto = class {
      static {
        __name(this, "NodeCrypto");
      }
      async sha256DigestBase64(str) {
        return crypto2.createHash("sha256").update(str).digest("base64");
      }
      randomBytesBase64(count3) {
        return crypto2.randomBytes(count3).toString("base64");
      }
      async verify(pubkey, data, signature) {
        const verifier = crypto2.createVerify("RSA-SHA256");
        verifier.update(data);
        verifier.end();
        return verifier.verify(pubkey, signature, "base64");
      }
      async sign(privateKey, data) {
        const signer = crypto2.createSign("RSA-SHA256");
        signer.update(data);
        signer.end();
        return signer.sign(privateKey, "base64");
      }
      decodeBase64StringUtf8(base64) {
        return Buffer.from(base64, "base64").toString("utf-8");
      }
      encodeBase64StringUtf8(text) {
        return Buffer.from(text, "utf-8").toString("base64");
      }
      /**
       * Computes the SHA-256 hash of the provided string.
       * @param str The plain text string to hash.
       * @return A promise that resolves with the SHA-256 hash of the provided
       *   string in hexadecimal encoding.
       */
      async sha256DigestHex(str) {
        return crypto2.createHash("sha256").update(str).digest("hex");
      }
      /**
       * Computes the HMAC hash of a message using the provided crypto key and the
       * SHA-256 algorithm.
       * @param key The secret crypto key in utf-8 or ArrayBuffer format.
       * @param msg The plain text message.
       * @return A promise that resolves with the HMAC-SHA256 hash in ArrayBuffer
       *   format.
       */
      async signWithHmacSha256(key, msg) {
        const cryptoKey = typeof key === "string" ? key : toBuffer(key);
        return toArrayBuffer(crypto2.createHmac("sha256", cryptoKey).update(msg).digest());
      }
    };
    exports.NodeCrypto = NodeCrypto;
    function toArrayBuffer(buffer) {
      return buffer.buffer.slice(buffer.byteOffset, buffer.byteOffset + buffer.byteLength);
    }
    __name(toArrayBuffer, "toArrayBuffer");
    function toBuffer(arrayBuffer) {
      return Buffer.from(arrayBuffer);
    }
    __name(toBuffer, "toBuffer");
  }
});

// node_modules/google-auth-library/build/src/crypto/crypto.js
var require_crypto4 = __commonJS({
  "node_modules/google-auth-library/build/src/crypto/crypto.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCrypto = createCrypto;
    exports.hasBrowserCrypto = hasBrowserCrypto;
    exports.fromArrayBufferToHex = fromArrayBufferToHex;
    var crypto_1 = require_crypto();
    var crypto_2 = require_crypto3();
    function createCrypto() {
      if (hasBrowserCrypto()) {
        return new crypto_1.BrowserCrypto();
      }
      return new crypto_2.NodeCrypto();
    }
    __name(createCrypto, "createCrypto");
    function hasBrowserCrypto() {
      return typeof window !== "undefined" && typeof window.crypto !== "undefined" && typeof window.crypto.subtle !== "undefined";
    }
    __name(hasBrowserCrypto, "hasBrowserCrypto");
    function fromArrayBufferToHex(arrayBuffer) {
      const byteArray = Array.from(new Uint8Array(arrayBuffer));
      return byteArray.map((byte) => {
        return byte.toString(16).padStart(2, "0");
      }).join("");
    }
    __name(fromArrayBufferToHex, "fromArrayBufferToHex");
  }
});

// node_modules/google-auth-library/build/src/options.js
var require_options = __commonJS({
  "node_modules/google-auth-library/build/src/options.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validate = validate;
    function validate(options) {
      const vpairs = [
        { invalid: "uri", expected: "url" },
        { invalid: "json", expected: "data" },
        { invalid: "qs", expected: "params" }
      ];
      for (const pair of vpairs) {
        if (options[pair.invalid]) {
          const e = `'${pair.invalid}' is not a valid configuration option. Please use '${pair.expected}' instead. This library is using Axios for requests. Please see https://github.com/axios/axios to learn more about the valid request options.`;
          throw new Error(e);
        }
      }
    }
    __name(validate, "validate");
  }
});

// node_modules/google-auth-library/package.json
var require_package2 = __commonJS({
  "node_modules/google-auth-library/package.json"(exports, module) {
    module.exports = {
      name: "google-auth-library",
      version: "9.15.0",
      author: "Google Inc.",
      description: "Google APIs Authentication Client Library for Node.js",
      engines: {
        node: ">=14"
      },
      main: "./build/src/index.js",
      types: "./build/src/index.d.ts",
      repository: "googleapis/google-auth-library-nodejs.git",
      keywords: [
        "google",
        "api",
        "google apis",
        "client",
        "client library"
      ],
      dependencies: {
        "base64-js": "^1.3.0",
        "ecdsa-sig-formatter": "^1.0.11",
        gaxios: "^6.1.1",
        "gcp-metadata": "^6.1.0",
        gtoken: "^7.0.0",
        jws: "^4.0.0"
      },
      devDependencies: {
        "@types/base64-js": "^1.2.5",
        "@types/chai": "^4.1.7",
        "@types/jws": "^3.1.0",
        "@types/mocha": "^9.0.0",
        "@types/mv": "^2.1.0",
        "@types/ncp": "^2.0.1",
        "@types/node": "^20.4.2",
        "@types/sinon": "^17.0.0",
        "assert-rejects": "^1.0.0",
        c8: "^8.0.0",
        chai: "^4.2.0",
        cheerio: "1.0.0-rc.12",
        codecov: "^3.0.2",
        execa: "^5.0.0",
        gts: "^5.0.0",
        "is-docker": "^2.0.0",
        jsdoc: "^4.0.0",
        "jsdoc-fresh": "^3.0.0",
        "jsdoc-region-tag": "^3.0.0",
        karma: "^6.0.0",
        "karma-chrome-launcher": "^3.0.0",
        "karma-coverage": "^2.0.0",
        "karma-firefox-launcher": "^2.0.0",
        "karma-mocha": "^2.0.0",
        "karma-sourcemap-loader": "^0.4.0",
        "karma-webpack": "5.0.0",
        keypair: "^1.0.4",
        linkinator: "^4.0.0",
        mocha: "^9.2.2",
        mv: "^2.1.1",
        ncp: "^2.0.0",
        nock: "^13.0.0",
        "null-loader": "^4.0.0",
        pdfmake: "0.2.12",
        puppeteer: "^21.0.0",
        sinon: "^18.0.0",
        "ts-loader": "^8.0.0",
        typescript: "^5.1.6",
        webpack: "^5.21.2",
        "webpack-cli": "^4.0.0"
      },
      files: [
        "build/src",
        "!build/src/**/*.map"
      ],
      scripts: {
        test: "c8 mocha build/test",
        clean: "gts clean",
        prepare: "npm run compile",
        lint: "gts check",
        compile: "tsc -p .",
        fix: "gts fix",
        pretest: "npm run compile -- --sourceMap",
        docs: "jsdoc -c .jsdoc.json",
        "samples-setup": "cd samples/ && npm link ../ && npm run setup && cd ../",
        "samples-test": "cd samples/ && npm link ../ && npm test && cd ../",
        "system-test": "mocha build/system-test --timeout 60000",
        "presystem-test": "npm run compile -- --sourceMap",
        webpack: "webpack",
        "browser-test": "karma start",
        "docs-test": "linkinator docs",
        "predocs-test": "npm run docs",
        prelint: "cd samples; npm link ../; npm install",
        precompile: "gts clean"
      },
      license: "Apache-2.0"
    };
  }
});

// node_modules/google-auth-library/build/src/transporters.js
var require_transporters = __commonJS({
  "node_modules/google-auth-library/build/src/transporters.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultTransporter = void 0;
    var gaxios_1 = require_src();
    var options_1 = require_options();
    var pkg = require_package2();
    var PRODUCT_NAME = "google-api-nodejs-client";
    var DefaultTransporter = class _DefaultTransporter {
      static {
        __name(this, "DefaultTransporter");
      }
      constructor() {
        this.instance = new gaxios_1.Gaxios();
      }
      /**
       * Configures request options before making a request.
       * @param opts GaxiosOptions options.
       * @return Configured options.
       */
      configure(opts = {}) {
        opts.headers = opts.headers || {};
        if (typeof window === "undefined") {
          const uaValue = opts.headers["User-Agent"];
          if (!uaValue) {
            opts.headers["User-Agent"] = _DefaultTransporter.USER_AGENT;
          } else if (!uaValue.includes(`${PRODUCT_NAME}/`)) {
            opts.headers["User-Agent"] = `${uaValue} ${_DefaultTransporter.USER_AGENT}`;
          }
          if (!opts.headers["x-goog-api-client"]) {
            const nodeVersion = process.version.replace(/^v/, "");
            opts.headers["x-goog-api-client"] = `gl-node/${nodeVersion}`;
          }
        }
        return opts;
      }
      /**
       * Makes a request using Gaxios with given options.
       * @param opts GaxiosOptions options.
       * @param callback optional callback that contains GaxiosResponse object.
       * @return GaxiosPromise, assuming no callback is passed.
       */
      request(opts) {
        opts = this.configure(opts);
        (0, options_1.validate)(opts);
        return this.instance.request(opts).catch((e) => {
          throw this.processError(e);
        });
      }
      get defaults() {
        return this.instance.defaults;
      }
      set defaults(opts) {
        this.instance.defaults = opts;
      }
      /**
       * Changes the error to include details from the body.
       */
      processError(e) {
        const res = e.response;
        const err = e;
        const body = res ? res.data : null;
        if (res && body && body.error && res.status !== 200) {
          if (typeof body.error === "string") {
            err.message = body.error;
            err.status = res.status;
          } else if (Array.isArray(body.error.errors)) {
            err.message = body.error.errors.map((err2) => err2.message).join("\n");
            err.code = body.error.code;
            err.errors = body.error.errors;
          } else {
            err.message = body.error.message;
            err.code = body.error.code;
          }
        } else if (res && res.status >= 400) {
          err.message = body;
          err.status = res.status;
        }
        return err;
      }
    };
    exports.DefaultTransporter = DefaultTransporter;
    DefaultTransporter.USER_AGENT = `${PRODUCT_NAME}/${pkg.version}`;
  }
});

// node-built-in-modules:buffer
import libDefault7 from "buffer";
var require_buffer = __commonJS({
  "node-built-in-modules:buffer"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault7;
  }
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/safe-buffer/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module.exports = buffer;
    } else {
      copyProps(buffer, exports);
      exports.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js
var require_param_bytes_for_alg = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/param-bytes-for-alg.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function getParamSize(keySize) {
      var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
      return result;
    }
    __name(getParamSize, "getParamSize");
    var paramBytesForAlg = {
      ES256: getParamSize(256),
      ES384: getParamSize(384),
      ES512: getParamSize(521)
    };
    function getParamBytesForAlg(alg) {
      var paramBytes = paramBytesForAlg[alg];
      if (paramBytes) {
        return paramBytes;
      }
      throw new Error('Unknown algorithm "' + alg + '"');
    }
    __name(getParamBytesForAlg, "getParamBytesForAlg");
    module.exports = getParamBytesForAlg;
  }
});

// node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js
var require_ecdsa_sig_formatter = __commonJS({
  "node_modules/ecdsa-sig-formatter/src/ecdsa-sig-formatter.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var getParamBytesForAlg = require_param_bytes_for_alg();
    var MAX_OCTET = 128;
    var CLASS_UNIVERSAL = 0;
    var PRIMITIVE_BIT = 32;
    var TAG_SEQ = 16;
    var TAG_INT = 2;
    var ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6;
    var ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
    function base64Url(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64Url, "base64Url");
    function signatureAsBuffer(signature) {
      if (Buffer2.isBuffer(signature)) {
        return signature;
      } else if ("string" === typeof signature) {
        return Buffer2.from(signature, "base64");
      }
      throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
    }
    __name(signatureAsBuffer, "signatureAsBuffer");
    function derToJose(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var maxEncodedParamLength = paramBytes + 1;
      var inputLength = signature.length;
      var offset = 0;
      if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
      }
      var seqLength = signature[offset++];
      if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
      }
      if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
      }
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
      }
      var rLength = signature[offset++];
      if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
      }
      if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var rOffset = offset;
      offset += rLength;
      if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
      }
      var sLength = signature[offset++];
      if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
      }
      if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
      }
      var sOffset = offset;
      offset += sLength;
      if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
      }
      var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
      var dst = Buffer2.allocUnsafe(rPadding + rLength + sPadding + sLength);
      for (offset = 0; offset < rPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
      offset = paramBytes;
      for (var o = offset; offset < o + sPadding; ++offset) {
        dst[offset] = 0;
      }
      signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
      dst = dst.toString("base64");
      dst = base64Url(dst);
      return dst;
    }
    __name(derToJose, "derToJose");
    function countPadding(buf, start, stop) {
      var padding = 0;
      while (start + padding < stop && buf[start + padding] === 0) {
        ++padding;
      }
      var needsSign = buf[start + padding] >= MAX_OCTET;
      if (needsSign) {
        --padding;
      }
      return padding;
    }
    __name(countPadding, "countPadding");
    function joseToDer(signature, alg) {
      signature = signatureAsBuffer(signature);
      var paramBytes = getParamBytesForAlg(alg);
      var signatureBytes = signature.length;
      if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
      }
      var rPadding = countPadding(signature, 0, paramBytes);
      var sPadding = countPadding(signature, paramBytes, signature.length);
      var rLength = paramBytes - rPadding;
      var sLength = paramBytes - sPadding;
      var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
      var shortLength = rsBytes < MAX_OCTET;
      var dst = Buffer2.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
      var offset = 0;
      dst[offset++] = ENCODED_TAG_SEQ;
      if (shortLength) {
        dst[offset++] = rsBytes;
      } else {
        dst[offset++] = MAX_OCTET | 1;
        dst[offset++] = rsBytes & 255;
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = rLength;
      if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
      } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
      }
      dst[offset++] = ENCODED_TAG_INT;
      dst[offset++] = sLength;
      if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
      } else {
        signature.copy(dst, offset, paramBytes + sPadding);
      }
      return dst;
    }
    __name(joseToDer, "joseToDer");
    module.exports = {
      derToJose,
      joseToDer
    };
  }
});

// node-built-in-modules:events
import libDefault8 from "events";
var require_events = __commonJS({
  "node-built-in-modules:events"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault8;
  }
});

// node_modules/google-auth-library/build/src/util.js
var require_util2 = __commonJS({
  "node_modules/google-auth-library/build/src/util.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _LRUCache_instances;
    var _LRUCache_cache;
    var _LRUCache_moveToEnd;
    var _LRUCache_evict;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    exports.snakeToCamel = snakeToCamel;
    exports.originalOrCamelOptions = originalOrCamelOptions;
    function snakeToCamel(str) {
      return str.replace(/([_][^_])/g, (match) => match.slice(1).toUpperCase());
    }
    __name(snakeToCamel, "snakeToCamel");
    function originalOrCamelOptions(obj) {
      function get3(key) {
        var _a;
        const o = obj || {};
        return (_a = o[key]) !== null && _a !== void 0 ? _a : o[snakeToCamel(key)];
      }
      __name(get3, "get");
      return { get: get3 };
    }
    __name(originalOrCamelOptions, "originalOrCamelOptions");
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor(options) {
        _LRUCache_instances.add(this);
        _LRUCache_cache.set(this, /* @__PURE__ */ new Map());
        this.capacity = options.capacity;
        this.maxAge = options.maxAge;
      }
      /**
       * Add an item to the cache.
       *
       * @param key the key to upsert
       * @param value the value of the key
       */
      set(key, value) {
        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, value);
        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
      }
      /**
       * Get an item from the cache.
       *
       * @param key the key to retrieve
       */
      get(key) {
        const item = __classPrivateFieldGet(this, _LRUCache_cache, "f").get(key);
        if (!item)
          return;
        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_moveToEnd).call(this, key, item.value);
        __classPrivateFieldGet(this, _LRUCache_instances, "m", _LRUCache_evict).call(this);
        return item.value;
      }
    };
    exports.LRUCache = LRUCache;
    _LRUCache_cache = /* @__PURE__ */ new WeakMap(), _LRUCache_instances = /* @__PURE__ */ new WeakSet(), _LRUCache_moveToEnd = /* @__PURE__ */ __name(function _LRUCache_moveToEnd2(key, value) {
      __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(key);
      __classPrivateFieldGet(this, _LRUCache_cache, "f").set(key, {
        value,
        lastAccessed: Date.now()
      });
    }, "_LRUCache_moveToEnd"), _LRUCache_evict = /* @__PURE__ */ __name(function _LRUCache_evict2() {
      const cutoffDate = this.maxAge ? Date.now() - this.maxAge : 0;
      let oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, "f").entries().next();
      while (!oldestItem.done && (__classPrivateFieldGet(this, _LRUCache_cache, "f").size > this.capacity || // too many
      oldestItem.value[1].lastAccessed < cutoffDate)) {
        __classPrivateFieldGet(this, _LRUCache_cache, "f").delete(oldestItem.value[0]);
        oldestItem = __classPrivateFieldGet(this, _LRUCache_cache, "f").entries().next();
      }
    }, "_LRUCache_evict");
  }
});

// node_modules/google-auth-library/build/src/auth/authclient.js
var require_authclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/authclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthClient = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = exports.DEFAULT_UNIVERSE = void 0;
    var events_1 = require_events();
    var gaxios_1 = require_src();
    var transporters_1 = require_transporters();
    var util_1 = require_util2();
    exports.DEFAULT_UNIVERSE = "googleapis.com";
    exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var AuthClient = class extends events_1.EventEmitter {
      static {
        __name(this, "AuthClient");
      }
      constructor(opts = {}) {
        var _a, _b, _c, _d, _e;
        super();
        this.credentials = {};
        this.eagerRefreshThresholdMillis = exports.DEFAULT_EAGER_REFRESH_THRESHOLD_MILLIS;
        this.forceRefreshOnFailure = false;
        this.universeDomain = exports.DEFAULT_UNIVERSE;
        const options = (0, util_1.originalOrCamelOptions)(opts);
        this.apiKey = opts.apiKey;
        this.projectId = (_a = options.get("project_id")) !== null && _a !== void 0 ? _a : null;
        this.quotaProjectId = options.get("quota_project_id");
        this.credentials = (_b = options.get("credentials")) !== null && _b !== void 0 ? _b : {};
        this.universeDomain = (_c = options.get("universe_domain")) !== null && _c !== void 0 ? _c : exports.DEFAULT_UNIVERSE;
        this.transporter = (_d = opts.transporter) !== null && _d !== void 0 ? _d : new transporters_1.DefaultTransporter();
        if (opts.transporterOptions) {
          this.transporter.defaults = opts.transporterOptions;
        }
        if (opts.eagerRefreshThresholdMillis) {
          this.eagerRefreshThresholdMillis = opts.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = (_e = opts.forceRefreshOnFailure) !== null && _e !== void 0 ? _e : false;
      }
      /**
       * Return the {@link Gaxios `Gaxios`} instance from the {@link AuthClient.transporter}.
       *
       * @expiremental
       */
      get gaxios() {
        if (this.transporter instanceof gaxios_1.Gaxios) {
          return this.transporter;
        } else if (this.transporter instanceof transporters_1.DefaultTransporter) {
          return this.transporter.instance;
        } else if ("instance" in this.transporter && this.transporter.instance instanceof gaxios_1.Gaxios) {
          return this.transporter.instance;
        }
        return null;
      }
      /**
       * Sets the auth credentials.
       */
      setCredentials(credentials) {
        this.credentials = credentials;
      }
      /**
       * Append additional headers, e.g., x-goog-user-project, shared across the
       * classes inheriting AuthClient. This method should be used by any method
       * that overrides getRequestMetadataAsync(), which is a shared helper for
       * setting request information in both gRPC and HTTP API calls.
       *
       * @param headers object to append additional headers to.
       */
      addSharedMetadataHeaders(headers) {
        if (!headers["x-goog-user-project"] && // don't override a value the user sets.
        this.quotaProjectId) {
          headers["x-goog-user-project"] = this.quotaProjectId;
        }
        return headers;
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    exports.AuthClient = AuthClient;
  }
});

// node_modules/google-auth-library/build/src/auth/loginticket.js
var require_loginticket = __commonJS({
  "node_modules/google-auth-library/build/src/auth/loginticket.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LoginTicket = void 0;
    var LoginTicket = class {
      static {
        __name(this, "LoginTicket");
      }
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @param {string} env Envelope of the jwt
       * @param {TokenPayload} pay Payload of the jwt
       * @constructor
       */
      constructor(env2, pay) {
        this.envelope = env2;
        this.payload = pay;
      }
      getEnvelope() {
        return this.envelope;
      }
      getPayload() {
        return this.payload;
      }
      /**
       * Create a simple class to extract user ID from an ID Token
       *
       * @return The user ID
       */
      getUserId() {
        const payload = this.getPayload();
        if (payload && payload.sub) {
          return payload.sub;
        }
        return null;
      }
      /**
       * Returns attributes from the login ticket.  This can contain
       * various information about the user session.
       *
       * @return The envelope and payload
       */
      getAttributes() {
        return { envelope: this.getEnvelope(), payload: this.getPayload() };
      }
    };
    exports.LoginTicket = LoginTicket;
  }
});

// node_modules/google-auth-library/build/src/auth/oauth2client.js
var require_oauth2client = __commonJS({
  "node_modules/google-auth-library/build/src/auth/oauth2client.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OAuth2Client = exports.ClientAuthentication = exports.CertificateFormat = exports.CodeChallengeMethod = void 0;
    var gaxios_1 = require_src();
    var querystring = require_querystring();
    var stream = require_stream();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var crypto_1 = require_crypto4();
    var authclient_1 = require_authclient();
    var loginticket_1 = require_loginticket();
    var CodeChallengeMethod;
    (function(CodeChallengeMethod2) {
      CodeChallengeMethod2["Plain"] = "plain";
      CodeChallengeMethod2["S256"] = "S256";
    })(CodeChallengeMethod || (exports.CodeChallengeMethod = CodeChallengeMethod = {}));
    var CertificateFormat;
    (function(CertificateFormat2) {
      CertificateFormat2["PEM"] = "PEM";
      CertificateFormat2["JWK"] = "JWK";
    })(CertificateFormat || (exports.CertificateFormat = CertificateFormat = {}));
    var ClientAuthentication;
    (function(ClientAuthentication2) {
      ClientAuthentication2["ClientSecretPost"] = "ClientSecretPost";
      ClientAuthentication2["ClientSecretBasic"] = "ClientSecretBasic";
      ClientAuthentication2["None"] = "None";
    })(ClientAuthentication || (exports.ClientAuthentication = ClientAuthentication = {}));
    var OAuth2Client = class _OAuth2Client extends authclient_1.AuthClient {
      static {
        __name(this, "OAuth2Client");
      }
      constructor(optionsOrClientId, clientSecret, redirectUri) {
        const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : { clientId: optionsOrClientId, clientSecret, redirectUri };
        super(opts);
        this.certificateCache = {};
        this.certificateExpiry = null;
        this.certificateCacheFormat = CertificateFormat.PEM;
        this.refreshTokenPromises = /* @__PURE__ */ new Map();
        this._clientId = opts.clientId;
        this._clientSecret = opts.clientSecret;
        this.redirectUri = opts.redirectUri;
        this.endpoints = {
          tokenInfoUrl: "https://oauth2.googleapis.com/tokeninfo",
          oauth2AuthBaseUrl: "https://accounts.google.com/o/oauth2/v2/auth",
          oauth2TokenUrl: "https://oauth2.googleapis.com/token",
          oauth2RevokeUrl: "https://oauth2.googleapis.com/revoke",
          oauth2FederatedSignonPemCertsUrl: "https://www.googleapis.com/oauth2/v1/certs",
          oauth2FederatedSignonJwkCertsUrl: "https://www.googleapis.com/oauth2/v3/certs",
          oauth2IapPublicKeyUrl: "https://www.gstatic.com/iap/verify/public_key",
          ...opts.endpoints
        };
        this.clientAuthentication = opts.clientAuthentication || ClientAuthentication.ClientSecretPost;
        this.issuers = opts.issuers || [
          "accounts.google.com",
          "https://accounts.google.com",
          this.universeDomain
        ];
      }
      /**
       * Generates URL for consent page landing.
       * @param opts Options.
       * @return URL to consent page.
       */
      generateAuthUrl(opts = {}) {
        if (opts.code_challenge_method && !opts.code_challenge) {
          throw new Error("If a code_challenge_method is provided, code_challenge must be included.");
        }
        opts.response_type = opts.response_type || "code";
        opts.client_id = opts.client_id || this._clientId;
        opts.redirect_uri = opts.redirect_uri || this.redirectUri;
        if (Array.isArray(opts.scope)) {
          opts.scope = opts.scope.join(" ");
        }
        const rootUrl = this.endpoints.oauth2AuthBaseUrl.toString();
        return rootUrl + "?" + querystring.stringify(opts);
      }
      generateCodeVerifier() {
        throw new Error("generateCodeVerifier is removed, please use generateCodeVerifierAsync instead.");
      }
      /**
       * Convenience method to automatically generate a code_verifier, and its
       * resulting SHA256. If used, this must be paired with a S256
       * code_challenge_method.
       *
       * For a full example see:
       * https://github.com/googleapis/google-auth-library-nodejs/blob/main/samples/oauth2-codeVerifier.js
       */
      async generateCodeVerifierAsync() {
        const crypto2 = (0, crypto_1.createCrypto)();
        const randomString = crypto2.randomBytesBase64(96);
        const codeVerifier = randomString.replace(/\+/g, "~").replace(/=/g, "_").replace(/\//g, "-");
        const unencodedCodeChallenge = await crypto2.sha256DigestBase64(codeVerifier);
        const codeChallenge = unencodedCodeChallenge.split("=")[0].replace(/\+/g, "-").replace(/\//g, "_");
        return { codeVerifier, codeChallenge };
      }
      getToken(codeOrOptions, callback) {
        const options = typeof codeOrOptions === "string" ? { code: codeOrOptions } : codeOrOptions;
        if (callback) {
          this.getTokenAsync(options).then((r) => callback(null, r.tokens, r.res), (e) => callback(e, null, e.response));
        } else {
          return this.getTokenAsync(options);
        }
      }
      async getTokenAsync(options) {
        const url = this.endpoints.oauth2TokenUrl.toString();
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded"
        };
        const values = {
          client_id: options.client_id || this._clientId,
          code_verifier: options.codeVerifier,
          code: options.code,
          grant_type: "authorization_code",
          redirect_uri: options.redirect_uri || this.redirectUri
        };
        if (this.clientAuthentication === ClientAuthentication.ClientSecretBasic) {
          const basic = Buffer.from(`${this._clientId}:${this._clientSecret}`);
          headers["Authorization"] = `Basic ${basic.toString("base64")}`;
        }
        if (this.clientAuthentication === ClientAuthentication.ClientSecretPost) {
          values.client_secret = this._clientSecret;
        }
        const res = await this.transporter.request({
          ..._OAuth2Client.RETRY_CONFIG,
          method: "POST",
          url,
          data: querystring.stringify(values),
          headers
        });
        const tokens = res.data;
        if (res.data && res.data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res };
      }
      /**
       * Refreshes the access token.
       * @param refresh_token Existing refresh token.
       * @private
       */
      async refreshToken(refreshToken2) {
        if (!refreshToken2) {
          return this.refreshTokenNoCache(refreshToken2);
        }
        if (this.refreshTokenPromises.has(refreshToken2)) {
          return this.refreshTokenPromises.get(refreshToken2);
        }
        const p2 = this.refreshTokenNoCache(refreshToken2).then((r) => {
          this.refreshTokenPromises.delete(refreshToken2);
          return r;
        }, (e) => {
          this.refreshTokenPromises.delete(refreshToken2);
          throw e;
        });
        this.refreshTokenPromises.set(refreshToken2, p2);
        return p2;
      }
      async refreshTokenNoCache(refreshToken2) {
        var _a;
        if (!refreshToken2) {
          throw new Error("No refresh token is set.");
        }
        const url = this.endpoints.oauth2TokenUrl.toString();
        const data = {
          refresh_token: refreshToken2,
          client_id: this._clientId,
          client_secret: this._clientSecret,
          grant_type: "refresh_token"
        };
        let res;
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            method: "POST",
            url,
            data: querystring.stringify(data),
            headers: { "Content-Type": "application/x-www-form-urlencoded" }
          });
        } catch (e) {
          if (e instanceof gaxios_1.GaxiosError && e.message === "invalid_grant" && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) && /ReAuth/i.test(e.response.data.error_description)) {
            e.message = JSON.stringify(e.response.data);
          }
          throw e;
        }
        const tokens = res.data;
        if (res.data && res.data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + res.data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res };
      }
      refreshAccessToken(callback) {
        if (callback) {
          this.refreshAccessTokenAsync().then((r) => callback(null, r.credentials, r.res), callback);
        } else {
          return this.refreshAccessTokenAsync();
        }
      }
      async refreshAccessTokenAsync() {
        const r = await this.refreshToken(this.credentials.refresh_token);
        const tokens = r.tokens;
        tokens.refresh_token = this.credentials.refresh_token;
        this.credentials = tokens;
        return { credentials: this.credentials, res: r.res };
      }
      getAccessToken(callback) {
        if (callback) {
          this.getAccessTokenAsync().then((r) => callback(null, r.token, r.res), callback);
        } else {
          return this.getAccessTokenAsync();
        }
      }
      async getAccessTokenAsync() {
        const shouldRefresh = !this.credentials.access_token || this.isTokenExpiring();
        if (shouldRefresh) {
          if (!this.credentials.refresh_token) {
            if (this.refreshHandler) {
              const refreshedAccessToken = await this.processAndValidateRefreshHandler();
              if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
                this.setCredentials(refreshedAccessToken);
                return { token: this.credentials.access_token };
              }
            } else {
              throw new Error("No refresh token or refresh handler callback is set.");
            }
          }
          const r = await this.refreshAccessTokenAsync();
          if (!r.credentials || r.credentials && !r.credentials.access_token) {
            throw new Error("Could not refresh access token.");
          }
          return { token: r.credentials.access_token, res: r.res };
        } else {
          return { token: this.credentials.access_token };
        }
      }
      /**
       * The main authentication interface.  It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * In OAuth2Client, the result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       * @param url The optional url being authorized
       */
      async getRequestHeaders(url) {
        const headers = (await this.getRequestMetadataAsync(url)).headers;
        return headers;
      }
      async getRequestMetadataAsync(url) {
        const thisCreds = this.credentials;
        if (!thisCreds.access_token && !thisCreds.refresh_token && !this.apiKey && !this.refreshHandler) {
          throw new Error("No access, refresh token, API key or refresh handler callback is set.");
        }
        if (thisCreds.access_token && !this.isTokenExpiring()) {
          thisCreds.token_type = thisCreds.token_type || "Bearer";
          const headers2 = {
            Authorization: thisCreds.token_type + " " + thisCreds.access_token
          };
          return { headers: this.addSharedMetadataHeaders(headers2) };
        }
        if (this.refreshHandler) {
          const refreshedAccessToken = await this.processAndValidateRefreshHandler();
          if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
            this.setCredentials(refreshedAccessToken);
            const headers2 = {
              Authorization: "Bearer " + this.credentials.access_token
            };
            return { headers: this.addSharedMetadataHeaders(headers2) };
          }
        }
        if (this.apiKey) {
          return { headers: { "X-Goog-Api-Key": this.apiKey } };
        }
        let r = null;
        let tokens = null;
        try {
          r = await this.refreshToken(thisCreds.refresh_token);
          tokens = r.tokens;
        } catch (err) {
          const e = err;
          if (e.response && (e.response.status === 403 || e.response.status === 404)) {
            e.message = `Could not refresh access token: ${e.message}`;
          }
          throw e;
        }
        const credentials = this.credentials;
        credentials.token_type = credentials.token_type || "Bearer";
        tokens.refresh_token = credentials.refresh_token;
        this.credentials = tokens;
        const headers = {
          Authorization: credentials.token_type + " " + tokens.access_token
        };
        return { headers: this.addSharedMetadataHeaders(headers), res: r.res };
      }
      /**
       * Generates an URL to revoke the given token.
       * @param token The existing token to be revoked.
       *
       * @deprecated use instance method {@link OAuth2Client.getRevokeTokenURL}
       */
      static getRevokeTokenUrl(token) {
        return new _OAuth2Client().getRevokeTokenURL(token).toString();
      }
      /**
       * Generates a URL to revoke the given token.
       *
       * @param token The existing token to be revoked.
       */
      getRevokeTokenURL(token) {
        const url = new URL(this.endpoints.oauth2RevokeUrl);
        url.searchParams.append("token", token);
        return url;
      }
      revokeToken(token, callback) {
        const opts = {
          ..._OAuth2Client.RETRY_CONFIG,
          url: this.getRevokeTokenURL(token).toString(),
          method: "POST"
        };
        if (callback) {
          this.transporter.request(opts).then((r) => callback(null, r), callback);
        } else {
          return this.transporter.request(opts);
        }
      }
      revokeCredentials(callback) {
        if (callback) {
          this.revokeCredentialsAsync().then((res) => callback(null, res), callback);
        } else {
          return this.revokeCredentialsAsync();
        }
      }
      async revokeCredentialsAsync() {
        const token = this.credentials.access_token;
        this.credentials = {};
        if (token) {
          return this.revokeToken(token);
        } else {
          throw new Error("No access token to revoke.");
        }
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r) => callback(null, r), (e) => {
            return callback(e, e.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      async requestAsync(opts, reAuthRetried = false) {
        let r2;
        try {
          const r = await this.getRequestMetadataAsync(opts.url);
          opts.headers = opts.headers || {};
          if (r.headers && r.headers["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = r.headers["x-goog-user-project"];
          }
          if (r.headers && r.headers.Authorization) {
            opts.headers.Authorization = r.headers.Authorization;
          }
          if (this.apiKey) {
            opts.headers["X-Goog-Api-Key"] = this.apiKey;
          }
          r2 = await this.transporter.request(opts);
        } catch (e) {
          const res = e.response;
          if (res) {
            const statusCode = res.status;
            const mayRequireRefresh = this.credentials && this.credentials.access_token && this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure);
            const mayRequireRefreshWithNoRefreshToken = this.credentials && this.credentials.access_token && !this.credentials.refresh_token && (!this.credentials.expiry_date || this.forceRefreshOnFailure) && this.refreshHandler;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefresh) {
              await this.refreshAccessTokenAsync();
              return this.requestAsync(opts, true);
            } else if (!reAuthRetried && isAuthErr && !isReadableStream && mayRequireRefreshWithNoRefreshToken) {
              const refreshedAccessToken = await this.processAndValidateRefreshHandler();
              if (refreshedAccessToken === null || refreshedAccessToken === void 0 ? void 0 : refreshedAccessToken.access_token) {
                this.setCredentials(refreshedAccessToken);
              }
              return this.requestAsync(opts, true);
            }
          }
          throw e;
        }
        return r2;
      }
      verifyIdToken(options, callback) {
        if (callback && typeof callback !== "function") {
          throw new Error("This method accepts an options object as the first parameter, which includes the idToken, audience, and maxExpiry.");
        }
        if (callback) {
          this.verifyIdTokenAsync(options).then((r) => callback(null, r), callback);
        } else {
          return this.verifyIdTokenAsync(options);
        }
      }
      async verifyIdTokenAsync(options) {
        if (!options.idToken) {
          throw new Error("The verifyIdToken method requires an ID Token");
        }
        const response = await this.getFederatedSignonCertsAsync();
        const login = await this.verifySignedJwtWithCertsAsync(options.idToken, response.certs, options.audience, this.issuers, options.maxExpiry);
        return login;
      }
      /**
       * Obtains information about the provisioned access token.  Especially useful
       * if you want to check the scopes that were provisioned to a given token.
       *
       * @param accessToken Required.  The Access Token for which you want to get
       * user info.
       */
      async getTokenInfo(accessToken) {
        const { data } = await this.transporter.request({
          ..._OAuth2Client.RETRY_CONFIG,
          method: "POST",
          headers: {
            "Content-Type": "application/x-www-form-urlencoded",
            Authorization: `Bearer ${accessToken}`
          },
          url: this.endpoints.tokenInfoUrl.toString()
        });
        const info3 = Object.assign({
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3,
          scopes: data.scope.split(" ")
        }, data);
        delete info3.expires_in;
        delete info3.scope;
        return info3;
      }
      getFederatedSignonCerts(callback) {
        if (callback) {
          this.getFederatedSignonCertsAsync().then((r) => callback(null, r.certs, r.res), callback);
        } else {
          return this.getFederatedSignonCertsAsync();
        }
      }
      async getFederatedSignonCertsAsync() {
        const nowTime = (/* @__PURE__ */ new Date()).getTime();
        const format2 = (0, crypto_1.hasBrowserCrypto)() ? CertificateFormat.JWK : CertificateFormat.PEM;
        if (this.certificateExpiry && nowTime < this.certificateExpiry.getTime() && this.certificateCacheFormat === format2) {
          return { certs: this.certificateCache, format: format2 };
        }
        let res;
        let url;
        switch (format2) {
          case CertificateFormat.PEM:
            url = this.endpoints.oauth2FederatedSignonPemCertsUrl.toString();
            break;
          case CertificateFormat.JWK:
            url = this.endpoints.oauth2FederatedSignonJwkCertsUrl.toString();
            break;
          default:
            throw new Error(`Unsupported certificate format ${format2}`);
        }
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            url
          });
        } catch (e) {
          if (e instanceof Error) {
            e.message = `Failed to retrieve verification certificates: ${e.message}`;
          }
          throw e;
        }
        const cacheControl = res ? res.headers["cache-control"] : void 0;
        let cacheAge = -1;
        if (cacheControl) {
          const pattern = new RegExp("max-age=([0-9]*)");
          const regexResult = pattern.exec(cacheControl);
          if (regexResult && regexResult.length === 2) {
            cacheAge = Number(regexResult[1]) * 1e3;
          }
        }
        let certificates = {};
        switch (format2) {
          case CertificateFormat.PEM:
            certificates = res.data;
            break;
          case CertificateFormat.JWK:
            for (const key of res.data.keys) {
              certificates[key.kid] = key;
            }
            break;
          default:
            throw new Error(`Unsupported certificate format ${format2}`);
        }
        const now = /* @__PURE__ */ new Date();
        this.certificateExpiry = cacheAge === -1 ? null : new Date(now.getTime() + cacheAge);
        this.certificateCache = certificates;
        this.certificateCacheFormat = format2;
        return { certs: certificates, format: format2, res };
      }
      getIapPublicKeys(callback) {
        if (callback) {
          this.getIapPublicKeysAsync().then((r) => callback(null, r.pubkeys, r.res), callback);
        } else {
          return this.getIapPublicKeysAsync();
        }
      }
      async getIapPublicKeysAsync() {
        let res;
        const url = this.endpoints.oauth2IapPublicKeyUrl.toString();
        try {
          res = await this.transporter.request({
            ..._OAuth2Client.RETRY_CONFIG,
            url
          });
        } catch (e) {
          if (e instanceof Error) {
            e.message = `Failed to retrieve verification certificates: ${e.message}`;
          }
          throw e;
        }
        return { pubkeys: res.data, res };
      }
      verifySignedJwtWithCerts() {
        throw new Error("verifySignedJwtWithCerts is removed, please use verifySignedJwtWithCertsAsync instead.");
      }
      /**
       * Verify the id token is signed with the correct certificate
       * and is from the correct audience.
       * @param jwt The jwt to verify (The ID Token in this case).
       * @param certs The array of certs to test the jwt against.
       * @param requiredAudience The audience to test the jwt against.
       * @param issuers The allowed issuers of the jwt (Optional).
       * @param maxExpiry The max expiry the certificate can be (Optional).
       * @return Returns a promise resolving to LoginTicket on verification.
       */
      async verifySignedJwtWithCertsAsync(jwt, certs, requiredAudience, issuers, maxExpiry) {
        const crypto2 = (0, crypto_1.createCrypto)();
        if (!maxExpiry) {
          maxExpiry = _OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_;
        }
        const segments = jwt.split(".");
        if (segments.length !== 3) {
          throw new Error("Wrong number of segments in token: " + jwt);
        }
        const signed = segments[0] + "." + segments[1];
        let signature = segments[2];
        let envelope;
        let payload;
        try {
          envelope = JSON.parse(crypto2.decodeBase64StringUtf8(segments[0]));
        } catch (err) {
          if (err instanceof Error) {
            err.message = `Can't parse token envelope: ${segments[0]}': ${err.message}`;
          }
          throw err;
        }
        if (!envelope) {
          throw new Error("Can't parse token envelope: " + segments[0]);
        }
        try {
          payload = JSON.parse(crypto2.decodeBase64StringUtf8(segments[1]));
        } catch (err) {
          if (err instanceof Error) {
            err.message = `Can't parse token payload '${segments[0]}`;
          }
          throw err;
        }
        if (!payload) {
          throw new Error("Can't parse token payload: " + segments[1]);
        }
        if (!Object.prototype.hasOwnProperty.call(certs, envelope.kid)) {
          throw new Error("No pem found for envelope: " + JSON.stringify(envelope));
        }
        const cert2 = certs[envelope.kid];
        if (envelope.alg === "ES256") {
          signature = formatEcdsa.joseToDer(signature, "ES256").toString("base64");
        }
        const verified = await crypto2.verify(cert2, signed, signature);
        if (!verified) {
          throw new Error("Invalid token signature: " + jwt);
        }
        if (!payload.iat) {
          throw new Error("No issue time in token: " + JSON.stringify(payload));
        }
        if (!payload.exp) {
          throw new Error("No expiration time in token: " + JSON.stringify(payload));
        }
        const iat = Number(payload.iat);
        if (isNaN(iat))
          throw new Error("iat field using invalid format");
        const exp = Number(payload.exp);
        if (isNaN(exp))
          throw new Error("exp field using invalid format");
        const now = (/* @__PURE__ */ new Date()).getTime() / 1e3;
        if (exp >= now + maxExpiry) {
          throw new Error("Expiration time too far in future: " + JSON.stringify(payload));
        }
        const earliest = iat - _OAuth2Client.CLOCK_SKEW_SECS_;
        const latest = exp + _OAuth2Client.CLOCK_SKEW_SECS_;
        if (now < earliest) {
          throw new Error("Token used too early, " + now + " < " + earliest + ": " + JSON.stringify(payload));
        }
        if (now > latest) {
          throw new Error("Token used too late, " + now + " > " + latest + ": " + JSON.stringify(payload));
        }
        if (issuers && issuers.indexOf(payload.iss) < 0) {
          throw new Error("Invalid issuer, expected one of [" + issuers + "], but got " + payload.iss);
        }
        if (typeof requiredAudience !== "undefined" && requiredAudience !== null) {
          const aud = payload.aud;
          let audVerified = false;
          if (requiredAudience.constructor === Array) {
            audVerified = requiredAudience.indexOf(aud) > -1;
          } else {
            audVerified = aud === requiredAudience;
          }
          if (!audVerified) {
            throw new Error("Wrong recipient, payload audience != requiredAudience");
          }
        }
        return new loginticket_1.LoginTicket(envelope, payload);
      }
      /**
       * Returns a promise that resolves with AccessTokenResponse type if
       * refreshHandler is defined.
       * If not, nothing is returned.
       */
      async processAndValidateRefreshHandler() {
        if (this.refreshHandler) {
          const accessTokenResponse = await this.refreshHandler();
          if (!accessTokenResponse.access_token) {
            throw new Error("No access token is returned by the refreshHandler callback.");
          }
          return accessTokenResponse;
        }
        return;
      }
      /**
       * Returns true if a token is expired or will expire within
       * eagerRefreshThresholdMillismilliseconds.
       * If there is no expiry time, assumes the token is not expired or expiring.
       */
      isTokenExpiring() {
        const expiryDate = this.credentials.expiry_date;
        return expiryDate ? expiryDate <= (/* @__PURE__ */ new Date()).getTime() + this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.OAuth2Client = OAuth2Client;
    OAuth2Client.GOOGLE_TOKEN_INFO_URL = "https://oauth2.googleapis.com/tokeninfo";
    OAuth2Client.CLOCK_SKEW_SECS_ = 300;
    OAuth2Client.DEFAULT_MAX_TOKEN_LIFETIME_SECS_ = 86400;
  }
});

// node_modules/google-auth-library/build/src/auth/computeclient.js
var require_computeclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/computeclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Compute = void 0;
    var gaxios_1 = require_src();
    var gcpMetadata = require_src2();
    var oauth2client_1 = require_oauth2client();
    var Compute = class extends oauth2client_1.OAuth2Client {
      static {
        __name(this, "Compute");
      }
      /**
       * Google Compute Engine service account credentials.
       *
       * Retrieve access token from the metadata server.
       * See: https://cloud.google.com/compute/docs/access/authenticate-workloads#applications
       */
      constructor(options = {}) {
        super(options);
        this.credentials = { expiry_date: 1, refresh_token: "compute-placeholder" };
        this.serviceAccountEmail = options.serviceAccountEmail || "default";
        this.scopes = Array.isArray(options.scopes) ? options.scopes : options.scopes ? [options.scopes] : [];
      }
      /**
       * Refreshes the access token.
       * @param refreshToken Unused parameter
       */
      async refreshTokenNoCache(refreshToken2) {
        const tokenPath = `service-accounts/${this.serviceAccountEmail}/token`;
        let data;
        try {
          const instanceOptions = {
            property: tokenPath
          };
          if (this.scopes.length > 0) {
            instanceOptions.params = {
              scopes: this.scopes.join(",")
            };
          }
          data = await gcpMetadata.instance(instanceOptions);
        } catch (e) {
          if (e instanceof gaxios_1.GaxiosError) {
            e.message = `Could not refresh access token: ${e.message}`;
            this.wrapError(e);
          }
          throw e;
        }
        const tokens = data;
        if (data && data.expires_in) {
          tokens.expiry_date = (/* @__PURE__ */ new Date()).getTime() + data.expires_in * 1e3;
          delete tokens.expires_in;
        }
        this.emit("tokens", tokens);
        return { tokens, res: null };
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      async fetchIdToken(targetAudience) {
        const idTokenPath = `service-accounts/${this.serviceAccountEmail}/identity?format=full&audience=${targetAudience}`;
        let idToken;
        try {
          const instanceOptions = {
            property: idTokenPath
          };
          idToken = await gcpMetadata.instance(instanceOptions);
        } catch (e) {
          if (e instanceof Error) {
            e.message = `Could not fetch ID token: ${e.message}`;
          }
          throw e;
        }
        return idToken;
      }
      wrapError(e) {
        const res = e.response;
        if (res && res.status) {
          e.status = res.status;
          if (res.status === 403) {
            e.message = "A Forbidden error was returned while attempting to retrieve an access token for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have the correct permission scopes specified: " + e.message;
          } else if (res.status === 404) {
            e.message = "A Not Found error was returned while attempting to retrieve an accesstoken for the Compute Engine built-in service account. This may be because the Compute Engine instance does not have any permission scopes specified: " + e.message;
          }
        }
      }
    };
    exports.Compute = Compute;
  }
});

// node_modules/google-auth-library/build/src/auth/idtokenclient.js
var require_idtokenclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/idtokenclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdTokenClient = void 0;
    var oauth2client_1 = require_oauth2client();
    var IdTokenClient = class extends oauth2client_1.OAuth2Client {
      static {
        __name(this, "IdTokenClient");
      }
      /**
       * Google ID Token client
       *
       * Retrieve ID token from the metadata server.
       * See: https://cloud.google.com/docs/authentication/get-id-token#metadata-server
       */
      constructor(options) {
        super(options);
        this.targetAudience = options.targetAudience;
        this.idTokenProvider = options.idTokenProvider;
      }
      async getRequestMetadataAsync(url) {
        if (!this.credentials.id_token || !this.credentials.expiry_date || this.isTokenExpiring()) {
          const idToken = await this.idTokenProvider.fetchIdToken(this.targetAudience);
          this.credentials = {
            id_token: idToken,
            expiry_date: this.getIdTokenExpiryDate(idToken)
          };
        }
        const headers = {
          Authorization: "Bearer " + this.credentials.id_token
        };
        return { headers };
      }
      getIdTokenExpiryDate(idToken) {
        const payloadB64 = idToken.split(".")[1];
        if (payloadB64) {
          const payload = JSON.parse(Buffer.from(payloadB64, "base64").toString("ascii"));
          return payload.exp * 1e3;
        }
      }
    };
    exports.IdTokenClient = IdTokenClient;
  }
});

// node_modules/google-auth-library/build/src/auth/envDetect.js
var require_envDetect = __commonJS({
  "node_modules/google-auth-library/build/src/auth/envDetect.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GCPEnv = void 0;
    exports.clear = clear3;
    exports.getEnv = getEnv;
    var gcpMetadata = require_src2();
    var GCPEnv;
    (function(GCPEnv2) {
      GCPEnv2["APP_ENGINE"] = "APP_ENGINE";
      GCPEnv2["KUBERNETES_ENGINE"] = "KUBERNETES_ENGINE";
      GCPEnv2["CLOUD_FUNCTIONS"] = "CLOUD_FUNCTIONS";
      GCPEnv2["COMPUTE_ENGINE"] = "COMPUTE_ENGINE";
      GCPEnv2["CLOUD_RUN"] = "CLOUD_RUN";
      GCPEnv2["NONE"] = "NONE";
    })(GCPEnv || (exports.GCPEnv = GCPEnv = {}));
    var envPromise;
    function clear3() {
      envPromise = void 0;
    }
    __name(clear3, "clear");
    async function getEnv() {
      if (envPromise) {
        return envPromise;
      }
      envPromise = getEnvMemoized();
      return envPromise;
    }
    __name(getEnv, "getEnv");
    async function getEnvMemoized() {
      let env2 = GCPEnv.NONE;
      if (isAppEngine()) {
        env2 = GCPEnv.APP_ENGINE;
      } else if (isCloudFunction()) {
        env2 = GCPEnv.CLOUD_FUNCTIONS;
      } else if (await isComputeEngine()) {
        if (await isKubernetesEngine()) {
          env2 = GCPEnv.KUBERNETES_ENGINE;
        } else if (isCloudRun()) {
          env2 = GCPEnv.CLOUD_RUN;
        } else {
          env2 = GCPEnv.COMPUTE_ENGINE;
        }
      } else {
        env2 = GCPEnv.NONE;
      }
      return env2;
    }
    __name(getEnvMemoized, "getEnvMemoized");
    function isAppEngine() {
      return !!(process.env.GAE_SERVICE || process.env.GAE_MODULE_NAME);
    }
    __name(isAppEngine, "isAppEngine");
    function isCloudFunction() {
      return !!(process.env.FUNCTION_NAME || process.env.FUNCTION_TARGET);
    }
    __name(isCloudFunction, "isCloudFunction");
    function isCloudRun() {
      return !!process.env.K_CONFIGURATION;
    }
    __name(isCloudRun, "isCloudRun");
    async function isKubernetesEngine() {
      try {
        await gcpMetadata.instance("attributes/cluster-name");
        return true;
      } catch (e) {
        return false;
      }
    }
    __name(isKubernetesEngine, "isKubernetesEngine");
    async function isComputeEngine() {
      return gcpMetadata.isAvailable();
    }
    __name(isComputeEngine, "isComputeEngine");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs
var isRegExp, isDate, isBoolean, isNull, isNullOrUndefined, isNumber, isString, isSymbol, isUndefined, isFunction, isBuffer, isObject, isError, isPrimitive;
var init_legacy_types = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/util/legacy-types.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isRegExp = /* @__PURE__ */ __name((val) => val instanceof RegExp, "isRegExp");
    isDate = /* @__PURE__ */ __name((val) => val instanceof Date, "isDate");
    isBoolean = /* @__PURE__ */ __name((val) => typeof val === "boolean", "isBoolean");
    isNull = /* @__PURE__ */ __name((val) => val === null, "isNull");
    isNullOrUndefined = /* @__PURE__ */ __name((val) => val === null || val === void 0, "isNullOrUndefined");
    isNumber = /* @__PURE__ */ __name((val) => typeof val === "number", "isNumber");
    isString = /* @__PURE__ */ __name((val) => typeof val === "string", "isString");
    isSymbol = /* @__PURE__ */ __name((val) => typeof val === "symbol", "isSymbol");
    isUndefined = /* @__PURE__ */ __name((val) => val === void 0, "isUndefined");
    isFunction = /* @__PURE__ */ __name((val) => typeof val === "function", "isFunction");
    isBuffer = /* @__PURE__ */ __name((val) => {
      return val && typeof val === "object" && typeof val.copy === "function" && typeof val.fill === "function" && typeof val.readUInt8 === "function";
    }, "isBuffer");
    isObject = /* @__PURE__ */ __name((val) => val !== null && typeof val === "object" && Object.getPrototypeOf(val).isPrototypeOf(Object), "isObject");
    isError = /* @__PURE__ */ __name((val) => val instanceof Error, "isError");
    isPrimitive = /* @__PURE__ */ __name((val) => {
      if (typeof val === "object") {
        return val === null;
      }
      return typeof val !== "function";
    }, "isPrimitive");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/util/log.mjs
var init_log = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/util/log.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/util.mjs
import types from "node:util/types";
import { default as default2 } from "node:util/types";
var TextDecoder2, TextEncoder2, _errnoException, _exceptionWithHostPort, getSystemErrorMap, getSystemErrorName, parseEnv, styleText;
var init_util = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/util.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_legacy_types();
    init_log();
    TextDecoder2 = globalThis.TextDecoder;
    TextEncoder2 = globalThis.TextEncoder;
    _errnoException = /* @__PURE__ */ notImplemented("util._errnoException");
    _exceptionWithHostPort = /* @__PURE__ */ notImplemented("util._exceptionWithHostPort");
    getSystemErrorMap = /* @__PURE__ */ notImplemented("util.getSystemErrorMap");
    getSystemErrorName = /* @__PURE__ */ notImplemented("util.getSystemErrorName");
    parseEnv = /* @__PURE__ */ notImplemented("util.parseEnv");
    styleText = /* @__PURE__ */ notImplemented("util.styleText");
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs
var workerdUtil, MIMEParams, MIMEType, TextDecoder3, TextEncoder3, _extend, aborted, callbackify2, debug4, debuglog, deprecate, format, formatWithOptions, getCallSite, inherits, inspect, isArray, isDeepStrictEqual, log3, parseArgs, promisify, stripVTControlCharacters, toUSVString, transferableAbortController, transferableAbortSignal, types2, util_default;
var init_util2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/@cloudflare/unenv-preset/dist/runtime/node/util.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util();
    workerdUtil = process.getBuiltinModule("node:util");
    ({
      MIMEParams,
      MIMEType,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder3,
      _extend: (
        // @ts-expect-error missing types?
        _extend
      ),
      aborted,
      callbackify: callbackify2,
      debug: debug4,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite: (
        // @ts-expect-error unknown type
        getCallSite
      ),
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal
    } = workerdUtil);
    types2 = workerdUtil.types;
    util_default = {
      /**
       * manually unroll unenv-polyfilled-symbols to make it tree-shakeable
       */
      _errnoException,
      _exceptionWithHostPort,
      // @ts-expect-error unenv has unknown type
      getSystemErrorMap,
      // @ts-expect-error unenv has unknown type
      getSystemErrorName,
      isBoolean,
      isBuffer,
      isDate,
      isError,
      isFunction,
      isNull,
      isNullOrUndefined,
      isNumber,
      isObject,
      isPrimitive,
      isRegExp,
      isString,
      isSymbol,
      isUndefined,
      // @ts-expect-error unenv has unknown type
      parseEnv,
      // @ts-expect-error unenv has unknown type
      styleText,
      /**
       * manually unroll workerd-polyfilled-symbols to make it tree-shakeable
       */
      _extend,
      aborted,
      callbackify: callbackify2,
      debug: debug4,
      debuglog,
      deprecate,
      format,
      formatWithOptions,
      getCallSite,
      inherits,
      inspect,
      isArray,
      isDeepStrictEqual,
      log: log3,
      MIMEParams,
      MIMEType,
      parseArgs,
      promisify,
      stripVTControlCharacters,
      TextDecoder: TextDecoder3,
      TextEncoder: TextEncoder3,
      toUSVString,
      transferableAbortController,
      transferableAbortSignal,
      // special-cased deep merged symbols
      types: types2
    };
  }
});

// node-built-in-modules:util
var require_util3 = __commonJS({
  "node-built-in-modules:util"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    module.exports = util_default;
  }
});

// node_modules/gtoken/node_modules/jws/lib/data-stream.js
var require_data_stream = __commonJS({
  "node_modules/gtoken/node_modules/jws/lib/data-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util3();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    __name(DataStream, "DataStream");
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = /* @__PURE__ */ __name(function write2(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    }, "write");
    DataStream.prototype.end = /* @__PURE__ */ __name(function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    }, "end");
    module.exports = DataStream;
  }
});

// node_modules/buffer-equal-constant-time/index.js
var require_buffer_equal_constant_time = __commonJS({
  "node_modules/buffer-equal-constant-time/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    var SlowBuffer = require_buffer().SlowBuffer;
    module.exports = bufferEq;
    function bufferEq(a2, b2) {
      if (!Buffer2.isBuffer(a2) || !Buffer2.isBuffer(b2)) {
        return false;
      }
      if (a2.length !== b2.length) {
        return false;
      }
      var c = 0;
      for (var i = 0; i < a2.length; i++) {
        c |= a2[i] ^ b2[i];
      }
      return c === 0;
    }
    __name(bufferEq, "bufferEq");
    bufferEq.install = function() {
      Buffer2.prototype.equal = SlowBuffer.prototype.equal = /* @__PURE__ */ __name(function equal(that) {
        return bufferEq(this, that);
      }, "equal");
    };
    var origBufEqual = Buffer2.prototype.equal;
    var origSlowBufEqual = SlowBuffer.prototype.equal;
    bufferEq.restore = function() {
      Buffer2.prototype.equal = origBufEqual;
      SlowBuffer.prototype.equal = origSlowBufEqual;
    };
  }
});

// node_modules/gtoken/node_modules/jwa/index.js
var require_jwa = __commonJS({
  "node_modules/gtoken/node_modules/jwa/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto2 = require_crypto2();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util3();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    __name(checkIsPublicKey, "checkIsPublicKey");
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    __name(checkIsPrivateKey, "checkIsPrivateKey");
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    __name(checkIsSecretKey, "checkIsSecretKey");
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(fromBase64, "fromBase64");
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    __name(toBase64, "toBase64");
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    __name(typeError, "typeError");
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    __name(bufferOrString, "bufferOrString");
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    __name(normalizeInput, "normalizeInput");
    function createHmacSigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createHmacSigner, "createHmacSigner");
    function createHmacVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      }, "verify");
    }
    __name(createHmacVerifier, "createHmacVerifier");
    function createKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createKeySigner, "createKeySigner");
    function createKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      }, "verify");
    }
    __name(createKeyVerifier, "createKeyVerifier");
    function createPSSKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createPSSKeySigner, "createPSSKeySigner");
    function createPSSKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      }, "verify");
    }
    __name(createPSSKeyVerifier, "createPSSKeyVerifier");
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return /* @__PURE__ */ __name(function sign3() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      }, "sign");
    }
    __name(createECDSASigner, "createECDSASigner");
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      }, "verify");
    }
    __name(createECDSAVerifer, "createECDSAVerifer");
    function createNoneSigner() {
      return /* @__PURE__ */ __name(function sign3() {
        return "";
      }, "sign");
    }
    __name(createNoneSigner, "createNoneSigner");
    function createNoneVerifier() {
      return /* @__PURE__ */ __name(function verify3(thing, signature) {
        return signature === "";
      }, "verify");
    }
    __name(createNoneVerifier, "createNoneVerifier");
    module.exports = /* @__PURE__ */ __name(function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    }, "jwa");
  }
});

// node_modules/gtoken/node_modules/jws/lib/tostring.js
var require_tostring = __commonJS({
  "node_modules/gtoken/node_modules/jws/lib/tostring.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    module.exports = /* @__PURE__ */ __name(function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    }, "toString");
  }
});

// node_modules/gtoken/node_modules/jws/lib/sign-stream.js
var require_sign_stream = __commonJS({
  "node_modules/gtoken/node_modules/jws/lib/sign-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util3();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64url, "base64url");
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    __name(jwsSecuredInput, "jwsSecuredInput");
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    __name(jwsSign, "jwsSign");
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    __name(SignStream, "SignStream");
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = /* @__PURE__ */ __name(function sign3() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "sign");
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// node_modules/gtoken/node_modules/jws/lib/verify-stream.js
var require_verify_stream = __commonJS({
  "node_modules/gtoken/node_modules/jws/lib/verify-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream();
    var jwa = require_jwa();
    var Stream = require_stream();
    var toString = require_tostring();
    var util = require_util3();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    __name(isObject3, "isObject");
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    __name(headerFromJWS, "headerFromJWS");
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    __name(securedInputFromJWS, "securedInputFromJWS");
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    __name(signatureFromJWS, "signatureFromJWS");
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    __name(payloadFromJWS, "payloadFromJWS");
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    __name(isValidJws, "isValidJws");
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    __name(jwsVerify, "jwsVerify");
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    __name(jwsDecode, "jwsDecode");
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    __name(VerifyStream, "VerifyStream");
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = /* @__PURE__ */ __name(function verify3() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "verify");
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// node_modules/gtoken/node_modules/jws/index.js
var require_jws = __commonJS({
  "node_modules/gtoken/node_modules/jws/index.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SignStream = require_sign_stream();
    var VerifyStream = require_verify_stream();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = /* @__PURE__ */ __name(function createSign2(opts) {
      return new SignStream(opts);
    }, "createSign");
    exports.createVerify = /* @__PURE__ */ __name(function createVerify2(opts) {
      return new VerifyStream(opts);
    }, "createVerify");
  }
});

// node_modules/gtoken/build/src/index.js
var require_src3 = __commonJS({
  "node_modules/gtoken/build/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _GoogleToken_instances;
    var _GoogleToken_inFlightRequest;
    var _GoogleToken_getTokenAsync;
    var _GoogleToken_getTokenAsyncInner;
    var _GoogleToken_ensureEmail;
    var _GoogleToken_revokeTokenAsync;
    var _GoogleToken_configure;
    var _GoogleToken_requestToken;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleToken = void 0;
    var fs = require_fs();
    var gaxios_1 = require_src();
    var jws = require_jws();
    var path = require_path();
    var util_1 = require_util3();
    var readFile3 = fs.readFile ? (0, util_1.promisify)(fs.readFile) : async () => {
      throw new ErrorWithCode("use key rather than keyFile.", "MISSING_CREDENTIALS");
    };
    var GOOGLE_TOKEN_URL = "https://www.googleapis.com/oauth2/v4/token";
    var GOOGLE_REVOKE_TOKEN_URL = "https://accounts.google.com/o/oauth2/revoke?token=";
    var ErrorWithCode = class extends Error {
      static {
        __name(this, "ErrorWithCode");
      }
      constructor(message2, code) {
        super(message2);
        this.code = code;
      }
    };
    var GoogleToken = class {
      static {
        __name(this, "GoogleToken");
      }
      get accessToken() {
        return this.rawToken ? this.rawToken.access_token : void 0;
      }
      get idToken() {
        return this.rawToken ? this.rawToken.id_token : void 0;
      }
      get tokenType() {
        return this.rawToken ? this.rawToken.token_type : void 0;
      }
      get refreshToken() {
        return this.rawToken ? this.rawToken.refresh_token : void 0;
      }
      /**
       * Create a GoogleToken.
       *
       * @param options  Configuration object.
       */
      constructor(options) {
        _GoogleToken_instances.add(this);
        this.transporter = {
          request: /* @__PURE__ */ __name((opts) => (0, gaxios_1.request)(opts), "request")
        };
        _GoogleToken_inFlightRequest.set(this, void 0);
        __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, options);
      }
      /**
       * Returns whether the token has expired.
       *
       * @return true if the token has expired, false otherwise.
       */
      hasExpired() {
        const now = (/* @__PURE__ */ new Date()).getTime();
        if (this.rawToken && this.expiresAt) {
          return now >= this.expiresAt;
        } else {
          return true;
        }
      }
      /**
       * Returns whether the token will expire within eagerRefreshThresholdMillis
       *
       * @return true if the token will be expired within eagerRefreshThresholdMillis, false otherwise.
       */
      isTokenExpiring() {
        var _a;
        const now = (/* @__PURE__ */ new Date()).getTime();
        const eagerRefreshThresholdMillis = (_a = this.eagerRefreshThresholdMillis) !== null && _a !== void 0 ? _a : 0;
        if (this.rawToken && this.expiresAt) {
          return this.expiresAt <= now + eagerRefreshThresholdMillis;
        } else {
          return true;
        }
      }
      getToken(callback, opts = {}) {
        if (typeof callback === "object") {
          opts = callback;
          callback = void 0;
        }
        opts = Object.assign({
          forceRefresh: false
        }, opts);
        if (callback) {
          const cb = callback;
          __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts).then((t) => cb(null, t), callback);
          return;
        }
        return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsync).call(this, opts);
      }
      /**
       * Given a keyFile, extract the key and client email if available
       * @param keyFile Path to a json, pem, or p12 file that contains the key.
       * @returns an object with privateKey and clientEmail properties
       */
      async getCredentials(keyFile) {
        const ext = path.extname(keyFile);
        switch (ext) {
          case ".json": {
            const key = await readFile3(keyFile, "utf8");
            const body = JSON.parse(key);
            const privateKey = body.private_key;
            const clientEmail = body.client_email;
            if (!privateKey || !clientEmail) {
              throw new ErrorWithCode("private_key and client_email are required.", "MISSING_CREDENTIALS");
            }
            return { privateKey, clientEmail };
          }
          case ".der":
          case ".crt":
          case ".pem": {
            const privateKey = await readFile3(keyFile, "utf8");
            return { privateKey };
          }
          case ".p12":
          case ".pfx": {
            throw new ErrorWithCode("*.p12 certificates are not supported after v6.1.2. Consider utilizing *.json format or converting *.p12 to *.pem using the OpenSSL CLI.", "UNKNOWN_CERTIFICATE_TYPE");
          }
          default:
            throw new ErrorWithCode("Unknown certificate type. Type is determined based on file extension. Current supported extensions are *.json, and *.pem.", "UNKNOWN_CERTIFICATE_TYPE");
        }
      }
      revokeToken(callback) {
        if (callback) {
          __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this).then(() => callback(), callback);
          return;
        }
        return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_revokeTokenAsync).call(this);
      }
    };
    exports.GoogleToken = GoogleToken;
    _GoogleToken_inFlightRequest = /* @__PURE__ */ new WeakMap(), _GoogleToken_instances = /* @__PURE__ */ new WeakSet(), _GoogleToken_getTokenAsync = /* @__PURE__ */ __name(async function _GoogleToken_getTokenAsync2(opts) {
      if (__classPrivateFieldGet(this, _GoogleToken_inFlightRequest, "f") && !opts.forceRefresh) {
        return __classPrivateFieldGet(this, _GoogleToken_inFlightRequest, "f");
      }
      try {
        return await __classPrivateFieldSet(this, _GoogleToken_inFlightRequest, __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_getTokenAsyncInner).call(this, opts), "f");
      } finally {
        __classPrivateFieldSet(this, _GoogleToken_inFlightRequest, void 0, "f");
      }
    }, "_GoogleToken_getTokenAsync"), _GoogleToken_getTokenAsyncInner = /* @__PURE__ */ __name(async function _GoogleToken_getTokenAsyncInner2(opts) {
      if (this.isTokenExpiring() === false && opts.forceRefresh === false) {
        return Promise.resolve(this.rawToken);
      }
      if (!this.key && !this.keyFile) {
        throw new Error("No key or keyFile set.");
      }
      if (!this.key && this.keyFile) {
        const creds = await this.getCredentials(this.keyFile);
        this.key = creds.privateKey;
        this.iss = creds.clientEmail || this.iss;
        if (!creds.clientEmail) {
          __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_ensureEmail).call(this);
        }
      }
      return __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_requestToken).call(this);
    }, "_GoogleToken_getTokenAsyncInner"), _GoogleToken_ensureEmail = /* @__PURE__ */ __name(function _GoogleToken_ensureEmail2() {
      if (!this.iss) {
        throw new ErrorWithCode("email is required.", "MISSING_CREDENTIALS");
      }
    }, "_GoogleToken_ensureEmail"), _GoogleToken_revokeTokenAsync = /* @__PURE__ */ __name(async function _GoogleToken_revokeTokenAsync2() {
      if (!this.accessToken) {
        throw new Error("No token to revoke.");
      }
      const url = GOOGLE_REVOKE_TOKEN_URL + this.accessToken;
      await this.transporter.request({
        url,
        retry: true
      });
      __classPrivateFieldGet(this, _GoogleToken_instances, "m", _GoogleToken_configure).call(this, {
        email: this.iss,
        sub: this.sub,
        key: this.key,
        keyFile: this.keyFile,
        scope: this.scope,
        additionalClaims: this.additionalClaims
      });
    }, "_GoogleToken_revokeTokenAsync"), _GoogleToken_configure = /* @__PURE__ */ __name(function _GoogleToken_configure2(options = {}) {
      this.keyFile = options.keyFile;
      this.key = options.key;
      this.rawToken = void 0;
      this.iss = options.email || options.iss;
      this.sub = options.sub;
      this.additionalClaims = options.additionalClaims;
      if (typeof options.scope === "object") {
        this.scope = options.scope.join(" ");
      } else {
        this.scope = options.scope;
      }
      this.eagerRefreshThresholdMillis = options.eagerRefreshThresholdMillis;
      if (options.transporter) {
        this.transporter = options.transporter;
      }
    }, "_GoogleToken_configure"), _GoogleToken_requestToken = /**
     * Request the token from Google.
     */
    /* @__PURE__ */ __name(async function _GoogleToken_requestToken2() {
      var _a, _b;
      const iat = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      const additionalClaims = this.additionalClaims || {};
      const payload = Object.assign({
        iss: this.iss,
        scope: this.scope,
        aud: GOOGLE_TOKEN_URL,
        exp: iat + 3600,
        iat,
        sub: this.sub
      }, additionalClaims);
      const signedJWT = jws.sign({
        header: { alg: "RS256" },
        payload,
        secret: this.key
      });
      try {
        const r = await this.transporter.request({
          method: "POST",
          url: GOOGLE_TOKEN_URL,
          data: {
            grant_type: "urn:ietf:params:oauth:grant-type:jwt-bearer",
            assertion: signedJWT
          },
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          responseType: "json",
          retryConfig: {
            httpMethodsToRetry: ["POST"]
          }
        });
        this.rawToken = r.data;
        this.expiresAt = r.data.expires_in === null || r.data.expires_in === void 0 ? void 0 : (iat + r.data.expires_in) * 1e3;
        return this.rawToken;
      } catch (e) {
        this.rawToken = void 0;
        this.tokenExpires = void 0;
        const body = e.response && ((_a = e.response) === null || _a === void 0 ? void 0 : _a.data) ? (_b = e.response) === null || _b === void 0 ? void 0 : _b.data : {};
        if (body.error) {
          const desc = body.error_description ? `: ${body.error_description}` : "";
          e.message = `${body.error}${desc}`;
        }
        throw e;
      }
    }, "_GoogleToken_requestToken");
  }
});

// node_modules/google-auth-library/node_modules/jws/lib/data-stream.js
var require_data_stream2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jws/lib/data-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util3();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    __name(DataStream, "DataStream");
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = /* @__PURE__ */ __name(function write2(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    }, "write");
    DataStream.prototype.end = /* @__PURE__ */ __name(function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    }, "end");
    module.exports = DataStream;
  }
});

// node_modules/google-auth-library/node_modules/jwa/index.js
var require_jwa2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jwa/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto2 = require_crypto2();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util3();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    __name(checkIsPublicKey, "checkIsPublicKey");
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    __name(checkIsPrivateKey, "checkIsPrivateKey");
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    __name(checkIsSecretKey, "checkIsSecretKey");
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(fromBase64, "fromBase64");
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    __name(toBase64, "toBase64");
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    __name(typeError, "typeError");
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    __name(bufferOrString, "bufferOrString");
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    __name(normalizeInput, "normalizeInput");
    function createHmacSigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createHmacSigner, "createHmacSigner");
    function createHmacVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      }, "verify");
    }
    __name(createHmacVerifier, "createHmacVerifier");
    function createKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createKeySigner, "createKeySigner");
    function createKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      }, "verify");
    }
    __name(createKeyVerifier, "createKeyVerifier");
    function createPSSKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createPSSKeySigner, "createPSSKeySigner");
    function createPSSKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      }, "verify");
    }
    __name(createPSSKeyVerifier, "createPSSKeyVerifier");
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return /* @__PURE__ */ __name(function sign3() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      }, "sign");
    }
    __name(createECDSASigner, "createECDSASigner");
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      }, "verify");
    }
    __name(createECDSAVerifer, "createECDSAVerifer");
    function createNoneSigner() {
      return /* @__PURE__ */ __name(function sign3() {
        return "";
      }, "sign");
    }
    __name(createNoneSigner, "createNoneSigner");
    function createNoneVerifier() {
      return /* @__PURE__ */ __name(function verify3(thing, signature) {
        return signature === "";
      }, "verify");
    }
    __name(createNoneVerifier, "createNoneVerifier");
    module.exports = /* @__PURE__ */ __name(function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    }, "jwa");
  }
});

// node_modules/google-auth-library/node_modules/jws/lib/tostring.js
var require_tostring2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jws/lib/tostring.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    module.exports = /* @__PURE__ */ __name(function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    }, "toString");
  }
});

// node_modules/google-auth-library/node_modules/jws/lib/sign-stream.js
var require_sign_stream2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jws/lib/sign-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream2();
    var jwa = require_jwa2();
    var Stream = require_stream();
    var toString = require_tostring2();
    var util = require_util3();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64url, "base64url");
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    __name(jwsSecuredInput, "jwsSecuredInput");
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    __name(jwsSign, "jwsSign");
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    __name(SignStream, "SignStream");
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = /* @__PURE__ */ __name(function sign3() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "sign");
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// node_modules/google-auth-library/node_modules/jws/lib/verify-stream.js
var require_verify_stream2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jws/lib/verify-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream2();
    var jwa = require_jwa2();
    var Stream = require_stream();
    var toString = require_tostring2();
    var util = require_util3();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    __name(isObject3, "isObject");
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    __name(headerFromJWS, "headerFromJWS");
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    __name(securedInputFromJWS, "securedInputFromJWS");
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    __name(signatureFromJWS, "signatureFromJWS");
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    __name(payloadFromJWS, "payloadFromJWS");
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    __name(isValidJws, "isValidJws");
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    __name(jwsVerify, "jwsVerify");
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    __name(jwsDecode, "jwsDecode");
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    __name(VerifyStream, "VerifyStream");
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = /* @__PURE__ */ __name(function verify3() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "verify");
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// node_modules/google-auth-library/node_modules/jws/index.js
var require_jws2 = __commonJS({
  "node_modules/google-auth-library/node_modules/jws/index.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SignStream = require_sign_stream2();
    var VerifyStream = require_verify_stream2();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = /* @__PURE__ */ __name(function createSign2(opts) {
      return new SignStream(opts);
    }, "createSign");
    exports.createVerify = /* @__PURE__ */ __name(function createVerify2(opts) {
      return new VerifyStream(opts);
    }, "createVerify");
  }
});

// node_modules/google-auth-library/build/src/auth/jwtaccess.js
var require_jwtaccess = __commonJS({
  "node_modules/google-auth-library/build/src/auth/jwtaccess.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JWTAccess = void 0;
    var jws = require_jws2();
    var util_1 = require_util2();
    var DEFAULT_HEADER = {
      alg: "RS256",
      typ: "JWT"
    };
    var JWTAccess = class _JWTAccess {
      static {
        __name(this, "JWTAccess");
      }
      /**
       * JWTAccess service account credentials.
       *
       * Create a new access token by using the credential to create a new JWT token
       * that's recognized as the access token.
       *
       * @param email the service account email address.
       * @param key the private key that will be used to sign the token.
       * @param keyId the ID of the private key used to sign the token.
       */
      constructor(email, key, keyId, eagerRefreshThresholdMillis) {
        this.cache = new util_1.LRUCache({
          capacity: 500,
          maxAge: 60 * 60 * 1e3
        });
        this.email = email;
        this.key = key;
        this.keyId = keyId;
        this.eagerRefreshThresholdMillis = eagerRefreshThresholdMillis !== null && eagerRefreshThresholdMillis !== void 0 ? eagerRefreshThresholdMillis : 5 * 60 * 1e3;
      }
      /**
       * Ensures that we're caching a key appropriately, giving precedence to scopes vs. url
       *
       * @param url The URI being authorized.
       * @param scopes The scope or scopes being authorized
       * @returns A string that returns the cached key.
       */
      getCachedKey(url, scopes) {
        let cacheKey = url;
        if (scopes && Array.isArray(scopes) && scopes.length) {
          cacheKey = url ? `${url}_${scopes.join("_")}` : `${scopes.join("_")}`;
        } else if (typeof scopes === "string") {
          cacheKey = url ? `${url}_${scopes}` : scopes;
        }
        if (!cacheKey) {
          throw Error("Scopes or url must be provided");
        }
        return cacheKey;
      }
      /**
       * Get a non-expired access token, after refreshing if necessary.
       *
       * @param url The URI being authorized.
       * @param additionalClaims An object with a set of additional claims to
       * include in the payload.
       * @returns An object that includes the authorization header.
       */
      getRequestHeaders(url, additionalClaims, scopes) {
        const key = this.getCachedKey(url, scopes);
        const cachedToken = this.cache.get(key);
        const now = Date.now();
        if (cachedToken && cachedToken.expiration - now > this.eagerRefreshThresholdMillis) {
          return cachedToken.headers;
        }
        const iat = Math.floor(Date.now() / 1e3);
        const exp = _JWTAccess.getExpirationTime(iat);
        let defaultClaims;
        if (Array.isArray(scopes)) {
          scopes = scopes.join(" ");
        }
        if (scopes) {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            scope: scopes,
            exp,
            iat
          };
        } else {
          defaultClaims = {
            iss: this.email,
            sub: this.email,
            aud: url,
            exp,
            iat
          };
        }
        if (additionalClaims) {
          for (const claim in defaultClaims) {
            if (additionalClaims[claim]) {
              throw new Error(`The '${claim}' property is not allowed when passing additionalClaims. This claim is included in the JWT by default.`);
            }
          }
        }
        const header = this.keyId ? { ...DEFAULT_HEADER, kid: this.keyId } : DEFAULT_HEADER;
        const payload = Object.assign(defaultClaims, additionalClaims);
        const signedJWT = jws.sign({ header, payload, secret: this.key });
        const headers = { Authorization: `Bearer ${signedJWT}` };
        this.cache.set(key, {
          expiration: exp * 1e3,
          headers
        });
        return headers;
      }
      /**
       * Returns an expiration time for the JWT token.
       *
       * @param iat The issued at time for the JWT.
       * @returns An expiration time for the JWT.
       */
      static getExpirationTime(iat) {
        const exp = iat + 3600;
        return exp;
      }
      /**
       * Create a JWTAccess credentials instance using the given input options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            reject(new Error("Must pass in a stream containing the service account auth settings."));
          }
          let s = "";
          inputStream.setEncoding("utf8").on("data", (chunk) => s += chunk).on("error", reject).on("end", () => {
            try {
              const data = JSON.parse(s);
              this.fromJSON(data);
              resolve();
            } catch (err) {
              reject(err);
            }
          });
        });
      }
    };
    exports.JWTAccess = JWTAccess;
  }
});

// node_modules/google-auth-library/build/src/auth/jwtclient.js
var require_jwtclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/jwtclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JWT = void 0;
    var gtoken_1 = require_src3();
    var jwtaccess_1 = require_jwtaccess();
    var oauth2client_1 = require_oauth2client();
    var authclient_1 = require_authclient();
    var JWT = class _JWT extends oauth2client_1.OAuth2Client {
      static {
        __name(this, "JWT");
      }
      constructor(optionsOrEmail, keyFile, key, scopes, subject, keyId) {
        const opts = optionsOrEmail && typeof optionsOrEmail === "object" ? optionsOrEmail : { email: optionsOrEmail, keyFile, key, keyId, scopes, subject };
        super(opts);
        this.email = opts.email;
        this.keyFile = opts.keyFile;
        this.key = opts.key;
        this.keyId = opts.keyId;
        this.scopes = opts.scopes;
        this.subject = opts.subject;
        this.additionalClaims = opts.additionalClaims;
        this.credentials = { refresh_token: "jwt-placeholder", expiry_date: 1 };
      }
      /**
       * Creates a copy of the credential with the specified scopes.
       * @param scopes List of requested scopes or a single scope.
       * @return The cloned instance.
       */
      createScoped(scopes) {
        const jwt = new _JWT(this);
        jwt.scopes = scopes;
        return jwt;
      }
      /**
       * Obtains the metadata to be sent with the request.
       *
       * @param url the URI being authorized.
       */
      async getRequestMetadataAsync(url) {
        url = this.defaultServicePath ? `https://${this.defaultServicePath}/` : url;
        const useSelfSignedJWT = !this.hasUserScopes() && url || this.useJWTAccessWithScope && this.hasAnyScopes() || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
        if (this.subject && this.universeDomain !== authclient_1.DEFAULT_UNIVERSE) {
          throw new RangeError(`Service Account user is configured for the credential. Domain-wide delegation is not supported in universes other than ${authclient_1.DEFAULT_UNIVERSE}`);
        }
        if (!this.apiKey && useSelfSignedJWT) {
          if (this.additionalClaims && this.additionalClaims.target_audience) {
            const { tokens } = await this.refreshToken();
            return {
              headers: this.addSharedMetadataHeaders({
                Authorization: `Bearer ${tokens.id_token}`
              })
            };
          } else {
            if (!this.access) {
              this.access = new jwtaccess_1.JWTAccess(this.email, this.key, this.keyId, this.eagerRefreshThresholdMillis);
            }
            let scopes;
            if (this.hasUserScopes()) {
              scopes = this.scopes;
            } else if (!url) {
              scopes = this.defaultScopes;
            }
            const useScopes = this.useJWTAccessWithScope || this.universeDomain !== authclient_1.DEFAULT_UNIVERSE;
            const headers = await this.access.getRequestHeaders(
              url !== null && url !== void 0 ? url : void 0,
              this.additionalClaims,
              // Scopes take precedent over audience for signing,
              // so we only provide them if `useJWTAccessWithScope` is on or
              // if we are in a non-default universe
              useScopes ? scopes : void 0
            );
            return { headers: this.addSharedMetadataHeaders(headers) };
          }
        } else if (this.hasAnyScopes() || this.apiKey) {
          return super.getRequestMetadataAsync(url);
        } else {
          return { headers: {} };
        }
      }
      /**
       * Fetches an ID token.
       * @param targetAudience the audience for the fetched ID token.
       */
      async fetchIdToken(targetAudience) {
        const gtoken = new gtoken_1.GoogleToken({
          iss: this.email,
          sub: this.subject,
          scope: this.scopes || this.defaultScopes,
          keyFile: this.keyFile,
          key: this.key,
          additionalClaims: { target_audience: targetAudience },
          transporter: this.transporter
        });
        await gtoken.getToken({
          forceRefresh: true
        });
        if (!gtoken.idToken) {
          throw new Error("Unknown error: Failed to fetch ID token");
        }
        return gtoken.idToken;
      }
      /**
       * Determine if there are currently scopes available.
       */
      hasUserScopes() {
        if (!this.scopes) {
          return false;
        }
        return this.scopes.length > 0;
      }
      /**
       * Are there any default or user scopes defined.
       */
      hasAnyScopes() {
        if (this.scopes && this.scopes.length > 0)
          return true;
        if (this.defaultScopes && this.defaultScopes.length > 0)
          return true;
        return false;
      }
      authorize(callback) {
        if (callback) {
          this.authorizeAsync().then((r) => callback(null, r), callback);
        } else {
          return this.authorizeAsync();
        }
      }
      async authorizeAsync() {
        const result = await this.refreshToken();
        if (!result) {
          throw new Error("No result returned");
        }
        this.credentials = result.tokens;
        this.credentials.refresh_token = "jwt-placeholder";
        this.key = this.gtoken.key;
        this.email = this.gtoken.iss;
        return result.tokens;
      }
      /**
       * Refreshes the access token.
       * @param refreshToken ignored
       * @private
       */
      async refreshTokenNoCache(refreshToken2) {
        const gtoken = this.createGToken();
        const token = await gtoken.getToken({
          forceRefresh: this.isTokenExpiring()
        });
        const tokens = {
          access_token: token.access_token,
          token_type: "Bearer",
          expiry_date: gtoken.expiresAt,
          id_token: gtoken.idToken
        };
        this.emit("tokens", tokens);
        return { res: null, tokens };
      }
      /**
       * Create a gToken if it doesn't already exist.
       */
      createGToken() {
        if (!this.gtoken) {
          this.gtoken = new gtoken_1.GoogleToken({
            iss: this.email,
            sub: this.subject,
            scope: this.scopes || this.defaultScopes,
            keyFile: this.keyFile,
            key: this.key,
            additionalClaims: this.additionalClaims,
            transporter: this.transporter
          });
        }
        return this.gtoken;
      }
      /**
       * Create a JWT credentials instance using the given input options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the service account auth settings.");
        }
        if (!json.client_email) {
          throw new Error("The incoming JSON object does not contain a client_email field");
        }
        if (!json.private_key) {
          throw new Error("The incoming JSON object does not contain a private_key field");
        }
        this.email = json.client_email;
        this.key = json.private_key;
        this.keyId = json.private_key_id;
        this.projectId = json.project_id;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the service account auth settings.");
          }
          let s = "";
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
            try {
              const data = JSON.parse(s);
              this.fromJSON(data);
              resolve();
            } catch (e) {
              reject(e);
            }
          });
        });
      }
      /**
       * Creates a JWT credentials instance using an API Key for authentication.
       * @param apiKey The API Key in string form.
       */
      fromAPIKey(apiKey) {
        if (typeof apiKey !== "string") {
          throw new Error("Must provide an API Key string.");
        }
        this.apiKey = apiKey;
      }
      /**
       * Using the key or keyFile on the JWT client, obtain an object that contains
       * the key and the client email.
       */
      async getCredentials() {
        if (this.key) {
          return { private_key: this.key, client_email: this.email };
        } else if (this.keyFile) {
          const gtoken = this.createGToken();
          const creds = await gtoken.getCredentials(this.keyFile);
          return { private_key: creds.privateKey, client_email: creds.clientEmail };
        }
        throw new Error("A key or a keyFile must be provided to getCredentials.");
      }
    };
    exports.JWT = JWT;
  }
});

// node_modules/google-auth-library/build/src/auth/refreshclient.js
var require_refreshclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/refreshclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserRefreshClient = exports.USER_REFRESH_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var querystring_1 = require_querystring();
    exports.USER_REFRESH_ACCOUNT_TYPE = "authorized_user";
    var UserRefreshClient = class _UserRefreshClient extends oauth2client_1.OAuth2Client {
      static {
        __name(this, "UserRefreshClient");
      }
      constructor(optionsOrClientId, clientSecret, refreshToken2, eagerRefreshThresholdMillis, forceRefreshOnFailure) {
        const opts = optionsOrClientId && typeof optionsOrClientId === "object" ? optionsOrClientId : {
          clientId: optionsOrClientId,
          clientSecret,
          refreshToken: refreshToken2,
          eagerRefreshThresholdMillis,
          forceRefreshOnFailure
        };
        super(opts);
        this._refreshToken = opts.refreshToken;
        this.credentials.refresh_token = opts.refreshToken;
      }
      /**
       * Refreshes the access token.
       * @param refreshToken An ignored refreshToken..
       * @param callback Optional callback.
       */
      async refreshTokenNoCache(refreshToken2) {
        return super.refreshTokenNoCache(this._refreshToken);
      }
      async fetchIdToken(targetAudience) {
        const res = await this.transporter.request({
          ..._UserRefreshClient.RETRY_CONFIG,
          url: this.endpoints.oauth2TokenUrl,
          headers: {
            "Content-Type": "application/x-www-form-urlencoded"
          },
          method: "POST",
          data: (0, querystring_1.stringify)({
            client_id: this._clientId,
            client_secret: this._clientSecret,
            grant_type: "refresh_token",
            refresh_token: this._refreshToken,
            target_audience: targetAudience
          })
        });
        return res.data.id_token;
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      fromJSON(json) {
        if (!json) {
          throw new Error("Must pass in a JSON object containing the user refresh token");
        }
        if (json.type !== "authorized_user") {
          throw new Error('The incoming JSON object does not have the "authorized_user" type');
        }
        if (!json.client_id) {
          throw new Error("The incoming JSON object does not contain a client_id field");
        }
        if (!json.client_secret) {
          throw new Error("The incoming JSON object does not contain a client_secret field");
        }
        if (!json.refresh_token) {
          throw new Error("The incoming JSON object does not contain a refresh_token field");
        }
        this._clientId = json.client_id;
        this._clientSecret = json.client_secret;
        this._refreshToken = json.refresh_token;
        this.credentials.refresh_token = json.refresh_token;
        this.quotaProjectId = json.quota_project_id;
        this.universeDomain = json.universe_domain || this.universeDomain;
      }
      fromStream(inputStream, callback) {
        if (callback) {
          this.fromStreamAsync(inputStream).then(() => callback(), callback);
        } else {
          return this.fromStreamAsync(inputStream);
        }
      }
      async fromStreamAsync(inputStream) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            return reject(new Error("Must pass in a stream containing the user refresh token."));
          }
          let s = "";
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => s += chunk).on("end", () => {
            try {
              const data = JSON.parse(s);
              this.fromJSON(data);
              return resolve();
            } catch (err) {
              return reject(err);
            }
          });
        });
      }
      /**
       * Create a UserRefreshClient credentials instance using the given input
       * options.
       * @param json The input object.
       */
      static fromJSON(json) {
        const client = new _UserRefreshClient();
        client.fromJSON(json);
        return client;
      }
    };
    exports.UserRefreshClient = UserRefreshClient;
  }
});

// node_modules/google-auth-library/build/src/auth/impersonated.js
var require_impersonated = __commonJS({
  "node_modules/google-auth-library/build/src/auth/impersonated.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Impersonated = exports.IMPERSONATED_ACCOUNT_TYPE = void 0;
    var oauth2client_1 = require_oauth2client();
    var gaxios_1 = require_src();
    var util_1 = require_util2();
    exports.IMPERSONATED_ACCOUNT_TYPE = "impersonated_service_account";
    var Impersonated = class _Impersonated extends oauth2client_1.OAuth2Client {
      static {
        __name(this, "Impersonated");
      }
      /**
       * Impersonated service account credentials.
       *
       * Create a new access token by impersonating another service account.
       *
       * Impersonated Credentials allowing credentials issued to a user or
       * service account to impersonate another. The source project using
       * Impersonated Credentials must enable the "IAMCredentials" API.
       * Also, the target service account must grant the orginating principal
       * the "Service Account Token Creator" IAM role.
       *
       * @param {object} options - The configuration object.
       * @param {object} [options.sourceClient] the source credential used as to
       * acquire the impersonated credentials.
       * @param {string} [options.targetPrincipal] the service account to
       * impersonate.
       * @param {string[]} [options.delegates] the chained list of delegates
       * required to grant the final access_token. If set, the sequence of
       * identities must have "Service Account Token Creator" capability granted to
       * the preceding identity. For example, if set to [serviceAccountB,
       * serviceAccountC], the sourceCredential must have the Token Creator role on
       * serviceAccountB. serviceAccountB must have the Token Creator on
       * serviceAccountC. Finally, C must have Token Creator on target_principal.
       * If left unset, sourceCredential must have that role on targetPrincipal.
       * @param {string[]} [options.targetScopes] scopes to request during the
       * authorization grant.
       * @param {number} [options.lifetime] number of seconds the delegated
       * credential should be valid for up to 3600 seconds by default, or 43,200
       * seconds by extending the token's lifetime, see:
       * https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials#sa-credentials-oauth
       * @param {string} [options.endpoint] api endpoint override.
       */
      constructor(options = {}) {
        var _a, _b, _c, _d, _e, _f;
        super(options);
        this.credentials = {
          expiry_date: 1,
          refresh_token: "impersonated-placeholder"
        };
        this.sourceClient = (_a = options.sourceClient) !== null && _a !== void 0 ? _a : new oauth2client_1.OAuth2Client();
        this.targetPrincipal = (_b = options.targetPrincipal) !== null && _b !== void 0 ? _b : "";
        this.delegates = (_c = options.delegates) !== null && _c !== void 0 ? _c : [];
        this.targetScopes = (_d = options.targetScopes) !== null && _d !== void 0 ? _d : [];
        this.lifetime = (_e = options.lifetime) !== null && _e !== void 0 ? _e : 3600;
        const usingExplicitUniverseDomain = !!(0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (!usingExplicitUniverseDomain) {
          this.universeDomain = this.sourceClient.universeDomain;
        } else if (this.sourceClient.universeDomain !== this.universeDomain) {
          throw new RangeError(`Universe domain ${this.sourceClient.universeDomain} in source credentials does not match ${this.universeDomain} universe domain set for impersonated credentials.`);
        }
        this.endpoint = (_f = options.endpoint) !== null && _f !== void 0 ? _f : `https://iamcredentials.${this.universeDomain}`;
      }
      /**
       * Signs some bytes.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/signBlob Reference Documentation}
       * @param blobToSign String to sign.
       *
       * @returns A {@link SignBlobResponse} denoting the keyID and signedBlob in base64 string
       */
      async sign(blobToSign) {
        await this.sourceClient.getAccessToken();
        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
        const u = `${this.endpoint}/v1/${name}:signBlob`;
        const body = {
          delegates: this.delegates,
          payload: Buffer.from(blobToSign).toString("base64")
        };
        const res = await this.sourceClient.request({
          ..._Impersonated.RETRY_CONFIG,
          url: u,
          data: body,
          method: "POST"
        });
        return res.data;
      }
      /** The service account email to be impersonated. */
      getTargetPrincipal() {
        return this.targetPrincipal;
      }
      /**
       * Refreshes the access token.
       */
      async refreshToken() {
        var _a, _b, _c, _d, _e, _f;
        try {
          await this.sourceClient.getAccessToken();
          const name = "projects/-/serviceAccounts/" + this.targetPrincipal;
          const u = `${this.endpoint}/v1/${name}:generateAccessToken`;
          const body = {
            delegates: this.delegates,
            scope: this.targetScopes,
            lifetime: this.lifetime + "s"
          };
          const res = await this.sourceClient.request({
            ..._Impersonated.RETRY_CONFIG,
            url: u,
            data: body,
            method: "POST"
          });
          const tokenResponse = res.data;
          this.credentials.access_token = tokenResponse.accessToken;
          this.credentials.expiry_date = Date.parse(tokenResponse.expireTime);
          return {
            tokens: this.credentials,
            res
          };
        } catch (error3) {
          if (!(error3 instanceof Error))
            throw error3;
          let status = 0;
          let message2 = "";
          if (error3 instanceof gaxios_1.GaxiosError) {
            status = (_c = (_b = (_a = error3 === null || error3 === void 0 ? void 0 : error3.response) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.error) === null || _c === void 0 ? void 0 : _c.status;
            message2 = (_f = (_e = (_d = error3 === null || error3 === void 0 ? void 0 : error3.response) === null || _d === void 0 ? void 0 : _d.data) === null || _e === void 0 ? void 0 : _e.error) === null || _f === void 0 ? void 0 : _f.message;
          }
          if (status && message2) {
            error3.message = `${status}: unable to impersonate: ${message2}`;
            throw error3;
          } else {
            error3.message = `unable to impersonate: ${error3}`;
            throw error3;
          }
        }
      }
      /**
       * Generates an OpenID Connect ID token for a service account.
       *
       * {@link https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateIdToken Reference Documentation}
       *
       * @param targetAudience the audience for the fetched ID token.
       * @param options the for the request
       * @return an OpenID Connect ID token
       */
      async fetchIdToken(targetAudience, options) {
        var _a, _b;
        await this.sourceClient.getAccessToken();
        const name = `projects/-/serviceAccounts/${this.targetPrincipal}`;
        const u = `${this.endpoint}/v1/${name}:generateIdToken`;
        const body = {
          delegates: this.delegates,
          audience: targetAudience,
          includeEmail: (_a = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _a !== void 0 ? _a : true,
          useEmailAzp: (_b = options === null || options === void 0 ? void 0 : options.includeEmail) !== null && _b !== void 0 ? _b : true
        };
        const res = await this.sourceClient.request({
          ..._Impersonated.RETRY_CONFIG,
          url: u,
          data: body,
          method: "POST"
        });
        return res.data.token;
      }
    };
    exports.Impersonated = Impersonated;
  }
});

// node_modules/google-auth-library/build/src/auth/oauth2common.js
var require_oauth2common = __commonJS({
  "node_modules/google-auth-library/build/src/auth/oauth2common.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OAuthClientAuthHandler = void 0;
    exports.getErrorFromOAuthErrorResponse = getErrorFromOAuthErrorResponse;
    var querystring = require_querystring();
    var crypto_1 = require_crypto4();
    var METHODS_SUPPORTING_REQUEST_BODY = ["PUT", "POST", "PATCH"];
    var OAuthClientAuthHandler = class {
      static {
        __name(this, "OAuthClientAuthHandler");
      }
      /**
       * Instantiates an OAuth client authentication handler.
       * @param clientAuthentication The client auth credentials.
       */
      constructor(clientAuthentication) {
        this.clientAuthentication = clientAuthentication;
        this.crypto = (0, crypto_1.createCrypto)();
      }
      /**
       * Applies client authentication on the OAuth request's headers or POST
       * body but does not process the request.
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      applyClientAuthenticationOptions(opts, bearerToken) {
        this.injectAuthenticatedHeaders(opts, bearerToken);
        if (!bearerToken) {
          this.injectAuthenticatedRequestBody(opts);
        }
      }
      /**
       * Applies client authentication on the request's header if either
       * basic authentication or bearer token authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       * @param bearerToken The optional bearer token to use for authentication.
       *   When this is used, no client authentication credentials are needed.
       */
      injectAuthenticatedHeaders(opts, bearerToken) {
        var _a;
        if (bearerToken) {
          opts.headers = opts.headers || {};
          Object.assign(opts.headers, {
            Authorization: `Bearer ${bearerToken}}`
          });
        } else if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === "basic") {
          opts.headers = opts.headers || {};
          const clientId = this.clientAuthentication.clientId;
          const clientSecret = this.clientAuthentication.clientSecret || "";
          const base64EncodedCreds = this.crypto.encodeBase64StringUtf8(`${clientId}:${clientSecret}`);
          Object.assign(opts.headers, {
            Authorization: `Basic ${base64EncodedCreds}`
          });
        }
      }
      /**
       * Applies client authentication on the request's body if request-body
       * client authentication is selected.
       *
       * @param opts The GaxiosOptions whose headers or data are to be modified
       *   depending on the client authentication mechanism to be used.
       */
      injectAuthenticatedRequestBody(opts) {
        var _a;
        if (((_a = this.clientAuthentication) === null || _a === void 0 ? void 0 : _a.confidentialClientType) === "request-body") {
          const method = (opts.method || "GET").toUpperCase();
          if (METHODS_SUPPORTING_REQUEST_BODY.indexOf(method) !== -1) {
            let contentType;
            const headers = opts.headers || {};
            for (const key in headers) {
              if (key.toLowerCase() === "content-type" && headers[key]) {
                contentType = headers[key].toLowerCase();
                break;
              }
            }
            if (contentType === "application/x-www-form-urlencoded") {
              opts.data = opts.data || "";
              const data = querystring.parse(opts.data);
              Object.assign(data, {
                client_id: this.clientAuthentication.clientId,
                client_secret: this.clientAuthentication.clientSecret || ""
              });
              opts.data = querystring.stringify(data);
            } else if (contentType === "application/json") {
              opts.data = opts.data || {};
              Object.assign(opts.data, {
                client_id: this.clientAuthentication.clientId,
                client_secret: this.clientAuthentication.clientSecret || ""
              });
            } else {
              throw new Error(`${contentType} content-types are not supported with ${this.clientAuthentication.confidentialClientType} client authentication`);
            }
          } else {
            throw new Error(`${method} HTTP method does not support ${this.clientAuthentication.confidentialClientType} client authentication`);
          }
        }
      }
      /**
       * Retry config for Auth-related requests.
       *
       * @remarks
       *
       * This is not a part of the default {@link AuthClient.transporter transporter/gaxios}
       * config as some downstream APIs would prefer if customers explicitly enable retries,
       * such as GCS.
       */
      static get RETRY_CONFIG() {
        return {
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["GET", "PUT", "POST", "HEAD", "OPTIONS", "DELETE"]
          }
        };
      }
    };
    exports.OAuthClientAuthHandler = OAuthClientAuthHandler;
    function getErrorFromOAuthErrorResponse(resp, err) {
      const errorCode = resp.error;
      const errorDescription = resp.error_description;
      const errorUri = resp.error_uri;
      let message2 = `Error code ${errorCode}`;
      if (typeof errorDescription !== "undefined") {
        message2 += `: ${errorDescription}`;
      }
      if (typeof errorUri !== "undefined") {
        message2 += ` - ${errorUri}`;
      }
      const newError = new Error(message2);
      if (err) {
        const keys = Object.keys(err);
        if (err.stack) {
          keys.push("stack");
        }
        keys.forEach((key) => {
          if (key !== "message") {
            Object.defineProperty(newError, key, {
              // eslint-disable-next-line @typescript-eslint/no-explicit-any
              value: err[key],
              writable: false,
              enumerable: true
            });
          }
        });
      }
      return newError;
    }
    __name(getErrorFromOAuthErrorResponse, "getErrorFromOAuthErrorResponse");
  }
});

// node_modules/google-auth-library/build/src/auth/stscredentials.js
var require_stscredentials = __commonJS({
  "node_modules/google-auth-library/build/src/auth/stscredentials.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StsCredentials = void 0;
    var gaxios_1 = require_src();
    var querystring = require_querystring();
    var transporters_1 = require_transporters();
    var oauth2common_1 = require_oauth2common();
    var StsCredentials = class _StsCredentials extends oauth2common_1.OAuthClientAuthHandler {
      static {
        __name(this, "StsCredentials");
      }
      /**
       * Initializes an STS credentials instance.
       * @param tokenExchangeEndpoint The token exchange endpoint.
       * @param clientAuthentication The client authentication credentials if
       *   available.
       */
      constructor(tokenExchangeEndpoint, clientAuthentication) {
        super(clientAuthentication);
        this.tokenExchangeEndpoint = tokenExchangeEndpoint;
        this.transporter = new transporters_1.DefaultTransporter();
      }
      /**
       * Exchanges the provided token for another type of token based on the
       * rfc8693 spec.
       * @param stsCredentialsOptions The token exchange options used to populate
       *   the token exchange request.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @param options Optional additional GCP-specific non-spec defined options
       *   to send with the request.
       *   Example: `&options=${encodeUriComponent(JSON.stringified(options))}`
       * @return A promise that resolves with the token exchange response containing
       *   the requested token and its expiration time.
       */
      async exchangeToken(stsCredentialsOptions, additionalHeaders, options) {
        var _a, _b, _c;
        const values = {
          grant_type: stsCredentialsOptions.grantType,
          resource: stsCredentialsOptions.resource,
          audience: stsCredentialsOptions.audience,
          scope: (_a = stsCredentialsOptions.scope) === null || _a === void 0 ? void 0 : _a.join(" "),
          requested_token_type: stsCredentialsOptions.requestedTokenType,
          subject_token: stsCredentialsOptions.subjectToken,
          subject_token_type: stsCredentialsOptions.subjectTokenType,
          actor_token: (_b = stsCredentialsOptions.actingParty) === null || _b === void 0 ? void 0 : _b.actorToken,
          actor_token_type: (_c = stsCredentialsOptions.actingParty) === null || _c === void 0 ? void 0 : _c.actorTokenType,
          // Non-standard GCP-specific options.
          options: options && JSON.stringify(options)
        };
        Object.keys(values).forEach((key) => {
          if (typeof values[key] === "undefined") {
            delete values[key];
          }
        });
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded"
        };
        Object.assign(headers, additionalHeaders || {});
        const opts = {
          ..._StsCredentials.RETRY_CONFIG,
          url: this.tokenExchangeEndpoint.toString(),
          method: "POST",
          headers,
          data: querystring.stringify(values),
          responseType: "json"
        };
        this.applyClientAuthenticationOptions(opts);
        try {
          const response = await this.transporter.request(opts);
          const stsSuccessfulResponse = response.data;
          stsSuccessfulResponse.res = response;
          return stsSuccessfulResponse;
        } catch (error3) {
          if (error3 instanceof gaxios_1.GaxiosError && error3.response) {
            throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
              error3.response.data,
              // Preserve other fields from the original error.
              error3
            );
          }
          throw error3;
        }
      }
    };
    exports.StsCredentials = StsCredentials;
  }
});

// node_modules/google-auth-library/build/src/auth/baseexternalclient.js
var require_baseexternalclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/baseexternalclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _BaseExternalAccountClient_instances;
    var _BaseExternalAccountClient_pendingAccessToken;
    var _BaseExternalAccountClient_internalRefreshAccessTokenAsync;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseExternalAccountClient = exports.DEFAULT_UNIVERSE = exports.CLOUD_RESOURCE_MANAGER = exports.EXTERNAL_ACCOUNT_TYPE = exports.EXPIRATION_TIME_OFFSET = void 0;
    var stream = require_stream();
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var util_1 = require_util2();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var DEFAULT_OAUTH_SCOPE = "https://www.googleapis.com/auth/cloud-platform";
    var DEFAULT_TOKEN_LIFESPAN = 3600;
    exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    exports.EXTERNAL_ACCOUNT_TYPE = "external_account";
    exports.CLOUD_RESOURCE_MANAGER = "https://cloudresourcemanager.googleapis.com/v1/projects/";
    var WORKFORCE_AUDIENCE_PATTERN = "//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/[^/]+/providers/.+";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/token";
    var pkg = require_package2();
    var authclient_2 = require_authclient();
    Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return authclient_2.DEFAULT_UNIVERSE;
    }, "get") });
    var BaseExternalAccountClient = class _BaseExternalAccountClient extends authclient_1.AuthClient {
      static {
        __name(this, "BaseExternalAccountClient");
      }
      /**
       * Instantiate a BaseExternalAccountClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        var _a;
        super({ ...options, ...additionalOptions });
        _BaseExternalAccountClient_instances.add(this);
        _BaseExternalAccountClient_pendingAccessToken.set(this, null);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const type2 = opts.get("type");
        if (type2 && type2 !== exports.EXTERNAL_ACCOUNT_TYPE) {
          throw new Error(`Expected "${exports.EXTERNAL_ACCOUNT_TYPE}" type but received "${options.type}"`);
        }
        const clientId = opts.get("client_id");
        const clientSecret = opts.get("client_secret");
        const tokenUrl = (_a = opts.get("token_url")) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain);
        const subjectTokenType = opts.get("subject_token_type");
        const workforcePoolUserProject = opts.get("workforce_pool_user_project");
        const serviceAccountImpersonationUrl = opts.get("service_account_impersonation_url");
        const serviceAccountImpersonation = opts.get("service_account_impersonation");
        const serviceAccountImpersonationLifetime = (0, util_1.originalOrCamelOptions)(serviceAccountImpersonation).get("token_lifetime_seconds");
        this.cloudResourceManagerURL = new URL(opts.get("cloud_resource_manager_url") || `https://cloudresourcemanager.${this.universeDomain}/v1/projects/`);
        if (clientId) {
          this.clientAuth = {
            confidentialClientType: "basic",
            clientId,
            clientSecret
          };
        }
        this.stsCredential = new sts.StsCredentials(tokenUrl, this.clientAuth);
        this.scopes = opts.get("scopes") || [DEFAULT_OAUTH_SCOPE];
        this.cachedAccessToken = null;
        this.audience = opts.get("audience");
        this.subjectTokenType = subjectTokenType;
        this.workforcePoolUserProject = workforcePoolUserProject;
        const workforceAudiencePattern = new RegExp(WORKFORCE_AUDIENCE_PATTERN);
        if (this.workforcePoolUserProject && !this.audience.match(workforceAudiencePattern)) {
          throw new Error("workforcePoolUserProject should not be set for non-workforce pool credentials.");
        }
        this.serviceAccountImpersonationUrl = serviceAccountImpersonationUrl;
        this.serviceAccountImpersonationLifetime = serviceAccountImpersonationLifetime;
        if (this.serviceAccountImpersonationLifetime) {
          this.configLifetimeRequested = true;
        } else {
          this.configLifetimeRequested = false;
          this.serviceAccountImpersonationLifetime = DEFAULT_TOKEN_LIFESPAN;
        }
        this.projectNumber = this.getProjectNumber(this.audience);
        this.supplierContext = {
          audience: this.audience,
          subjectTokenType: this.subjectTokenType,
          transporter: this.transporter
        };
      }
      /** The service account email to be impersonated, if available. */
      getServiceAccountEmail() {
        var _a;
        if (this.serviceAccountImpersonationUrl) {
          if (this.serviceAccountImpersonationUrl.length > 256) {
            throw new RangeError(`URL is too long: ${this.serviceAccountImpersonationUrl}`);
          }
          const re = /serviceAccounts\/(?<email>[^:]+):generateAccessToken$/;
          const result = re.exec(this.serviceAccountImpersonationUrl);
          return ((_a = result === null || result === void 0 ? void 0 : result.groups) === null || _a === void 0 ? void 0 : _a.email) || null;
        }
        return null;
      }
      /**
       * Provides a mechanism to inject GCP access tokens directly.
       * When the provided credential expires, a new credential, using the
       * external account options, is retrieved.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        super.setCredentials(credentials);
        this.cachedAccessToken = credentials;
      }
      /**
       * @return A promise that resolves with the current GCP access token
       *   response. If the current credential is expired, a new one is retrieved.
       */
      async getAccessToken() {
        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedAccessToken.access_token,
          res: this.cachedAccessToken.res
        };
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       */
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r) => callback(null, r), (e) => {
            return callback(e, e.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * @return A promise that resolves with the project ID corresponding to the
       *   current workload identity pool or current workforce pool if
       *   determinable. For workforce pool credential, it returns the project ID
       *   corresponding to the workforcePoolUserProject.
       *   This is introduced to match the current pattern of using the Auth
       *   library:
       *   const projectId = await auth.getProjectId();
       *   const url = `https://dns.googleapis.com/dns/v1/projects/${projectId}`;
       *   const res = await client.request({ url });
       *   The resource may not have permission
       *   (resourcemanager.projects.get) to call this API or the required
       *   scopes may not be selected:
       *   https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes
       */
      async getProjectId() {
        const projectNumber = this.projectNumber || this.workforcePoolUserProject;
        if (this.projectId) {
          return this.projectId;
        } else if (projectNumber) {
          const headers = await this.getRequestHeaders();
          const response = await this.transporter.request({
            ..._BaseExternalAccountClient.RETRY_CONFIG,
            headers,
            url: `${this.cloudResourceManagerURL.toString()}${projectNumber}`,
            responseType: "json"
          });
          this.projectId = response.data.projectId;
          return this.projectId;
        }
        return null;
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e) {
          const res = e.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * External credentials are exchanged for GCP access tokens via the token
       * exchange endpoint and other settings provided in the client options
       * object.
       * If the service_account_impersonation_url is provided, an additional
       * step to exchange the external account GCP access token for a service
       * account impersonated token is performed.
       * @return A promise that resolves with the fresh GCP access tokens.
       */
      async refreshAccessTokenAsync() {
        __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, "f") || __classPrivateFieldGet(this, _BaseExternalAccountClient_instances, "m", _BaseExternalAccountClient_internalRefreshAccessTokenAsync).call(this), "f");
        try {
          return await __classPrivateFieldGet(this, _BaseExternalAccountClient_pendingAccessToken, "f");
        } finally {
          __classPrivateFieldSet(this, _BaseExternalAccountClient_pendingAccessToken, null, "f");
        }
      }
      /**
       * Returns the workload identity pool project number if it is determinable
       * from the audience resource name.
       * @param audience The STS audience used to determine the project number.
       * @return The project number associated with the workload identity pool, if
       *   this can be determined from the STS audience field. Otherwise, null is
       *   returned.
       */
      getProjectNumber(audience) {
        const match = audience.match(/\/projects\/([^/]+)/);
        if (!match) {
          return null;
        }
        return match[1];
      }
      /**
       * Exchanges an external account GCP access token for a service
       * account impersonated access token using iamcredentials
       * GenerateAccessToken API.
       * @param token The access token to exchange for a service account access
       *   token.
       * @return A promise that resolves with the service account impersonated
       *   credentials response.
       */
      async getImpersonatedAccessToken(token) {
        const opts = {
          ..._BaseExternalAccountClient.RETRY_CONFIG,
          url: this.serviceAccountImpersonationUrl,
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`
          },
          data: {
            scope: this.getScopesArray(),
            lifetime: this.serviceAccountImpersonationLifetime + "s"
          },
          responseType: "json"
        };
        const response = await this.transporter.request(opts);
        const successResponse = response.data;
        return {
          access_token: successResponse.accessToken,
          // Convert from ISO format to timestamp.
          expiry_date: new Date(successResponse.expireTime).getTime(),
          res: response
        };
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param accessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(accessToken) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return accessToken.expiry_date ? now >= accessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
      /**
       * @return The list of scopes for the requested GCP access token.
       */
      getScopesArray() {
        if (typeof this.scopes === "string") {
          return [this.scopes];
        }
        return this.scopes || [DEFAULT_OAUTH_SCOPE];
      }
      getMetricsHeaderValue() {
        const nodeVersion = process.version.replace(/^v/, "");
        const saImpersonation = this.serviceAccountImpersonationUrl !== void 0;
        const credentialSourceType = this.credentialSourceType ? this.credentialSourceType : "unknown";
        return `gl-node/${nodeVersion} auth/${pkg.version} google-byoid-sdk source/${credentialSourceType} sa-impersonation/${saImpersonation} config-lifetime/${this.configLifetimeRequested}`;
      }
    };
    exports.BaseExternalAccountClient = BaseExternalAccountClient;
    _BaseExternalAccountClient_pendingAccessToken = /* @__PURE__ */ new WeakMap(), _BaseExternalAccountClient_instances = /* @__PURE__ */ new WeakSet(), _BaseExternalAccountClient_internalRefreshAccessTokenAsync = /* @__PURE__ */ __name(async function _BaseExternalAccountClient_internalRefreshAccessTokenAsync2() {
      const subjectToken = await this.retrieveSubjectToken();
      const stsCredentialsOptions = {
        grantType: STS_GRANT_TYPE,
        audience: this.audience,
        requestedTokenType: STS_REQUEST_TOKEN_TYPE,
        subjectToken,
        subjectTokenType: this.subjectTokenType,
        // generateAccessToken requires the provided access token to have
        // scopes:
        // https://www.googleapis.com/auth/iam or
        // https://www.googleapis.com/auth/cloud-platform
        // The new service account access token scopes will match the user
        // provided ones.
        scope: this.serviceAccountImpersonationUrl ? [DEFAULT_OAUTH_SCOPE] : this.getScopesArray()
      };
      const additionalOptions = !this.clientAuth && this.workforcePoolUserProject ? { userProject: this.workforcePoolUserProject } : void 0;
      const additionalHeaders = {
        "x-goog-api-client": this.getMetricsHeaderValue()
      };
      const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, additionalHeaders, additionalOptions);
      if (this.serviceAccountImpersonationUrl) {
        this.cachedAccessToken = await this.getImpersonatedAccessToken(stsResponse.access_token);
      } else if (stsResponse.expires_in) {
        this.cachedAccessToken = {
          access_token: stsResponse.access_token,
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3,
          res: stsResponse.res
        };
      } else {
        this.cachedAccessToken = {
          access_token: stsResponse.access_token,
          res: stsResponse.res
        };
      }
      this.credentials = {};
      Object.assign(this.credentials, this.cachedAccessToken);
      delete this.credentials.res;
      this.emit("tokens", {
        refresh_token: null,
        expiry_date: this.cachedAccessToken.expiry_date,
        access_token: this.cachedAccessToken.access_token,
        token_type: "Bearer",
        id_token: null
      });
      return this.cachedAccessToken;
    }, "_BaseExternalAccountClient_internalRefreshAccessTokenAsync");
  }
});

// node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js
var require_filesubjecttokensupplier = __commonJS({
  "node_modules/google-auth-library/build/src/auth/filesubjecttokensupplier.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var _a;
    var _b;
    var _c;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileSubjectTokenSupplier = void 0;
    var util_1 = require_util3();
    var fs = require_fs();
    var readFile3 = (0, util_1.promisify)((_a = fs.readFile) !== null && _a !== void 0 ? _a : () => {
    });
    var realpath3 = (0, util_1.promisify)((_b = fs.realpath) !== null && _b !== void 0 ? _b : () => {
    });
    var lstat3 = (0, util_1.promisify)((_c = fs.lstat) !== null && _c !== void 0 ? _c : () => {
    });
    var FileSubjectTokenSupplier = class {
      static {
        __name(this, "FileSubjectTokenSupplier");
      }
      /**
       * Instantiates a new file based subject token supplier.
       * @param opts The file subject token supplier options to build the supplier
       *   with.
       */
      constructor(opts) {
        this.filePath = opts.filePath;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
      }
      /**
       * Returns the subject token stored at the file specified in the constructor.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      async getSubjectToken(context2) {
        let parsedFilePath = this.filePath;
        try {
          parsedFilePath = await realpath3(parsedFilePath);
          if (!(await lstat3(parsedFilePath)).isFile()) {
            throw new Error();
          }
        } catch (err) {
          if (err instanceof Error) {
            err.message = `The file at ${parsedFilePath} does not exist, or it is not a file. ${err.message}`;
          }
          throw err;
        }
        let subjectToken;
        const rawText = await readFile3(parsedFilePath, { encoding: "utf8" });
        if (this.formatType === "text") {
          subjectToken = rawText;
        } else if (this.formatType === "json" && this.subjectTokenFieldName) {
          const json = JSON.parse(rawText);
          subjectToken = json[this.subjectTokenFieldName];
        }
        if (!subjectToken) {
          throw new Error("Unable to parse the subject_token from the credential_source file");
        }
        return subjectToken;
      }
    };
    exports.FileSubjectTokenSupplier = FileSubjectTokenSupplier;
  }
});

// node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js
var require_urlsubjecttokensupplier = __commonJS({
  "node_modules/google-auth-library/build/src/auth/urlsubjecttokensupplier.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UrlSubjectTokenSupplier = void 0;
    var UrlSubjectTokenSupplier = class {
      static {
        __name(this, "UrlSubjectTokenSupplier");
      }
      /**
       * Instantiates a URL subject token supplier.
       * @param opts The URL subject token supplier options to build the supplier with.
       */
      constructor(opts) {
        this.url = opts.url;
        this.formatType = opts.formatType;
        this.subjectTokenFieldName = opts.subjectTokenFieldName;
        this.headers = opts.headers;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Sends a GET request to the URL provided in the constructor and resolves
       * with the returned external subject token.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link IdentityPoolClient}, contains the requested audience and subject
       *   token type for the external account identity. Not used.
       */
      async getSubjectToken(context2) {
        const opts = {
          ...this.additionalGaxiosOptions,
          url: this.url,
          method: "GET",
          headers: this.headers,
          responseType: this.formatType
        };
        let subjectToken;
        if (this.formatType === "text") {
          const response = await context2.transporter.request(opts);
          subjectToken = response.data;
        } else if (this.formatType === "json" && this.subjectTokenFieldName) {
          const response = await context2.transporter.request(opts);
          subjectToken = response.data[this.subjectTokenFieldName];
        }
        if (!subjectToken) {
          throw new Error("Unable to parse the subject_token from the credential_source URL");
        }
        return subjectToken;
      }
    };
    exports.UrlSubjectTokenSupplier = UrlSubjectTokenSupplier;
  }
});

// node_modules/google-auth-library/build/src/auth/identitypoolclient.js
var require_identitypoolclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/identitypoolclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdentityPoolClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var util_1 = require_util2();
    var filesubjecttokensupplier_1 = require_filesubjecttokensupplier();
    var urlsubjecttokensupplier_1 = require_urlsubjecttokensupplier();
    var IdentityPoolClient = class _IdentityPoolClient extends baseexternalclient_1.BaseExternalAccountClient {
      static {
        __name(this, "IdentityPoolClient");
      }
      /**
       * Instantiate an IdentityPoolClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid file-sourced or
       * url-sourced credential or a workforce pool user project is provided
       * with a non workforce audience.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file. The camelCased options
       *   are aliases for the snake_cased options.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const subjectTokenSupplier = opts.get("subject_token_supplier");
        if (!credentialSource && !subjectTokenSupplier) {
          throw new Error("A credential source or subject token supplier must be specified.");
        }
        if (credentialSource && subjectTokenSupplier) {
          throw new Error("Only one of credential source or subject token supplier can be specified.");
        }
        if (subjectTokenSupplier) {
          this.subjectTokenSupplier = subjectTokenSupplier;
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          const formatOpts = (0, util_1.originalOrCamelOptions)(credentialSourceOpts.get("format"));
          const formatType = formatOpts.get("type") || "text";
          const formatSubjectTokenFieldName = formatOpts.get("subject_token_field_name");
          if (formatType !== "json" && formatType !== "text") {
            throw new Error(`Invalid credential_source format "${formatType}"`);
          }
          if (formatType === "json" && !formatSubjectTokenFieldName) {
            throw new Error("Missing subject_token_field_name for JSON credential_source format");
          }
          const file = credentialSourceOpts.get("file");
          const url = credentialSourceOpts.get("url");
          const headers = credentialSourceOpts.get("headers");
          if (file && url) {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
          } else if (file && !url) {
            this.credentialSourceType = "file";
            this.subjectTokenSupplier = new filesubjecttokensupplier_1.FileSubjectTokenSupplier({
              filePath: file,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName
            });
          } else if (!file && url) {
            this.credentialSourceType = "url";
            this.subjectTokenSupplier = new urlsubjecttokensupplier_1.UrlSubjectTokenSupplier({
              url,
              formatType,
              subjectTokenFieldName: formatSubjectTokenFieldName,
              headers,
              additionalGaxiosOptions: _IdentityPoolClient.RETRY_CONFIG
            });
          } else {
            throw new Error('No valid Identity Pool "credential_source" provided, must be either file or url.');
          }
        }
      }
      /**
       * Triggered when a external subject token is needed to be exchanged for a GCP
       * access token via GCP STS endpoint. Gets a subject token by calling
       * the configured {@link SubjectTokenSupplier}
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        return this.subjectTokenSupplier.getSubjectToken(this.supplierContext);
      }
    };
    exports.IdentityPoolClient = IdentityPoolClient;
  }
});

// node_modules/google-auth-library/build/src/auth/awsrequestsigner.js
var require_awsrequestsigner = __commonJS({
  "node_modules/google-auth-library/build/src/auth/awsrequestsigner.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsRequestSigner = void 0;
    var crypto_1 = require_crypto4();
    var AWS_ALGORITHM = "AWS4-HMAC-SHA256";
    var AWS_REQUEST_TYPE = "aws4_request";
    var AwsRequestSigner = class {
      static {
        __name(this, "AwsRequestSigner");
      }
      /**
       * Instantiates an AWS API request signer used to send authenticated signed
       * requests to AWS APIs based on the AWS Signature Version 4 signing process.
       * This also provides a mechanism to generate the signed request without
       * sending it.
       * @param getCredentials A mechanism to retrieve AWS security credentials
       *   when needed.
       * @param region The AWS region to use.
       */
      constructor(getCredentials, region) {
        this.getCredentials = getCredentials;
        this.region = region;
        this.crypto = (0, crypto_1.createCrypto)();
      }
      /**
       * Generates the signed request for the provided HTTP request for calling
       * an AWS API. This follows the steps described at:
       * https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html
       * @param amzOptions The AWS request options that need to be signed.
       * @return A promise that resolves with the GaxiosOptions containing the
       *   signed HTTP request parameters.
       */
      async getRequestOptions(amzOptions) {
        if (!amzOptions.url) {
          throw new Error('"url" is required in "amzOptions"');
        }
        const requestPayloadData = typeof amzOptions.data === "object" ? JSON.stringify(amzOptions.data) : amzOptions.data;
        const url = amzOptions.url;
        const method = amzOptions.method || "GET";
        const requestPayload = amzOptions.body || requestPayloadData;
        const additionalAmzHeaders = amzOptions.headers;
        const awsSecurityCredentials = await this.getCredentials();
        const uri = new URL(url);
        const headerMap = await generateAuthenticationHeaderMap({
          crypto: this.crypto,
          host: uri.host,
          canonicalUri: uri.pathname,
          canonicalQuerystring: uri.search.substr(1),
          method,
          region: this.region,
          securityCredentials: awsSecurityCredentials,
          requestPayload,
          additionalAmzHeaders
        });
        const headers = Object.assign(
          // Add x-amz-date if available.
          headerMap.amzDate ? { "x-amz-date": headerMap.amzDate } : {},
          {
            Authorization: headerMap.authorizationHeader,
            host: uri.host
          },
          additionalAmzHeaders || {}
        );
        if (awsSecurityCredentials.token) {
          Object.assign(headers, {
            "x-amz-security-token": awsSecurityCredentials.token
          });
        }
        const awsSignedReq = {
          url,
          method,
          headers
        };
        if (typeof requestPayload !== "undefined") {
          awsSignedReq.body = requestPayload;
        }
        return awsSignedReq;
      }
    };
    exports.AwsRequestSigner = AwsRequestSigner;
    async function sign3(crypto2, key, msg) {
      return await crypto2.signWithHmacSha256(key, msg);
    }
    __name(sign3, "sign");
    async function getSigningKey(crypto2, key, dateStamp, region, serviceName) {
      const kDate = await sign3(crypto2, `AWS4${key}`, dateStamp);
      const kRegion = await sign3(crypto2, kDate, region);
      const kService = await sign3(crypto2, kRegion, serviceName);
      const kSigning = await sign3(crypto2, kService, "aws4_request");
      return kSigning;
    }
    __name(getSigningKey, "getSigningKey");
    async function generateAuthenticationHeaderMap(options) {
      const additionalAmzHeaders = options.additionalAmzHeaders || {};
      const requestPayload = options.requestPayload || "";
      const serviceName = options.host.split(".")[0];
      const now = /* @__PURE__ */ new Date();
      const amzDate = now.toISOString().replace(/[-:]/g, "").replace(/\.[0-9]+/, "");
      const dateStamp = now.toISOString().replace(/[-]/g, "").replace(/T.*/, "");
      const reformattedAdditionalAmzHeaders = {};
      Object.keys(additionalAmzHeaders).forEach((key) => {
        reformattedAdditionalAmzHeaders[key.toLowerCase()] = additionalAmzHeaders[key];
      });
      if (options.securityCredentials.token) {
        reformattedAdditionalAmzHeaders["x-amz-security-token"] = options.securityCredentials.token;
      }
      const amzHeaders = Object.assign(
        {
          host: options.host
        },
        // Previously the date was not fixed with x-amz- and could be provided manually.
        // https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req
        reformattedAdditionalAmzHeaders.date ? {} : { "x-amz-date": amzDate },
        reformattedAdditionalAmzHeaders
      );
      let canonicalHeaders = "";
      const signedHeadersList = Object.keys(amzHeaders).sort();
      signedHeadersList.forEach((key) => {
        canonicalHeaders += `${key}:${amzHeaders[key]}
`;
      });
      const signedHeaders = signedHeadersList.join(";");
      const payloadHash = await options.crypto.sha256DigestHex(requestPayload);
      const canonicalRequest = `${options.method}
${options.canonicalUri}
${options.canonicalQuerystring}
${canonicalHeaders}
${signedHeaders}
${payloadHash}`;
      const credentialScope = `${dateStamp}/${options.region}/${serviceName}/${AWS_REQUEST_TYPE}`;
      const stringToSign = `${AWS_ALGORITHM}
${amzDate}
${credentialScope}
` + await options.crypto.sha256DigestHex(canonicalRequest);
      const signingKey = await getSigningKey(options.crypto, options.securityCredentials.secretAccessKey, dateStamp, options.region, serviceName);
      const signature = await sign3(options.crypto, signingKey, stringToSign);
      const authorizationHeader = `${AWS_ALGORITHM} Credential=${options.securityCredentials.accessKeyId}/${credentialScope}, SignedHeaders=${signedHeaders}, Signature=${(0, crypto_1.fromArrayBufferToHex)(signature)}`;
      return {
        // Do not return x-amz-date if date is available.
        amzDate: reformattedAdditionalAmzHeaders.date ? void 0 : amzDate,
        authorizationHeader,
        canonicalQuerystring: options.canonicalQuerystring
      };
    }
    __name(generateAuthenticationHeaderMap, "generateAuthenticationHeaderMap");
  }
});

// node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js
var require_defaultawssecuritycredentialssupplier = __commonJS({
  "node_modules/google-auth-library/build/src/auth/defaultawssecuritycredentialssupplier.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _DefaultAwsSecurityCredentialsSupplier_instances;
    var _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken;
    var _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName;
    var _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials;
    var _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get;
    var _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DefaultAwsSecurityCredentialsSupplier = void 0;
    var DefaultAwsSecurityCredentialsSupplier = class {
      static {
        __name(this, "DefaultAwsSecurityCredentialsSupplier");
      }
      /**
       * Instantiates a new DefaultAwsSecurityCredentialsSupplier using information
       * from the credential_source stored in the ADC file.
       * @param opts The default aws security credentials supplier options object to
       *   build the supplier with.
       */
      constructor(opts) {
        _DefaultAwsSecurityCredentialsSupplier_instances.add(this);
        this.regionUrl = opts.regionUrl;
        this.securityCredentialsUrl = opts.securityCredentialsUrl;
        this.imdsV2SessionTokenUrl = opts.imdsV2SessionTokenUrl;
        this.additionalGaxiosOptions = opts.additionalGaxiosOptions;
      }
      /**
       * Returns the active AWS region. This first checks to see if the region
       * is available as an environment variable. If it is not, then the supplier
       * will call the region URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS region string.
       */
      async getAwsRegion(context2) {
        if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get)) {
          return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get);
        }
        const metadataHeaders = {};
        if (!__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get) && this.imdsV2SessionTokenUrl) {
          metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context2.transporter);
        }
        if (!this.regionUrl) {
          throw new Error('Unable to determine AWS region due to missing "options.credential_source.region_url"');
        }
        const opts = {
          ...this.additionalGaxiosOptions,
          url: this.regionUrl,
          method: "GET",
          responseType: "text",
          headers: metadataHeaders
        };
        const response = await context2.transporter.request(opts);
        return response.data.substr(0, response.data.length - 1);
      }
      /**
       * Returns AWS security credentials. This first checks to see if the credentials
       * is available as environment variables. If it is not, then the supplier
       * will call the security credentials URL.
       * @param context {@link ExternalAccountSupplierContext} from the calling
       *   {@link AwsClient}, contains the requested audience and subject token type
       *   for the external account identity.
       * @return A promise that resolves with the AWS security credentials.
       */
      async getAwsSecurityCredentials(context2) {
        if (__classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get)) {
          return __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "a", _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get);
        }
        const metadataHeaders = {};
        if (this.imdsV2SessionTokenUrl) {
          metadataHeaders["x-aws-ec2-metadata-token"] = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken).call(this, context2.transporter);
        }
        const roleName = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName).call(this, metadataHeaders, context2.transporter);
        const awsCreds = await __classPrivateFieldGet(this, _DefaultAwsSecurityCredentialsSupplier_instances, "m", _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials).call(this, roleName, metadataHeaders, context2.transporter);
        return {
          accessKeyId: awsCreds.AccessKeyId,
          secretAccessKey: awsCreds.SecretAccessKey,
          token: awsCreds.Token
        };
      }
    };
    exports.DefaultAwsSecurityCredentialsSupplier = DefaultAwsSecurityCredentialsSupplier;
    _DefaultAwsSecurityCredentialsSupplier_instances = /* @__PURE__ */ new WeakSet(), _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken = /**
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the IMDSv2 Session Token.
     */
    /* @__PURE__ */ __name(async function _DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken2(transporter) {
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.imdsV2SessionTokenUrl,
        method: "PUT",
        responseType: "text",
        headers: { "x-aws-ec2-metadata-token-ttl-seconds": "300" }
      };
      const response = await transporter.request(opts);
      return response.data;
    }, "_DefaultAwsSecurityCredentialsSupplier_getImdsV2SessionToken"), _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName = /**
     * @param headers The headers to be used in the metadata request.
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the assigned role to the current
     *   AWS VM. This is needed for calling the security-credentials endpoint.
     */
    /* @__PURE__ */ __name(async function _DefaultAwsSecurityCredentialsSupplier_getAwsRoleName2(headers, transporter) {
      if (!this.securityCredentialsUrl) {
        throw new Error('Unable to determine AWS role name due to missing "options.credential_source.url"');
      }
      const opts = {
        ...this.additionalGaxiosOptions,
        url: this.securityCredentialsUrl,
        method: "GET",
        responseType: "text",
        headers
      };
      const response = await transporter.request(opts);
      return response.data;
    }, "_DefaultAwsSecurityCredentialsSupplier_getAwsRoleName"), _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials = /**
     * Retrieves the temporary AWS credentials by calling the security-credentials
     * endpoint as specified in the `credential_source` object.
     * @param roleName The role attached to the current VM.
     * @param headers The headers to be used in the metadata request.
     * @param transporter The transporter to use for requests.
     * @return A promise that resolves with the temporary AWS credentials
     *   needed for creating the GetCallerIdentity signed request.
     */
    /* @__PURE__ */ __name(async function _DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials2(roleName, headers, transporter) {
      const response = await transporter.request({
        ...this.additionalGaxiosOptions,
        url: `${this.securityCredentialsUrl}/${roleName}`,
        responseType: "json",
        headers
      });
      return response.data;
    }, "_DefaultAwsSecurityCredentialsSupplier_retrieveAwsSecurityCredentials"), _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get = /* @__PURE__ */ __name(function _DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get2() {
      return process.env["AWS_REGION"] || process.env["AWS_DEFAULT_REGION"] || null;
    }, "_DefaultAwsSecurityCredentialsSupplier_regionFromEnv_get"), _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get = /* @__PURE__ */ __name(function _DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get2() {
      if (process.env["AWS_ACCESS_KEY_ID"] && process.env["AWS_SECRET_ACCESS_KEY"]) {
        return {
          accessKeyId: process.env["AWS_ACCESS_KEY_ID"],
          secretAccessKey: process.env["AWS_SECRET_ACCESS_KEY"],
          token: process.env["AWS_SESSION_TOKEN"]
        };
      }
      return null;
    }, "_DefaultAwsSecurityCredentialsSupplier_securityCredentialsFromEnv_get");
  }
});

// node_modules/google-auth-library/build/src/auth/awsclient.js
var require_awsclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/awsclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var _a;
    var _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AwsClient = void 0;
    var awsrequestsigner_1 = require_awsrequestsigner();
    var baseexternalclient_1 = require_baseexternalclient();
    var defaultawssecuritycredentialssupplier_1 = require_defaultawssecuritycredentialssupplier();
    var util_1 = require_util2();
    var AwsClient = class extends baseexternalclient_1.BaseExternalAccountClient {
      static {
        __name(this, "AwsClient");
      }
      /**
       * Instantiates an AwsClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid AWS credential.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        const opts = (0, util_1.originalOrCamelOptions)(options);
        const credentialSource = opts.get("credential_source");
        const awsSecurityCredentialsSupplier = opts.get("aws_security_credentials_supplier");
        if (!credentialSource && !awsSecurityCredentialsSupplier) {
          throw new Error("A credential source or AWS security credentials supplier must be specified.");
        }
        if (credentialSource && awsSecurityCredentialsSupplier) {
          throw new Error("Only one of credential source or AWS security credentials supplier can be specified.");
        }
        if (awsSecurityCredentialsSupplier) {
          this.awsSecurityCredentialsSupplier = awsSecurityCredentialsSupplier;
          this.regionalCredVerificationUrl = __classPrivateFieldGet(_a, _a, "f", _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL);
          this.credentialSourceType = "programmatic";
        } else {
          const credentialSourceOpts = (0, util_1.originalOrCamelOptions)(credentialSource);
          this.environmentId = credentialSourceOpts.get("environment_id");
          const regionUrl = credentialSourceOpts.get("region_url");
          const securityCredentialsUrl = credentialSourceOpts.get("url");
          const imdsV2SessionTokenUrl = credentialSourceOpts.get("imdsv2_session_token_url");
          this.awsSecurityCredentialsSupplier = new defaultawssecuritycredentialssupplier_1.DefaultAwsSecurityCredentialsSupplier({
            regionUrl,
            securityCredentialsUrl,
            imdsV2SessionTokenUrl
          });
          this.regionalCredVerificationUrl = credentialSourceOpts.get("regional_cred_verification_url");
          this.credentialSourceType = "aws";
          this.validateEnvironmentId();
        }
        this.awsRequestSigner = null;
        this.region = "";
      }
      validateEnvironmentId() {
        var _b;
        const match = (_b = this.environmentId) === null || _b === void 0 ? void 0 : _b.match(/^(aws)(\d+)$/);
        if (!match || !this.regionalCredVerificationUrl) {
          throw new Error('No valid AWS "credential_source" provided');
        } else if (parseInt(match[2], 10) !== 1) {
          throw new Error(`aws version "${match[2]}" is not supported in the current build.`);
        }
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint. This will call the
       * {@link AwsSecurityCredentialsSupplier} to retrieve an AWS region and AWS
       * Security Credentials, then use them to create a signed AWS STS request that
       * can be exchanged for a GCP access token.
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        if (!this.awsRequestSigner) {
          this.region = await this.awsSecurityCredentialsSupplier.getAwsRegion(this.supplierContext);
          this.awsRequestSigner = new awsrequestsigner_1.AwsRequestSigner(async () => {
            return this.awsSecurityCredentialsSupplier.getAwsSecurityCredentials(this.supplierContext);
          }, this.region);
        }
        const options = await this.awsRequestSigner.getRequestOptions({
          ..._a.RETRY_CONFIG,
          url: this.regionalCredVerificationUrl.replace("{region}", this.region),
          method: "POST"
        });
        const reformattedHeader = [];
        const extendedHeaders = Object.assign({
          // The full, canonical resource name of the workload identity pool
          // provider, with or without the HTTPS prefix.
          // Including this header as part of the signature is recommended to
          // ensure data integrity.
          "x-goog-cloud-target-resource": this.audience
        }, options.headers);
        for (const key in extendedHeaders) {
          reformattedHeader.push({
            key,
            value: extendedHeaders[key]
          });
        }
        return encodeURIComponent(JSON.stringify({
          url: options.url,
          method: options.method,
          headers: reformattedHeader
        }));
      }
    };
    exports.AwsClient = AwsClient;
    _a = AwsClient;
    _AwsClient_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = { value: "https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15" };
    AwsClient.AWS_EC2_METADATA_IPV4_ADDRESS = "169.254.169.254";
    AwsClient.AWS_EC2_METADATA_IPV6_ADDRESS = "fd00:ec2::254";
  }
});

// node_modules/google-auth-library/build/src/auth/executable-response.js
var require_executable_response = __commonJS({
  "node_modules/google-auth-library/build/src/auth/executable-response.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InvalidSubjectTokenError = exports.InvalidMessageFieldError = exports.InvalidCodeFieldError = exports.InvalidTokenTypeFieldError = exports.InvalidExpirationTimeFieldError = exports.InvalidSuccessFieldError = exports.InvalidVersionFieldError = exports.ExecutableResponseError = exports.ExecutableResponse = void 0;
    var SAML_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:saml2";
    var OIDC_SUBJECT_TOKEN_TYPE1 = "urn:ietf:params:oauth:token-type:id_token";
    var OIDC_SUBJECT_TOKEN_TYPE2 = "urn:ietf:params:oauth:token-type:jwt";
    var ExecutableResponse = class {
      static {
        __name(this, "ExecutableResponse");
      }
      /**
       * Instantiates an ExecutableResponse instance using the provided JSON object
       * from the output of the executable.
       * @param responseJson Response from a 3rd party executable, loaded from a
       * run of the executable or a cached output file.
       */
      constructor(responseJson) {
        if (!responseJson.version) {
          throw new InvalidVersionFieldError("Executable response must contain a 'version' field.");
        }
        if (responseJson.success === void 0) {
          throw new InvalidSuccessFieldError("Executable response must contain a 'success' field.");
        }
        this.version = responseJson.version;
        this.success = responseJson.success;
        if (this.success) {
          this.expirationTime = responseJson.expiration_time;
          this.tokenType = responseJson.token_type;
          if (this.tokenType !== SAML_SUBJECT_TOKEN_TYPE && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE1 && this.tokenType !== OIDC_SUBJECT_TOKEN_TYPE2) {
            throw new InvalidTokenTypeFieldError(`Executable response must contain a 'token_type' field when successful and it must be one of ${OIDC_SUBJECT_TOKEN_TYPE1}, ${OIDC_SUBJECT_TOKEN_TYPE2}, or ${SAML_SUBJECT_TOKEN_TYPE}.`);
          }
          if (this.tokenType === SAML_SUBJECT_TOKEN_TYPE) {
            if (!responseJson.saml_response) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'saml_response' field when token_type=${SAML_SUBJECT_TOKEN_TYPE}.`);
            }
            this.subjectToken = responseJson.saml_response;
          } else {
            if (!responseJson.id_token) {
              throw new InvalidSubjectTokenError(`Executable response must contain a 'id_token' field when token_type=${OIDC_SUBJECT_TOKEN_TYPE1} or ${OIDC_SUBJECT_TOKEN_TYPE2}.`);
            }
            this.subjectToken = responseJson.id_token;
          }
        } else {
          if (!responseJson.code) {
            throw new InvalidCodeFieldError("Executable response must contain a 'code' field when unsuccessful.");
          }
          if (!responseJson.message) {
            throw new InvalidMessageFieldError("Executable response must contain a 'message' field when unsuccessful.");
          }
          this.errorCode = responseJson.code;
          this.errorMessage = responseJson.message;
        }
      }
      /**
       * @return A boolean representing if the response has a valid token. Returns
       * true when the response was successful and the token is not expired.
       */
      isValid() {
        return !this.isExpired() && this.success;
      }
      /**
       * @return A boolean representing if the response is expired. Returns true if the
       * provided timeout has passed.
       */
      isExpired() {
        return this.expirationTime !== void 0 && this.expirationTime < Math.round(Date.now() / 1e3);
      }
    };
    exports.ExecutableResponse = ExecutableResponse;
    var ExecutableResponseError = class extends Error {
      static {
        __name(this, "ExecutableResponseError");
      }
      constructor(message2) {
        super(message2);
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.ExecutableResponseError = ExecutableResponseError;
    var InvalidVersionFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidVersionFieldError");
      }
    };
    exports.InvalidVersionFieldError = InvalidVersionFieldError;
    var InvalidSuccessFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidSuccessFieldError");
      }
    };
    exports.InvalidSuccessFieldError = InvalidSuccessFieldError;
    var InvalidExpirationTimeFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidExpirationTimeFieldError");
      }
    };
    exports.InvalidExpirationTimeFieldError = InvalidExpirationTimeFieldError;
    var InvalidTokenTypeFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidTokenTypeFieldError");
      }
    };
    exports.InvalidTokenTypeFieldError = InvalidTokenTypeFieldError;
    var InvalidCodeFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidCodeFieldError");
      }
    };
    exports.InvalidCodeFieldError = InvalidCodeFieldError;
    var InvalidMessageFieldError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidMessageFieldError");
      }
    };
    exports.InvalidMessageFieldError = InvalidMessageFieldError;
    var InvalidSubjectTokenError = class extends ExecutableResponseError {
      static {
        __name(this, "InvalidSubjectTokenError");
      }
    };
    exports.InvalidSubjectTokenError = InvalidSubjectTokenError;
  }
});

// node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js
var require_pluggable_auth_handler = __commonJS({
  "node_modules/google-auth-library/build/src/auth/pluggable-auth-handler.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PluggableAuthHandler = void 0;
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    var executable_response_1 = require_executable_response();
    var childProcess = require_child_process();
    var fs = require_fs();
    var PluggableAuthHandler = class _PluggableAuthHandler {
      static {
        __name(this, "PluggableAuthHandler");
      }
      /**
       * Instantiates a PluggableAuthHandler instance using the provided
       * PluggableAuthHandlerOptions object.
       */
      constructor(options) {
        if (!options.command) {
          throw new Error("No command provided.");
        }
        this.commandComponents = _PluggableAuthHandler.parseCommand(options.command);
        this.timeoutMillis = options.timeoutMillis;
        if (!this.timeoutMillis) {
          throw new Error("No timeoutMillis provided.");
        }
        this.outputFile = options.outputFile;
      }
      /**
       * Calls user provided executable to get a 3rd party subject token and
       * returns the response.
       * @param envMap a Map of additional Environment Variables required for
       *   the executable.
       * @return A promise that resolves with the executable response.
       */
      retrieveResponseFromExecutable(envMap) {
        return new Promise((resolve, reject) => {
          const child = childProcess.spawn(this.commandComponents[0], this.commandComponents.slice(1), {
            env: { ...process.env, ...Object.fromEntries(envMap) }
          });
          let output = "";
          child.stdout.on("data", (data) => {
            output += data;
          });
          child.stderr.on("data", (err) => {
            output += err;
          });
          const timeout = setTimeout(() => {
            child.removeAllListeners();
            child.kill();
            return reject(new Error("The executable failed to finish within the timeout specified."));
          }, this.timeoutMillis);
          child.on("close", (code) => {
            clearTimeout(timeout);
            if (code === 0) {
              try {
                const responseJson = JSON.parse(output);
                const response = new executable_response_1.ExecutableResponse(responseJson);
                return resolve(response);
              } catch (error3) {
                if (error3 instanceof executable_response_1.ExecutableResponseError) {
                  return reject(error3);
                }
                return reject(new executable_response_1.ExecutableResponseError(`The executable returned an invalid response: ${output}`));
              }
            } else {
              return reject(new pluggable_auth_client_1.ExecutableError(output, code.toString()));
            }
          });
        });
      }
      /**
       * Checks user provided output file for response from previous run of
       * executable and return the response if it exists, is formatted correctly, and is not expired.
       */
      async retrieveCachedResponse() {
        if (!this.outputFile || this.outputFile.length === 0) {
          return void 0;
        }
        let filePath;
        try {
          filePath = await fs.promises.realpath(this.outputFile);
        } catch (_a) {
          return void 0;
        }
        if (!(await fs.promises.lstat(filePath)).isFile()) {
          return void 0;
        }
        const responseString = await fs.promises.readFile(filePath, {
          encoding: "utf8"
        });
        if (responseString === "") {
          return void 0;
        }
        try {
          const responseJson = JSON.parse(responseString);
          const response = new executable_response_1.ExecutableResponse(responseJson);
          if (response.isValid()) {
            return new executable_response_1.ExecutableResponse(responseJson);
          }
          return void 0;
        } catch (error3) {
          if (error3 instanceof executable_response_1.ExecutableResponseError) {
            throw error3;
          }
          throw new executable_response_1.ExecutableResponseError(`The output file contained an invalid response: ${responseString}`);
        }
      }
      /**
       * Parses given command string into component array, splitting on spaces unless
       * spaces are between quotation marks.
       */
      static parseCommand(command) {
        const components = command.match(/(?:[^\s"]+|"[^"]*")+/g);
        if (!components) {
          throw new Error(`Provided command: "${command}" could not be parsed.`);
        }
        for (let i = 0; i < components.length; i++) {
          if (components[i][0] === '"' && components[i].slice(-1) === '"') {
            components[i] = components[i].slice(1, -1);
          }
        }
        return components;
      }
    };
    exports.PluggableAuthHandler = PluggableAuthHandler;
  }
});

// node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js
var require_pluggable_auth_client = __commonJS({
  "node_modules/google-auth-library/build/src/auth/pluggable-auth-client.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PluggableAuthClient = exports.ExecutableError = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var executable_response_1 = require_executable_response();
    var pluggable_auth_handler_1 = require_pluggable_auth_handler();
    var ExecutableError = class extends Error {
      static {
        __name(this, "ExecutableError");
      }
      constructor(message2, code) {
        super(`The executable failed with exit code: ${code} and error message: ${message2}.`);
        this.code = code;
        Object.setPrototypeOf(this, new.target.prototype);
      }
    };
    exports.ExecutableError = ExecutableError;
    var DEFAULT_EXECUTABLE_TIMEOUT_MILLIS = 30 * 1e3;
    var MINIMUM_EXECUTABLE_TIMEOUT_MILLIS = 5 * 1e3;
    var MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS = 120 * 1e3;
    var GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES = "GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES";
    var MAXIMUM_EXECUTABLE_VERSION = 1;
    var PluggableAuthClient = class extends baseexternalclient_1.BaseExternalAccountClient {
      static {
        __name(this, "PluggableAuthClient");
      }
      /**
       * Instantiates a PluggableAuthClient instance using the provided JSON
       * object loaded from an external account credentials file.
       * An error is thrown if the credential is not a valid pluggable auth credential.
       * @param options The external account options object typically loaded from
       *   the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        super(options, additionalOptions);
        if (!options.credential_source.executable) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        this.command = options.credential_source.executable.command;
        if (!this.command) {
          throw new Error('No valid Pluggable Auth "credential_source" provided.');
        }
        if (options.credential_source.executable.timeout_millis === void 0) {
          this.timeoutMillis = DEFAULT_EXECUTABLE_TIMEOUT_MILLIS;
        } else {
          this.timeoutMillis = options.credential_source.executable.timeout_millis;
          if (this.timeoutMillis < MINIMUM_EXECUTABLE_TIMEOUT_MILLIS || this.timeoutMillis > MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS) {
            throw new Error(`Timeout must be between ${MINIMUM_EXECUTABLE_TIMEOUT_MILLIS} and ${MAXIMUM_EXECUTABLE_TIMEOUT_MILLIS} milliseconds.`);
          }
        }
        this.outputFile = options.credential_source.executable.output_file;
        this.handler = new pluggable_auth_handler_1.PluggableAuthHandler({
          command: this.command,
          timeoutMillis: this.timeoutMillis,
          outputFile: this.outputFile
        });
        this.credentialSourceType = "executable";
      }
      /**
       * Triggered when an external subject token is needed to be exchanged for a
       * GCP access token via GCP STS endpoint.
       * This uses the `options.credential_source` object to figure out how
       * to retrieve the token using the current environment. In this case,
       * this calls a user provided executable which returns the subject token.
       * The logic is summarized as:
       * 1. Validated that the executable is allowed to run. The
       *    GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment must be set to
       *    1 for security reasons.
       * 2. If an output file is specified by the user, check the file location
       *    for a response. If the file exists and contains a valid response,
       *    return the subject token from the file.
       * 3. Call the provided executable and return response.
       * @return A promise that resolves with the external subject token.
       */
      async retrieveSubjectToken() {
        if (process.env[GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES] !== "1") {
          throw new Error("Pluggable Auth executables need to be explicitly allowed to run by setting the GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES environment Variable to 1.");
        }
        let executableResponse = void 0;
        if (this.outputFile) {
          executableResponse = await this.handler.retrieveCachedResponse();
        }
        if (!executableResponse) {
          const envMap = /* @__PURE__ */ new Map();
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE", this.audience);
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE", this.subjectTokenType);
          envMap.set("GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE", "0");
          if (this.outputFile) {
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE", this.outputFile);
          }
          const serviceAccountEmail = this.getServiceAccountEmail();
          if (serviceAccountEmail) {
            envMap.set("GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL", serviceAccountEmail);
          }
          executableResponse = await this.handler.retrieveResponseFromExecutable(envMap);
        }
        if (executableResponse.version > MAXIMUM_EXECUTABLE_VERSION) {
          throw new Error(`Version of executable is not currently supported, maximum supported version is ${MAXIMUM_EXECUTABLE_VERSION}.`);
        }
        if (!executableResponse.success) {
          throw new ExecutableError(executableResponse.errorMessage, executableResponse.errorCode);
        }
        if (this.outputFile) {
          if (!executableResponse.expirationTime) {
            throw new executable_response_1.InvalidExpirationTimeFieldError("The executable response must contain the `expiration_time` field for successful responses when an output_file has been specified in the configuration.");
          }
        }
        if (executableResponse.isExpired()) {
          throw new Error("Executable response is expired.");
        }
        return executableResponse.subjectToken;
      }
    };
    exports.PluggableAuthClient = PluggableAuthClient;
  }
});

// node_modules/google-auth-library/build/src/auth/externalclient.js
var require_externalclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/externalclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAccountClient = void 0;
    var baseexternalclient_1 = require_baseexternalclient();
    var identitypoolclient_1 = require_identitypoolclient();
    var awsclient_1 = require_awsclient();
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    var ExternalAccountClient = class {
      static {
        __name(this, "ExternalAccountClient");
      }
      constructor() {
        throw new Error("ExternalAccountClients should be initialized via: ExternalAccountClient.fromJSON(), directly via explicit constructors, eg. new AwsClient(options), new IdentityPoolClient(options), newPluggableAuthClientOptions, or via new GoogleAuth(options).getClient()");
      }
      /**
       * This static method will instantiate the
       * corresponding type of external account credential depending on the
       * underlying credential source.
       * @param options The external account options object typically loaded
       *   from the external account JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       * @return A BaseExternalAccountClient instance or null if the options
       *   provided do not correspond to an external account credential.
       */
      static fromJSON(options, additionalOptions) {
        var _a, _b;
        if (options && options.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          if ((_a = options.credential_source) === null || _a === void 0 ? void 0 : _a.environment_id) {
            return new awsclient_1.AwsClient(options, additionalOptions);
          } else if ((_b = options.credential_source) === null || _b === void 0 ? void 0 : _b.executable) {
            return new pluggable_auth_client_1.PluggableAuthClient(options, additionalOptions);
          } else {
            return new identitypoolclient_1.IdentityPoolClient(options, additionalOptions);
          }
        } else {
          return null;
        }
      }
    };
    exports.ExternalAccountClient = ExternalAccountClient;
  }
});

// node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js
var require_externalAccountAuthorizedUserClient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/externalAccountAuthorizedUserClient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ExternalAccountAuthorizedUserClient = exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = void 0;
    var authclient_1 = require_authclient();
    var oauth2common_1 = require_oauth2common();
    var gaxios_1 = require_src();
    var stream = require_stream();
    var baseexternalclient_1 = require_baseexternalclient();
    exports.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = "external_account_authorized_user";
    var DEFAULT_TOKEN_URL = "https://sts.{universeDomain}/v1/oauthtoken";
    var ExternalAccountAuthorizedUserHandler = class _ExternalAccountAuthorizedUserHandler extends oauth2common_1.OAuthClientAuthHandler {
      static {
        __name(this, "ExternalAccountAuthorizedUserHandler");
      }
      /**
       * Initializes an ExternalAccountAuthorizedUserHandler instance.
       * @param url The URL of the token refresh endpoint.
       * @param transporter The transporter to use for the refresh request.
       * @param clientAuthentication The client authentication credentials to use
       *   for the refresh request.
       */
      constructor(url, transporter, clientAuthentication) {
        super(clientAuthentication);
        this.url = url;
        this.transporter = transporter;
      }
      /**
       * Requests a new access token from the token_url endpoint using the provided
       *   refresh token.
       * @param refreshToken The refresh token to use to generate a new access token.
       * @param additionalHeaders Optional additional headers to pass along the
       *   request.
       * @return A promise that resolves with the token refresh response containing
       *   the requested access token and its expiration time.
       */
      async refreshToken(refreshToken2, additionalHeaders) {
        const values = new URLSearchParams({
          grant_type: "refresh_token",
          refresh_token: refreshToken2
        });
        const headers = {
          "Content-Type": "application/x-www-form-urlencoded",
          ...additionalHeaders
        };
        const opts = {
          ..._ExternalAccountAuthorizedUserHandler.RETRY_CONFIG,
          url: this.url,
          method: "POST",
          headers,
          data: values.toString(),
          responseType: "json"
        };
        this.applyClientAuthenticationOptions(opts);
        try {
          const response = await this.transporter.request(opts);
          const tokenRefreshResponse = response.data;
          tokenRefreshResponse.res = response;
          return tokenRefreshResponse;
        } catch (error3) {
          if (error3 instanceof gaxios_1.GaxiosError && error3.response) {
            throw (0, oauth2common_1.getErrorFromOAuthErrorResponse)(
              error3.response.data,
              // Preserve other fields from the original error.
              error3
            );
          }
          throw error3;
        }
      }
    };
    var ExternalAccountAuthorizedUserClient = class extends authclient_1.AuthClient {
      static {
        __name(this, "ExternalAccountAuthorizedUserClient");
      }
      /**
       * Instantiates an ExternalAccountAuthorizedUserClient instances using the
       * provided JSON object loaded from a credentials files.
       * An error is throws if the credential is not valid.
       * @param options The external account authorized user option object typically
       *   from the external accoutn authorized user JSON credential file.
       * @param additionalOptions **DEPRECATED, all options are available in the
       *   `options` parameter.** Optional additional behavior customization options.
       *   These currently customize expiration threshold time and whether to retry
       *   on 401/403 API request errors.
       */
      constructor(options, additionalOptions) {
        var _a;
        super({ ...options, ...additionalOptions });
        if (options.universe_domain) {
          this.universeDomain = options.universe_domain;
        }
        this.refreshToken = options.refresh_token;
        const clientAuth = {
          confidentialClientType: "basic",
          clientId: options.client_id,
          clientSecret: options.client_secret
        };
        this.externalAccountAuthorizedUserHandler = new ExternalAccountAuthorizedUserHandler((_a = options.token_url) !== null && _a !== void 0 ? _a : DEFAULT_TOKEN_URL.replace("{universeDomain}", this.universeDomain), this.transporter, clientAuth);
        this.cachedAccessToken = null;
        this.quotaProjectId = options.quota_project_id;
        if (typeof (additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.eagerRefreshThresholdMillis) !== "number") {
          this.eagerRefreshThresholdMillis = baseexternalclient_1.EXPIRATION_TIME_OFFSET;
        } else {
          this.eagerRefreshThresholdMillis = additionalOptions.eagerRefreshThresholdMillis;
        }
        this.forceRefreshOnFailure = !!(additionalOptions === null || additionalOptions === void 0 ? void 0 : additionalOptions.forceRefreshOnFailure);
      }
      async getAccessToken() {
        if (!this.cachedAccessToken || this.isExpired(this.cachedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedAccessToken.access_token,
          res: this.cachedAccessToken.res
        };
      }
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r) => callback(null, r), (e) => {
            return callback(e, e.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure.
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e) {
          const res = e.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * @return A promise that resolves with the refreshed credential.
       */
      async refreshAccessTokenAsync() {
        const refreshResponse = await this.externalAccountAuthorizedUserHandler.refreshToken(this.refreshToken);
        this.cachedAccessToken = {
          access_token: refreshResponse.access_token,
          expiry_date: (/* @__PURE__ */ new Date()).getTime() + refreshResponse.expires_in * 1e3,
          res: refreshResponse.res
        };
        if (refreshResponse.refresh_token !== void 0) {
          this.refreshToken = refreshResponse.refresh_token;
        }
        return this.cachedAccessToken;
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param credentials The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(credentials) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return credentials.expiry_date ? now >= credentials.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.ExternalAccountAuthorizedUserClient = ExternalAccountAuthorizedUserClient;
  }
});

// node_modules/google-auth-library/build/src/auth/googleauth.js
var require_googleauth = __commonJS({
  "node_modules/google-auth-library/build/src/auth/googleauth.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __classPrivateFieldGet = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    var __classPrivateFieldSet = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
    };
    var _GoogleAuth_instances;
    var _GoogleAuth_pendingAuthClient;
    var _GoogleAuth_prepareAndCacheClient;
    var _GoogleAuth_determineClient;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleAuth = exports.GoogleAuthExceptionMessages = exports.CLOUD_SDK_CLIENT_ID = void 0;
    var child_process_1 = require_child_process();
    var fs = require_fs();
    var gcpMetadata = require_src2();
    var os2 = require_os();
    var path = require_path();
    var crypto_1 = require_crypto4();
    var transporters_1 = require_transporters();
    var computeclient_1 = require_computeclient();
    var idtokenclient_1 = require_idtokenclient();
    var envDetect_1 = require_envDetect();
    var jwtclient_1 = require_jwtclient();
    var refreshclient_1 = require_refreshclient();
    var impersonated_1 = require_impersonated();
    var externalclient_1 = require_externalclient();
    var baseexternalclient_1 = require_baseexternalclient();
    var authclient_1 = require_authclient();
    var externalAccountAuthorizedUserClient_1 = require_externalAccountAuthorizedUserClient();
    var util_1 = require_util2();
    exports.CLOUD_SDK_CLIENT_ID = "764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com";
    exports.GoogleAuthExceptionMessages = {
      API_KEY_WITH_CREDENTIALS: "API Keys and Credentials are mutually exclusive authentication methods and cannot be used together.",
      NO_PROJECT_ID_FOUND: "Unable to detect a Project Id in the current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_CREDENTIALS_FOUND: "Unable to find credentials in current environment. \nTo learn more about authentication and Google APIs, visit: \nhttps://cloud.google.com/docs/authentication/getting-started",
      NO_ADC_FOUND: "Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.",
      NO_UNIVERSE_DOMAIN_FOUND: "Unable to detect a Universe Domain in the current environment.\nTo learn more about Universe Domain retrieval, visit: \nhttps://cloud.google.com/compute/docs/metadata/predefined-metadata-keys"
    };
    var GoogleAuth = class {
      static {
        __name(this, "GoogleAuth");
      }
      // Note:  this properly is only public to satisfy unit tests.
      // https://github.com/Microsoft/TypeScript/issues/5228
      get isGCE() {
        return this.checkIsGCE;
      }
      /**
       * Configuration is resolved in the following order of precedence:
       * - {@link GoogleAuthOptions.credentials `credentials`}
       * - {@link GoogleAuthOptions.keyFilename `keyFilename`}
       * - {@link GoogleAuthOptions.keyFile `keyFile`}
       *
       * {@link GoogleAuthOptions.clientOptions `clientOptions`} are passed to the
       * {@link AuthClient `AuthClient`s}.
       *
       * @param opts
       */
      constructor(opts = {}) {
        _GoogleAuth_instances.add(this);
        this.checkIsGCE = void 0;
        this.jsonContent = null;
        this.cachedCredential = null;
        _GoogleAuth_pendingAuthClient.set(this, null);
        this.clientOptions = {};
        this._cachedProjectId = opts.projectId || null;
        this.cachedCredential = opts.authClient || null;
        this.keyFilename = opts.keyFilename || opts.keyFile;
        this.scopes = opts.scopes;
        this.clientOptions = opts.clientOptions || {};
        this.jsonContent = opts.credentials || null;
        this.apiKey = opts.apiKey || this.clientOptions.apiKey || null;
        if (this.apiKey && (this.jsonContent || this.clientOptions.credentials)) {
          throw new RangeError(exports.GoogleAuthExceptionMessages.API_KEY_WITH_CREDENTIALS);
        }
        if (opts.universeDomain) {
          this.clientOptions.universeDomain = opts.universeDomain;
        }
      }
      // GAPIC client libraries should always use self-signed JWTs. The following
      // variables are set on the JWT client in order to indicate the type of library,
      // and sign the JWT with the correct audience and scopes (if not supplied).
      setGapicJWTValues(client) {
        client.defaultServicePath = this.defaultServicePath;
        client.useJWTAccessWithScope = this.useJWTAccessWithScope;
        client.defaultScopes = this.defaultScopes;
      }
      getProjectId(callback) {
        if (callback) {
          this.getProjectIdAsync().then((r) => callback(null, r), callback);
        } else {
          return this.getProjectIdAsync();
        }
      }
      /**
       * A temporary method for internal `getProjectId` usages where `null` is
       * acceptable. In a future major release, `getProjectId` should return `null`
       * (as the `Promise<string | null>` base signature describes) and this private
       * method should be removed.
       *
       * @returns Promise that resolves with project id (or `null`)
       */
      async getProjectIdOptional() {
        try {
          return await this.getProjectId();
        } catch (e) {
          if (e instanceof Error && e.message === exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND) {
            return null;
          } else {
            throw e;
          }
        }
      }
      /**
       * A private method for finding and caching a projectId.
       *
       * Supports environments in order of precedence:
       * - GCLOUD_PROJECT or GOOGLE_CLOUD_PROJECT environment variable
       * - GOOGLE_APPLICATION_CREDENTIALS JSON file
       * - Cloud SDK: `gcloud config config-helper --format json`
       * - GCE project ID from metadata server
       *
       * @returns projectId
       */
      async findAndCacheProjectId() {
        let projectId = null;
        projectId || (projectId = await this.getProductionProjectId());
        projectId || (projectId = await this.getFileProjectId());
        projectId || (projectId = await this.getDefaultServiceProjectId());
        projectId || (projectId = await this.getGCEProjectId());
        projectId || (projectId = await this.getExternalAccountClientProjectId());
        if (projectId) {
          this._cachedProjectId = projectId;
          return projectId;
        } else {
          throw new Error(exports.GoogleAuthExceptionMessages.NO_PROJECT_ID_FOUND);
        }
      }
      async getProjectIdAsync() {
        if (this._cachedProjectId) {
          return this._cachedProjectId;
        }
        if (!this._findProjectIdPromise) {
          this._findProjectIdPromise = this.findAndCacheProjectId();
        }
        return this._findProjectIdPromise;
      }
      /**
       * Retrieves a universe domain from the metadata server via
       * {@link gcpMetadata.universe}.
       *
       * @returns a universe domain
       */
      async getUniverseDomainFromMetadataServer() {
        var _a;
        let universeDomain;
        try {
          universeDomain = await gcpMetadata.universe("universe-domain");
          universeDomain || (universeDomain = authclient_1.DEFAULT_UNIVERSE);
        } catch (e) {
          if (e && ((_a = e === null || e === void 0 ? void 0 : e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
            universeDomain = authclient_1.DEFAULT_UNIVERSE;
          } else {
            throw e;
          }
        }
        return universeDomain;
      }
      /**
       * Retrieves, caches, and returns the universe domain in the following order
       * of precedence:
       * - The universe domain in {@link GoogleAuth.clientOptions}
       * - An existing or ADC {@link AuthClient}'s universe domain
       * - {@link gcpMetadata.universe}, if {@link Compute} client
       *
       * @returns The universe domain
       */
      async getUniverseDomain() {
        let universeDomain = (0, util_1.originalOrCamelOptions)(this.clientOptions).get("universe_domain");
        try {
          universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = (await this.getClient()).universeDomain;
        } catch (_a) {
          universeDomain !== null && universeDomain !== void 0 ? universeDomain : universeDomain = authclient_1.DEFAULT_UNIVERSE;
        }
        return universeDomain;
      }
      /**
       * @returns Any scopes (user-specified or default scopes specified by the
       *   client library) that need to be set on the current Auth client.
       */
      getAnyScopes() {
        return this.scopes || this.defaultScopes;
      }
      getApplicationDefault(optionsOrCallback = {}, callback) {
        let options;
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.getApplicationDefaultAsync(options).then((r) => callback(null, r.credential, r.projectId), callback);
        } else {
          return this.getApplicationDefaultAsync(options);
        }
      }
      async getApplicationDefaultAsync(options = {}) {
        if (this.cachedCredential) {
          return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, this.cachedCredential, null);
        }
        let credential;
        credential = await this._tryGetApplicationCredentialsFromEnvironmentVariable(options);
        if (credential) {
          if (credential instanceof jwtclient_1.JWT) {
            credential.scopes = this.scopes;
          } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
            credential.scopes = this.getAnyScopes();
          }
          return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
        }
        credential = await this._tryGetApplicationCredentialsFromWellKnownFile(options);
        if (credential) {
          if (credential instanceof jwtclient_1.JWT) {
            credential.scopes = this.scopes;
          } else if (credential instanceof baseexternalclient_1.BaseExternalAccountClient) {
            credential.scopes = this.getAnyScopes();
          }
          return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, credential);
        }
        if (await this._checkIsGCE()) {
          options.scopes = this.getAnyScopes();
          return await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, new computeclient_1.Compute(options));
        }
        throw new Error(exports.GoogleAuthExceptionMessages.NO_ADC_FOUND);
      }
      /**
       * Determines whether the auth layer is running on Google Compute Engine.
       * Checks for GCP Residency, then fallback to checking if metadata server
       * is available.
       *
       * @returns A promise that resolves with the boolean.
       * @api private
       */
      async _checkIsGCE() {
        if (this.checkIsGCE === void 0) {
          this.checkIsGCE = gcpMetadata.getGCPResidency() || await gcpMetadata.isAvailable();
        }
        return this.checkIsGCE;
      }
      /**
       * Attempts to load default credentials from the environment variable path..
       * @returns Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      async _tryGetApplicationCredentialsFromEnvironmentVariable(options) {
        const credentialsPath = process.env["GOOGLE_APPLICATION_CREDENTIALS"] || process.env["google_application_credentials"];
        if (!credentialsPath || credentialsPath.length === 0) {
          return null;
        }
        try {
          return this._getApplicationCredentialsFromFilePath(credentialsPath, options);
        } catch (e) {
          if (e instanceof Error) {
            e.message = `Unable to read the credential file specified by the GOOGLE_APPLICATION_CREDENTIALS environment variable: ${e.message}`;
          }
          throw e;
        }
      }
      /**
       * Attempts to load default credentials from a well-known file location
       * @return Promise that resolves with the OAuth2Client or null.
       * @api private
       */
      async _tryGetApplicationCredentialsFromWellKnownFile(options) {
        let location2 = null;
        if (this._isWindows()) {
          location2 = process.env["APPDATA"];
        } else {
          const home = process.env["HOME"];
          if (home) {
            location2 = path.join(home, ".config");
          }
        }
        if (location2) {
          location2 = path.join(location2, "gcloud", "application_default_credentials.json");
          if (!fs.existsSync(location2)) {
            location2 = null;
          }
        }
        if (!location2) {
          return null;
        }
        const client = await this._getApplicationCredentialsFromFilePath(location2, options);
        return client;
      }
      /**
       * Attempts to load default credentials from a file at the given path..
       * @param filePath The path to the file to read.
       * @returns Promise that resolves with the OAuth2Client
       * @api private
       */
      async _getApplicationCredentialsFromFilePath(filePath, options = {}) {
        if (!filePath || filePath.length === 0) {
          throw new Error("The file path is invalid.");
        }
        try {
          filePath = fs.realpathSync(filePath);
          if (!fs.lstatSync(filePath).isFile()) {
            throw new Error();
          }
        } catch (err) {
          if (err instanceof Error) {
            err.message = `The file at ${filePath} does not exist, or it is not a file. ${err.message}`;
          }
          throw err;
        }
        const readStream = fs.createReadStream(filePath);
        return this.fromStream(readStream, options);
      }
      /**
       * Create a credentials instance using a given impersonated input options.
       * @param json The impersonated input object.
       * @returns JWT or UserRefresh Client with data
       */
      fromImpersonatedJSON(json) {
        var _a, _b, _c, _d;
        if (!json) {
          throw new Error("Must pass in a JSON object containing an  impersonated refresh token");
        }
        if (json.type !== impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          throw new Error(`The incoming JSON object does not have the "${impersonated_1.IMPERSONATED_ACCOUNT_TYPE}" type`);
        }
        if (!json.source_credentials) {
          throw new Error("The incoming JSON object does not contain a source_credentials field");
        }
        if (!json.service_account_impersonation_url) {
          throw new Error("The incoming JSON object does not contain a service_account_impersonation_url field");
        }
        const sourceClient = this.fromJSON(json.source_credentials);
        if (((_a = json.service_account_impersonation_url) === null || _a === void 0 ? void 0 : _a.length) > 256) {
          throw new RangeError(`Target principal is too long: ${json.service_account_impersonation_url}`);
        }
        const targetPrincipal = (_c = (_b = /(?<target>[^/]+):(generateAccessToken|generateIdToken)$/.exec(json.service_account_impersonation_url)) === null || _b === void 0 ? void 0 : _b.groups) === null || _c === void 0 ? void 0 : _c.target;
        if (!targetPrincipal) {
          throw new RangeError(`Cannot extract target principal from ${json.service_account_impersonation_url}`);
        }
        const targetScopes = (_d = this.getAnyScopes()) !== null && _d !== void 0 ? _d : [];
        return new impersonated_1.Impersonated({
          ...json,
          sourceClient,
          targetPrincipal,
          targetScopes: Array.isArray(targetScopes) ? targetScopes : [targetScopes]
        });
      }
      /**
       * Create a credentials instance using the given input options.
       * This client is not cached.
       *
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      fromJSON(json, options = {}) {
        let client;
        const preferredUniverseDomain = (0, util_1.originalOrCamelOptions)(options).get("universe_domain");
        if (json.type === refreshclient_1.USER_REFRESH_ACCOUNT_TYPE) {
          client = new refreshclient_1.UserRefreshClient(options);
          client.fromJSON(json);
        } else if (json.type === impersonated_1.IMPERSONATED_ACCOUNT_TYPE) {
          client = this.fromImpersonatedJSON(json);
        } else if (json.type === baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          client = externalclient_1.ExternalAccountClient.fromJSON(json, options);
          client.scopes = this.getAnyScopes();
        } else if (json.type === externalAccountAuthorizedUserClient_1.EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE) {
          client = new externalAccountAuthorizedUserClient_1.ExternalAccountAuthorizedUserClient(json, options);
        } else {
          options.scopes = this.scopes;
          client = new jwtclient_1.JWT(options);
          this.setGapicJWTValues(client);
          client.fromJSON(json);
        }
        if (preferredUniverseDomain) {
          client.universeDomain = preferredUniverseDomain;
        }
        return client;
      }
      /**
       * Return a JWT or UserRefreshClient from JavaScript object, caching both the
       * object used to instantiate and the client.
       * @param json The input object.
       * @param options The JWT or UserRefresh options for the client
       * @returns JWT or UserRefresh Client with data
       */
      _cacheClientFromJSON(json, options) {
        const client = this.fromJSON(json, options);
        this.jsonContent = json;
        this.cachedCredential = client;
        return client;
      }
      fromStream(inputStream, optionsOrCallback = {}, callback) {
        let options = {};
        if (typeof optionsOrCallback === "function") {
          callback = optionsOrCallback;
        } else {
          options = optionsOrCallback;
        }
        if (callback) {
          this.fromStreamAsync(inputStream, options).then((r) => callback(null, r), callback);
        } else {
          return this.fromStreamAsync(inputStream, options);
        }
      }
      fromStreamAsync(inputStream, options) {
        return new Promise((resolve, reject) => {
          if (!inputStream) {
            throw new Error("Must pass in a stream containing the Google auth settings.");
          }
          const chunks = [];
          inputStream.setEncoding("utf8").on("error", reject).on("data", (chunk) => chunks.push(chunk)).on("end", () => {
            try {
              try {
                const data = JSON.parse(chunks.join(""));
                const r = this._cacheClientFromJSON(data, options);
                return resolve(r);
              } catch (err) {
                if (!this.keyFilename)
                  throw err;
                const client = new jwtclient_1.JWT({
                  ...this.clientOptions,
                  keyFile: this.keyFilename
                });
                this.cachedCredential = client;
                this.setGapicJWTValues(client);
                return resolve(client);
              }
            } catch (err) {
              return reject(err);
            }
          });
        });
      }
      /**
       * Create a credentials instance using the given API key string.
       * The created client is not cached. In order to create and cache it use the {@link GoogleAuth.getClient `getClient`} method after first providing an {@link GoogleAuth.apiKey `apiKey`}.
       *
       * @param apiKey The API key string
       * @param options An optional options object.
       * @returns A JWT loaded from the key
       */
      fromAPIKey(apiKey, options = {}) {
        return new jwtclient_1.JWT({ ...options, apiKey });
      }
      /**
       * Determines whether the current operating system is Windows.
       * @api private
       */
      _isWindows() {
        const sys = os2.platform();
        if (sys && sys.length >= 3) {
          if (sys.substring(0, 3).toLowerCase() === "win") {
            return true;
          }
        }
        return false;
      }
      /**
       * Run the Google Cloud SDK command that prints the default project ID
       */
      async getDefaultServiceProjectId() {
        return new Promise((resolve) => {
          (0, child_process_1.exec)("gcloud config config-helper --format json", (err, stdout2) => {
            if (!err && stdout2) {
              try {
                const projectId = JSON.parse(stdout2).configuration.properties.core.project;
                resolve(projectId);
                return;
              } catch (e) {
              }
            }
            resolve(null);
          });
        });
      }
      /**
       * Loads the project id from environment variables.
       * @api private
       */
      getProductionProjectId() {
        return process.env["GCLOUD_PROJECT"] || process.env["GOOGLE_CLOUD_PROJECT"] || process.env["gcloud_project"] || process.env["google_cloud_project"];
      }
      /**
       * Loads the project id from the GOOGLE_APPLICATION_CREDENTIALS json file.
       * @api private
       */
      async getFileProjectId() {
        if (this.cachedCredential) {
          return this.cachedCredential.projectId;
        }
        if (this.keyFilename) {
          const creds = await this.getClient();
          if (creds && creds.projectId) {
            return creds.projectId;
          }
        }
        const r = await this._tryGetApplicationCredentialsFromEnvironmentVariable();
        if (r) {
          return r.projectId;
        } else {
          return null;
        }
      }
      /**
       * Gets the project ID from external account client if available.
       */
      async getExternalAccountClientProjectId() {
        if (!this.jsonContent || this.jsonContent.type !== baseexternalclient_1.EXTERNAL_ACCOUNT_TYPE) {
          return null;
        }
        const creds = await this.getClient();
        return await creds.getProjectId();
      }
      /**
       * Gets the Compute Engine project ID if it can be inferred.
       */
      async getGCEProjectId() {
        try {
          const r = await gcpMetadata.project("project-id");
          return r;
        } catch (e) {
          return null;
        }
      }
      getCredentials(callback) {
        if (callback) {
          this.getCredentialsAsync().then((r) => callback(null, r), callback);
        } else {
          return this.getCredentialsAsync();
        }
      }
      async getCredentialsAsync() {
        const client = await this.getClient();
        if (client instanceof impersonated_1.Impersonated) {
          return { client_email: client.getTargetPrincipal() };
        }
        if (client instanceof baseexternalclient_1.BaseExternalAccountClient) {
          const serviceAccountEmail = client.getServiceAccountEmail();
          if (serviceAccountEmail) {
            return {
              client_email: serviceAccountEmail,
              universe_domain: client.universeDomain
            };
          }
        }
        if (this.jsonContent) {
          return {
            client_email: this.jsonContent.client_email,
            private_key: this.jsonContent.private_key,
            universe_domain: this.jsonContent.universe_domain
          };
        }
        if (await this._checkIsGCE()) {
          const [client_email, universe_domain] = await Promise.all([
            gcpMetadata.instance("service-accounts/default/email"),
            this.getUniverseDomain()
          ]);
          return { client_email, universe_domain };
        }
        throw new Error(exports.GoogleAuthExceptionMessages.NO_CREDENTIALS_FOUND);
      }
      /**
       * Automatically obtain an {@link AuthClient `AuthClient`} based on the
       * provided configuration. If no options were passed, use Application
       * Default Credentials.
       */
      async getClient() {
        if (this.cachedCredential) {
          return this.cachedCredential;
        }
        __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f") || __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_determineClient).call(this), "f");
        try {
          return await __classPrivateFieldGet(this, _GoogleAuth_pendingAuthClient, "f");
        } finally {
          __classPrivateFieldSet(this, _GoogleAuth_pendingAuthClient, null, "f");
        }
      }
      /**
       * Creates a client which will fetch an ID token for authorization.
       * @param targetAudience the audience for the fetched ID token.
       * @returns IdTokenClient for making HTTP calls authenticated with ID tokens.
       */
      async getIdTokenClient(targetAudience) {
        const client = await this.getClient();
        if (!("fetchIdToken" in client)) {
          throw new Error("Cannot fetch ID token in this environment, use GCE or set the GOOGLE_APPLICATION_CREDENTIALS environment variable to a service account credentials JSON file.");
        }
        return new idtokenclient_1.IdTokenClient({ targetAudience, idTokenProvider: client });
      }
      /**
       * Automatically obtain application default credentials, and return
       * an access token for making requests.
       */
      async getAccessToken() {
        const client = await this.getClient();
        return (await client.getAccessToken()).token;
      }
      /**
       * Obtain the HTTP headers that will provide authorization for a given
       * request.
       */
      async getRequestHeaders(url) {
        const client = await this.getClient();
        return client.getRequestHeaders(url);
      }
      /**
       * Obtain credentials for a request, then attach the appropriate headers to
       * the request options.
       * @param opts Axios or Request options on which to attach the headers
       */
      async authorizeRequest(opts) {
        opts = opts || {};
        const url = opts.url || opts.uri;
        const client = await this.getClient();
        const headers = await client.getRequestHeaders(url);
        opts.headers = Object.assign(opts.headers || {}, headers);
        return opts;
      }
      /**
       * Automatically obtain application default credentials, and make an
       * HTTP request using the given options.
       * @param opts Axios request options for the HTTP request.
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      async request(opts) {
        const client = await this.getClient();
        return client.request(opts);
      }
      /**
       * Determine the compute environment in which the code is running.
       */
      getEnv() {
        return (0, envDetect_1.getEnv)();
      }
      /**
       * Sign the given data with the current private key, or go out
       * to the IAM API to sign it.
       * @param data The data to be signed.
       * @param endpoint A custom endpoint to use.
       *
       * @example
       * ```
       * sign('data', 'https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/');
       * ```
       */
      async sign(data, endpoint) {
        const client = await this.getClient();
        const universe = await this.getUniverseDomain();
        endpoint = endpoint || `https://iamcredentials.${universe}/v1/projects/-/serviceAccounts/`;
        if (client instanceof impersonated_1.Impersonated) {
          const signed = await client.sign(data);
          return signed.signedBlob;
        }
        const crypto2 = (0, crypto_1.createCrypto)();
        if (client instanceof jwtclient_1.JWT && client.key) {
          const sign3 = await crypto2.sign(client.key, data);
          return sign3;
        }
        const creds = await this.getCredentials();
        if (!creds.client_email) {
          throw new Error("Cannot sign data without `client_email`.");
        }
        return this.signBlob(crypto2, creds.client_email, data, endpoint);
      }
      async signBlob(crypto2, emailOrUniqueId, data, endpoint) {
        const url = new URL(endpoint + `${emailOrUniqueId}:signBlob`);
        const res = await this.request({
          method: "POST",
          url: url.href,
          data: {
            payload: crypto2.encodeBase64StringUtf8(data)
          },
          retry: true,
          retryConfig: {
            httpMethodsToRetry: ["POST"]
          }
        });
        return res.data.signedBlob;
      }
    };
    exports.GoogleAuth = GoogleAuth;
    _GoogleAuth_pendingAuthClient = /* @__PURE__ */ new WeakMap(), _GoogleAuth_instances = /* @__PURE__ */ new WeakSet(), _GoogleAuth_prepareAndCacheClient = /* @__PURE__ */ __name(async function _GoogleAuth_prepareAndCacheClient2(credential, quotaProjectIdOverride = process.env["GOOGLE_CLOUD_QUOTA_PROJECT"] || null) {
      const projectId = await this.getProjectIdOptional();
      if (quotaProjectIdOverride) {
        credential.quotaProjectId = quotaProjectIdOverride;
      }
      this.cachedCredential = credential;
      return { credential, projectId };
    }, "_GoogleAuth_prepareAndCacheClient"), _GoogleAuth_determineClient = /* @__PURE__ */ __name(async function _GoogleAuth_determineClient2() {
      if (this.jsonContent) {
        return this._cacheClientFromJSON(this.jsonContent, this.clientOptions);
      } else if (this.keyFilename) {
        const filePath = path.resolve(this.keyFilename);
        const stream = fs.createReadStream(filePath);
        return await this.fromStreamAsync(stream, this.clientOptions);
      } else if (this.apiKey) {
        const client = await this.fromAPIKey(this.apiKey, this.clientOptions);
        client.scopes = this.scopes;
        const { credential } = await __classPrivateFieldGet(this, _GoogleAuth_instances, "m", _GoogleAuth_prepareAndCacheClient).call(this, client);
        return credential;
      } else {
        const { credential } = await this.getApplicationDefaultAsync(this.clientOptions);
        return credential;
      }
    }, "_GoogleAuth_determineClient");
    GoogleAuth.DefaultTransporter = transporters_1.DefaultTransporter;
  }
});

// node_modules/google-auth-library/build/src/auth/iam.js
var require_iam = __commonJS({
  "node_modules/google-auth-library/build/src/auth/iam.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IAMAuth = void 0;
    var IAMAuth = class {
      static {
        __name(this, "IAMAuth");
      }
      /**
       * IAM credentials.
       *
       * @param selector the iam authority selector
       * @param token the token
       * @constructor
       */
      constructor(selector, token) {
        this.selector = selector;
        this.token = token;
        this.selector = selector;
        this.token = token;
      }
      /**
       * Acquire the HTTP headers required to make an authenticated request.
       */
      getRequestHeaders() {
        return {
          "x-goog-iam-authority-selector": this.selector,
          "x-goog-iam-authorization-token": this.token
        };
      }
    };
    exports.IAMAuth = IAMAuth;
  }
});

// node_modules/google-auth-library/build/src/auth/downscopedclient.js
var require_downscopedclient = __commonJS({
  "node_modules/google-auth-library/build/src/auth/downscopedclient.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DownscopedClient = exports.EXPIRATION_TIME_OFFSET = exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = void 0;
    var stream = require_stream();
    var authclient_1 = require_authclient();
    var sts = require_stscredentials();
    var STS_GRANT_TYPE = "urn:ietf:params:oauth:grant-type:token-exchange";
    var STS_REQUEST_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    var STS_SUBJECT_TOKEN_TYPE = "urn:ietf:params:oauth:token-type:access_token";
    exports.MAX_ACCESS_BOUNDARY_RULES_COUNT = 10;
    exports.EXPIRATION_TIME_OFFSET = 5 * 60 * 1e3;
    var DownscopedClient = class extends authclient_1.AuthClient {
      static {
        __name(this, "DownscopedClient");
      }
      /**
       * Instantiates a downscoped client object using the provided source
       * AuthClient and credential access boundary rules.
       * To downscope permissions of a source AuthClient, a Credential Access
       * Boundary that specifies which resources the new credential can access, as
       * well as an upper bound on the permissions that are available on each
       * resource, has to be defined. A downscoped client can then be instantiated
       * using the source AuthClient and the Credential Access Boundary.
       * @param authClient The source AuthClient to be downscoped based on the
       *   provided Credential Access Boundary rules.
       * @param credentialAccessBoundary The Credential Access Boundary which
       *   contains a list of access boundary rules. Each rule contains information
       *   on the resource that the rule applies to, the upper bound of the
       *   permissions that are available on that resource and an optional
       *   condition to further restrict permissions.
       * @param additionalOptions **DEPRECATED, set this in the provided `authClient`.**
       *   Optional additional behavior customization options.
       * @param quotaProjectId **DEPRECATED, set this in the provided `authClient`.**
       *   Optional quota project id for setting up in the x-goog-user-project header.
       */
      constructor(authClient, credentialAccessBoundary, additionalOptions, quotaProjectId) {
        super({ ...additionalOptions, quotaProjectId });
        this.authClient = authClient;
        this.credentialAccessBoundary = credentialAccessBoundary;
        if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length === 0) {
          throw new Error("At least one access boundary rule needs to be defined.");
        } else if (credentialAccessBoundary.accessBoundary.accessBoundaryRules.length > exports.MAX_ACCESS_BOUNDARY_RULES_COUNT) {
          throw new Error(`The provided access boundary has more than ${exports.MAX_ACCESS_BOUNDARY_RULES_COUNT} access boundary rules.`);
        }
        for (const rule of credentialAccessBoundary.accessBoundary.accessBoundaryRules) {
          if (rule.availablePermissions.length === 0) {
            throw new Error("At least one permission should be defined in access boundary rules.");
          }
        }
        this.stsCredential = new sts.StsCredentials(`https://sts.${this.universeDomain}/v1/token`);
        this.cachedDownscopedAccessToken = null;
      }
      /**
       * Provides a mechanism to inject Downscoped access tokens directly.
       * The expiry_date field is required to facilitate determination of the token
       * expiration which would make it easier for the token consumer to handle.
       * @param credentials The Credentials object to set on the current client.
       */
      setCredentials(credentials) {
        if (!credentials.expiry_date) {
          throw new Error("The access token expiry_date field is missing in the provided credentials.");
        }
        super.setCredentials(credentials);
        this.cachedDownscopedAccessToken = credentials;
      }
      async getAccessToken() {
        if (!this.cachedDownscopedAccessToken || this.isExpired(this.cachedDownscopedAccessToken)) {
          await this.refreshAccessTokenAsync();
        }
        return {
          token: this.cachedDownscopedAccessToken.access_token,
          expirationTime: this.cachedDownscopedAccessToken.expiry_date,
          res: this.cachedDownscopedAccessToken.res
        };
      }
      /**
       * The main authentication interface. It takes an optional url which when
       * present is the endpoint being accessed, and returns a Promise which
       * resolves with authorization header fields.
       *
       * The result has the form:
       * { Authorization: 'Bearer <access_token_value>' }
       */
      async getRequestHeaders() {
        const accessTokenResponse = await this.getAccessToken();
        const headers = {
          Authorization: `Bearer ${accessTokenResponse.token}`
        };
        return this.addSharedMetadataHeaders(headers);
      }
      request(opts, callback) {
        if (callback) {
          this.requestAsync(opts).then((r) => callback(null, r), (e) => {
            return callback(e, e.response);
          });
        } else {
          return this.requestAsync(opts);
        }
      }
      /**
       * Authenticates the provided HTTP request, processes it and resolves with the
       * returned response.
       * @param opts The HTTP request options.
       * @param reAuthRetried Whether the current attempt is a retry after a failed attempt due to an auth failure
       * @return A promise that resolves with the successful response.
       */
      async requestAsync(opts, reAuthRetried = false) {
        let response;
        try {
          const requestHeaders = await this.getRequestHeaders();
          opts.headers = opts.headers || {};
          if (requestHeaders && requestHeaders["x-goog-user-project"]) {
            opts.headers["x-goog-user-project"] = requestHeaders["x-goog-user-project"];
          }
          if (requestHeaders && requestHeaders.Authorization) {
            opts.headers.Authorization = requestHeaders.Authorization;
          }
          response = await this.transporter.request(opts);
        } catch (e) {
          const res = e.response;
          if (res) {
            const statusCode = res.status;
            const isReadableStream = res.config.data instanceof stream.Readable;
            const isAuthErr = statusCode === 401 || statusCode === 403;
            if (!reAuthRetried && isAuthErr && !isReadableStream && this.forceRefreshOnFailure) {
              await this.refreshAccessTokenAsync();
              return await this.requestAsync(opts, true);
            }
          }
          throw e;
        }
        return response;
      }
      /**
       * Forces token refresh, even if unexpired tokens are currently cached.
       * GCP access tokens are retrieved from authclient object/source credential.
       * Then GCP access tokens are exchanged for downscoped access tokens via the
       * token exchange endpoint.
       * @return A promise that resolves with the fresh downscoped access token.
       */
      async refreshAccessTokenAsync() {
        var _a;
        const subjectToken = (await this.authClient.getAccessToken()).token;
        const stsCredentialsOptions = {
          grantType: STS_GRANT_TYPE,
          requestedTokenType: STS_REQUEST_TOKEN_TYPE,
          subjectToken,
          subjectTokenType: STS_SUBJECT_TOKEN_TYPE
        };
        const stsResponse = await this.stsCredential.exchangeToken(stsCredentialsOptions, void 0, this.credentialAccessBoundary);
        const sourceCredExpireDate = ((_a = this.authClient.credentials) === null || _a === void 0 ? void 0 : _a.expiry_date) || null;
        const expiryDate = stsResponse.expires_in ? (/* @__PURE__ */ new Date()).getTime() + stsResponse.expires_in * 1e3 : sourceCredExpireDate;
        this.cachedDownscopedAccessToken = {
          access_token: stsResponse.access_token,
          expiry_date: expiryDate,
          res: stsResponse.res
        };
        this.credentials = {};
        Object.assign(this.credentials, this.cachedDownscopedAccessToken);
        delete this.credentials.res;
        this.emit("tokens", {
          refresh_token: null,
          expiry_date: this.cachedDownscopedAccessToken.expiry_date,
          access_token: this.cachedDownscopedAccessToken.access_token,
          token_type: "Bearer",
          id_token: null
        });
        return this.cachedDownscopedAccessToken;
      }
      /**
       * Returns whether the provided credentials are expired or not.
       * If there is no expiry time, assumes the token is not expired or expiring.
       * @param downscopedAccessToken The credentials to check for expiration.
       * @return Whether the credentials are expired or not.
       */
      isExpired(downscopedAccessToken) {
        const now = (/* @__PURE__ */ new Date()).getTime();
        return downscopedAccessToken.expiry_date ? now >= downscopedAccessToken.expiry_date - this.eagerRefreshThresholdMillis : false;
      }
    };
    exports.DownscopedClient = DownscopedClient;
  }
});

// node_modules/google-auth-library/build/src/auth/passthrough.js
var require_passthrough = __commonJS({
  "node_modules/google-auth-library/build/src/auth/passthrough.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PassThroughClient = void 0;
    var authclient_1 = require_authclient();
    var PassThroughClient = class extends authclient_1.AuthClient {
      static {
        __name(this, "PassThroughClient");
      }
      /**
       * Creates a request without any authentication headers or checks.
       *
       * @remarks
       *
       * In testing environments it may be useful to change the provided
       * {@link AuthClient.transporter} for any desired request overrides/handling.
       *
       * @param opts
       * @returns The response of the request.
       */
      async request(opts) {
        return this.transporter.request(opts);
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      async getAccessToken() {
        return {};
      }
      /**
       * A required method of the base class.
       * Always will return an empty object.
       *
       * @returns {}
       */
      async getRequestHeaders() {
        return {};
      }
    };
    exports.PassThroughClient = PassThroughClient;
    var a2 = new PassThroughClient();
    a2.getAccessToken();
  }
});

// node_modules/google-auth-library/build/src/index.js
var require_src4 = __commonJS({
  "node_modules/google-auth-library/build/src/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.GoogleAuth = exports.auth = exports.DefaultTransporter = exports.PassThroughClient = exports.ExecutableError = exports.PluggableAuthClient = exports.DownscopedClient = exports.BaseExternalAccountClient = exports.ExternalAccountClient = exports.IdentityPoolClient = exports.AwsRequestSigner = exports.AwsClient = exports.UserRefreshClient = exports.LoginTicket = exports.ClientAuthentication = exports.OAuth2Client = exports.CodeChallengeMethod = exports.Impersonated = exports.JWT = exports.JWTAccess = exports.IdTokenClient = exports.IAMAuth = exports.GCPEnv = exports.Compute = exports.DEFAULT_UNIVERSE = exports.AuthClient = exports.gaxios = exports.gcpMetadata = void 0;
    var googleauth_1 = require_googleauth();
    Object.defineProperty(exports, "GoogleAuth", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return googleauth_1.GoogleAuth;
    }, "get") });
    exports.gcpMetadata = require_src2();
    exports.gaxios = require_src();
    var authclient_1 = require_authclient();
    Object.defineProperty(exports, "AuthClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return authclient_1.AuthClient;
    }, "get") });
    Object.defineProperty(exports, "DEFAULT_UNIVERSE", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return authclient_1.DEFAULT_UNIVERSE;
    }, "get") });
    var computeclient_1 = require_computeclient();
    Object.defineProperty(exports, "Compute", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return computeclient_1.Compute;
    }, "get") });
    var envDetect_1 = require_envDetect();
    Object.defineProperty(exports, "GCPEnv", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return envDetect_1.GCPEnv;
    }, "get") });
    var iam_1 = require_iam();
    Object.defineProperty(exports, "IAMAuth", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return iam_1.IAMAuth;
    }, "get") });
    var idtokenclient_1 = require_idtokenclient();
    Object.defineProperty(exports, "IdTokenClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return idtokenclient_1.IdTokenClient;
    }, "get") });
    var jwtaccess_1 = require_jwtaccess();
    Object.defineProperty(exports, "JWTAccess", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return jwtaccess_1.JWTAccess;
    }, "get") });
    var jwtclient_1 = require_jwtclient();
    Object.defineProperty(exports, "JWT", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return jwtclient_1.JWT;
    }, "get") });
    var impersonated_1 = require_impersonated();
    Object.defineProperty(exports, "Impersonated", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return impersonated_1.Impersonated;
    }, "get") });
    var oauth2client_1 = require_oauth2client();
    Object.defineProperty(exports, "CodeChallengeMethod", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return oauth2client_1.CodeChallengeMethod;
    }, "get") });
    Object.defineProperty(exports, "OAuth2Client", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return oauth2client_1.OAuth2Client;
    }, "get") });
    Object.defineProperty(exports, "ClientAuthentication", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return oauth2client_1.ClientAuthentication;
    }, "get") });
    var loginticket_1 = require_loginticket();
    Object.defineProperty(exports, "LoginTicket", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return loginticket_1.LoginTicket;
    }, "get") });
    var refreshclient_1 = require_refreshclient();
    Object.defineProperty(exports, "UserRefreshClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return refreshclient_1.UserRefreshClient;
    }, "get") });
    var awsclient_1 = require_awsclient();
    Object.defineProperty(exports, "AwsClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return awsclient_1.AwsClient;
    }, "get") });
    var awsrequestsigner_1 = require_awsrequestsigner();
    Object.defineProperty(exports, "AwsRequestSigner", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return awsrequestsigner_1.AwsRequestSigner;
    }, "get") });
    var identitypoolclient_1 = require_identitypoolclient();
    Object.defineProperty(exports, "IdentityPoolClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return identitypoolclient_1.IdentityPoolClient;
    }, "get") });
    var externalclient_1 = require_externalclient();
    Object.defineProperty(exports, "ExternalAccountClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return externalclient_1.ExternalAccountClient;
    }, "get") });
    var baseexternalclient_1 = require_baseexternalclient();
    Object.defineProperty(exports, "BaseExternalAccountClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return baseexternalclient_1.BaseExternalAccountClient;
    }, "get") });
    var downscopedclient_1 = require_downscopedclient();
    Object.defineProperty(exports, "DownscopedClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return downscopedclient_1.DownscopedClient;
    }, "get") });
    var pluggable_auth_client_1 = require_pluggable_auth_client();
    Object.defineProperty(exports, "PluggableAuthClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return pluggable_auth_client_1.PluggableAuthClient;
    }, "get") });
    Object.defineProperty(exports, "ExecutableError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return pluggable_auth_client_1.ExecutableError;
    }, "get") });
    var passthrough_1 = require_passthrough();
    Object.defineProperty(exports, "PassThroughClient", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return passthrough_1.PassThroughClient;
    }, "get") });
    var transporters_1 = require_transporters();
    Object.defineProperty(exports, "DefaultTransporter", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return transporters_1.DefaultTransporter;
    }, "get") });
    var auth = new googleauth_1.GoogleAuth();
    exports.auth = auth;
  }
});

// node_modules/firebase-admin/lib/utils/deep-copy.js
var require_deep_copy = __commonJS({
  "node_modules/firebase-admin/lib/utils/deep-copy.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepCopy = deepCopy;
    exports.deepExtend = deepExtend;
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    __name(deepCopy, "deepCopy");
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date: {
          const dateValue = source;
          return new Date(dateValue.getTime());
        }
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (const prop in source) {
        if (!Object.prototype.hasOwnProperty.call(source, prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    __name(deepExtend, "deepExtend");
  }
});

// node_modules/firebase-admin/lib/utils/error.js
var require_error = __commonJS({
  "node_modules/firebase-admin/lib/utils/error.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InstanceIdClientErrorCode = exports.InstallationsClientErrorCode = exports.MessagingClientErrorCode = exports.AuthClientErrorCode = exports.AppErrorCodes = exports.FirebaseProjectManagementError = exports.FirebaseMessagingError = exports.FirebaseInstallationsError = exports.FirebaseInstanceIdError = exports.FirebaseFirestoreError = exports.FirebaseDatabaseError = exports.FirebaseAuthError = exports.FirebaseAppError = exports.PrefixedFirebaseError = exports.FirebaseError = void 0;
    var deep_copy_1 = require_deep_copy();
    var FirebaseError = class _FirebaseError extends Error {
      static {
        __name(this, "FirebaseError");
      }
      /**
       * @param errorInfo - The error information (code and message).
       * @constructor
       * @internal
       */
      constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        this.__proto__ = _FirebaseError.prototype;
      }
      /** @returns The error code. */
      get code() {
        return this.errorInfo?.code;
      }
      /** @returns The error message. */
      get message() {
        return this.errorInfo?.message;
      }
      /** @returns The object representation of the error. */
      toJSON() {
        return {
          code: this.code,
          message: this.message
        };
      }
    };
    exports.FirebaseError = FirebaseError;
    var PrefixedFirebaseError = class _PrefixedFirebaseError extends FirebaseError {
      static {
        __name(this, "PrefixedFirebaseError");
      }
      /**
       * @param codePrefix - The prefix to apply to the error code.
       * @param code - The error code.
       * @param message - The error message.
       * @constructor
       * @internal
       */
      constructor(codePrefix, code, message2) {
        super({
          code: `${codePrefix}/${code}`,
          message: message2
        });
        this.codePrefix = codePrefix;
        this.__proto__ = _PrefixedFirebaseError.prototype;
      }
      /**
       * Allows the error type to be checked without needing to know implementation details
       * of the code prefixing.
       *
       * @param code - The non-prefixed error code to test against.
       * @returns True if the code matches, false otherwise.
       */
      hasCode(code) {
        return `${this.codePrefix}/${code}` === this.code;
      }
    };
    exports.PrefixedFirebaseError = PrefixedFirebaseError;
    var FirebaseAppError2 = class _FirebaseAppError extends PrefixedFirebaseError {
      static {
        __name(this, "FirebaseAppError");
      }
      /**
       * @param code - The error code.
       * @param message - The error message.
       * @constructor
       * @internal
       */
      constructor(code, message2) {
        super("app", code, message2);
        this.__proto__ = _FirebaseAppError.prototype;
      }
    };
    exports.FirebaseAppError = FirebaseAppError2;
    var FirebaseAuthError2 = class _FirebaseAuthError extends PrefixedFirebaseError {
      static {
        __name(this, "FirebaseAuthError");
      }
      /**
       * Creates the developer-facing error corresponding to the backend error code.
       *
       * @param serverErrorCode - The server error code.
       * @param [message] The error message. The default message is used
       *     if not provided.
       * @param [rawServerResponse] The error's raw server response.
       * @returns The corresponding developer-facing error.
       * @internal
       */
      static fromServerError(serverErrorCode, message2, rawServerResponse) {
        const colonSeparator = (serverErrorCode || "").indexOf(":");
        let customMessage = null;
        if (colonSeparator !== -1) {
          customMessage = serverErrorCode.substring(colonSeparator + 1).trim();
          serverErrorCode = serverErrorCode.substring(0, colonSeparator).trim();
        }
        const clientCodeKey = AUTH_SERVER_TO_CLIENT_CODE[serverErrorCode] || "INTERNAL_ERROR";
        const error3 = (0, deep_copy_1.deepCopy)(AuthClientErrorCode2[clientCodeKey]);
        error3.message = customMessage || message2 || error3.message;
        if (clientCodeKey === "INTERNAL_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error3.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseAuthError(error3);
      }
      /**
       * @param info - The error code info.
       * @param message - The error message. This will override the default message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super("auth", info3.code, message2 || info3.message);
        this.__proto__ = _FirebaseAuthError.prototype;
      }
    };
    exports.FirebaseAuthError = FirebaseAuthError2;
    var FirebaseDatabaseError2 = class extends FirebaseError {
      static {
        __name(this, "FirebaseDatabaseError");
      }
      /**
       * @param info - The error code info.
       * @param message - The error message. This will override the default
       *     message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super({ code: "database/" + info3.code, message: message2 || info3.message });
      }
    };
    exports.FirebaseDatabaseError = FirebaseDatabaseError2;
    var FirebaseFirestoreError = class extends FirebaseError {
      static {
        __name(this, "FirebaseFirestoreError");
      }
      /**
       * @param info - The error code info.
       * @param message - The error message. This will override the default
       *     message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super({ code: "firestore/" + info3.code, message: message2 || info3.message });
      }
    };
    exports.FirebaseFirestoreError = FirebaseFirestoreError;
    var FirebaseInstanceIdError = class _FirebaseInstanceIdError extends FirebaseError {
      static {
        __name(this, "FirebaseInstanceIdError");
      }
      /**
       *
       * @param info - The error code info.
       * @param message - The error message. This will override the default
       *     message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super({ code: "instance-id/" + info3.code, message: message2 || info3.message });
        this.__proto__ = _FirebaseInstanceIdError.prototype;
      }
    };
    exports.FirebaseInstanceIdError = FirebaseInstanceIdError;
    var FirebaseInstallationsError = class _FirebaseInstallationsError extends FirebaseError {
      static {
        __name(this, "FirebaseInstallationsError");
      }
      /**
       *
       * @param info - The error code info.
       * @param message - The error message. This will override the default
       *     message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super({ code: "installations/" + info3.code, message: message2 || info3.message });
        this.__proto__ = _FirebaseInstallationsError.prototype;
      }
    };
    exports.FirebaseInstallationsError = FirebaseInstallationsError;
    var FirebaseMessagingError = class _FirebaseMessagingError extends PrefixedFirebaseError {
      static {
        __name(this, "FirebaseMessagingError");
      }
      /**
       * Creates the developer-facing error corresponding to the backend error code.
       *
       * @param serverErrorCode - The server error code.
       * @param [message] The error message. The default message is used
       *     if not provided.
       * @param [rawServerResponse] The error's raw server response.
       * @returns The corresponding developer-facing error.
       * @internal
       */
      static fromServerError(serverErrorCode, message2, rawServerResponse) {
        let clientCodeKey = "UNKNOWN_ERROR";
        if (serverErrorCode && serverErrorCode in MESSAGING_SERVER_TO_CLIENT_CODE) {
          clientCodeKey = MESSAGING_SERVER_TO_CLIENT_CODE[serverErrorCode];
        }
        const error3 = (0, deep_copy_1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error3.message = message2 || error3.message;
        if (clientCodeKey === "UNKNOWN_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error3.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseMessagingError(error3);
      }
      /**
       * @internal
       */
      static fromTopicManagementServerError(serverErrorCode, message2, rawServerResponse) {
        const clientCodeKey = TOPIC_MGT_SERVER_TO_CLIENT_CODE[serverErrorCode] || "UNKNOWN_ERROR";
        const error3 = (0, deep_copy_1.deepCopy)(MessagingClientErrorCode[clientCodeKey]);
        error3.message = message2 || error3.message;
        if (clientCodeKey === "UNKNOWN_ERROR" && typeof rawServerResponse !== "undefined") {
          try {
            error3.message += ` Raw server response: "${JSON.stringify(rawServerResponse)}"`;
          } catch (e) {
          }
        }
        return new _FirebaseMessagingError(error3);
      }
      /**
       *
       * @param info - The error code info.
       * @param message - The error message. This will override the default message if provided.
       * @constructor
       * @internal
       */
      constructor(info3, message2) {
        super("messaging", info3.code, message2 || info3.message);
        this.__proto__ = _FirebaseMessagingError.prototype;
      }
    };
    exports.FirebaseMessagingError = FirebaseMessagingError;
    var FirebaseProjectManagementError = class _FirebaseProjectManagementError extends PrefixedFirebaseError {
      static {
        __name(this, "FirebaseProjectManagementError");
      }
      /**
       * @param code - The error code.
       * @param message - The error message.
       * @constructor
       * @internal
       */
      constructor(code, message2) {
        super("project-management", code, message2);
        this.__proto__ = _FirebaseProjectManagementError.prototype;
      }
    };
    exports.FirebaseProjectManagementError = FirebaseProjectManagementError;
    var AppErrorCodes2 = class {
      static {
        __name(this, "AppErrorCodes");
      }
    };
    exports.AppErrorCodes = AppErrorCodes2;
    AppErrorCodes2.APP_DELETED = "app-deleted";
    AppErrorCodes2.DUPLICATE_APP = "duplicate-app";
    AppErrorCodes2.INVALID_ARGUMENT = "invalid-argument";
    AppErrorCodes2.INTERNAL_ERROR = "internal-error";
    AppErrorCodes2.INVALID_APP_NAME = "invalid-app-name";
    AppErrorCodes2.INVALID_APP_OPTIONS = "invalid-app-options";
    AppErrorCodes2.INVALID_CREDENTIAL = "invalid-credential";
    AppErrorCodes2.NETWORK_ERROR = "network-error";
    AppErrorCodes2.NETWORK_TIMEOUT = "network-timeout";
    AppErrorCodes2.NO_APP = "no-app";
    AppErrorCodes2.UNABLE_TO_PARSE_RESPONSE = "unable-to-parse-response";
    var AuthClientErrorCode2 = class {
      static {
        __name(this, "AuthClientErrorCode");
      }
    };
    exports.AuthClientErrorCode = AuthClientErrorCode2;
    AuthClientErrorCode2.AUTH_BLOCKING_TOKEN_EXPIRED = {
      code: "auth-blocking-token-expired",
      message: "The provided Firebase Auth Blocking token is expired."
    };
    AuthClientErrorCode2.BILLING_NOT_ENABLED = {
      code: "billing-not-enabled",
      message: "Feature requires billing to be enabled."
    };
    AuthClientErrorCode2.CLAIMS_TOO_LARGE = {
      code: "claims-too-large",
      message: "Developer claims maximum payload size exceeded."
    };
    AuthClientErrorCode2.CONFIGURATION_EXISTS = {
      code: "configuration-exists",
      message: "A configuration already exists with the provided identifier."
    };
    AuthClientErrorCode2.CONFIGURATION_NOT_FOUND = {
      code: "configuration-not-found",
      message: "There is no configuration corresponding to the provided identifier."
    };
    AuthClientErrorCode2.ID_TOKEN_EXPIRED = {
      code: "id-token-expired",
      message: "The provided Firebase ID token is expired."
    };
    AuthClientErrorCode2.INVALID_ARGUMENT = {
      code: "argument-error",
      message: "Invalid argument provided."
    };
    AuthClientErrorCode2.INVALID_CONFIG = {
      code: "invalid-config",
      message: "The provided configuration is invalid."
    };
    AuthClientErrorCode2.EMAIL_ALREADY_EXISTS = {
      code: "email-already-exists",
      message: "The email address is already in use by another account."
    };
    AuthClientErrorCode2.EMAIL_NOT_FOUND = {
      code: "email-not-found",
      message: "There is no user record corresponding to the provided email."
    };
    AuthClientErrorCode2.FORBIDDEN_CLAIM = {
      code: "reserved-claim",
      message: "The specified developer claim is reserved and cannot be specified."
    };
    AuthClientErrorCode2.INVALID_ID_TOKEN = {
      code: "invalid-id-token",
      message: "The provided ID token is not a valid Firebase ID token."
    };
    AuthClientErrorCode2.ID_TOKEN_REVOKED = {
      code: "id-token-revoked",
      message: "The Firebase ID token has been revoked."
    };
    AuthClientErrorCode2.INTERNAL_ERROR = {
      code: "internal-error",
      message: "An internal error has occurred."
    };
    AuthClientErrorCode2.INVALID_CLAIMS = {
      code: "invalid-claims",
      message: "The provided custom claim attributes are invalid."
    };
    AuthClientErrorCode2.INVALID_CONTINUE_URI = {
      code: "invalid-continue-uri",
      message: "The continue URL must be a valid URL string."
    };
    AuthClientErrorCode2.INVALID_CREATION_TIME = {
      code: "invalid-creation-time",
      message: "The creation time must be a valid UTC date string."
    };
    AuthClientErrorCode2.INVALID_CREDENTIAL = {
      code: "invalid-credential",
      message: "Invalid credential object provided."
    };
    AuthClientErrorCode2.INVALID_DISABLED_FIELD = {
      code: "invalid-disabled-field",
      message: "The disabled field must be a boolean."
    };
    AuthClientErrorCode2.INVALID_DISPLAY_NAME = {
      code: "invalid-display-name",
      message: "The displayName field must be a valid string."
    };
    AuthClientErrorCode2.INVALID_DYNAMIC_LINK_DOMAIN = {
      code: "invalid-dynamic-link-domain",
      message: "The provided dynamic link domain is not configured or authorized for the current project."
    };
    AuthClientErrorCode2.INVALID_EMAIL_VERIFIED = {
      code: "invalid-email-verified",
      message: "The emailVerified field must be a boolean."
    };
    AuthClientErrorCode2.INVALID_EMAIL = {
      code: "invalid-email",
      message: "The email address is improperly formatted."
    };
    AuthClientErrorCode2.INVALID_NEW_EMAIL = {
      code: "invalid-new-email",
      message: "The new email address is improperly formatted."
    };
    AuthClientErrorCode2.INVALID_ENROLLED_FACTORS = {
      code: "invalid-enrolled-factors",
      message: "The enrolled factors must be a valid array of MultiFactorInfo objects."
    };
    AuthClientErrorCode2.INVALID_ENROLLMENT_TIME = {
      code: "invalid-enrollment-time",
      message: "The second factor enrollment time must be a valid UTC date string."
    };
    AuthClientErrorCode2.INVALID_HASH_ALGORITHM = {
      code: "invalid-hash-algorithm",
      message: "The hash algorithm must match one of the strings in the list of supported algorithms."
    };
    AuthClientErrorCode2.INVALID_HASH_BLOCK_SIZE = {
      code: "invalid-hash-block-size",
      message: "The hash block size must be a valid number."
    };
    AuthClientErrorCode2.INVALID_HASH_DERIVED_KEY_LENGTH = {
      code: "invalid-hash-derived-key-length",
      message: "The hash derived key length must be a valid number."
    };
    AuthClientErrorCode2.INVALID_HASH_KEY = {
      code: "invalid-hash-key",
      message: "The hash key must a valid byte buffer."
    };
    AuthClientErrorCode2.INVALID_HASH_MEMORY_COST = {
      code: "invalid-hash-memory-cost",
      message: "The hash memory cost must be a valid number."
    };
    AuthClientErrorCode2.INVALID_HASH_PARALLELIZATION = {
      code: "invalid-hash-parallelization",
      message: "The hash parallelization must be a valid number."
    };
    AuthClientErrorCode2.INVALID_HASH_ROUNDS = {
      code: "invalid-hash-rounds",
      message: "The hash rounds must be a valid number."
    };
    AuthClientErrorCode2.INVALID_HASH_SALT_SEPARATOR = {
      code: "invalid-hash-salt-separator",
      message: "The hashing algorithm salt separator field must be a valid byte buffer."
    };
    AuthClientErrorCode2.INVALID_LAST_SIGN_IN_TIME = {
      code: "invalid-last-sign-in-time",
      message: "The last sign-in time must be a valid UTC date string."
    };
    AuthClientErrorCode2.INVALID_NAME = {
      code: "invalid-name",
      message: "The resource name provided is invalid."
    };
    AuthClientErrorCode2.INVALID_OAUTH_CLIENT_ID = {
      code: "invalid-oauth-client-id",
      message: "The provided OAuth client ID is invalid."
    };
    AuthClientErrorCode2.INVALID_PAGE_TOKEN = {
      code: "invalid-page-token",
      message: "The page token must be a valid non-empty string."
    };
    AuthClientErrorCode2.INVALID_PASSWORD = {
      code: "invalid-password",
      message: "The password must be a string with at least 6 characters."
    };
    AuthClientErrorCode2.INVALID_PASSWORD_HASH = {
      code: "invalid-password-hash",
      message: "The password hash must be a valid byte buffer."
    };
    AuthClientErrorCode2.INVALID_PASSWORD_SALT = {
      code: "invalid-password-salt",
      message: "The password salt must be a valid byte buffer."
    };
    AuthClientErrorCode2.INVALID_PHONE_NUMBER = {
      code: "invalid-phone-number",
      message: "The phone number must be a non-empty E.164 standard compliant identifier string."
    };
    AuthClientErrorCode2.INVALID_PHOTO_URL = {
      code: "invalid-photo-url",
      message: "The photoURL field must be a valid URL."
    };
    AuthClientErrorCode2.INVALID_PROJECT_ID = {
      code: "invalid-project-id",
      message: "Invalid parent project. Either parent project doesn't exist or didn't enable multi-tenancy."
    };
    AuthClientErrorCode2.INVALID_PROVIDER_DATA = {
      code: "invalid-provider-data",
      message: "The providerData must be a valid array of UserInfo objects."
    };
    AuthClientErrorCode2.INVALID_PROVIDER_ID = {
      code: "invalid-provider-id",
      message: "The providerId must be a valid supported provider identifier string."
    };
    AuthClientErrorCode2.INVALID_PROVIDER_UID = {
      code: "invalid-provider-uid",
      message: "The providerUid must be a valid provider uid string."
    };
    AuthClientErrorCode2.INVALID_OAUTH_RESPONSETYPE = {
      code: "invalid-oauth-responsetype",
      message: "Only exactly one OAuth responseType should be set to true."
    };
    AuthClientErrorCode2.INVALID_SESSION_COOKIE_DURATION = {
      code: "invalid-session-cookie-duration",
      message: "The session cookie duration must be a valid number in milliseconds between 5 minutes and 2 weeks."
    };
    AuthClientErrorCode2.INVALID_TENANT_ID = {
      code: "invalid-tenant-id",
      message: "The tenant ID must be a valid non-empty string."
    };
    AuthClientErrorCode2.INVALID_TENANT_TYPE = {
      code: "invalid-tenant-type",
      message: 'Tenant type must be either "full_service" or "lightweight".'
    };
    AuthClientErrorCode2.INVALID_TESTING_PHONE_NUMBER = {
      code: "invalid-testing-phone-number",
      message: "Invalid testing phone number or invalid test code provided."
    };
    AuthClientErrorCode2.INVALID_UID = {
      code: "invalid-uid",
      message: "The uid must be a non-empty string with at most 128 characters."
    };
    AuthClientErrorCode2.INVALID_USER_IMPORT = {
      code: "invalid-user-import",
      message: "The user record to import is invalid."
    };
    AuthClientErrorCode2.INVALID_TOKENS_VALID_AFTER_TIME = {
      code: "invalid-tokens-valid-after-time",
      message: "The tokensValidAfterTime must be a valid UTC number in seconds."
    };
    AuthClientErrorCode2.MISMATCHING_TENANT_ID = {
      code: "mismatching-tenant-id",
      message: "User tenant ID does not match with the current TenantAwareAuth tenant ID."
    };
    AuthClientErrorCode2.MISSING_ANDROID_PACKAGE_NAME = {
      code: "missing-android-pkg-name",
      message: "An Android Package Name must be provided if the Android App is required to be installed."
    };
    AuthClientErrorCode2.MISSING_CONFIG = {
      code: "missing-config",
      message: "The provided configuration is missing required attributes."
    };
    AuthClientErrorCode2.MISSING_CONTINUE_URI = {
      code: "missing-continue-uri",
      message: "A valid continue URL must be provided in the request."
    };
    AuthClientErrorCode2.MISSING_DISPLAY_NAME = {
      code: "missing-display-name",
      message: "The resource being created or edited is missing a valid display name."
    };
    AuthClientErrorCode2.MISSING_EMAIL = {
      code: "missing-email",
      message: "The email is required for the specified action. For example, a multi-factor user requires a verified email."
    };
    AuthClientErrorCode2.MISSING_IOS_BUNDLE_ID = {
      code: "missing-ios-bundle-id",
      message: "The request is missing an iOS Bundle ID."
    };
    AuthClientErrorCode2.MISSING_ISSUER = {
      code: "missing-issuer",
      message: "The OAuth/OIDC configuration issuer must not be empty."
    };
    AuthClientErrorCode2.MISSING_HASH_ALGORITHM = {
      code: "missing-hash-algorithm",
      message: "Importing users with password hashes requires that the hashing algorithm and its parameters be provided."
    };
    AuthClientErrorCode2.MISSING_OAUTH_CLIENT_ID = {
      code: "missing-oauth-client-id",
      message: "The OAuth/OIDC configuration client ID must not be empty."
    };
    AuthClientErrorCode2.MISSING_OAUTH_CLIENT_SECRET = {
      code: "missing-oauth-client-secret",
      message: "The OAuth configuration client secret is required to enable OIDC code flow."
    };
    AuthClientErrorCode2.MISSING_PROVIDER_ID = {
      code: "missing-provider-id",
      message: "A valid provider ID must be provided in the request."
    };
    AuthClientErrorCode2.MISSING_SAML_RELYING_PARTY_CONFIG = {
      code: "missing-saml-relying-party-config",
      message: "The SAML configuration provided is missing a relying party configuration."
    };
    AuthClientErrorCode2.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED = {
      code: "test-phone-number-limit-exceeded",
      message: "The maximum allowed number of test phone number / code pairs has been exceeded."
    };
    AuthClientErrorCode2.MAXIMUM_USER_COUNT_EXCEEDED = {
      code: "maximum-user-count-exceeded",
      message: "The maximum allowed number of users to import has been exceeded."
    };
    AuthClientErrorCode2.MISSING_UID = {
      code: "missing-uid",
      message: "A uid identifier is required for the current operation."
    };
    AuthClientErrorCode2.OPERATION_NOT_ALLOWED = {
      code: "operation-not-allowed",
      message: "The given sign-in provider is disabled for this Firebase project. Enable it in the Firebase console, under the sign-in method tab of the Auth section."
    };
    AuthClientErrorCode2.PHONE_NUMBER_ALREADY_EXISTS = {
      code: "phone-number-already-exists",
      message: "The user with the provided phone number already exists."
    };
    AuthClientErrorCode2.PROJECT_NOT_FOUND = {
      code: "project-not-found",
      message: "No Firebase project was found for the provided credential."
    };
    AuthClientErrorCode2.INSUFFICIENT_PERMISSION = {
      code: "insufficient-permission",
      message: 'Credential implementation provided to initializeApp() via the "credential" property has insufficient permission to access the requested resource. See https://firebase.google.com/docs/admin/setup for details on how to authenticate this SDK with appropriate permissions.'
    };
    AuthClientErrorCode2.QUOTA_EXCEEDED = {
      code: "quota-exceeded",
      message: "The project quota for the specified operation has been exceeded."
    };
    AuthClientErrorCode2.SECOND_FACTOR_LIMIT_EXCEEDED = {
      code: "second-factor-limit-exceeded",
      message: "The maximum number of allowed second factors on a user has been exceeded."
    };
    AuthClientErrorCode2.SECOND_FACTOR_UID_ALREADY_EXISTS = {
      code: "second-factor-uid-already-exists",
      message: 'The specified second factor "uid" already exists.'
    };
    AuthClientErrorCode2.SESSION_COOKIE_EXPIRED = {
      code: "session-cookie-expired",
      message: "The Firebase session cookie is expired."
    };
    AuthClientErrorCode2.SESSION_COOKIE_REVOKED = {
      code: "session-cookie-revoked",
      message: "The Firebase session cookie has been revoked."
    };
    AuthClientErrorCode2.TENANT_NOT_FOUND = {
      code: "tenant-not-found",
      message: "There is no tenant corresponding to the provided identifier."
    };
    AuthClientErrorCode2.UID_ALREADY_EXISTS = {
      code: "uid-already-exists",
      message: "The user with the provided uid already exists."
    };
    AuthClientErrorCode2.UNAUTHORIZED_DOMAIN = {
      code: "unauthorized-continue-uri",
      message: "The domain of the continue URL is not whitelisted. Whitelist the domain in the Firebase console."
    };
    AuthClientErrorCode2.UNSUPPORTED_FIRST_FACTOR = {
      code: "unsupported-first-factor",
      message: "A multi-factor user requires a supported first factor."
    };
    AuthClientErrorCode2.UNSUPPORTED_SECOND_FACTOR = {
      code: "unsupported-second-factor",
      message: "The request specified an unsupported type of second factor."
    };
    AuthClientErrorCode2.UNSUPPORTED_TENANT_OPERATION = {
      code: "unsupported-tenant-operation",
      message: "This operation is not supported in a multi-tenant context."
    };
    AuthClientErrorCode2.UNVERIFIED_EMAIL = {
      code: "unverified-email",
      message: "A verified email is required for the specified action. For example, a multi-factor user requires a verified email."
    };
    AuthClientErrorCode2.USER_NOT_FOUND = {
      code: "user-not-found",
      message: "There is no user record corresponding to the provided identifier."
    };
    AuthClientErrorCode2.NOT_FOUND = {
      code: "not-found",
      message: "The requested resource was not found."
    };
    AuthClientErrorCode2.USER_DISABLED = {
      code: "user-disabled",
      message: "The user record is disabled."
    };
    AuthClientErrorCode2.USER_NOT_DISABLED = {
      code: "user-not-disabled",
      message: "The user must be disabled in order to bulk delete it (or you must pass force=true)."
    };
    AuthClientErrorCode2.INVALID_RECAPTCHA_ACTION = {
      code: "invalid-recaptcha-action",
      message: 'reCAPTCHA action must be "BLOCK".'
    };
    AuthClientErrorCode2.INVALID_RECAPTCHA_ENFORCEMENT_STATE = {
      code: "invalid-recaptcha-enforcement-state",
      message: 'reCAPTCHA enforcement state must be either "OFF", "AUDIT" or "ENFORCE".'
    };
    AuthClientErrorCode2.RECAPTCHA_NOT_ENABLED = {
      code: "racaptcha-not-enabled",
      message: "reCAPTCHA enterprise is not enabled."
    };
    var MessagingClientErrorCode = class {
      static {
        __name(this, "MessagingClientErrorCode");
      }
    };
    exports.MessagingClientErrorCode = MessagingClientErrorCode;
    MessagingClientErrorCode.INVALID_ARGUMENT = {
      code: "invalid-argument",
      message: "Invalid argument provided."
    };
    MessagingClientErrorCode.INVALID_RECIPIENT = {
      code: "invalid-recipient",
      message: "Invalid message recipient provided."
    };
    MessagingClientErrorCode.INVALID_PAYLOAD = {
      code: "invalid-payload",
      message: "Invalid message payload provided."
    };
    MessagingClientErrorCode.INVALID_DATA_PAYLOAD_KEY = {
      code: "invalid-data-payload-key",
      message: "The data message payload contains an invalid key. See the reference documentation for the DataMessagePayload type for restricted keys."
    };
    MessagingClientErrorCode.PAYLOAD_SIZE_LIMIT_EXCEEDED = {
      code: "payload-size-limit-exceeded",
      message: "The provided message payload exceeds the FCM size limits. See the error documentation for more details."
    };
    MessagingClientErrorCode.INVALID_OPTIONS = {
      code: "invalid-options",
      message: "Invalid message options provided."
    };
    MessagingClientErrorCode.INVALID_REGISTRATION_TOKEN = {
      code: "invalid-registration-token",
      message: "Invalid registration token provided. Make sure it matches the registration token the client app receives from registering with FCM."
    };
    MessagingClientErrorCode.REGISTRATION_TOKEN_NOT_REGISTERED = {
      code: "registration-token-not-registered",
      message: "The provided registration token is not registered. A previously valid registration token can be unregistered for a variety of reasons. See the error documentation for more details. Remove this registration token and stop using it to send messages."
    };
    MessagingClientErrorCode.MISMATCHED_CREDENTIAL = {
      code: "mismatched-credential",
      message: "The credential used to authenticate this SDK does not have permission to send messages to the device corresponding to the provided registration token. Make sure the credential and registration token both belong to the same Firebase project."
    };
    MessagingClientErrorCode.INVALID_PACKAGE_NAME = {
      code: "invalid-package-name",
      message: 'The message was addressed to a registration token whose package name does not match the provided "restrictedPackageName" option.'
    };
    MessagingClientErrorCode.DEVICE_MESSAGE_RATE_EXCEEDED = {
      code: "device-message-rate-exceeded",
      message: "The rate of messages to a particular device is too high. Reduce the number of messages sent to this device and do not immediately retry sending to this device."
    };
    MessagingClientErrorCode.TOPICS_MESSAGE_RATE_EXCEEDED = {
      code: "topics-message-rate-exceeded",
      message: "The rate of messages to subscribers to a particular topic is too high. Reduce the number of messages sent for this topic, and do not immediately retry sending to this topic."
    };
    MessagingClientErrorCode.MESSAGE_RATE_EXCEEDED = {
      code: "message-rate-exceeded",
      message: "Sending limit exceeded for the message target."
    };
    MessagingClientErrorCode.THIRD_PARTY_AUTH_ERROR = {
      code: "third-party-auth-error",
      message: "A message targeted to an iOS device could not be sent because the required APNs SSL certificate was not uploaded or has expired. Check the validity of your development and production certificates."
    };
    MessagingClientErrorCode.TOO_MANY_TOPICS = {
      code: "too-many-topics",
      message: "The maximum number of topics the provided registration token can be subscribed to has been exceeded."
    };
    MessagingClientErrorCode.AUTHENTICATION_ERROR = {
      code: "authentication-error",
      message: "An error occurred when trying to authenticate to the FCM servers. Make sure the credential used to authenticate this SDK has the proper permissions. See https://firebase.google.com/docs/admin/setup for setup instructions."
    };
    MessagingClientErrorCode.SERVER_UNAVAILABLE = {
      code: "server-unavailable",
      message: "The FCM server could not process the request in time. See the error documentation for more details."
    };
    MessagingClientErrorCode.INTERNAL_ERROR = {
      code: "internal-error",
      message: "An internal error has occurred. Please retry the request."
    };
    MessagingClientErrorCode.UNKNOWN_ERROR = {
      code: "unknown-error",
      message: "An unknown server error was returned."
    };
    var InstallationsClientErrorCode = class {
      static {
        __name(this, "InstallationsClientErrorCode");
      }
    };
    exports.InstallationsClientErrorCode = InstallationsClientErrorCode;
    InstallationsClientErrorCode.INVALID_ARGUMENT = {
      code: "invalid-argument",
      message: "Invalid argument provided."
    };
    InstallationsClientErrorCode.INVALID_PROJECT_ID = {
      code: "invalid-project-id",
      message: "Invalid project ID provided."
    };
    InstallationsClientErrorCode.INVALID_INSTALLATION_ID = {
      code: "invalid-installation-id",
      message: "Invalid installation ID provided."
    };
    InstallationsClientErrorCode.API_ERROR = {
      code: "api-error",
      message: "Installation ID API call failed."
    };
    var InstanceIdClientErrorCode = class extends InstallationsClientErrorCode {
      static {
        __name(this, "InstanceIdClientErrorCode");
      }
    };
    exports.InstanceIdClientErrorCode = InstanceIdClientErrorCode;
    InstanceIdClientErrorCode.INVALID_INSTANCE_ID = {
      code: "invalid-instance-id",
      message: "Invalid instance ID provided."
    };
    var AUTH_SERVER_TO_CLIENT_CODE = {
      // Feature being configured or used requires a billing account.
      BILLING_NOT_ENABLED: "BILLING_NOT_ENABLED",
      // Claims payload is too large.
      CLAIMS_TOO_LARGE: "CLAIMS_TOO_LARGE",
      // Configuration being added already exists.
      CONFIGURATION_EXISTS: "CONFIGURATION_EXISTS",
      // Configuration not found.
      CONFIGURATION_NOT_FOUND: "CONFIGURATION_NOT_FOUND",
      // Provided credential has insufficient permissions.
      INSUFFICIENT_PERMISSION: "INSUFFICIENT_PERMISSION",
      // Provided configuration has invalid fields.
      INVALID_CONFIG: "INVALID_CONFIG",
      // Provided configuration identifier is invalid.
      INVALID_CONFIG_ID: "INVALID_PROVIDER_ID",
      // ActionCodeSettings missing continue URL.
      INVALID_CONTINUE_URI: "INVALID_CONTINUE_URI",
      // Dynamic link domain in provided ActionCodeSettings is not authorized.
      INVALID_DYNAMIC_LINK_DOMAIN: "INVALID_DYNAMIC_LINK_DOMAIN",
      // uploadAccount provides an email that already exists.
      DUPLICATE_EMAIL: "EMAIL_ALREADY_EXISTS",
      // uploadAccount provides a localId that already exists.
      DUPLICATE_LOCAL_ID: "UID_ALREADY_EXISTS",
      // Request specified a multi-factor enrollment ID that already exists.
      DUPLICATE_MFA_ENROLLMENT_ID: "SECOND_FACTOR_UID_ALREADY_EXISTS",
      // setAccountInfo email already exists.
      EMAIL_EXISTS: "EMAIL_ALREADY_EXISTS",
      // /accounts:sendOobCode for password reset when user is not found.
      EMAIL_NOT_FOUND: "EMAIL_NOT_FOUND",
      // Reserved claim name.
      FORBIDDEN_CLAIM: "FORBIDDEN_CLAIM",
      // Invalid claims provided.
      INVALID_CLAIMS: "INVALID_CLAIMS",
      // Invalid session cookie duration.
      INVALID_DURATION: "INVALID_SESSION_COOKIE_DURATION",
      // Invalid email provided.
      INVALID_EMAIL: "INVALID_EMAIL",
      // Invalid new email provided.
      INVALID_NEW_EMAIL: "INVALID_NEW_EMAIL",
      // Invalid tenant display name. This can be thrown on CreateTenant and UpdateTenant.
      INVALID_DISPLAY_NAME: "INVALID_DISPLAY_NAME",
      // Invalid ID token provided.
      INVALID_ID_TOKEN: "INVALID_ID_TOKEN",
      // Invalid tenant/parent resource name.
      INVALID_NAME: "INVALID_NAME",
      // OIDC configuration has an invalid OAuth client ID.
      INVALID_OAUTH_CLIENT_ID: "INVALID_OAUTH_CLIENT_ID",
      // Invalid page token.
      INVALID_PAGE_SELECTION: "INVALID_PAGE_TOKEN",
      // Invalid phone number.
      INVALID_PHONE_NUMBER: "INVALID_PHONE_NUMBER",
      // Invalid agent project. Either agent project doesn't exist or didn't enable multi-tenancy.
      INVALID_PROJECT_ID: "INVALID_PROJECT_ID",
      // Invalid provider ID.
      INVALID_PROVIDER_ID: "INVALID_PROVIDER_ID",
      // Invalid service account.
      INVALID_SERVICE_ACCOUNT: "INVALID_SERVICE_ACCOUNT",
      // Invalid testing phone number.
      INVALID_TESTING_PHONE_NUMBER: "INVALID_TESTING_PHONE_NUMBER",
      // Invalid tenant type.
      INVALID_TENANT_TYPE: "INVALID_TENANT_TYPE",
      // Missing Android package name.
      MISSING_ANDROID_PACKAGE_NAME: "MISSING_ANDROID_PACKAGE_NAME",
      // Missing configuration.
      MISSING_CONFIG: "MISSING_CONFIG",
      // Missing configuration identifier.
      MISSING_CONFIG_ID: "MISSING_PROVIDER_ID",
      // Missing tenant display name: This can be thrown on CreateTenant and UpdateTenant.
      MISSING_DISPLAY_NAME: "MISSING_DISPLAY_NAME",
      // Email is required for the specified action. For example a multi-factor user requires
      // a verified email.
      MISSING_EMAIL: "MISSING_EMAIL",
      // Missing iOS bundle ID.
      MISSING_IOS_BUNDLE_ID: "MISSING_IOS_BUNDLE_ID",
      // Missing OIDC issuer.
      MISSING_ISSUER: "MISSING_ISSUER",
      // No localId provided (deleteAccount missing localId).
      MISSING_LOCAL_ID: "MISSING_UID",
      // OIDC configuration is missing an OAuth client ID.
      MISSING_OAUTH_CLIENT_ID: "MISSING_OAUTH_CLIENT_ID",
      // Missing provider ID.
      MISSING_PROVIDER_ID: "MISSING_PROVIDER_ID",
      // Missing SAML RP config.
      MISSING_SAML_RELYING_PARTY_CONFIG: "MISSING_SAML_RELYING_PARTY_CONFIG",
      // Empty user list in uploadAccount.
      MISSING_USER_ACCOUNT: "MISSING_UID",
      // Password auth disabled in console.
      OPERATION_NOT_ALLOWED: "OPERATION_NOT_ALLOWED",
      // Provided credential has insufficient permissions.
      PERMISSION_DENIED: "INSUFFICIENT_PERMISSION",
      // Phone number already exists.
      PHONE_NUMBER_EXISTS: "PHONE_NUMBER_ALREADY_EXISTS",
      // Project not found.
      PROJECT_NOT_FOUND: "PROJECT_NOT_FOUND",
      // In multi-tenancy context: project creation quota exceeded.
      QUOTA_EXCEEDED: "QUOTA_EXCEEDED",
      // Currently only 5 second factors can be set on the same user.
      SECOND_FACTOR_LIMIT_EXCEEDED: "SECOND_FACTOR_LIMIT_EXCEEDED",
      // Tenant not found.
      TENANT_NOT_FOUND: "TENANT_NOT_FOUND",
      // Tenant ID mismatch.
      TENANT_ID_MISMATCH: "MISMATCHING_TENANT_ID",
      // Token expired error.
      TOKEN_EXPIRED: "ID_TOKEN_EXPIRED",
      // Continue URL provided in ActionCodeSettings has a domain that is not whitelisted.
      UNAUTHORIZED_DOMAIN: "UNAUTHORIZED_DOMAIN",
      // A multi-factor user requires a supported first factor.
      UNSUPPORTED_FIRST_FACTOR: "UNSUPPORTED_FIRST_FACTOR",
      // The request specified an unsupported type of second factor.
      UNSUPPORTED_SECOND_FACTOR: "UNSUPPORTED_SECOND_FACTOR",
      // Operation is not supported in a multi-tenant context.
      UNSUPPORTED_TENANT_OPERATION: "UNSUPPORTED_TENANT_OPERATION",
      // A verified email is required for the specified action. For example a multi-factor user
      // requires a verified email.
      UNVERIFIED_EMAIL: "UNVERIFIED_EMAIL",
      // User on which action is to be performed is not found.
      USER_NOT_FOUND: "USER_NOT_FOUND",
      // User record is disabled.
      USER_DISABLED: "USER_DISABLED",
      // Password provided is too weak.
      WEAK_PASSWORD: "INVALID_PASSWORD",
      // Unrecognized reCAPTCHA action.
      INVALID_RECAPTCHA_ACTION: "INVALID_RECAPTCHA_ACTION",
      // Unrecognized reCAPTCHA enforcement state.
      INVALID_RECAPTCHA_ENFORCEMENT_STATE: "INVALID_RECAPTCHA_ENFORCEMENT_STATE",
      // reCAPTCHA is not enabled for account defender.
      RECAPTCHA_NOT_ENABLED: "RECAPTCHA_NOT_ENABLED"
    };
    var MESSAGING_SERVER_TO_CLIENT_CODE = {
      /* GENERIC ERRORS */
      // Generic invalid message parameter provided.
      InvalidParameters: "INVALID_ARGUMENT",
      // Mismatched sender ID.
      MismatchSenderId: "MISMATCHED_CREDENTIAL",
      // FCM server unavailable.
      Unavailable: "SERVER_UNAVAILABLE",
      // FCM server internal error.
      InternalServerError: "INTERNAL_ERROR",
      /* SEND ERRORS */
      // Invalid registration token format.
      InvalidRegistration: "INVALID_REGISTRATION_TOKEN",
      // Registration token is not registered.
      NotRegistered: "REGISTRATION_TOKEN_NOT_REGISTERED",
      // Registration token does not match restricted package name.
      InvalidPackageName: "INVALID_PACKAGE_NAME",
      // Message payload size limit exceeded.
      MessageTooBig: "PAYLOAD_SIZE_LIMIT_EXCEEDED",
      // Invalid key in the data message payload.
      InvalidDataKey: "INVALID_DATA_PAYLOAD_KEY",
      // Invalid time to live option.
      InvalidTtl: "INVALID_OPTIONS",
      // Device message rate exceeded.
      DeviceMessageRateExceeded: "DEVICE_MESSAGE_RATE_EXCEEDED",
      // Topics message rate exceeded.
      TopicsMessageRateExceeded: "TOPICS_MESSAGE_RATE_EXCEEDED",
      // Invalid APNs credentials.
      InvalidApnsCredential: "THIRD_PARTY_AUTH_ERROR",
      /* FCM v1 canonical error codes */
      NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
      PERMISSION_DENIED: "MISMATCHED_CREDENTIAL",
      RESOURCE_EXHAUSTED: "MESSAGE_RATE_EXCEEDED",
      UNAUTHENTICATED: "THIRD_PARTY_AUTH_ERROR",
      /* FCM v1 new error codes */
      APNS_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
      INTERNAL: "INTERNAL_ERROR",
      INVALID_ARGUMENT: "INVALID_ARGUMENT",
      QUOTA_EXCEEDED: "MESSAGE_RATE_EXCEEDED",
      SENDER_ID_MISMATCH: "MISMATCHED_CREDENTIAL",
      THIRD_PARTY_AUTH_ERROR: "THIRD_PARTY_AUTH_ERROR",
      UNAVAILABLE: "SERVER_UNAVAILABLE",
      UNREGISTERED: "REGISTRATION_TOKEN_NOT_REGISTERED",
      UNSPECIFIED_ERROR: "UNKNOWN_ERROR"
    };
    var TOPIC_MGT_SERVER_TO_CLIENT_CODE = {
      /* TOPIC SUBSCRIPTION MANAGEMENT ERRORS */
      NOT_FOUND: "REGISTRATION_TOKEN_NOT_REGISTERED",
      INVALID_ARGUMENT: "INVALID_REGISTRATION_TOKEN",
      TOO_MANY_TOPICS: "TOO_MANY_TOPICS",
      RESOURCE_EXHAUSTED: "TOO_MANY_TOPICS",
      PERMISSION_DENIED: "AUTHENTICATION_ERROR",
      DEADLINE_EXCEEDED: "SERVER_UNAVAILABLE",
      INTERNAL: "INTERNAL_ERROR",
      UNKNOWN: "UNKNOWN_ERROR"
    };
  }
});

// node_modules/firebase-admin/lib/utils/validator.js
var require_validator = __commonJS({
  "node_modules/firebase-admin/lib/utils/validator.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isBuffer = isBuffer2;
    exports.isArray = isArray2;
    exports.isNonEmptyArray = isNonEmptyArray;
    exports.isBoolean = isBoolean2;
    exports.isNumber = isNumber2;
    exports.isString = isString2;
    exports.isBase64String = isBase64String;
    exports.isNonEmptyString = isNonEmptyString;
    exports.isObject = isObject3;
    exports.isNonNullObject = isNonNullObject;
    exports.isUid = isUid;
    exports.isPassword = isPassword;
    exports.isEmail = isEmail;
    exports.isPhoneNumber = isPhoneNumber;
    exports.isISODateString = isISODateString;
    exports.isUTCDateString = isUTCDateString;
    exports.isURL = isURL;
    exports.isTopic = isTopic;
    exports.isTaskId = isTaskId;
    var url = require_url();
    function isBuffer2(value) {
      return value instanceof Buffer;
    }
    __name(isBuffer2, "isBuffer");
    function isArray2(value) {
      return Array.isArray(value);
    }
    __name(isArray2, "isArray");
    function isNonEmptyArray(value) {
      return isArray2(value) && value.length !== 0;
    }
    __name(isNonEmptyArray, "isNonEmptyArray");
    function isBoolean2(value) {
      return typeof value === "boolean";
    }
    __name(isBoolean2, "isBoolean");
    function isNumber2(value) {
      return typeof value === "number" && !isNaN(value);
    }
    __name(isNumber2, "isNumber");
    function isString2(value) {
      return typeof value === "string";
    }
    __name(isString2, "isString");
    function isBase64String(value) {
      if (!isString2(value)) {
        return false;
      }
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(value);
    }
    __name(isBase64String, "isBase64String");
    function isNonEmptyString(value) {
      return isString2(value) && value !== "";
    }
    __name(isNonEmptyString, "isNonEmptyString");
    function isObject3(value) {
      return typeof value === "object" && !isArray2(value);
    }
    __name(isObject3, "isObject");
    function isNonNullObject(value) {
      return isObject3(value) && value !== null;
    }
    __name(isNonNullObject, "isNonNullObject");
    function isUid(uid) {
      return typeof uid === "string" && uid.length > 0 && uid.length <= 128;
    }
    __name(isUid, "isUid");
    function isPassword(password) {
      return typeof password === "string" && password.length >= 6;
    }
    __name(isPassword, "isPassword");
    function isEmail(email) {
      if (typeof email !== "string") {
        return false;
      }
      const re = /^[^@]+@[^@]+$/;
      return re.test(email);
    }
    __name(isEmail, "isEmail");
    function isPhoneNumber(phoneNumber) {
      if (typeof phoneNumber !== "string") {
        return false;
      }
      const re1 = /^\+/;
      const re2 = /[\da-zA-Z]+/;
      return re1.test(phoneNumber) && re2.test(phoneNumber);
    }
    __name(isPhoneNumber, "isPhoneNumber");
    function isISODateString(dateString) {
      try {
        return isNonEmptyString(dateString) && new Date(dateString).toISOString() === dateString;
      } catch (e) {
        return false;
      }
    }
    __name(isISODateString, "isISODateString");
    function isUTCDateString(dateString) {
      try {
        return isNonEmptyString(dateString) && new Date(dateString).toUTCString() === dateString;
      } catch (e) {
        return false;
      }
    }
    __name(isUTCDateString, "isUTCDateString");
    function isURL(urlStr) {
      if (typeof urlStr !== "string") {
        return false;
      }
      const re = /[^a-z0-9:/?#[\]@!$&'()*+,;=.\-_~%]/i;
      if (re.test(urlStr)) {
        return false;
      }
      try {
        const uri = url.parse(urlStr);
        const scheme = uri.protocol;
        const slashes = uri.slashes;
        const hostname2 = uri.hostname;
        const pathname = uri.pathname;
        if (scheme !== "http:" && scheme !== "https:" || !slashes) {
          return false;
        }
        if (!hostname2 || !/^[a-zA-Z0-9]+[\w-]*([.]?[a-zA-Z0-9]+[\w-]*)*$/.test(hostname2)) {
          return false;
        }
        const pathnameRe = /^(\/[\w\-.~!$'()*+,;=:@%]+)*\/?$/;
        if (pathname && pathname !== "/" && !pathnameRe.test(pathname)) {
          return false;
        }
      } catch (e) {
        return false;
      }
      return true;
    }
    __name(isURL, "isURL");
    function isTopic(topic) {
      if (typeof topic !== "string") {
        return false;
      }
      const VALID_TOPIC_REGEX = /^(\/topics\/)?(private\/)?[a-zA-Z0-9-_.~%]+$/;
      return VALID_TOPIC_REGEX.test(topic);
    }
    __name(isTopic, "isTopic");
    function isTaskId(taskId) {
      if (typeof taskId !== "string") {
        return false;
      }
      const VALID_TASK_ID_REGEX = /^[A-Za-z0-9_-]+$/;
      return VALID_TASK_ID_REGEX.test(taskId);
    }
    __name(isTaskId, "isTaskId");
  }
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS({
  "node_modules/node-forge/lib/forge.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      // default options
      options: {
        usePureJavaScript: false
      }
    };
  }
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS({
  "node_modules/node-forge/lib/baseN.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var api = {};
    module.exports = api;
    var _reverseAlphabets = {};
    api.encode = function(input, alphabet, maxline) {
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      if (maxline !== void 0 && typeof maxline !== "number") {
        throw new TypeError('"maxline" must be a number.');
      }
      var output = "";
      if (!(input instanceof Uint8Array)) {
        output = _encodeWithByteBuffer(input, alphabet);
      } else {
        var i = 0;
        var base = alphabet.length;
        var first = alphabet.charAt(0);
        var digits = [0];
        for (i = 0; i < input.length; ++i) {
          for (var j = 0, carry = input[i]; j < digits.length; ++j) {
            carry += digits[j] << 8;
            digits[j] = carry % base;
            carry = carry / base | 0;
          }
          while (carry > 0) {
            digits.push(carry % base);
            carry = carry / base | 0;
          }
        }
        for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
          output += first;
        }
        for (i = digits.length - 1; i >= 0; --i) {
          output += alphabet[digits[i]];
        }
      }
      if (maxline) {
        var regex = new RegExp(".{1," + maxline + "}", "g");
        output = output.match(regex).join("\r\n");
      }
      return output;
    };
    api.decode = function(input, alphabet) {
      if (typeof input !== "string") {
        throw new TypeError('"input" must be a string.');
      }
      if (typeof alphabet !== "string") {
        throw new TypeError('"alphabet" must be a string.');
      }
      var table3 = _reverseAlphabets[alphabet];
      if (!table3) {
        table3 = _reverseAlphabets[alphabet] = [];
        for (var i = 0; i < alphabet.length; ++i) {
          table3[alphabet.charCodeAt(i)] = i;
        }
      }
      input = input.replace(/\s/g, "");
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var bytes = [0];
      for (var i = 0; i < input.length; i++) {
        var value = table3[input.charCodeAt(i)];
        if (value === void 0) {
          return;
        }
        for (var j = 0, carry = value; j < bytes.length; ++j) {
          carry += bytes[j] * base;
          bytes[j] = carry & 255;
          carry >>= 8;
        }
        while (carry > 0) {
          bytes.push(carry & 255);
          carry >>= 8;
        }
      }
      for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
        bytes.push(0);
      }
      if (typeof Buffer !== "undefined") {
        return Buffer.from(bytes.reverse());
      }
      return new Uint8Array(bytes.reverse());
    };
    function _encodeWithByteBuffer(input, alphabet) {
      var i = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length(); ++i) {
        for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      var output = "";
      for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
      return output;
    }
    __name(_encodeWithByteBuffer, "_encodeWithByteBuffer");
  }
});

// node_modules/node-forge/lib/util.js
var require_util4 = __commonJS({
  "node_modules/node-forge/lib/util.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    var baseN = require_baseN();
    var util = module.exports = forge.util = forge.util || {};
    (function() {
      if (typeof process !== "undefined" && process.nextTick && !process.browser) {
        util.nextTick = process.nextTick;
        if (typeof setImmediate === "function") {
          util.setImmediate = setImmediate;
        } else {
          util.setImmediate = util.nextTick;
        }
        return;
      }
      if (typeof setImmediate === "function") {
        util.setImmediate = function() {
          return setImmediate.apply(void 0, arguments);
        };
        util.nextTick = function(callback) {
          return setImmediate(callback);
        };
        return;
      }
      util.setImmediate = function(callback) {
        setTimeout(callback, 0);
      };
      if (typeof window !== "undefined" && typeof window.postMessage === "function") {
        let handler2 = function(event) {
          if (event.source === window && event.data === msg) {
            event.stopPropagation();
            var copy = callbacks.slice();
            callbacks.length = 0;
            copy.forEach(function(callback) {
              callback();
            });
          }
        };
        var handler = handler2;
        __name(handler2, "handler");
        var msg = "forge.setImmediate";
        var callbacks = [];
        util.setImmediate = function(callback) {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            window.postMessage(msg, "*");
          }
        };
        window.addEventListener("message", handler2, true);
      }
      if (typeof MutationObserver !== "undefined") {
        var now = Date.now();
        var attr = true;
        var div = document.createElement("div");
        var callbacks = [];
        new MutationObserver(function() {
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }).observe(div, { attributes: true });
        var oldSetImmediate = util.setImmediate;
        util.setImmediate = function(callback) {
          if (Date.now() - now > 15) {
            now = Date.now();
            oldSetImmediate(callback);
          } else {
            callbacks.push(callback);
            if (callbacks.length === 1) {
              div.setAttribute("a", attr = !attr);
            }
          }
        };
      }
      util.nextTick = util.setImmediate;
    })();
    util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
    util.globalScope = function() {
      if (util.isNodejs) {
        return global;
      }
      return typeof self === "undefined" ? window : self;
    }();
    util.isArray = Array.isArray || function(x) {
      return Object.prototype.toString.call(x) === "[object Array]";
    };
    util.isArrayBuffer = function(x) {
      return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
    };
    util.isArrayBufferView = function(x) {
      return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
    };
    function _checkBitsParam(n) {
      if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
        throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
      }
    }
    __name(_checkBitsParam, "_checkBitsParam");
    util.ByteBuffer = ByteStringBuffer;
    function ByteStringBuffer(b2) {
      this.data = "";
      this.read = 0;
      if (typeof b2 === "string") {
        this.data = b2;
      } else if (util.isArrayBuffer(b2) || util.isArrayBufferView(b2)) {
        if (typeof Buffer !== "undefined" && b2 instanceof Buffer) {
          this.data = b2.toString("binary");
        } else {
          var arr = new Uint8Array(b2);
          try {
            this.data = String.fromCharCode.apply(null, arr);
          } catch (e) {
            for (var i = 0; i < arr.length; ++i) {
              this.putByte(arr[i]);
            }
          }
        }
      } else if (b2 instanceof ByteStringBuffer || typeof b2 === "object" && typeof b2.data === "string" && typeof b2.read === "number") {
        this.data = b2.data;
        this.read = b2.read;
      }
      this._constructedStringLength = 0;
    }
    __name(ByteStringBuffer, "ByteStringBuffer");
    util.ByteStringBuffer = ByteStringBuffer;
    var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
    util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
      this._constructedStringLength += x;
      if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
        this.data.substr(0, 1);
        this._constructedStringLength = 0;
      }
    };
    util.ByteStringBuffer.prototype.length = function() {
      return this.data.length - this.read;
    };
    util.ByteStringBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.ByteStringBuffer.prototype.putByte = function(b2) {
      return this.putBytes(String.fromCharCode(b2));
    };
    util.ByteStringBuffer.prototype.fillWithByte = function(b2, n) {
      b2 = String.fromCharCode(b2);
      var d2 = this.data;
      while (n > 0) {
        if (n & 1) {
          d2 += b2;
        }
        n >>>= 1;
        if (n > 0) {
          b2 += b2;
        }
      }
      this.data = d2;
      this._optimizeConstructedString(n);
      return this;
    };
    util.ByteStringBuffer.prototype.putBytes = function(bytes) {
      this.data += bytes;
      this._optimizeConstructedString(bytes.length);
      return this;
    };
    util.ByteStringBuffer.prototype.putString = function(str) {
      return this.putBytes(util.encodeUtf8(str));
    };
    util.ByteStringBuffer.prototype.putInt16 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32 = function(i) {
      return this.putBytes(
        String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt16Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt24Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt32Le = function(i) {
      return this.putBytes(
        String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
      );
    };
    util.ByteStringBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      var bytes = "";
      do {
        n -= 8;
        bytes += String.fromCharCode(i >> n & 255);
      } while (n > 0);
      return this.putBytes(bytes);
    };
    util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
      return this.putBytes(buffer.getBytes());
    };
    util.ByteStringBuffer.prototype.getByte = function() {
      return this.data.charCodeAt(this.read++);
    };
    util.ByteStringBuffer.prototype.getInt16 = function() {
      var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24 = function() {
      var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32 = function() {
      var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt16Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
      this.read += 2;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt24Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
      this.read += 3;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt32Le = function() {
      var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
      this.read += 4;
      return rval;
    };
    util.ByteStringBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.charCodeAt(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.ByteStringBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.ByteStringBuffer.prototype.getBytes = function(count3) {
      var rval;
      if (count3) {
        count3 = Math.min(this.length(), count3);
        rval = this.data.slice(this.read, this.read + count3);
        this.read += count3;
      } else if (count3 === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.bytes = function(count3) {
      return typeof count3 === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count3);
    };
    util.ByteStringBuffer.prototype.at = function(i) {
      return this.data.charCodeAt(this.read + i);
    };
    util.ByteStringBuffer.prototype.setAt = function(i, b2) {
      this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b2) + this.data.substr(this.read + i + 1);
      return this;
    };
    util.ByteStringBuffer.prototype.last = function() {
      return this.data.charCodeAt(this.data.length - 1);
    };
    util.ByteStringBuffer.prototype.copy = function() {
      var c = util.createBuffer(this.data);
      c.read = this.read;
      return c;
    };
    util.ByteStringBuffer.prototype.compact = function() {
      if (this.read > 0) {
        this.data = this.data.slice(this.read);
        this.read = 0;
      }
      return this;
    };
    util.ByteStringBuffer.prototype.clear = function() {
      this.data = "";
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.truncate = function(count3) {
      var len = Math.max(0, this.length() - count3);
      this.data = this.data.substr(this.read, len);
      this.read = 0;
      return this;
    };
    util.ByteStringBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.length; ++i) {
        var b2 = this.data.charCodeAt(i);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.ByteStringBuffer.prototype.toString = function() {
      return util.decodeUtf8(this.bytes());
    };
    function DataBuffer(b2, options) {
      options = options || {};
      this.read = options.readOffset || 0;
      this.growSize = options.growSize || 1024;
      var isArrayBuffer = util.isArrayBuffer(b2);
      var isArrayBufferView = util.isArrayBufferView(b2);
      if (isArrayBuffer || isArrayBufferView) {
        if (isArrayBuffer) {
          this.data = new DataView(b2);
        } else {
          this.data = new DataView(b2.buffer, b2.byteOffset, b2.byteLength);
        }
        this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
        return;
      }
      this.data = new DataView(new ArrayBuffer(0));
      this.write = 0;
      if (b2 !== null && b2 !== void 0) {
        this.putBytes(b2);
      }
      if ("writeOffset" in options) {
        this.write = options.writeOffset;
      }
    }
    __name(DataBuffer, "DataBuffer");
    util.DataBuffer = DataBuffer;
    util.DataBuffer.prototype.length = function() {
      return this.write - this.read;
    };
    util.DataBuffer.prototype.isEmpty = function() {
      return this.length() <= 0;
    };
    util.DataBuffer.prototype.accommodate = function(amount, growSize) {
      if (this.length() >= amount) {
        return this;
      }
      growSize = Math.max(growSize || this.growSize, amount);
      var src = new Uint8Array(
        this.data.buffer,
        this.data.byteOffset,
        this.data.byteLength
      );
      var dst = new Uint8Array(this.length() + growSize);
      dst.set(src);
      this.data = new DataView(dst.buffer);
      return this;
    };
    util.DataBuffer.prototype.putByte = function(b2) {
      this.accommodate(1);
      this.data.setUint8(this.write++, b2);
      return this;
    };
    util.DataBuffer.prototype.fillWithByte = function(b2, n) {
      this.accommodate(n);
      for (var i = 0; i < n; ++i) {
        this.data.setUint8(b2);
      }
      return this;
    };
    util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
      if (util.isArrayBufferView(bytes)) {
        var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
        var len = src.byteLength - src.byteOffset;
        this.accommodate(len);
        var dst = new Uint8Array(this.data.buffer, this.write);
        dst.set(src);
        this.write += len;
        return this;
      }
      if (util.isArrayBuffer(bytes)) {
        var src = new Uint8Array(bytes);
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(this.data.buffer);
        dst.set(src, this.write);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
        var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
        this.accommodate(src.byteLength);
        var dst = new Uint8Array(bytes.data.byteLength, this.write);
        dst.set(src);
        this.write += src.byteLength;
        return this;
      }
      if (bytes instanceof util.ByteStringBuffer) {
        bytes = bytes.data;
        encoding = "binary";
      }
      encoding = encoding || "binary";
      if (typeof bytes === "string") {
        var view;
        if (encoding === "hex") {
          this.accommodate(Math.ceil(bytes.length / 2));
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.hex.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "base64") {
          this.accommodate(Math.ceil(bytes.length / 4) * 3);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.base64.decode(bytes, view, this.write);
          return this;
        }
        if (encoding === "utf8") {
          bytes = util.encodeUtf8(bytes);
          encoding = "binary";
        }
        if (encoding === "binary" || encoding === "raw") {
          this.accommodate(bytes.length);
          view = new Uint8Array(this.data.buffer, this.write);
          this.write += util.binary.raw.decode(view);
          return this;
        }
        if (encoding === "utf16") {
          this.accommodate(bytes.length * 2);
          view = new Uint16Array(this.data.buffer, this.write);
          this.write += util.text.utf16.encode(view);
          return this;
        }
        throw new Error("Invalid encoding: " + encoding);
      }
      throw Error("Invalid parameter: " + bytes);
    };
    util.DataBuffer.prototype.putBuffer = function(buffer) {
      this.putBytes(buffer);
      buffer.clear();
      return this;
    };
    util.DataBuffer.prototype.putString = function(str) {
      return this.putBytes(str, "utf16");
    };
    util.DataBuffer.prototype.putInt16 = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24 = function(i) {
      this.accommodate(3);
      this.data.setInt16(this.write, i >> 8 & 65535);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32 = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt16Le = function(i) {
      this.accommodate(2);
      this.data.setInt16(this.write, i, true);
      this.write += 2;
      return this;
    };
    util.DataBuffer.prototype.putInt24Le = function(i) {
      this.accommodate(3);
      this.data.setInt8(this.write, i >> 16 & 255);
      this.data.setInt16(this.write, i >> 8 & 65535, true);
      this.write += 3;
      return this;
    };
    util.DataBuffer.prototype.putInt32Le = function(i) {
      this.accommodate(4);
      this.data.setInt32(this.write, i, true);
      this.write += 4;
      return this;
    };
    util.DataBuffer.prototype.putInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      do {
        n -= 8;
        this.data.setInt8(this.write++, i >> n & 255);
      } while (n > 0);
      return this;
    };
    util.DataBuffer.prototype.putSignedInt = function(i, n) {
      _checkBitsParam(n);
      this.accommodate(n / 8);
      if (i < 0) {
        i += 2 << n - 1;
      }
      return this.putInt(i, n);
    };
    util.DataBuffer.prototype.getByte = function() {
      return this.data.getInt8(this.read++);
    };
    util.DataBuffer.prototype.getInt16 = function() {
      var rval = this.data.getInt16(this.read);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24 = function() {
      var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32 = function() {
      var rval = this.data.getInt32(this.read);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt16Le = function() {
      var rval = this.data.getInt16(this.read, true);
      this.read += 2;
      return rval;
    };
    util.DataBuffer.prototype.getInt24Le = function() {
      var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
      this.read += 3;
      return rval;
    };
    util.DataBuffer.prototype.getInt32Le = function() {
      var rval = this.data.getInt32(this.read, true);
      this.read += 4;
      return rval;
    };
    util.DataBuffer.prototype.getInt = function(n) {
      _checkBitsParam(n);
      var rval = 0;
      do {
        rval = (rval << 8) + this.data.getInt8(this.read++);
        n -= 8;
      } while (n > 0);
      return rval;
    };
    util.DataBuffer.prototype.getSignedInt = function(n) {
      var x = this.getInt(n);
      var max = 2 << n - 2;
      if (x >= max) {
        x -= max << 1;
      }
      return x;
    };
    util.DataBuffer.prototype.getBytes = function(count3) {
      var rval;
      if (count3) {
        count3 = Math.min(this.length(), count3);
        rval = this.data.slice(this.read, this.read + count3);
        this.read += count3;
      } else if (count3 === 0) {
        rval = "";
      } else {
        rval = this.read === 0 ? this.data : this.data.slice(this.read);
        this.clear();
      }
      return rval;
    };
    util.DataBuffer.prototype.bytes = function(count3) {
      return typeof count3 === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count3);
    };
    util.DataBuffer.prototype.at = function(i) {
      return this.data.getUint8(this.read + i);
    };
    util.DataBuffer.prototype.setAt = function(i, b2) {
      this.data.setUint8(i, b2);
      return this;
    };
    util.DataBuffer.prototype.last = function() {
      return this.data.getUint8(this.write - 1);
    };
    util.DataBuffer.prototype.copy = function() {
      return new util.DataBuffer(this);
    };
    util.DataBuffer.prototype.compact = function() {
      if (this.read > 0) {
        var src = new Uint8Array(this.data.buffer, this.read);
        var dst = new Uint8Array(src.byteLength);
        dst.set(src);
        this.data = new DataView(dst);
        this.write -= this.read;
        this.read = 0;
      }
      return this;
    };
    util.DataBuffer.prototype.clear = function() {
      this.data = new DataView(new ArrayBuffer(0));
      this.read = this.write = 0;
      return this;
    };
    util.DataBuffer.prototype.truncate = function(count3) {
      this.write = Math.max(0, this.length() - count3);
      this.read = Math.min(this.read, this.write);
      return this;
    };
    util.DataBuffer.prototype.toHex = function() {
      var rval = "";
      for (var i = this.read; i < this.data.byteLength; ++i) {
        var b2 = this.data.getUint8(i);
        if (b2 < 16) {
          rval += "0";
        }
        rval += b2.toString(16);
      }
      return rval;
    };
    util.DataBuffer.prototype.toString = function(encoding) {
      var view = new Uint8Array(this.data, this.read, this.length());
      encoding = encoding || "utf8";
      if (encoding === "binary" || encoding === "raw") {
        return util.binary.raw.encode(view);
      }
      if (encoding === "hex") {
        return util.binary.hex.encode(view);
      }
      if (encoding === "base64") {
        return util.binary.base64.encode(view);
      }
      if (encoding === "utf8") {
        return util.text.utf8.decode(view);
      }
      if (encoding === "utf16") {
        return util.text.utf16.decode(view);
      }
      throw new Error("Invalid encoding: " + encoding);
    };
    util.createBuffer = function(input, encoding) {
      encoding = encoding || "raw";
      if (input !== void 0 && encoding === "utf8") {
        input = util.encodeUtf8(input);
      }
      return new util.ByteBuffer(input);
    };
    util.fillString = function(c, n) {
      var s = "";
      while (n > 0) {
        if (n & 1) {
          s += c;
        }
        n >>>= 1;
        if (n > 0) {
          c += c;
        }
      }
      return s;
    };
    util.xorBytes = function(s1, s2, n) {
      var s3 = "";
      var b2 = "";
      var t = "";
      var i = 0;
      var c = 0;
      for (; n > 0; --n, ++i) {
        b2 = s1.charCodeAt(i) ^ s2.charCodeAt(i);
        if (c >= 10) {
          s3 += t;
          t = "";
          c = 0;
        }
        t += String.fromCharCode(b2);
        ++c;
      }
      s3 += t;
      return s3;
    };
    util.hexToBytes = function(hex) {
      var rval = "";
      var i = 0;
      if (hex.length & true) {
        i = 1;
        rval += String.fromCharCode(parseInt(hex[0], 16));
      }
      for (; i < hex.length; i += 2) {
        rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
      }
      return rval;
    };
    util.bytesToHex = function(bytes) {
      return util.createBuffer(bytes).toHex();
    };
    util.int32ToBytes = function(i) {
      return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
    };
    var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
    var _base64Idx = [
      /*43 -43 = 0*/
      /*'+',  1,  2,  3,'/' */
      62,
      -1,
      -1,
      -1,
      63,
      /*'0','1','2','3','4','5','6','7','8','9' */
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      /*15, 16, 17,'=', 19, 20, 21 */
      -1,
      -1,
      -1,
      64,
      -1,
      -1,
      -1,
      /*65 - 43 = 22*/
      /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
      0,
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      /*91 - 43 = 48 */
      /*48, 49, 50, 51, 52, 53 */
      -1,
      -1,
      -1,
      -1,
      -1,
      -1,
      /*97 - 43 = 54*/
      /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51
    ];
    var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    util.encode64 = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.length) {
        chr1 = input.charCodeAt(i++);
        chr2 = input.charCodeAt(i++);
        chr3 = input.charCodeAt(i++);
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.decode64 = function(input) {
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      var output = "";
      var enc1, enc2, enc3, enc4;
      var i = 0;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
        if (enc3 !== 64) {
          output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
          if (enc4 !== 64) {
            output += String.fromCharCode((enc3 & 3) << 6 | enc4);
          }
        }
      }
      return output;
    };
    util.encodeUtf8 = function(str) {
      return unescape(encodeURIComponent(str));
    };
    util.decodeUtf8 = function(str) {
      return decodeURIComponent(escape(str));
    };
    util.binary = {
      raw: {},
      hex: {},
      base64: {},
      base58: {},
      baseN: {
        encode: baseN.encode,
        decode: baseN.decode
      }
    };
    util.binary.raw.encode = function(bytes) {
      return String.fromCharCode.apply(null, bytes);
    };
    util.binary.raw.decode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.binary.hex.encode = util.bytesToHex;
    util.binary.hex.decode = function(hex, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(hex.length / 2));
      }
      offset = offset || 0;
      var i = 0, j = offset;
      if (hex.length & 1) {
        i = 1;
        out[j++] = parseInt(hex[0], 16);
      }
      for (; i < hex.length; i += 2) {
        out[j++] = parseInt(hex.substr(i, 2), 16);
      }
      return output ? j - offset : out;
    };
    util.binary.base64.encode = function(input, maxline) {
      var line = "";
      var output = "";
      var chr1, chr2, chr3;
      var i = 0;
      while (i < input.byteLength) {
        chr1 = input[i++];
        chr2 = input[i++];
        chr3 = input[i++];
        line += _base64.charAt(chr1 >> 2);
        line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
        if (isNaN(chr2)) {
          line += "==";
        } else {
          line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
          line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
        }
        if (maxline && line.length > maxline) {
          output += line.substr(0, maxline) + "\r\n";
          line = line.substr(maxline);
        }
      }
      output += line;
      return output;
    };
    util.binary.base64.decode = function(input, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(Math.ceil(input.length / 4) * 3);
      }
      input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
      offset = offset || 0;
      var enc1, enc2, enc3, enc4;
      var i = 0, j = offset;
      while (i < input.length) {
        enc1 = _base64Idx[input.charCodeAt(i++) - 43];
        enc2 = _base64Idx[input.charCodeAt(i++) - 43];
        enc3 = _base64Idx[input.charCodeAt(i++) - 43];
        enc4 = _base64Idx[input.charCodeAt(i++) - 43];
        out[j++] = enc1 << 2 | enc2 >> 4;
        if (enc3 !== 64) {
          out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
          if (enc4 !== 64) {
            out[j++] = (enc3 & 3) << 6 | enc4;
          }
        }
      }
      return output ? j - offset : out.subarray(0, j);
    };
    util.binary.base58.encode = function(input, maxline) {
      return util.binary.baseN.encode(input, _base58, maxline);
    };
    util.binary.base58.decode = function(input, maxline) {
      return util.binary.baseN.decode(input, _base58, maxline);
    };
    util.text = {
      utf8: {},
      utf16: {}
    };
    util.text.utf8.encode = function(str, output, offset) {
      str = util.encodeUtf8(str);
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length);
      }
      offset = offset || 0;
      var j = offset;
      for (var i = 0; i < str.length; ++i) {
        out[j++] = str.charCodeAt(i);
      }
      return output ? j - offset : out;
    };
    util.text.utf8.decode = function(bytes) {
      return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
    };
    util.text.utf16.encode = function(str, output, offset) {
      var out = output;
      if (!out) {
        out = new Uint8Array(str.length * 2);
      }
      var view = new Uint16Array(out.buffer);
      offset = offset || 0;
      var j = offset;
      var k = offset;
      for (var i = 0; i < str.length; ++i) {
        view[k++] = str.charCodeAt(i);
        j += 2;
      }
      return output ? j - offset : out;
    };
    util.text.utf16.decode = function(bytes) {
      return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
    };
    util.deflate = function(api, bytes, raw) {
      bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
      if (raw) {
        var start = 2;
        var flg = bytes.charCodeAt(1);
        if (flg & 32) {
          start = 6;
        }
        bytes = bytes.substring(start, bytes.length - 4);
      }
      return bytes;
    };
    util.inflate = function(api, bytes, raw) {
      var rval = api.inflate(util.encode64(bytes)).rval;
      return rval === null ? null : util.decode64(rval);
    };
    var _setStorageObject = /* @__PURE__ */ __name(function(api, id, obj) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval;
      if (obj === null) {
        rval = api.removeItem(id);
      } else {
        obj = util.encode64(JSON.stringify(obj));
        rval = api.setItem(id, obj);
      }
      if (typeof rval !== "undefined" && rval.rval !== true) {
        var error3 = new Error(rval.error.message);
        error3.id = rval.error.id;
        error3.name = rval.error.name;
        throw error3;
      }
    }, "_setStorageObject");
    var _getStorageObject = /* @__PURE__ */ __name(function(api, id) {
      if (!api) {
        throw new Error("WebStorage not available.");
      }
      var rval = api.getItem(id);
      if (api.init) {
        if (rval.rval === null) {
          if (rval.error) {
            var error3 = new Error(rval.error.message);
            error3.id = rval.error.id;
            error3.name = rval.error.name;
            throw error3;
          }
          rval = null;
        } else {
          rval = rval.rval;
        }
      }
      if (rval !== null) {
        rval = JSON.parse(util.decode64(rval));
      }
      return rval;
    }, "_getStorageObject");
    var _setItem = /* @__PURE__ */ __name(function(api, id, key, data) {
      var obj = _getStorageObject(api, id);
      if (obj === null) {
        obj = {};
      }
      obj[key] = data;
      _setStorageObject(api, id, obj);
    }, "_setItem");
    var _getItem = /* @__PURE__ */ __name(function(api, id, key) {
      var rval = _getStorageObject(api, id);
      if (rval !== null) {
        rval = key in rval ? rval[key] : null;
      }
      return rval;
    }, "_getItem");
    var _removeItem = /* @__PURE__ */ __name(function(api, id, key) {
      var obj = _getStorageObject(api, id);
      if (obj !== null && key in obj) {
        delete obj[key];
        var empty = true;
        for (var prop in obj) {
          empty = false;
          break;
        }
        if (empty) {
          obj = null;
        }
        _setStorageObject(api, id, obj);
      }
    }, "_removeItem");
    var _clearItems = /* @__PURE__ */ __name(function(api, id) {
      _setStorageObject(api, id, null);
    }, "_clearItems");
    var _callStorageFunction = /* @__PURE__ */ __name(function(func, args, location2) {
      var rval = null;
      if (typeof location2 === "undefined") {
        location2 = ["web", "flash"];
      }
      var type2;
      var done = false;
      var exception = null;
      for (var idx in location2) {
        type2 = location2[idx];
        try {
          if (type2 === "flash" || type2 === "both") {
            if (args[0] === null) {
              throw new Error("Flash local storage not available.");
            }
            rval = func.apply(this, args);
            done = type2 === "flash";
          }
          if (type2 === "web" || type2 === "both") {
            args[0] = localStorage;
            rval = func.apply(this, args);
            done = true;
          }
        } catch (ex) {
          exception = ex;
        }
        if (done) {
          break;
        }
      }
      if (!done) {
        throw exception;
      }
      return rval;
    }, "_callStorageFunction");
    util.setItem = function(api, id, key, data, location2) {
      _callStorageFunction(_setItem, arguments, location2);
    };
    util.getItem = function(api, id, key, location2) {
      return _callStorageFunction(_getItem, arguments, location2);
    };
    util.removeItem = function(api, id, key, location2) {
      _callStorageFunction(_removeItem, arguments, location2);
    };
    util.clearItems = function(api, id, location2) {
      _callStorageFunction(_clearItems, arguments, location2);
    };
    util.isEmpty = function(obj) {
      for (var prop in obj) {
        if (obj.hasOwnProperty(prop)) {
          return false;
        }
      }
      return true;
    };
    util.format = function(format2) {
      var re = /%./g;
      var match;
      var part;
      var argi = 0;
      var parts = [];
      var last = 0;
      while (match = re.exec(format2)) {
        part = format2.substring(last, re.lastIndex - 2);
        if (part.length > 0) {
          parts.push(part);
        }
        last = re.lastIndex;
        var code = match[0][1];
        switch (code) {
          case "s":
          case "o":
            if (argi < arguments.length) {
              parts.push(arguments[argi++ + 1]);
            } else {
              parts.push("<?>");
            }
            break;
          // FIXME: do proper formating for numbers, etc
          //case 'f':
          //case 'd':
          case "%":
            parts.push("%");
            break;
          default:
            parts.push("<%" + code + "?>");
        }
      }
      parts.push(format2.substring(last));
      return parts.join("");
    };
    util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
      var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
      var d2 = dec_point === void 0 ? "," : dec_point;
      var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
      var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
      var j = i.length > 3 ? i.length % 3 : 0;
      return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d2 + Math.abs(n - i).toFixed(c).slice(2) : "");
    };
    util.formatSize = function(size) {
      if (size >= 1073741824) {
        size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
      } else if (size >= 1048576) {
        size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
      } else if (size >= 1024) {
        size = util.formatNumber(size / 1024, 0) + " KiB";
      } else {
        size = util.formatNumber(size, 0) + " bytes";
      }
      return size;
    };
    util.bytesFromIP = function(ip) {
      if (ip.indexOf(".") !== -1) {
        return util.bytesFromIPv4(ip);
      }
      if (ip.indexOf(":") !== -1) {
        return util.bytesFromIPv6(ip);
      }
      return null;
    };
    util.bytesFromIPv4 = function(ip) {
      ip = ip.split(".");
      if (ip.length !== 4) {
        return null;
      }
      var b2 = util.createBuffer();
      for (var i = 0; i < ip.length; ++i) {
        var num = parseInt(ip[i], 10);
        if (isNaN(num)) {
          return null;
        }
        b2.putByte(num);
      }
      return b2.getBytes();
    };
    util.bytesFromIPv6 = function(ip) {
      var blanks = 0;
      ip = ip.split(":").filter(function(e) {
        if (e.length === 0) ++blanks;
        return true;
      });
      var zeros = (8 - ip.length + blanks) * 2;
      var b2 = util.createBuffer();
      for (var i = 0; i < 8; ++i) {
        if (!ip[i] || ip[i].length === 0) {
          b2.fillWithByte(0, zeros);
          zeros = 0;
          continue;
        }
        var bytes = util.hexToBytes(ip[i]);
        if (bytes.length < 2) {
          b2.putByte(0);
        }
        b2.putBytes(bytes);
      }
      return b2.getBytes();
    };
    util.bytesToIP = function(bytes) {
      if (bytes.length === 4) {
        return util.bytesToIPv4(bytes);
      }
      if (bytes.length === 16) {
        return util.bytesToIPv6(bytes);
      }
      return null;
    };
    util.bytesToIPv4 = function(bytes) {
      if (bytes.length !== 4) {
        return null;
      }
      var ip = [];
      for (var i = 0; i < bytes.length; ++i) {
        ip.push(bytes.charCodeAt(i));
      }
      return ip.join(".");
    };
    util.bytesToIPv6 = function(bytes) {
      if (bytes.length !== 16) {
        return null;
      }
      var ip = [];
      var zeroGroups = [];
      var zeroMaxGroup = 0;
      for (var i = 0; i < bytes.length; i += 2) {
        var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
        while (hex[0] === "0" && hex !== "0") {
          hex = hex.substr(1);
        }
        if (hex === "0") {
          var last = zeroGroups[zeroGroups.length - 1];
          var idx = ip.length;
          if (!last || idx !== last.end + 1) {
            zeroGroups.push({ start: idx, end: idx });
          } else {
            last.end = idx;
            if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
              zeroMaxGroup = zeroGroups.length - 1;
            }
          }
        }
        ip.push(hex);
      }
      if (zeroGroups.length > 0) {
        var group3 = zeroGroups[zeroMaxGroup];
        if (group3.end - group3.start > 0) {
          ip.splice(group3.start, group3.end - group3.start + 1, "");
          if (group3.start === 0) {
            ip.unshift("");
          }
          if (group3.end === 7) {
            ip.push("");
          }
        }
      }
      return ip.join(":");
    };
    util.estimateCores = function(options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      if ("cores" in util && !options.update) {
        return callback(null, util.cores);
      }
      if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
        util.cores = navigator.hardwareConcurrency;
        return callback(null, util.cores);
      }
      if (typeof Worker === "undefined") {
        util.cores = 1;
        return callback(null, util.cores);
      }
      if (typeof Blob === "undefined") {
        util.cores = 2;
        return callback(null, util.cores);
      }
      var blobUrl = URL.createObjectURL(new Blob([
        "(",
        function() {
          self.addEventListener("message", function(e) {
            var st = Date.now();
            var et2 = st + 4;
            while (Date.now() < et2) ;
            self.postMessage({ st, et: et2 });
          });
        }.toString(),
        ")()"
      ], { type: "application/javascript" }));
      sample([], 5, 16);
      function sample(max, samples, numWorkers) {
        if (samples === 0) {
          var avg = Math.floor(max.reduce(function(avg2, x) {
            return avg2 + x;
          }, 0) / max.length);
          util.cores = Math.max(1, avg);
          URL.revokeObjectURL(blobUrl);
          return callback(null, util.cores);
        }
        map(numWorkers, function(err, results) {
          max.push(reduce(numWorkers, results));
          sample(max, samples - 1, numWorkers);
        });
      }
      __name(sample, "sample");
      function map(numWorkers, callback2) {
        var workers = [];
        var results = [];
        for (var i = 0; i < numWorkers; ++i) {
          var worker = new Worker(blobUrl);
          worker.addEventListener("message", function(e) {
            results.push(e.data);
            if (results.length === numWorkers) {
              for (var i2 = 0; i2 < numWorkers; ++i2) {
                workers[i2].terminate();
              }
              callback2(null, results);
            }
          });
          workers.push(worker);
        }
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].postMessage(i);
        }
      }
      __name(map, "map");
      function reduce(numWorkers, results) {
        var overlaps = [];
        for (var n = 0; n < numWorkers; ++n) {
          var r1 = results[n];
          var overlap = overlaps[n] = [];
          for (var i = 0; i < numWorkers; ++i) {
            if (n === i) {
              continue;
            }
            var r2 = results[i];
            if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
              overlap.push(i);
            }
          }
        }
        return overlaps.reduce(function(max, overlap2) {
          return Math.max(max, overlap2.length);
        }, 0);
      }
      __name(reduce, "reduce");
    };
  }
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS({
  "node_modules/node-forge/lib/cipher.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    module.exports = forge.cipher = forge.cipher || {};
    forge.cipher.algorithms = forge.cipher.algorithms || {};
    forge.cipher.createCipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: false
      });
    };
    forge.cipher.createDecipher = function(algorithm, key) {
      var api = algorithm;
      if (typeof api === "string") {
        api = forge.cipher.getAlgorithm(api);
        if (api) {
          api = api();
        }
      }
      if (!api) {
        throw new Error("Unsupported algorithm: " + algorithm);
      }
      return new forge.cipher.BlockCipher({
        algorithm: api,
        key,
        decrypt: true
      });
    };
    forge.cipher.registerAlgorithm = function(name, algorithm) {
      name = name.toUpperCase();
      forge.cipher.algorithms[name] = algorithm;
    };
    forge.cipher.getAlgorithm = function(name) {
      name = name.toUpperCase();
      if (name in forge.cipher.algorithms) {
        return forge.cipher.algorithms[name];
      }
      return null;
    };
    var BlockCipher = forge.cipher.BlockCipher = function(options) {
      this.algorithm = options.algorithm;
      this.mode = this.algorithm.mode;
      this.blockSize = this.mode.blockSize;
      this._finish = false;
      this._input = null;
      this.output = null;
      this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
      this._decrypt = options.decrypt;
      this.algorithm.initialize(options);
    };
    BlockCipher.prototype.start = function(options) {
      options = options || {};
      var opts = {};
      for (var key in options) {
        opts[key] = options[key];
      }
      opts.decrypt = this._decrypt;
      this._finish = false;
      this._input = forge.util.createBuffer();
      this.output = options.output || forge.util.createBuffer();
      this.mode.start(opts);
    };
    BlockCipher.prototype.update = function(input) {
      if (input) {
        this._input.putBuffer(input);
      }
      while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
      }
      this._input.compact();
    };
    BlockCipher.prototype.finish = function(pad) {
      if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
        this.mode.pad = function(input) {
          return pad(this.blockSize, input, false);
        };
        this.mode.unpad = function(output) {
          return pad(this.blockSize, output, true);
        };
      }
      var options = {};
      options.decrypt = this._decrypt;
      options.overflow = this._input.length() % this.blockSize;
      if (!this._decrypt && this.mode.pad) {
        if (!this.mode.pad(this._input, options)) {
          return false;
        }
      }
      this._finish = true;
      this.update();
      if (this._decrypt && this.mode.unpad) {
        if (!this.mode.unpad(this.output, options)) {
          return false;
        }
      }
      if (this.mode.afterFinish) {
        if (!this.mode.afterFinish(this.output, options)) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS({
  "node_modules/node-forge/lib/cipherModes.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    forge.cipher = forge.cipher || {};
    var modes = module.exports = forge.cipher.modes = forge.cipher.modes || {};
    modes.ecb = function(options) {
      options = options || {};
      this.name = "ECB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.ecb.prototype.start = function(options) {
    };
    modes.ecb.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
    };
    modes.ecb.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.ecb.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count3 = output.at(len - 1);
      if (count3 > this.blockSize << 2) {
        return false;
      }
      output.truncate(count3);
      return true;
    };
    modes.cbc = function(options) {
      options = options || {};
      this.name = "CBC";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
    };
    modes.cbc.prototype.start = function(options) {
      if (options.iv === null) {
        if (!this._prev) {
          throw new Error("Invalid IV parameter.");
        }
        this._iv = this._prev.slice(0);
      } else if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      } else {
        this._iv = transformIV(options.iv, this.blockSize);
        this._prev = this._iv.slice(0);
      }
    };
    modes.cbc.prototype.encrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._prev[i] ^ input.getInt32();
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i]);
      }
      this._prev = this._outBlock;
    };
    modes.cbc.prototype.decrypt = function(input, output, finish) {
      if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
        return true;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
      }
      this.cipher.decrypt(this._inBlock, this._outBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._prev[i] ^ this._outBlock[i]);
      }
      this._prev = this._inBlock.slice(0);
    };
    modes.cbc.prototype.pad = function(input, options) {
      var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
      input.fillWithByte(padding, padding);
      return true;
    };
    modes.cbc.prototype.unpad = function(output, options) {
      if (options.overflow > 0) {
        return false;
      }
      var len = output.length();
      var count3 = output.at(len - 1);
      if (count3 > this.blockSize << 2) {
        return false;
      }
      output.truncate(count3);
      return true;
    };
    modes.cfb = function(options) {
      options = options || {};
      this.name = "CFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.cfb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.cfb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
          output.putInt32(this._inBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
        this._partialOutput.putInt32(this._partialBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.cfb.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = input.getInt32();
          output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialBlock[i] = input.getInt32();
        this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._partialBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb = function(options) {
      options = options || {};
      this.name = "OFB";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ofb.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ofb.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (input.length() === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
          this._inBlock[i] = this._outBlock[i];
        }
        return;
      }
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      } else {
        for (var i = 0; i < this._ints; ++i) {
          this._inBlock[i] = this._outBlock[i];
        }
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(
          partialBytes - this._partialBytes
        ));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(
        inputLength - this._partialBytes
      ));
      this._partialBytes = 0;
    };
    modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
    modes.ctr = function(options) {
      options = options || {};
      this.name = "CTR";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = null;
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
    };
    modes.ctr.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = transformIV(options.iv, this.blockSize);
      this._inBlock = this._iv.slice(0);
      this._partialBytes = 0;
    };
    modes.ctr.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes > 0) {
          input.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      inc32(this._inBlock);
    };
    modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
    modes.gcm = function(options) {
      options = options || {};
      this.name = "GCM";
      this.cipher = options.cipher;
      this.blockSize = options.blockSize || 16;
      this._ints = this.blockSize / 4;
      this._inBlock = new Array(this._ints);
      this._outBlock = new Array(this._ints);
      this._partialOutput = forge.util.createBuffer();
      this._partialBytes = 0;
      this._R = 3774873600;
    };
    modes.gcm.prototype.start = function(options) {
      if (!("iv" in options)) {
        throw new Error("Invalid IV parameter.");
      }
      var iv = forge.util.createBuffer(options.iv);
      this._cipherLength = 0;
      var additionalData;
      if ("additionalData" in options) {
        additionalData = forge.util.createBuffer(options.additionalData);
      } else {
        additionalData = forge.util.createBuffer();
      }
      if ("tagLength" in options) {
        this._tagLength = options.tagLength;
      } else {
        this._tagLength = 128;
      }
      this._tag = null;
      if (options.decrypt) {
        this._tag = forge.util.createBuffer(options.tag).getBytes();
        if (this._tag.length !== this._tagLength / 8) {
          throw new Error("Authentication tag does not match tag length.");
        }
      }
      this._hashBlock = new Array(this._ints);
      this.tag = null;
      this._hashSubkey = new Array(this._ints);
      this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
      this.componentBits = 4;
      this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
      var ivLength = iv.length();
      if (ivLength === 12) {
        this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
      } else {
        this._j0 = [0, 0, 0, 0];
        while (iv.length() > 0) {
          this._j0 = this.ghash(
            this._hashSubkey,
            this._j0,
            [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]
          );
        }
        this._j0 = this.ghash(
          this._hashSubkey,
          this._j0,
          [0, 0].concat(from64To32(ivLength * 8))
        );
      }
      this._inBlock = this._j0.slice(0);
      inc32(this._inBlock);
      this._partialBytes = 0;
      additionalData = forge.util.createBuffer(additionalData);
      this._aDataLength = from64To32(additionalData.length() * 8);
      var overflow = additionalData.length() % this.blockSize;
      if (overflow) {
        additionalData.fillWithByte(0, this.blockSize - overflow);
      }
      this._s = [0, 0, 0, 0];
      while (additionalData.length() > 0) {
        this._s = this.ghash(this._hashSubkey, this._s, [
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32(),
          additionalData.getInt32()
        ]);
      }
    };
    modes.gcm.prototype.encrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength === 0) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      if (this._partialBytes === 0 && inputLength >= this.blockSize) {
        for (var i = 0; i < this._ints; ++i) {
          output.putInt32(this._outBlock[i] ^= input.getInt32());
        }
        this._cipherLength += this.blockSize;
      } else {
        var partialBytes = (this.blockSize - inputLength) % this.blockSize;
        if (partialBytes > 0) {
          partialBytes = this.blockSize - partialBytes;
        }
        this._partialOutput.clear();
        for (var i = 0; i < this._ints; ++i) {
          this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
        }
        if (partialBytes <= 0 || finish) {
          if (finish) {
            var overflow = inputLength % this.blockSize;
            this._cipherLength += overflow;
            this._partialOutput.truncate(this.blockSize - overflow);
          } else {
            this._cipherLength += this.blockSize;
          }
          for (var i = 0; i < this._ints; ++i) {
            this._outBlock[i] = this._partialOutput.getInt32();
          }
          this._partialOutput.read -= this.blockSize;
        }
        if (this._partialBytes > 0) {
          this._partialOutput.getBytes(this._partialBytes);
        }
        if (partialBytes > 0 && !finish) {
          input.read -= this.blockSize;
          output.putBytes(this._partialOutput.getBytes(
            partialBytes - this._partialBytes
          ));
          this._partialBytes = partialBytes;
          return true;
        }
        output.putBytes(this._partialOutput.getBytes(
          inputLength - this._partialBytes
        ));
        this._partialBytes = 0;
      }
      this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
      inc32(this._inBlock);
    };
    modes.gcm.prototype.decrypt = function(input, output, finish) {
      var inputLength = input.length();
      if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
        return true;
      }
      this.cipher.encrypt(this._inBlock, this._outBlock);
      inc32(this._inBlock);
      this._hashBlock[0] = input.getInt32();
      this._hashBlock[1] = input.getInt32();
      this._hashBlock[2] = input.getInt32();
      this._hashBlock[3] = input.getInt32();
      this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
      }
      if (inputLength < this.blockSize) {
        this._cipherLength += inputLength % this.blockSize;
      } else {
        this._cipherLength += this.blockSize;
      }
    };
    modes.gcm.prototype.afterFinish = function(output, options) {
      var rval = true;
      if (options.decrypt && options.overflow) {
        output.truncate(this.blockSize - options.overflow);
      }
      this.tag = forge.util.createBuffer();
      var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
      this._s = this.ghash(this._hashSubkey, this._s, lengths);
      var tag = [];
      this.cipher.encrypt(this._j0, tag);
      for (var i = 0; i < this._ints; ++i) {
        this.tag.putInt32(this._s[i] ^ tag[i]);
      }
      this.tag.truncate(this.tag.length() % (this._tagLength / 8));
      if (options.decrypt && this.tag.bytes() !== this._tag) {
        rval = false;
      }
      return rval;
    };
    modes.gcm.prototype.multiply = function(x, y) {
      var z_i = [0, 0, 0, 0];
      var v_i = y.slice(0);
      for (var i = 0; i < 128; ++i) {
        var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
        if (x_i) {
          z_i[0] ^= v_i[0];
          z_i[1] ^= v_i[1];
          z_i[2] ^= v_i[2];
          z_i[3] ^= v_i[3];
        }
        this.pow(v_i, v_i);
      }
      return z_i;
    };
    modes.gcm.prototype.pow = function(x, out) {
      var lsb = x[3] & 1;
      for (var i = 3; i > 0; --i) {
        out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
      }
      out[0] = x[0] >>> 1;
      if (lsb) {
        out[0] ^= this._R;
      }
    };
    modes.gcm.prototype.tableMultiply = function(x) {
      var z2 = [0, 0, 0, 0];
      for (var i = 0; i < 32; ++i) {
        var idx = i / 8 | 0;
        var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
        var ah = this._m[i][x_i];
        z2[0] ^= ah[0];
        z2[1] ^= ah[1];
        z2[2] ^= ah[2];
        z2[3] ^= ah[3];
      }
      return z2;
    };
    modes.gcm.prototype.ghash = function(h, y, x) {
      y[0] ^= x[0];
      y[1] ^= x[1];
      y[2] ^= x[2];
      y[3] ^= x[3];
      return this.tableMultiply(y);
    };
    modes.gcm.prototype.generateHashTable = function(h, bits) {
      var multiplier = 8 / bits;
      var perInt = 4 * multiplier;
      var size = 16 * multiplier;
      var m2 = new Array(size);
      for (var i = 0; i < size; ++i) {
        var tmp = [0, 0, 0, 0];
        var idx = i / perInt | 0;
        var shft = (perInt - 1 - i % perInt) * bits;
        tmp[idx] = 1 << bits - 1 << shft;
        m2[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
      }
      return m2;
    };
    modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
      var size = 1 << bits;
      var half = size >>> 1;
      var m2 = new Array(size);
      m2[half] = mid.slice(0);
      var i = half >>> 1;
      while (i > 0) {
        this.pow(m2[2 * i], m2[i] = []);
        i >>= 1;
      }
      i = 2;
      while (i < half) {
        for (var j = 1; j < i; ++j) {
          var m_i = m2[i];
          var m_j = m2[j];
          m2[i + j] = [
            m_i[0] ^ m_j[0],
            m_i[1] ^ m_j[1],
            m_i[2] ^ m_j[2],
            m_i[3] ^ m_j[3]
          ];
        }
        i *= 2;
      }
      m2[0] = [0, 0, 0, 0];
      for (i = half + 1; i < size; ++i) {
        var c = m2[i ^ half];
        m2[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
      }
      return m2;
    };
    function transformIV(iv, blockSize) {
      if (typeof iv === "string") {
        iv = forge.util.createBuffer(iv);
      }
      if (forge.util.isArray(iv) && iv.length > 4) {
        var tmp = iv;
        iv = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          iv.putByte(tmp[i]);
        }
      }
      if (iv.length() < blockSize) {
        throw new Error(
          "Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes."
        );
      }
      if (!forge.util.isArray(iv)) {
        var ints = [];
        var blocks = blockSize / 4;
        for (var i = 0; i < blocks; ++i) {
          ints.push(iv.getInt32());
        }
        iv = ints;
      }
      return iv;
    }
    __name(transformIV, "transformIV");
    function inc32(block) {
      block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
    }
    __name(inc32, "inc32");
    function from64To32(num) {
      return [num / 4294967296 | 0, num & 4294967295];
    }
    __name(from64To32, "from64To32");
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS({
  "node_modules/node-forge/lib/aes.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util4();
    module.exports = forge.aes = forge.aes || {};
    forge.aes.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.aes.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode
      });
      cipher.start(iv);
      return cipher;
    };
    forge.aes.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.aes.Algorithm = function(name, mode) {
      if (!init) {
        initialize();
      }
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 16,
        cipher: {
          encrypt: /* @__PURE__ */ __name(function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, false);
          }, "encrypt"),
          decrypt: /* @__PURE__ */ __name(function(inBlock, outBlock) {
            return _updateBlock(self2._w, inBlock, outBlock, true);
          }, "decrypt")
        }
      });
      self2._init = false;
    };
    forge.aes.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = options.key;
      var tmp;
      if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
        key = forge.util.createBuffer(key);
      } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
        tmp = key;
        key = forge.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      if (!forge.util.isArray(key)) {
        tmp = key;
        key = [];
        var len = tmp.length();
        if (len === 16 || len === 24 || len === 32) {
          len = len >>> 2;
          for (var i = 0; i < len; ++i) {
            key.push(tmp.getInt32());
          }
        }
      }
      if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
        throw new Error("Invalid key parameter.");
      }
      var mode = this.mode.name;
      var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
      this._w = _expandKey(key, options.decrypt && !encryptOp);
      this._init = true;
    };
    forge.aes._expandKey = function(key, decrypt4) {
      if (!init) {
        initialize();
      }
      return _expandKey(key, decrypt4);
    };
    forge.aes._updateBlock = _updateBlock;
    registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
    function registerAlgorithm(name, mode) {
      var factory = /* @__PURE__ */ __name(function() {
        return new forge.aes.Algorithm(name, mode);
      }, "factory");
      forge.cipher.registerAlgorithm(name, factory);
    }
    __name(registerAlgorithm, "registerAlgorithm");
    var init = false;
    var Nb = 4;
    var sbox;
    var isbox;
    var rcon;
    var mix;
    var imix;
    function initialize() {
      init = true;
      rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
      var xtime = new Array(256);
      for (var i = 0; i < 128; ++i) {
        xtime[i] = i << 1;
        xtime[i + 128] = i + 128 << 1 ^ 283;
      }
      sbox = new Array(256);
      isbox = new Array(256);
      mix = new Array(4);
      imix = new Array(4);
      for (var i = 0; i < 4; ++i) {
        mix[i] = new Array(256);
        imix[i] = new Array(256);
      }
      var e = 0, ei = 0, e2, e4, e8, sx, sx2, me2, ime;
      for (var i = 0; i < 256; ++i) {
        sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
        sx = sx >> 8 ^ sx & 255 ^ 99;
        sbox[e] = sx;
        isbox[sx] = e;
        sx2 = xtime[sx];
        e2 = xtime[e];
        e4 = xtime[e2];
        e8 = xtime[e4];
        me2 = sx2 << 24 ^ // 2
        sx << 16 ^ // 1
        sx << 8 ^ // 1
        (sx ^ sx2);
        ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
        (e ^ e8) << 16 ^ // 9
        (e ^ e4 ^ e8) << 8 ^ // D (13)
        (e ^ e2 ^ e8);
        for (var n = 0; n < 4; ++n) {
          mix[n][e] = me2;
          imix[n][sx] = ime;
          me2 = me2 << 24 | me2 >>> 8;
          ime = ime << 24 | ime >>> 8;
        }
        if (e === 0) {
          e = ei = 1;
        } else {
          e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
          ei ^= xtime[xtime[ei]];
        }
      }
    }
    __name(initialize, "initialize");
    function _expandKey(key, decrypt4) {
      var w2 = key.slice(0);
      var temp, iNk = 1;
      var Nk = w2.length;
      var Nr1 = Nk + 6 + 1;
      var end = Nb * Nr1;
      for (var i = Nk; i < end; ++i) {
        temp = w2[i - 1];
        if (i % Nk === 0) {
          temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
          iNk++;
        } else if (Nk > 6 && i % Nk === 4) {
          temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
        }
        w2[i] = w2[i - Nk] ^ temp;
      }
      if (decrypt4) {
        var tmp;
        var m0 = imix[0];
        var m1 = imix[1];
        var m2 = imix[2];
        var m3 = imix[3];
        var wnew = w2.slice(0);
        end = w2.length;
        for (var i = 0, wi2 = end - Nb; i < end; i += Nb, wi2 -= Nb) {
          if (i === 0 || i === end - Nb) {
            wnew[i] = w2[wi2];
            wnew[i + 1] = w2[wi2 + 3];
            wnew[i + 2] = w2[wi2 + 2];
            wnew[i + 3] = w2[wi2 + 1];
          } else {
            for (var n = 0; n < Nb; ++n) {
              tmp = w2[wi2 + n];
              wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
            }
          }
        }
        w2 = wnew;
      }
      return w2;
    }
    __name(_expandKey, "_expandKey");
    function _updateBlock(w2, input, output, decrypt4) {
      var Nr = w2.length / 4 - 1;
      var m0, m1, m2, m3, sub;
      if (decrypt4) {
        m0 = imix[0];
        m1 = imix[1];
        m2 = imix[2];
        m3 = imix[3];
        sub = isbox;
      } else {
        m0 = mix[0];
        m1 = mix[1];
        m2 = mix[2];
        m3 = mix[3];
        sub = sbox;
      }
      var a2, b2, c, d2, a22, b22, c2;
      a2 = input[0] ^ w2[0];
      b2 = input[decrypt4 ? 3 : 1] ^ w2[1];
      c = input[2] ^ w2[2];
      d2 = input[decrypt4 ? 1 : 3] ^ w2[3];
      var i = 3;
      for (var round = 1; round < Nr; ++round) {
        a22 = m0[a2 >>> 24] ^ m1[b2 >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i];
        b22 = m0[b2 >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a2 & 255] ^ w2[++i];
        c2 = m0[c >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a2 >>> 8 & 255] ^ m3[b2 & 255] ^ w2[++i];
        d2 = m0[d2 >>> 24] ^ m1[a2 >>> 16 & 255] ^ m2[b2 >>> 8 & 255] ^ m3[c & 255] ^ w2[++i];
        a2 = a22;
        b2 = b22;
        c = c2;
      }
      output[0] = sub[a2 >>> 24] << 24 ^ sub[b2 >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i];
      output[decrypt4 ? 3 : 1] = sub[b2 >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a2 & 255] ^ w2[++i];
      output[2] = sub[c >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a2 >>> 8 & 255] << 8 ^ sub[b2 & 255] ^ w2[++i];
      output[decrypt4 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a2 >>> 16 & 255] << 16 ^ sub[b2 >>> 8 & 255] << 8 ^ sub[c & 255] ^ w2[++i];
    }
    __name(_updateBlock, "_updateBlock");
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "AES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
    __name(_createCipher, "_createCipher");
  }
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS({
  "node_modules/node-forge/lib/oids.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    forge.pki = forge.pki || {};
    var oids = module.exports = forge.pki.oids = forge.oids = forge.oids || {};
    function _IN(id, name) {
      oids[id] = name;
      oids[name] = id;
    }
    __name(_IN, "_IN");
    function _I_(id, name) {
      oids[id] = name;
    }
    __name(_I_, "_I_");
    _IN("1.2.840.113549.1.1.1", "rsaEncryption");
    _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
    _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
    _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
    _IN("1.2.840.113549.1.1.8", "mgf1");
    _IN("1.2.840.113549.1.1.9", "pSpecified");
    _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
    _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
    _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
    _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
    _IN("1.3.101.112", "EdDSA25519");
    _IN("1.2.840.10040.4.3", "dsa-with-sha1");
    _IN("1.3.14.3.2.7", "desCBC");
    _IN("1.3.14.3.2.26", "sha1");
    _IN("1.3.14.3.2.29", "sha1WithRSASignature");
    _IN("2.16.840.1.101.3.4.2.1", "sha256");
    _IN("2.16.840.1.101.3.4.2.2", "sha384");
    _IN("2.16.840.1.101.3.4.2.3", "sha512");
    _IN("2.16.840.1.101.3.4.2.4", "sha224");
    _IN("2.16.840.1.101.3.4.2.5", "sha512-224");
    _IN("2.16.840.1.101.3.4.2.6", "sha512-256");
    _IN("1.2.840.113549.2.2", "md2");
    _IN("1.2.840.113549.2.5", "md5");
    _IN("1.2.840.113549.1.7.1", "data");
    _IN("1.2.840.113549.1.7.2", "signedData");
    _IN("1.2.840.113549.1.7.3", "envelopedData");
    _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
    _IN("1.2.840.113549.1.7.5", "digestedData");
    _IN("1.2.840.113549.1.7.6", "encryptedData");
    _IN("1.2.840.113549.1.9.1", "emailAddress");
    _IN("1.2.840.113549.1.9.2", "unstructuredName");
    _IN("1.2.840.113549.1.9.3", "contentType");
    _IN("1.2.840.113549.1.9.4", "messageDigest");
    _IN("1.2.840.113549.1.9.5", "signingTime");
    _IN("1.2.840.113549.1.9.6", "counterSignature");
    _IN("1.2.840.113549.1.9.7", "challengePassword");
    _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
    _IN("1.2.840.113549.1.9.14", "extensionRequest");
    _IN("1.2.840.113549.1.9.20", "friendlyName");
    _IN("1.2.840.113549.1.9.21", "localKeyId");
    _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
    _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
    _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
    _IN("1.2.840.113549.1.12.10.1.3", "certBag");
    _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
    _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
    _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
    _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
    _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
    _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
    _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
    _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
    _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
    _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
    _IN("1.2.840.113549.2.7", "hmacWithSHA1");
    _IN("1.2.840.113549.2.8", "hmacWithSHA224");
    _IN("1.2.840.113549.2.9", "hmacWithSHA256");
    _IN("1.2.840.113549.2.10", "hmacWithSHA384");
    _IN("1.2.840.113549.2.11", "hmacWithSHA512");
    _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
    _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
    _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
    _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
    _IN("2.5.4.3", "commonName");
    _IN("2.5.4.4", "surname");
    _IN("2.5.4.5", "serialNumber");
    _IN("2.5.4.6", "countryName");
    _IN("2.5.4.7", "localityName");
    _IN("2.5.4.8", "stateOrProvinceName");
    _IN("2.5.4.9", "streetAddress");
    _IN("2.5.4.10", "organizationName");
    _IN("2.5.4.11", "organizationalUnitName");
    _IN("2.5.4.12", "title");
    _IN("2.5.4.13", "description");
    _IN("2.5.4.15", "businessCategory");
    _IN("2.5.4.17", "postalCode");
    _IN("2.5.4.42", "givenName");
    _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
    _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
    _IN("2.16.840.1.113730.1.1", "nsCertType");
    _IN("2.16.840.1.113730.1.13", "nsComment");
    _I_("2.5.29.1", "authorityKeyIdentifier");
    _I_("2.5.29.2", "keyAttributes");
    _I_("2.5.29.3", "certificatePolicies");
    _I_("2.5.29.4", "keyUsageRestriction");
    _I_("2.5.29.5", "policyMapping");
    _I_("2.5.29.6", "subtreesConstraint");
    _I_("2.5.29.7", "subjectAltName");
    _I_("2.5.29.8", "issuerAltName");
    _I_("2.5.29.9", "subjectDirectoryAttributes");
    _I_("2.5.29.10", "basicConstraints");
    _I_("2.5.29.11", "nameConstraints");
    _I_("2.5.29.12", "policyConstraints");
    _I_("2.5.29.13", "basicConstraints");
    _IN("2.5.29.14", "subjectKeyIdentifier");
    _IN("2.5.29.15", "keyUsage");
    _I_("2.5.29.16", "privateKeyUsagePeriod");
    _IN("2.5.29.17", "subjectAltName");
    _IN("2.5.29.18", "issuerAltName");
    _IN("2.5.29.19", "basicConstraints");
    _I_("2.5.29.20", "cRLNumber");
    _I_("2.5.29.21", "cRLReason");
    _I_("2.5.29.22", "expirationDate");
    _I_("2.5.29.23", "instructionCode");
    _I_("2.5.29.24", "invalidityDate");
    _I_("2.5.29.25", "cRLDistributionPoints");
    _I_("2.5.29.26", "issuingDistributionPoint");
    _I_("2.5.29.27", "deltaCRLIndicator");
    _I_("2.5.29.28", "issuingDistributionPoint");
    _I_("2.5.29.29", "certificateIssuer");
    _I_("2.5.29.30", "nameConstraints");
    _IN("2.5.29.31", "cRLDistributionPoints");
    _IN("2.5.29.32", "certificatePolicies");
    _I_("2.5.29.33", "policyMappings");
    _I_("2.5.29.34", "policyConstraints");
    _IN("2.5.29.35", "authorityKeyIdentifier");
    _I_("2.5.29.36", "policyConstraints");
    _IN("2.5.29.37", "extKeyUsage");
    _I_("2.5.29.46", "freshestCRL");
    _I_("2.5.29.54", "inhibitAnyPolicy");
    _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
    _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
    _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
    _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
    _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
    _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
    _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
  }
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS({
  "node_modules/node-forge/lib/asn1.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    require_oids();
    var asn1 = module.exports = forge.asn1 = forge.asn1 || {};
    asn1.Class = {
      UNIVERSAL: 0,
      APPLICATION: 64,
      CONTEXT_SPECIFIC: 128,
      PRIVATE: 192
    };
    asn1.Type = {
      NONE: 0,
      BOOLEAN: 1,
      INTEGER: 2,
      BITSTRING: 3,
      OCTETSTRING: 4,
      NULL: 5,
      OID: 6,
      ODESC: 7,
      EXTERNAL: 8,
      REAL: 9,
      ENUMERATED: 10,
      EMBEDDED: 11,
      UTF8: 12,
      ROID: 13,
      SEQUENCE: 16,
      SET: 17,
      PRINTABLESTRING: 19,
      IA5STRING: 22,
      UTCTIME: 23,
      GENERALIZEDTIME: 24,
      BMPSTRING: 30
    };
    asn1.create = function(tagClass, type2, constructed, value, options) {
      if (forge.util.isArray(value)) {
        var tmp = [];
        for (var i = 0; i < value.length; ++i) {
          if (value[i] !== void 0) {
            tmp.push(value[i]);
          }
        }
        value = tmp;
      }
      var obj = {
        tagClass,
        type: type2,
        constructed,
        composed: constructed || forge.util.isArray(value),
        value
      };
      if (options && "bitStringContents" in options) {
        obj.bitStringContents = options.bitStringContents;
        obj.original = asn1.copy(obj);
      }
      return obj;
    };
    asn1.copy = function(obj, options) {
      var copy;
      if (forge.util.isArray(obj)) {
        copy = [];
        for (var i = 0; i < obj.length; ++i) {
          copy.push(asn1.copy(obj[i], options));
        }
        return copy;
      }
      if (typeof obj === "string") {
        return obj;
      }
      copy = {
        tagClass: obj.tagClass,
        type: obj.type,
        constructed: obj.constructed,
        composed: obj.composed,
        value: asn1.copy(obj.value, options)
      };
      if (options && !options.excludeBitStringContents) {
        copy.bitStringContents = obj.bitStringContents;
      }
      return copy;
    };
    asn1.equals = function(obj1, obj2, options) {
      if (forge.util.isArray(obj1)) {
        if (!forge.util.isArray(obj2)) {
          return false;
        }
        if (obj1.length !== obj2.length) {
          return false;
        }
        for (var i = 0; i < obj1.length; ++i) {
          if (!asn1.equals(obj1[i], obj2[i])) {
            return false;
          }
        }
        return true;
      }
      if (typeof obj1 !== typeof obj2) {
        return false;
      }
      if (typeof obj1 === "string") {
        return obj1 === obj2;
      }
      var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
      if (options && options.includeBitStringContents) {
        equal = equal && obj1.bitStringContents === obj2.bitStringContents;
      }
      return equal;
    };
    asn1.getBerValueLength = function(b2) {
      var b22 = b2.getByte();
      if (b22 === 128) {
        return void 0;
      }
      var length;
      var longForm = b22 & 128;
      if (!longForm) {
        length = b22;
      } else {
        length = b2.getInt((b22 & 127) << 3);
      }
      return length;
    };
    function _checkBufferLength(bytes, remaining, n) {
      if (n > remaining) {
        var error3 = new Error("Too few bytes to parse DER.");
        error3.available = bytes.length();
        error3.remaining = remaining;
        error3.requested = n;
        throw error3;
      }
    }
    __name(_checkBufferLength, "_checkBufferLength");
    var _getValueLength = /* @__PURE__ */ __name(function(bytes, remaining) {
      var b2 = bytes.getByte();
      remaining--;
      if (b2 === 128) {
        return void 0;
      }
      var length;
      var longForm = b2 & 128;
      if (!longForm) {
        length = b2;
      } else {
        var longFormBytes = b2 & 127;
        _checkBufferLength(bytes, remaining, longFormBytes);
        length = bytes.getInt(longFormBytes << 3);
      }
      if (length < 0) {
        throw new Error("Negative length: " + length);
      }
      return length;
    }, "_getValueLength");
    asn1.fromDer = function(bytes, options) {
      if (options === void 0) {
        options = {
          strict: true,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (typeof options === "boolean") {
        options = {
          strict: options,
          parseAllBytes: true,
          decodeBitStrings: true
        };
      }
      if (!("strict" in options)) {
        options.strict = true;
      }
      if (!("parseAllBytes" in options)) {
        options.parseAllBytes = true;
      }
      if (!("decodeBitStrings" in options)) {
        options.decodeBitStrings = true;
      }
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var byteCount = bytes.length();
      var value = _fromDer(bytes, bytes.length(), 0, options);
      if (options.parseAllBytes && bytes.length() !== 0) {
        var error3 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
        error3.byteCount = byteCount;
        error3.remaining = bytes.length();
        throw error3;
      }
      return value;
    };
    function _fromDer(bytes, remaining, depth, options) {
      var start;
      _checkBufferLength(bytes, remaining, 2);
      var b1 = bytes.getByte();
      remaining--;
      var tagClass = b1 & 192;
      var type2 = b1 & 31;
      start = bytes.length();
      var length = _getValueLength(bytes, remaining);
      remaining -= start - bytes.length();
      if (length !== void 0 && length > remaining) {
        if (options.strict) {
          var error3 = new Error("Too few bytes to read ASN.1 value.");
          error3.available = bytes.length();
          error3.remaining = remaining;
          error3.requested = length;
          throw error3;
        }
        length = remaining;
      }
      var value;
      var bitStringContents;
      var constructed = (b1 & 32) === 32;
      if (constructed) {
        value = [];
        if (length === void 0) {
          for (; ; ) {
            _checkBufferLength(bytes, remaining, 2);
            if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
              bytes.getBytes(2);
              remaining -= 2;
              break;
            }
            start = bytes.length();
            value.push(_fromDer(bytes, remaining, depth + 1, options));
            remaining -= start - bytes.length();
          }
        } else {
          while (length > 0) {
            start = bytes.length();
            value.push(_fromDer(bytes, length, depth + 1, options));
            remaining -= start - bytes.length();
            length -= start - bytes.length();
          }
        }
      }
      if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type2 === asn1.Type.BITSTRING) {
        bitStringContents = bytes.bytes(length);
      }
      if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
      // .. other parts of forge expect to decode OCTET STRINGs manually
      type2 === asn1.Type.BITSTRING && length > 1) {
        var savedRead = bytes.read;
        var savedRemaining = remaining;
        var unused = 0;
        if (type2 === asn1.Type.BITSTRING) {
          _checkBufferLength(bytes, remaining, 1);
          unused = bytes.getByte();
          remaining--;
        }
        if (unused === 0) {
          try {
            start = bytes.length();
            var subOptions = {
              // enforce strict mode to avoid parsing ASN.1 from plain data
              strict: true,
              decodeBitStrings: true
            };
            var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
            var used = start - bytes.length();
            remaining -= used;
            if (type2 == asn1.Type.BITSTRING) {
              used++;
            }
            var tc = composed.tagClass;
            if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
              value = [composed];
            }
          } catch (ex) {
          }
        }
        if (value === void 0) {
          bytes.read = savedRead;
          remaining = savedRemaining;
        }
      }
      if (value === void 0) {
        if (length === void 0) {
          if (options.strict) {
            throw new Error("Non-constructed ASN.1 object of indefinite length.");
          }
          length = remaining;
        }
        if (type2 === asn1.Type.BMPSTRING) {
          value = "";
          for (; length > 0; length -= 2) {
            _checkBufferLength(bytes, remaining, 2);
            value += String.fromCharCode(bytes.getInt16());
            remaining -= 2;
          }
        } else {
          value = bytes.getBytes(length);
          remaining -= length;
        }
      }
      var asn1Options = bitStringContents === void 0 ? null : {
        bitStringContents
      };
      return asn1.create(tagClass, type2, constructed, value, asn1Options);
    }
    __name(_fromDer, "_fromDer");
    asn1.toDer = function(obj) {
      var bytes = forge.util.createBuffer();
      var b1 = obj.tagClass | obj.type;
      var value = forge.util.createBuffer();
      var useBitStringContents = false;
      if ("bitStringContents" in obj) {
        useBitStringContents = true;
        if (obj.original) {
          useBitStringContents = asn1.equals(obj, obj.original);
        }
      }
      if (useBitStringContents) {
        value.putBytes(obj.bitStringContents);
      } else if (obj.composed) {
        if (obj.constructed) {
          b1 |= 32;
        } else {
          value.putByte(0);
        }
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            value.putBuffer(asn1.toDer(obj.value[i]));
          }
        }
      } else {
        if (obj.type === asn1.Type.BMPSTRING) {
          for (var i = 0; i < obj.value.length; ++i) {
            value.putInt16(obj.value.charCodeAt(i));
          }
        } else {
          if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
          (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
          obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
            value.putBytes(obj.value.substr(1));
          } else {
            value.putBytes(obj.value);
          }
        }
      }
      bytes.putByte(b1);
      if (value.length() <= 127) {
        bytes.putByte(value.length() & 127);
      } else {
        var len = value.length();
        var lenBytes = "";
        do {
          lenBytes += String.fromCharCode(len & 255);
          len = len >>> 8;
        } while (len > 0);
        bytes.putByte(lenBytes.length | 128);
        for (var i = lenBytes.length - 1; i >= 0; --i) {
          bytes.putByte(lenBytes.charCodeAt(i));
        }
      }
      bytes.putBuffer(value);
      return bytes;
    };
    asn1.oidToDer = function(oid) {
      var values = oid.split(".");
      var bytes = forge.util.createBuffer();
      bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
      var last, valueBytes, value, b2;
      for (var i = 2; i < values.length; ++i) {
        last = true;
        valueBytes = [];
        value = parseInt(values[i], 10);
        do {
          b2 = value & 127;
          value = value >>> 7;
          if (!last) {
            b2 |= 128;
          }
          valueBytes.push(b2);
          last = false;
        } while (value > 0);
        for (var n = valueBytes.length - 1; n >= 0; --n) {
          bytes.putByte(valueBytes[n]);
        }
      }
      return bytes;
    };
    asn1.derToOid = function(bytes) {
      var oid;
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var b2 = bytes.getByte();
      oid = Math.floor(b2 / 40) + "." + b2 % 40;
      var value = 0;
      while (bytes.length() > 0) {
        b2 = bytes.getByte();
        value = value << 7;
        if (b2 & 128) {
          value += b2 & 127;
        } else {
          oid += "." + (value + b2);
          value = 0;
        }
      }
      return oid;
    };
    asn1.utcTimeToDate = function(utc) {
      var date = /* @__PURE__ */ new Date();
      var year2 = parseInt(utc.substr(0, 2), 10);
      year2 = year2 >= 50 ? 1900 + year2 : 2e3 + year2;
      var MM = parseInt(utc.substr(2, 2), 10) - 1;
      var DD = parseInt(utc.substr(4, 2), 10);
      var hh = parseInt(utc.substr(6, 2), 10);
      var mm = parseInt(utc.substr(8, 2), 10);
      var ss2 = 0;
      if (utc.length > 11) {
        var c = utc.charAt(10);
        var end = 10;
        if (c !== "+" && c !== "-") {
          ss2 = parseInt(utc.substr(10, 2), 10);
          end += 2;
        }
      }
      date.setUTCFullYear(year2, MM, DD);
      date.setUTCHours(hh, mm, ss2, 0);
      if (end) {
        c = utc.charAt(end);
        if (c === "+" || c === "-") {
          var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
          var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
          var offset = hhoffset * 60 + mmoffset;
          offset *= 6e4;
          if (c === "+") {
            date.setTime(+date - offset);
          } else {
            date.setTime(+date + offset);
          }
        }
      }
      return date;
    };
    asn1.generalizedTimeToDate = function(gentime) {
      var date = /* @__PURE__ */ new Date();
      var YYYY = parseInt(gentime.substr(0, 4), 10);
      var MM = parseInt(gentime.substr(4, 2), 10) - 1;
      var DD = parseInt(gentime.substr(6, 2), 10);
      var hh = parseInt(gentime.substr(8, 2), 10);
      var mm = parseInt(gentime.substr(10, 2), 10);
      var ss2 = parseInt(gentime.substr(12, 2), 10);
      var fff = 0;
      var offset = 0;
      var isUTC = false;
      if (gentime.charAt(gentime.length - 1) === "Z") {
        isUTC = true;
      }
      var end = gentime.length - 5, c = gentime.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
        var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
        offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          offset *= -1;
        }
        isUTC = true;
      }
      if (gentime.charAt(14) === ".") {
        fff = parseFloat(gentime.substr(14), 10) * 1e3;
      }
      if (isUTC) {
        date.setUTCFullYear(YYYY, MM, DD);
        date.setUTCHours(hh, mm, ss2, fff);
        date.setTime(+date + offset);
      } else {
        date.setFullYear(YYYY, MM, DD);
        date.setHours(hh, mm, ss2, fff);
      }
      return date;
    };
    asn1.dateToUtcTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push(("" + date.getUTCFullYear()).substr(2));
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i = 0; i < format2.length; ++i) {
        if (format2[i].length < 2) {
          rval += "0";
        }
        rval += format2[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.dateToGeneralizedTime = function(date) {
      if (typeof date === "string") {
        return date;
      }
      var rval = "";
      var format2 = [];
      format2.push("" + date.getUTCFullYear());
      format2.push("" + (date.getUTCMonth() + 1));
      format2.push("" + date.getUTCDate());
      format2.push("" + date.getUTCHours());
      format2.push("" + date.getUTCMinutes());
      format2.push("" + date.getUTCSeconds());
      for (var i = 0; i < format2.length; ++i) {
        if (format2[i].length < 2) {
          rval += "0";
        }
        rval += format2[i];
      }
      rval += "Z";
      return rval;
    };
    asn1.integerToDer = function(x) {
      var rval = forge.util.createBuffer();
      if (x >= -128 && x < 128) {
        return rval.putSignedInt(x, 8);
      }
      if (x >= -32768 && x < 32768) {
        return rval.putSignedInt(x, 16);
      }
      if (x >= -8388608 && x < 8388608) {
        return rval.putSignedInt(x, 24);
      }
      if (x >= -2147483648 && x < 2147483648) {
        return rval.putSignedInt(x, 32);
      }
      var error3 = new Error("Integer too large; max is 32-bits.");
      error3.integer = x;
      throw error3;
    };
    asn1.derToInteger = function(bytes) {
      if (typeof bytes === "string") {
        bytes = forge.util.createBuffer(bytes);
      }
      var n = bytes.length() * 8;
      if (n > 32) {
        throw new Error("Integer too large; max is 32-bits.");
      }
      return bytes.getSignedInt(n);
    };
    asn1.validate = function(obj, v2, capture, errors) {
      var rval = false;
      if ((obj.tagClass === v2.tagClass || typeof v2.tagClass === "undefined") && (obj.type === v2.type || typeof v2.type === "undefined")) {
        if (obj.constructed === v2.constructed || typeof v2.constructed === "undefined") {
          rval = true;
          if (v2.value && forge.util.isArray(v2.value)) {
            var j = 0;
            for (var i = 0; rval && i < v2.value.length; ++i) {
              rval = v2.value[i].optional || false;
              if (obj.value[j]) {
                rval = asn1.validate(obj.value[j], v2.value[i], capture, errors);
                if (rval) {
                  ++j;
                } else if (v2.value[i].optional) {
                  rval = true;
                }
              }
              if (!rval && errors) {
                errors.push(
                  "[" + v2.name + '] Tag class "' + v2.tagClass + '", type "' + v2.type + '" expected value length "' + v2.value.length + '", got "' + obj.value.length + '"'
                );
              }
            }
          }
          if (rval && capture) {
            if (v2.capture) {
              capture[v2.capture] = obj.value;
            }
            if (v2.captureAsn1) {
              capture[v2.captureAsn1] = obj;
            }
            if (v2.captureBitStringContents && "bitStringContents" in obj) {
              capture[v2.captureBitStringContents] = obj.bitStringContents;
            }
            if (v2.captureBitStringValue && "bitStringContents" in obj) {
              var value;
              if (obj.bitStringContents.length < 2) {
                capture[v2.captureBitStringValue] = "";
              } else {
                var unused = obj.bitStringContents.charCodeAt(0);
                if (unused !== 0) {
                  throw new Error(
                    "captureBitStringValue only supported for zero unused bits"
                  );
                }
                capture[v2.captureBitStringValue] = obj.bitStringContents.slice(1);
              }
            }
          }
        } else if (errors) {
          errors.push(
            "[" + v2.name + '] Expected constructed "' + v2.constructed + '", got "' + obj.constructed + '"'
          );
        }
      } else if (errors) {
        if (obj.tagClass !== v2.tagClass) {
          errors.push(
            "[" + v2.name + '] Expected tag class "' + v2.tagClass + '", got "' + obj.tagClass + '"'
          );
        }
        if (obj.type !== v2.type) {
          errors.push(
            "[" + v2.name + '] Expected type "' + v2.type + '", got "' + obj.type + '"'
          );
        }
      }
      return rval;
    };
    var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
    asn1.prettyPrint = function(obj, level, indentation) {
      var rval = "";
      level = level || 0;
      indentation = indentation || 2;
      if (level > 0) {
        rval += "\n";
      }
      var indent = "";
      for (var i = 0; i < level * indentation; ++i) {
        indent += " ";
      }
      rval += indent + "Tag: ";
      switch (obj.tagClass) {
        case asn1.Class.UNIVERSAL:
          rval += "Universal:";
          break;
        case asn1.Class.APPLICATION:
          rval += "Application:";
          break;
        case asn1.Class.CONTEXT_SPECIFIC:
          rval += "Context-Specific:";
          break;
        case asn1.Class.PRIVATE:
          rval += "Private:";
          break;
      }
      if (obj.tagClass === asn1.Class.UNIVERSAL) {
        rval += obj.type;
        switch (obj.type) {
          case asn1.Type.NONE:
            rval += " (None)";
            break;
          case asn1.Type.BOOLEAN:
            rval += " (Boolean)";
            break;
          case asn1.Type.INTEGER:
            rval += " (Integer)";
            break;
          case asn1.Type.BITSTRING:
            rval += " (Bit string)";
            break;
          case asn1.Type.OCTETSTRING:
            rval += " (Octet string)";
            break;
          case asn1.Type.NULL:
            rval += " (Null)";
            break;
          case asn1.Type.OID:
            rval += " (Object Identifier)";
            break;
          case asn1.Type.ODESC:
            rval += " (Object Descriptor)";
            break;
          case asn1.Type.EXTERNAL:
            rval += " (External or Instance of)";
            break;
          case asn1.Type.REAL:
            rval += " (Real)";
            break;
          case asn1.Type.ENUMERATED:
            rval += " (Enumerated)";
            break;
          case asn1.Type.EMBEDDED:
            rval += " (Embedded PDV)";
            break;
          case asn1.Type.UTF8:
            rval += " (UTF8)";
            break;
          case asn1.Type.ROID:
            rval += " (Relative Object Identifier)";
            break;
          case asn1.Type.SEQUENCE:
            rval += " (Sequence)";
            break;
          case asn1.Type.SET:
            rval += " (Set)";
            break;
          case asn1.Type.PRINTABLESTRING:
            rval += " (Printable String)";
            break;
          case asn1.Type.IA5String:
            rval += " (IA5String (ASCII))";
            break;
          case asn1.Type.UTCTIME:
            rval += " (UTC time)";
            break;
          case asn1.Type.GENERALIZEDTIME:
            rval += " (Generalized time)";
            break;
          case asn1.Type.BMPSTRING:
            rval += " (BMP String)";
            break;
        }
      } else {
        rval += obj.type;
      }
      rval += "\n";
      rval += indent + "Constructed: " + obj.constructed + "\n";
      if (obj.composed) {
        var subvalues = 0;
        var sub = "";
        for (var i = 0; i < obj.value.length; ++i) {
          if (obj.value[i] !== void 0) {
            subvalues += 1;
            sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
            if (i + 1 < obj.value.length) {
              sub += ",";
            }
          }
        }
        rval += indent + "Sub values: " + subvalues + sub;
      } else {
        rval += indent + "Value: ";
        if (obj.type === asn1.Type.OID) {
          var oid = asn1.derToOid(obj.value);
          rval += oid;
          if (forge.pki && forge.pki.oids) {
            if (oid in forge.pki.oids) {
              rval += " (" + forge.pki.oids[oid] + ") ";
            }
          }
        }
        if (obj.type === asn1.Type.INTEGER) {
          try {
            rval += asn1.derToInteger(obj.value);
          } catch (ex) {
            rval += "0x" + forge.util.bytesToHex(obj.value);
          }
        } else if (obj.type === asn1.Type.BITSTRING) {
          if (obj.value.length > 1) {
            rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
          } else {
            rval += "(none)";
          }
          if (obj.value.length > 0) {
            var unused = obj.value.charCodeAt(0);
            if (unused == 1) {
              rval += " (1 unused bit shown)";
            } else if (unused > 1) {
              rval += " (" + unused + " unused bits shown)";
            }
          }
        } else if (obj.type === asn1.Type.OCTETSTRING) {
          if (!_nonLatinRegex.test(obj.value)) {
            rval += "(" + obj.value + ") ";
          }
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.type === asn1.Type.UTF8) {
          try {
            rval += forge.util.decodeUtf8(obj.value);
          } catch (e) {
            if (e.message === "URI malformed") {
              rval += "0x" + forge.util.bytesToHex(obj.value) + " (malformed UTF8)";
            } else {
              throw e;
            }
          }
        } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
          rval += obj.value;
        } else if (_nonLatinRegex.test(obj.value)) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        } else if (obj.value.length === 0) {
          rval += "[null]";
        } else {
          rval += obj.value;
        }
      }
      return rval;
    };
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS({
  "node_modules/node-forge/lib/md.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    module.exports = forge.md = forge.md || {};
    forge.md.algorithms = forge.md.algorithms || {};
  }
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS({
  "node_modules/node-forge/lib/hmac.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_md();
    require_util4();
    var hmac = module.exports = forge.hmac = forge.hmac || {};
    hmac.create = function() {
      var _key = null;
      var _md = null;
      var _ipadding = null;
      var _opadding = null;
      var ctx = {};
      ctx.start = function(md, key) {
        if (md !== null) {
          if (typeof md === "string") {
            md = md.toLowerCase();
            if (md in forge.md.algorithms) {
              _md = forge.md.algorithms[md].create();
            } else {
              throw new Error('Unknown hash algorithm "' + md + '"');
            }
          } else {
            _md = md;
          }
        }
        if (key === null) {
          key = _key;
        } else {
          if (typeof key === "string") {
            key = forge.util.createBuffer(key);
          } else if (forge.util.isArray(key)) {
            var tmp = key;
            key = forge.util.createBuffer();
            for (var i = 0; i < tmp.length; ++i) {
              key.putByte(tmp[i]);
            }
          }
          var keylen = key.length();
          if (keylen > _md.blockLength) {
            _md.start();
            _md.update(key.bytes());
            key = _md.digest();
          }
          _ipadding = forge.util.createBuffer();
          _opadding = forge.util.createBuffer();
          keylen = key.length();
          for (var i = 0; i < keylen; ++i) {
            var tmp = key.at(i);
            _ipadding.putByte(54 ^ tmp);
            _opadding.putByte(92 ^ tmp);
          }
          if (keylen < _md.blockLength) {
            var tmp = _md.blockLength - keylen;
            for (var i = 0; i < tmp; ++i) {
              _ipadding.putByte(54);
              _opadding.putByte(92);
            }
          }
          _key = key;
          _ipadding = _ipadding.bytes();
          _opadding = _opadding.bytes();
        }
        _md.start();
        _md.update(_ipadding);
      };
      ctx.update = function(bytes) {
        _md.update(bytes);
      };
      ctx.getMac = function() {
        var inner = _md.digest().bytes();
        _md.start();
        _md.update(_opadding);
        _md.update(inner);
        return _md.digest();
      };
      ctx.digest = ctx.getMac;
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/md5.js
var require_md52 = __commonJS({
  "node_modules/node-forge/lib/md5.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_md();
    require_util4();
    var md5 = module.exports = forge.md5 = forge.md5 || {};
    forge.md.md5 = forge.md.algorithms.md5 = md5;
    md5.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(16);
      var md = {
        algorithm: "md5",
        blockLength: 64,
        digestLength: 16,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var bits, carry = 0;
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          bits = md.fullMessageLength[i] * 8 + carry;
          carry = bits / 4294967296 >>> 0;
          finalBlock.putInt32Le(bits >>> 0);
        }
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32Le(s2.h0);
        rval.putInt32Le(s2.h1);
        rval.putInt32Le(s2.h2);
        rval.putInt32Le(s2.h3);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _g = null;
    var _r = null;
    var _k = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _g = [
        0,
        1,
        2,
        3,
        4,
        5,
        6,
        7,
        8,
        9,
        10,
        11,
        12,
        13,
        14,
        15,
        1,
        6,
        11,
        0,
        5,
        10,
        15,
        4,
        9,
        14,
        3,
        8,
        13,
        2,
        7,
        12,
        5,
        8,
        11,
        14,
        1,
        4,
        7,
        10,
        13,
        0,
        3,
        6,
        9,
        12,
        15,
        2,
        0,
        7,
        14,
        5,
        12,
        3,
        10,
        1,
        8,
        15,
        6,
        13,
        4,
        11,
        2,
        9
      ];
      _r = [
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        7,
        12,
        17,
        22,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        5,
        9,
        14,
        20,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        4,
        11,
        16,
        23,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21,
        6,
        10,
        15,
        21
      ];
      _k = new Array(64);
      for (var i = 0; i < 64; ++i) {
        _k[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
      }
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s, w2, bytes) {
      var t, a2, b2, c, d2, f, r, i;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s.h0;
        b2 = s.h1;
        c = s.h2;
        d2 = s.h3;
        for (i = 0; i < 16; ++i) {
          w2[i] = bytes.getInt32Le();
          f = d2 ^ b2 & (c ^ d2);
          t = a2 + f + _k[i] + w2[i];
          r = _r[i];
          a2 = d2;
          d2 = c;
          c = b2;
          b2 += t << r | t >>> 32 - r;
        }
        for (; i < 32; ++i) {
          f = c ^ d2 & (b2 ^ c);
          t = a2 + f + _k[i] + w2[_g[i]];
          r = _r[i];
          a2 = d2;
          d2 = c;
          c = b2;
          b2 += t << r | t >>> 32 - r;
        }
        for (; i < 48; ++i) {
          f = b2 ^ c ^ d2;
          t = a2 + f + _k[i] + w2[_g[i]];
          r = _r[i];
          a2 = d2;
          d2 = c;
          c = b2;
          b2 += t << r | t >>> 32 - r;
        }
        for (; i < 64; ++i) {
          f = c ^ (b2 | ~d2);
          t = a2 + f + _k[i] + w2[_g[i]];
          r = _r[i];
          a2 = d2;
          d2 = c;
          c = b2;
          b2 += t << r | t >>> 32 - r;
        }
        s.h0 = s.h0 + a2 | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d2 | 0;
        len -= 64;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS({
  "node_modules/node-forge/lib/pem.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    var pem = module.exports = forge.pem = forge.pem || {};
    pem.encode = function(msg, options) {
      options = options || {};
      var rval = "-----BEGIN " + msg.type + "-----\r\n";
      var header;
      if (msg.procType) {
        header = {
          name: "Proc-Type",
          values: [String(msg.procType.version), msg.procType.type]
        };
        rval += foldHeader(header);
      }
      if (msg.contentDomain) {
        header = { name: "Content-Domain", values: [msg.contentDomain] };
        rval += foldHeader(header);
      }
      if (msg.dekInfo) {
        header = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
        if (msg.dekInfo.parameters) {
          header.values.push(msg.dekInfo.parameters);
        }
        rval += foldHeader(header);
      }
      if (msg.headers) {
        for (var i = 0; i < msg.headers.length; ++i) {
          rval += foldHeader(msg.headers[i]);
        }
      }
      if (msg.procType) {
        rval += "\r\n";
      }
      rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
      rval += "-----END " + msg.type + "-----\r\n";
      return rval;
    };
    pem.decode = function(str) {
      var rval = [];
      var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
      var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
      var rCRLF = /\r?\n/;
      var match;
      while (true) {
        match = rMessage.exec(str);
        if (!match) {
          break;
        }
        var type2 = match[1];
        if (type2 === "NEW CERTIFICATE REQUEST") {
          type2 = "CERTIFICATE REQUEST";
        }
        var msg = {
          type: type2,
          procType: null,
          contentDomain: null,
          dekInfo: null,
          headers: [],
          body: forge.util.decode64(match[3])
        };
        rval.push(msg);
        if (!match[2]) {
          continue;
        }
        var lines = match[2].split(rCRLF);
        var li = 0;
        while (match && li < lines.length) {
          var line = lines[li].replace(/\s+$/, "");
          for (var nl = li + 1; nl < lines.length; ++nl) {
            var next = lines[nl];
            if (!/\s/.test(next[0])) {
              break;
            }
            line += next;
            li = nl;
          }
          match = line.match(rHeader);
          if (match) {
            var header = { name: match[1], values: [] };
            var values = match[2].split(",");
            for (var vi2 = 0; vi2 < values.length; ++vi2) {
              header.values.push(ltrim(values[vi2]));
            }
            if (!msg.procType) {
              if (header.name !== "Proc-Type") {
                throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
              } else if (header.values.length !== 2) {
                throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
              }
              msg.procType = { version: values[0], type: values[1] };
            } else if (!msg.contentDomain && header.name === "Content-Domain") {
              msg.contentDomain = values[0] || "";
            } else if (!msg.dekInfo && header.name === "DEK-Info") {
              if (header.values.length === 0) {
                throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
              }
              msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
            } else {
              msg.headers.push(header);
            }
          }
          ++li;
        }
        if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
          throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
        }
      }
      if (rval.length === 0) {
        throw new Error("Invalid PEM formatted message.");
      }
      return rval;
    };
    function foldHeader(header) {
      var rval = header.name + ": ";
      var values = [];
      var insertSpace = /* @__PURE__ */ __name(function(match, $1) {
        return " " + $1;
      }, "insertSpace");
      for (var i = 0; i < header.values.length; ++i) {
        values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
      }
      rval += values.join(",") + "\r\n";
      var length = 0;
      var candidate = -1;
      for (var i = 0; i < rval.length; ++i, ++length) {
        if (length > 65 && candidate !== -1) {
          var insert = rval[candidate];
          if (insert === ",") {
            ++candidate;
            rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
          } else {
            rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
          }
          length = i - candidate - 1;
          candidate = -1;
          ++i;
        } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
          candidate = i;
        }
      }
      return rval;
    }
    __name(foldHeader, "foldHeader");
    function ltrim(str) {
      return str.replace(/^\s+/, "");
    }
    __name(ltrim, "ltrim");
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS({
  "node_modules/node-forge/lib/des.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_cipher();
    require_cipherModes();
    require_util4();
    module.exports = forge.des = forge.des || {};
    forge.des.startEncrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: false,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createEncryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: false,
        mode
      });
    };
    forge.des.startDecrypting = function(key, iv, output, mode) {
      var cipher = _createCipher({
        key,
        output,
        decrypt: true,
        mode: mode || (iv === null ? "ECB" : "CBC")
      });
      cipher.start(iv);
      return cipher;
    };
    forge.des.createDecryptionCipher = function(key, mode) {
      return _createCipher({
        key,
        output: null,
        decrypt: true,
        mode
      });
    };
    forge.des.Algorithm = function(name, mode) {
      var self2 = this;
      self2.name = name;
      self2.mode = new mode({
        blockSize: 8,
        cipher: {
          encrypt: /* @__PURE__ */ __name(function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, false);
          }, "encrypt"),
          decrypt: /* @__PURE__ */ __name(function(inBlock, outBlock) {
            return _updateBlock(self2._keys, inBlock, outBlock, true);
          }, "decrypt")
        }
      });
      self2._init = false;
    };
    forge.des.Algorithm.prototype.initialize = function(options) {
      if (this._init) {
        return;
      }
      var key = forge.util.createBuffer(options.key);
      if (this.name.indexOf("3DES") === 0) {
        if (key.length() !== 24) {
          throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
        }
      }
      this._keys = _createKeys(key);
      this._init = true;
    };
    registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
    registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
    registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
    registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
    registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
    registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
    function registerAlgorithm(name, mode) {
      var factory = /* @__PURE__ */ __name(function() {
        return new forge.des.Algorithm(name, mode);
      }, "factory");
      forge.cipher.registerAlgorithm(name, factory);
    }
    __name(registerAlgorithm, "registerAlgorithm");
    var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
    var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
    var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
    var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
    var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
    var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
    var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
    var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
    function _createKeys(key) {
      var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
      var iterations = key.length() > 8 ? 3 : 1;
      var keys = [];
      var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
      var n = 0, tmp;
      for (var j = 0; j < iterations; j++) {
        var left = key.getInt32();
        var right = key.getInt32();
        tmp = (left >>> 4 ^ right) & 252645135;
        right ^= tmp;
        left ^= tmp << 4;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 2 ^ right) & 858993459;
        right ^= tmp;
        left ^= tmp << 2;
        tmp = (right >>> -16 ^ left) & 65535;
        left ^= tmp;
        right ^= tmp << -16;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = (right >>> 8 ^ left) & 16711935;
        left ^= tmp;
        right ^= tmp << 8;
        tmp = (left >>> 1 ^ right) & 1431655765;
        right ^= tmp;
        left ^= tmp << 1;
        tmp = left << 8 | right >>> 20 & 240;
        left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
        right = tmp;
        for (var i = 0; i < shifts.length; ++i) {
          if (shifts[i]) {
            left = left << 2 | left >>> 26;
            right = right << 2 | right >>> 26;
          } else {
            left = left << 1 | left >>> 27;
            right = right << 1 | right >>> 27;
          }
          left &= -15;
          right &= -15;
          var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
          var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
          tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
          keys[n++] = lefttmp ^ tmp;
          keys[n++] = righttmp ^ tmp << 16;
        }
      }
      return keys;
    }
    __name(_createKeys, "_createKeys");
    function _updateBlock(keys, input, output, decrypt4) {
      var iterations = keys.length === 32 ? 3 : 9;
      var looping;
      if (iterations === 3) {
        looping = decrypt4 ? [30, -2, -2] : [0, 32, 2];
      } else {
        looping = decrypt4 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
      }
      var tmp;
      var left = input[0];
      var right = input[1];
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      left = left << 1 | left >>> 31;
      right = right << 1 | right >>> 31;
      for (var j = 0; j < iterations; j += 3) {
        var endloop = looping[j + 1];
        var loopinc = looping[j + 2];
        for (var i = looping[j]; i != endloop; i += loopinc) {
          var right1 = right ^ keys[i];
          var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
          tmp = left;
          left = right;
          right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
        }
        tmp = left;
        left = right;
        right = tmp;
      }
      left = left >>> 1 | left << 31;
      right = right >>> 1 | right << 31;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (right >>> 2 ^ left) & 858993459;
      left ^= tmp;
      right ^= tmp << 2;
      tmp = (left >>> 16 ^ right) & 65535;
      right ^= tmp;
      left ^= tmp << 16;
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      output[0] = left;
      output[1] = right;
    }
    __name(_updateBlock, "_updateBlock");
    function _createCipher(options) {
      options = options || {};
      var mode = (options.mode || "CBC").toUpperCase();
      var algorithm = "DES-" + mode;
      var cipher;
      if (options.decrypt) {
        cipher = forge.cipher.createDecipher(algorithm, options.key);
      } else {
        cipher = forge.cipher.createCipher(algorithm, options.key);
      }
      var start = cipher.start;
      cipher.start = function(iv, options2) {
        var output = null;
        if (options2 instanceof forge.util.ByteBuffer) {
          output = options2;
          options2 = {};
        }
        options2 = options2 || {};
        options2.output = output;
        options2.iv = iv;
        start.call(cipher, options2);
      };
      return cipher;
    }
    __name(_createCipher, "_createCipher");
  }
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/node-forge/lib/pbkdf2.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_hmac();
    require_md();
    require_util4();
    var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
    var crypto2;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
      crypto2 = require_crypto2();
    }
    module.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p2, s, c, dkLen, md, callback) {
      if (typeof md === "function") {
        callback = md;
        md = null;
      }
      if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
        if (typeof md !== "string") {
          md = "sha1";
        }
        p2 = Buffer.from(p2, "binary");
        s = Buffer.from(s, "binary");
        if (!callback) {
          if (crypto2.pbkdf2Sync.length === 4) {
            return crypto2.pbkdf2Sync(p2, s, c, dkLen).toString("binary");
          }
          return crypto2.pbkdf2Sync(p2, s, c, dkLen, md).toString("binary");
        }
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2(p2, s, c, dkLen, function(err2, key) {
            if (err2) {
              return callback(err2);
            }
            callback(null, key.toString("binary"));
          });
        }
        return crypto2.pbkdf2(p2, s, c, dkLen, md, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      if (typeof md === "undefined" || md === null) {
        md = "sha1";
      }
      if (typeof md === "string") {
        if (!(md in forge.md.algorithms)) {
          throw new Error("Unknown hash algorithm: " + md);
        }
        md = forge.md[md].create();
      }
      var hLen = md.digestLength;
      if (dkLen > 4294967295 * hLen) {
        var err = new Error("Derived key is too long.");
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      var len = Math.ceil(dkLen / hLen);
      var r = dkLen - (len - 1) * hLen;
      var prf = forge.hmac.create();
      prf.start(md, p2);
      var dk = "";
      var xor, u_c, u_c1;
      if (!callback) {
        for (var i = 1; i <= len; ++i) {
          prf.start(null, null);
          prf.update(s);
          prf.update(forge.util.int32ToBytes(i));
          xor = u_c1 = prf.digest().getBytes();
          for (var j = 2; j <= c; ++j) {
            prf.start(null, null);
            prf.update(u_c1);
            u_c = prf.digest().getBytes();
            xor = forge.util.xorBytes(xor, u_c, hLen);
            u_c1 = u_c;
          }
          dk += i < len ? xor : xor.substr(0, r);
        }
        return dk;
      }
      var i = 1, j;
      function outer() {
        if (i > len) {
          return callback(null, dk);
        }
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        j = 2;
        inner();
      }
      __name(outer, "outer");
      function inner() {
        if (j <= c) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
          ++j;
          return forge.util.setImmediate(inner);
        }
        dk += i < len ? xor : xor.substr(0, r);
        ++i;
        outer();
      }
      __name(inner, "inner");
      outer();
    };
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS({
  "node_modules/node-forge/lib/sha256.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_md();
    require_util4();
    var sha256 = module.exports = forge.sha256 = forge.sha256 || {};
    forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
    sha256.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(64);
      var md = {
        algorithm: "sha256",
        blockLength: 64,
        digestLength: 32,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1779033703,
          h1: 3144134277,
          h2: 1013904242,
          h3: 2773480762,
          h4: 1359893119,
          h5: 2600822924,
          h6: 528734635,
          h7: 1541459225
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4,
          h5: _state.h5,
          h6: _state.h6,
          h7: _state.h7
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        rval.putInt32(s2.h5);
        rval.putInt32(s2.h6);
        rval.putInt32(s2.h7);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _k = [
        1116352408,
        1899447441,
        3049323471,
        3921009573,
        961987163,
        1508970993,
        2453635748,
        2870763221,
        3624381080,
        310598401,
        607225278,
        1426881987,
        1925078388,
        2162078206,
        2614888103,
        3248222580,
        3835390401,
        4022224774,
        264347078,
        604807628,
        770255983,
        1249150122,
        1555081692,
        1996064986,
        2554220882,
        2821834349,
        2952996808,
        3210313671,
        3336571891,
        3584528711,
        113926993,
        338241895,
        666307205,
        773529912,
        1294757372,
        1396182291,
        1695183700,
        1986661051,
        2177026350,
        2456956037,
        2730485921,
        2820302411,
        3259730800,
        3345764771,
        3516065817,
        3600352804,
        4094571909,
        275423344,
        430227734,
        506948616,
        659060556,
        883997877,
        958139571,
        1322822218,
        1537002063,
        1747873779,
        1955562222,
        2024104815,
        2227730452,
        2361852424,
        2428436474,
        2756734187,
        3204031479,
        3329325298
      ];
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s, w2, bytes) {
      var t1, t2, s0, s1, ch, maj, i, a2, b2, c, d2, e, f, g, h;
      var len = bytes.length();
      while (len >= 64) {
        for (i = 0; i < 16; ++i) {
          w2[i] = bytes.getInt32();
        }
        for (; i < 64; ++i) {
          t1 = w2[i - 2];
          t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
          t2 = w2[i - 15];
          t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
          w2[i] = t1 + w2[i - 7] + t2 + w2[i - 16] | 0;
        }
        a2 = s.h0;
        b2 = s.h1;
        c = s.h2;
        d2 = s.h3;
        e = s.h4;
        f = s.h5;
        g = s.h6;
        h = s.h7;
        for (i = 0; i < 64; ++i) {
          s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
          ch = g ^ e & (f ^ g);
          s0 = (a2 >>> 2 | a2 << 30) ^ (a2 >>> 13 | a2 << 19) ^ (a2 >>> 22 | a2 << 10);
          maj = a2 & b2 | c & (a2 ^ b2);
          t1 = h + s1 + ch + _k[i] + w2[i];
          t2 = s0 + maj;
          h = g;
          g = f;
          f = e;
          e = d2 + t1 >>> 0;
          d2 = c;
          c = b2;
          b2 = a2;
          a2 = t1 + t2 >>> 0;
        }
        s.h0 = s.h0 + a2 | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d2 | 0;
        s.h4 = s.h4 + e | 0;
        s.h5 = s.h5 + f | 0;
        s.h6 = s.h6 + g | 0;
        s.h7 = s.h7 + h | 0;
        len -= 64;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS({
  "node_modules/node-forge/lib/prng.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    var _crypto = null;
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
      _crypto = require_crypto2();
    }
    var prng = module.exports = forge.prng = forge.prng || {};
    prng.create = function(plugin) {
      var ctx = {
        plugin,
        key: null,
        seed: null,
        time: null,
        // number of reseeds so far
        reseeds: 0,
        // amount of data generated so far
        generated: 0,
        // no initial key bytes
        keyBytes: ""
      };
      var md = plugin.md;
      var pools = new Array(32);
      for (var i = 0; i < 32; ++i) {
        pools[i] = md.create();
      }
      ctx.pools = pools;
      ctx.pool = 0;
      ctx.generate = function(count3, callback) {
        if (!callback) {
          return ctx.generateSync(count3);
        }
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        var b2 = forge.util.createBuffer();
        ctx.key = null;
        generate();
        function generate(err) {
          if (err) {
            return callback(err);
          }
          if (b2.length() >= count3) {
            return callback(null, b2.getBytes(count3));
          }
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            return forge.util.nextTick(function() {
              _reseed(generate);
            });
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
          forge.util.setImmediate(generate);
        }
        __name(generate, "generate");
      };
      ctx.generateSync = function(count3) {
        var cipher = ctx.plugin.cipher;
        var increment = ctx.plugin.increment;
        var formatKey = ctx.plugin.formatKey;
        var formatSeed = ctx.plugin.formatSeed;
        ctx.key = null;
        var b2 = forge.util.createBuffer();
        while (b2.length() < count3) {
          if (ctx.generated > 1048575) {
            ctx.key = null;
          }
          if (ctx.key === null) {
            _reseedSync();
          }
          var bytes = cipher(ctx.key, ctx.seed);
          ctx.generated += bytes.length;
          b2.putBytes(bytes);
          ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
          ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        }
        return b2.getBytes(count3);
      };
      function _reseed(callback) {
        if (ctx.pools[0].messageLength >= 32) {
          _seed();
          return callback();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.seedFile(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          ctx.collect(bytes);
          _seed();
          callback();
        });
      }
      __name(_reseed, "_reseed");
      function _reseedSync() {
        if (ctx.pools[0].messageLength >= 32) {
          return _seed();
        }
        var needed = 32 - ctx.pools[0].messageLength << 5;
        ctx.collect(ctx.seedFileSync(needed));
        _seed();
      }
      __name(_reseedSync, "_reseedSync");
      function _seed() {
        ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
        var md2 = ctx.plugin.md.create();
        md2.update(ctx.keyBytes);
        var _2powK = 1;
        for (var k = 0; k < 32; ++k) {
          if (ctx.reseeds % _2powK === 0) {
            md2.update(ctx.pools[k].digest().getBytes());
            ctx.pools[k].start();
          }
          _2powK = _2powK << 1;
        }
        ctx.keyBytes = md2.digest().getBytes();
        md2.start();
        md2.update(ctx.keyBytes);
        var seedBytes = md2.digest().getBytes();
        ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
        ctx.seed = ctx.plugin.formatSeed(seedBytes);
        ctx.generated = 0;
      }
      __name(_seed, "_seed");
      function defaultSeedFile(needed) {
        var getRandomValues2 = null;
        var globalScope = forge.util.globalScope;
        var _crypto2 = globalScope.crypto || globalScope.msCrypto;
        if (_crypto2 && _crypto2.getRandomValues) {
          getRandomValues2 = /* @__PURE__ */ __name(function(arr) {
            return _crypto2.getRandomValues(arr);
          }, "getRandomValues");
        }
        var b2 = forge.util.createBuffer();
        if (getRandomValues2) {
          while (b2.length() < needed) {
            var count3 = Math.max(1, Math.min(needed - b2.length(), 65536) / 4);
            var entropy = new Uint32Array(Math.floor(count3));
            try {
              getRandomValues2(entropy);
              for (var i2 = 0; i2 < entropy.length; ++i2) {
                b2.putInt32(entropy[i2]);
              }
            } catch (e) {
              if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
                throw e;
              }
            }
          }
        }
        if (b2.length() < needed) {
          var hi, lo, next;
          var seed = Math.floor(Math.random() * 65536);
          while (b2.length() < needed) {
            lo = 16807 * (seed & 65535);
            hi = 16807 * (seed >> 16);
            lo += (hi & 32767) << 16;
            lo += hi >> 15;
            lo = (lo & 2147483647) + (lo >> 31);
            seed = lo & 4294967295;
            for (var i2 = 0; i2 < 3; ++i2) {
              next = seed >>> (i2 << 3);
              next ^= Math.floor(Math.random() * 256);
              b2.putByte(next & 255);
            }
          }
        }
        return b2.getBytes(needed);
      }
      __name(defaultSeedFile, "defaultSeedFile");
      if (_crypto) {
        ctx.seedFile = function(needed, callback) {
          _crypto.randomBytes(needed, function(err, bytes) {
            if (err) {
              return callback(err);
            }
            callback(null, bytes.toString());
          });
        };
        ctx.seedFileSync = function(needed) {
          return _crypto.randomBytes(needed).toString();
        };
      } else {
        ctx.seedFile = function(needed, callback) {
          try {
            callback(null, defaultSeedFile(needed));
          } catch (e) {
            callback(e);
          }
        };
        ctx.seedFileSync = defaultSeedFile;
      }
      ctx.collect = function(bytes) {
        var count3 = bytes.length;
        for (var i2 = 0; i2 < count3; ++i2) {
          ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
          ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
        }
      };
      ctx.collectInt = function(i2, n) {
        var bytes = "";
        for (var x = 0; x < n; x += 8) {
          bytes += String.fromCharCode(i2 >> x & 255);
        }
        ctx.collect(bytes);
      };
      ctx.registerWorker = function(worker) {
        if (worker === self) {
          ctx.seedFile = function(needed, callback) {
            function listener2(e) {
              var data = e.data;
              if (data.forge && data.forge.prng) {
                self.removeEventListener("message", listener2);
                callback(data.forge.prng.err, data.forge.prng.bytes);
              }
            }
            __name(listener2, "listener");
            self.addEventListener("message", listener2);
            self.postMessage({ forge: { prng: { needed } } });
          };
        } else {
          var listener = /* @__PURE__ */ __name(function(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
                worker.postMessage({ forge: { prng: { err, bytes } } });
              });
            }
          }, "listener");
          worker.addEventListener("message", listener);
        }
      };
      return ctx;
    };
  }
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS({
  "node_modules/node-forge/lib/random.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_sha256();
    require_prng();
    require_util4();
    (function() {
      if (forge.random && forge.random.getBytes) {
        module.exports = forge.random;
        return;
      }
      (function(jQuery2) {
        var prng_aes = {};
        var _prng_aes_output = new Array(4);
        var _prng_aes_buffer = forge.util.createBuffer();
        prng_aes.formatKey = function(key2) {
          var tmp = forge.util.createBuffer(key2);
          key2 = new Array(4);
          key2[0] = tmp.getInt32();
          key2[1] = tmp.getInt32();
          key2[2] = tmp.getInt32();
          key2[3] = tmp.getInt32();
          return forge.aes._expandKey(key2, false);
        };
        prng_aes.formatSeed = function(seed) {
          var tmp = forge.util.createBuffer(seed);
          seed = new Array(4);
          seed[0] = tmp.getInt32();
          seed[1] = tmp.getInt32();
          seed[2] = tmp.getInt32();
          seed[3] = tmp.getInt32();
          return seed;
        };
        prng_aes.cipher = function(key2, seed) {
          forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
          _prng_aes_buffer.putInt32(_prng_aes_output[0]);
          _prng_aes_buffer.putInt32(_prng_aes_output[1]);
          _prng_aes_buffer.putInt32(_prng_aes_output[2]);
          _prng_aes_buffer.putInt32(_prng_aes_output[3]);
          return _prng_aes_buffer.getBytes();
        };
        prng_aes.increment = function(seed) {
          ++seed[3];
          return seed;
        };
        prng_aes.md = forge.md.sha256;
        function spawnPrng() {
          var ctx = forge.prng.create(prng_aes);
          ctx.getBytes = function(count3, callback) {
            return ctx.generate(count3, callback);
          };
          ctx.getBytesSync = function(count3) {
            return ctx.generate(count3);
          };
          return ctx;
        }
        __name(spawnPrng, "spawnPrng");
        var _ctx = spawnPrng();
        var getRandomValues2 = null;
        var globalScope = forge.util.globalScope;
        var _crypto = globalScope.crypto || globalScope.msCrypto;
        if (_crypto && _crypto.getRandomValues) {
          getRandomValues2 = /* @__PURE__ */ __name(function(arr) {
            return _crypto.getRandomValues(arr);
          }, "getRandomValues");
        }
        if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues2) {
          if (typeof window === "undefined" || window.document === void 0) {
          }
          _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
          if (typeof navigator !== "undefined") {
            var _navBytes = "";
            for (var key in navigator) {
              try {
                if (typeof navigator[key] == "string") {
                  _navBytes += navigator[key];
                }
              } catch (e) {
              }
            }
            _ctx.collect(_navBytes);
            _navBytes = null;
          }
          if (jQuery2) {
            jQuery2().mousemove(function(e) {
              _ctx.collectInt(e.clientX, 16);
              _ctx.collectInt(e.clientY, 16);
            });
            jQuery2().keypress(function(e) {
              _ctx.collectInt(e.charCode, 8);
            });
          }
        }
        if (!forge.random) {
          forge.random = _ctx;
        } else {
          for (var key in _ctx) {
            forge.random[key] = _ctx[key];
          }
        }
        forge.random.createInstance = spawnPrng;
        module.exports = forge.random;
      })(typeof jQuery !== "undefined" ? jQuery : null);
    })();
  }
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS({
  "node_modules/node-forge/lib/rc2.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    var piTable = [
      217,
      120,
      249,
      196,
      25,
      221,
      181,
      237,
      40,
      233,
      253,
      121,
      74,
      160,
      216,
      157,
      198,
      126,
      55,
      131,
      43,
      118,
      83,
      142,
      98,
      76,
      100,
      136,
      68,
      139,
      251,
      162,
      23,
      154,
      89,
      245,
      135,
      179,
      79,
      19,
      97,
      69,
      109,
      141,
      9,
      129,
      125,
      50,
      189,
      143,
      64,
      235,
      134,
      183,
      123,
      11,
      240,
      149,
      33,
      34,
      92,
      107,
      78,
      130,
      84,
      214,
      101,
      147,
      206,
      96,
      178,
      28,
      115,
      86,
      192,
      20,
      167,
      140,
      241,
      220,
      18,
      117,
      202,
      31,
      59,
      190,
      228,
      209,
      66,
      61,
      212,
      48,
      163,
      60,
      182,
      38,
      111,
      191,
      14,
      218,
      70,
      105,
      7,
      87,
      39,
      242,
      29,
      155,
      188,
      148,
      67,
      3,
      248,
      17,
      199,
      246,
      144,
      239,
      62,
      231,
      6,
      195,
      213,
      47,
      200,
      102,
      30,
      215,
      8,
      232,
      234,
      222,
      128,
      82,
      238,
      247,
      132,
      170,
      114,
      172,
      53,
      77,
      106,
      42,
      150,
      26,
      210,
      113,
      90,
      21,
      73,
      116,
      75,
      159,
      208,
      94,
      4,
      24,
      164,
      236,
      194,
      224,
      65,
      110,
      15,
      81,
      203,
      204,
      36,
      145,
      175,
      80,
      161,
      244,
      112,
      57,
      153,
      124,
      58,
      133,
      35,
      184,
      180,
      122,
      252,
      2,
      54,
      91,
      37,
      85,
      151,
      49,
      45,
      93,
      250,
      152,
      227,
      138,
      146,
      174,
      5,
      223,
      41,
      16,
      103,
      108,
      186,
      201,
      211,
      0,
      230,
      207,
      225,
      158,
      168,
      44,
      99,
      22,
      1,
      63,
      88,
      226,
      137,
      169,
      13,
      56,
      52,
      27,
      171,
      51,
      255,
      176,
      187,
      72,
      12,
      95,
      185,
      177,
      205,
      46,
      197,
      243,
      219,
      71,
      229,
      165,
      156,
      119,
      10,
      166,
      32,
      104,
      254,
      127,
      193,
      173
    ];
    var s = [1, 2, 3, 5];
    var rol = /* @__PURE__ */ __name(function(word, bits) {
      return word << bits & 65535 | (word & 65535) >> 16 - bits;
    }, "rol");
    var ror = /* @__PURE__ */ __name(function(word, bits) {
      return (word & 65535) >> bits | word << 16 - bits & 65535;
    }, "ror");
    module.exports = forge.rc2 = forge.rc2 || {};
    forge.rc2.expandKey = function(key, effKeyBits) {
      if (typeof key === "string") {
        key = forge.util.createBuffer(key);
      }
      effKeyBits = effKeyBits || 128;
      var L = key;
      var T = key.length();
      var T1 = effKeyBits;
      var T8 = Math.ceil(T1 / 8);
      var TM = 255 >> (T1 & 7);
      var i;
      for (i = T; i < 128; i++) {
        L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
      }
      L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
      for (i = 127 - T8; i >= 0; i--) {
        L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
      }
      return L;
    };
    var createCipher2 = /* @__PURE__ */ __name(function(key, bits, encrypt4) {
      var _finish = false, _input = null, _output = null, _iv = null;
      var mixRound, mashRound;
      var i, j, K = [];
      key = forge.rc2.expandKey(key, bits);
      for (i = 0; i < 64; i++) {
        K.push(key.getInt16Le());
      }
      if (encrypt4) {
        mixRound = /* @__PURE__ */ __name(function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            R[i] = rol(R[i], s[i]);
            j++;
          }
        }, "mixRound");
        mashRound = /* @__PURE__ */ __name(function(R) {
          for (i = 0; i < 4; i++) {
            R[i] += K[R[(i + 3) % 4] & 63];
          }
        }, "mashRound");
      } else {
        mixRound = /* @__PURE__ */ __name(function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] = ror(R[i], s[i]);
            R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
            j--;
          }
        }, "mixRound");
        mashRound = /* @__PURE__ */ __name(function(R) {
          for (i = 3; i >= 0; i--) {
            R[i] -= K[R[(i + 3) % 4] & 63];
          }
        }, "mashRound");
      }
      var runPlan = /* @__PURE__ */ __name(function(plan) {
        var R = [];
        for (i = 0; i < 4; i++) {
          var val = _input.getInt16Le();
          if (_iv !== null) {
            if (encrypt4) {
              val ^= _iv.getInt16Le();
            } else {
              _iv.putInt16Le(val);
            }
          }
          R.push(val & 65535);
        }
        j = encrypt4 ? 0 : 63;
        for (var ptr = 0; ptr < plan.length; ptr++) {
          for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
            plan[ptr][1](R);
          }
        }
        for (i = 0; i < 4; i++) {
          if (_iv !== null) {
            if (encrypt4) {
              _iv.putInt16Le(R[i]);
            } else {
              R[i] ^= _iv.getInt16Le();
            }
          }
          _output.putInt16Le(R[i]);
        }
      }, "runPlan");
      var cipher = null;
      cipher = {
        /**
         * Starts or restarts the encryption or decryption process, whichever
         * was previously configured.
         *
         * To use the cipher in CBC mode, iv may be given either as a string
         * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
         *
         * @param iv the initialization vector to use, null for ECB mode.
         * @param output the output the buffer to write to, null to create one.
         */
        start: /* @__PURE__ */ __name(function(iv, output) {
          if (iv) {
            if (typeof iv === "string") {
              iv = forge.util.createBuffer(iv);
            }
          }
          _finish = false;
          _input = forge.util.createBuffer();
          _output = output || new forge.util.createBuffer();
          _iv = iv;
          cipher.output = _output;
        }, "start"),
        /**
         * Updates the next block.
         *
         * @param input the buffer to read from.
         */
        update: /* @__PURE__ */ __name(function(input) {
          if (!_finish) {
            _input.putBuffer(input);
          }
          while (_input.length() >= 8) {
            runPlan([
              [5, mixRound],
              [1, mashRound],
              [6, mixRound],
              [1, mashRound],
              [5, mixRound]
            ]);
          }
        }, "update"),
        /**
         * Finishes encrypting or decrypting.
         *
         * @param pad a padding function to use, null for PKCS#7 padding,
         *           signature(blockSize, buffer, decrypt).
         *
         * @return true if successful, false on error.
         */
        finish: /* @__PURE__ */ __name(function(pad) {
          var rval = true;
          if (encrypt4) {
            if (pad) {
              rval = pad(8, _input, !encrypt4);
            } else {
              var padding = _input.length() === 8 ? 8 : 8 - _input.length();
              _input.fillWithByte(padding, padding);
            }
          }
          if (rval) {
            _finish = true;
            cipher.update();
          }
          if (!encrypt4) {
            rval = _input.length() === 0;
            if (rval) {
              if (pad) {
                rval = pad(8, _output, !encrypt4);
              } else {
                var len = _output.length();
                var count3 = _output.at(len - 1);
                if (count3 > len) {
                  rval = false;
                } else {
                  _output.truncate(count3);
                }
              }
            }
          }
          return rval;
        }, "finish")
      };
      return cipher;
    }, "createCipher");
    forge.rc2.startEncrypting = function(key, iv, output) {
      var cipher = forge.rc2.createEncryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createEncryptionCipher = function(key, bits) {
      return createCipher2(key, bits, true);
    };
    forge.rc2.startDecrypting = function(key, iv, output) {
      var cipher = forge.rc2.createDecryptionCipher(key, 128);
      cipher.start(iv, output);
      return cipher;
    };
    forge.rc2.createDecryptionCipher = function(key, bits) {
      return createCipher2(key, bits, false);
    };
  }
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS({
  "node_modules/node-forge/lib/jsbn.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    module.exports = forge.jsbn = forge.jsbn || {};
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a2, b2, c) {
      this.data = [];
      if (a2 != null)
        if ("number" == typeof a2) this.fromNumber(a2, b2, c);
        else if (b2 == null && "string" != typeof a2) this.fromString(a2, 256);
        else this.fromString(a2, b2);
    }
    __name(BigInteger, "BigInteger");
    forge.jsbn.BigInteger = BigInteger;
    function nbi() {
      return new BigInteger(null);
    }
    __name(nbi, "nbi");
    function am1(i, x, w2, j, c, n) {
      while (--n >= 0) {
        var v2 = x * this.data[i++] + w2.data[j] + c;
        c = Math.floor(v2 / 67108864);
        w2.data[j++] = v2 & 67108863;
      }
      return c;
    }
    __name(am1, "am1");
    function am2(i, x, w2, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this.data[i] & 32767;
        var h = this.data[i++] >> 15;
        var m2 = xh * l + h * xl;
        l = xl * l + ((m2 & 32767) << 15) + w2.data[j] + (c & 1073741823);
        c = (l >>> 30) + (m2 >>> 15) + xh * h + (c >>> 30);
        w2.data[j++] = l & 1073741823;
      }
      return c;
    }
    __name(am2, "am2");
    function am3(i, x, w2, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this.data[i] & 16383;
        var h = this.data[i++] >> 14;
        var m2 = xh * l + h * xl;
        l = xl * l + ((m2 & 16383) << 14) + w2.data[j] + c;
        c = (l >> 28) + (m2 >> 14) + xh * h;
        w2.data[j++] = l & 268435455;
      }
      return c;
    }
    __name(am3, "am3");
    if (typeof navigator === "undefined") {
      BigInteger.prototype.am = am3;
      dbits = 28;
    } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr;
    var vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    __name(int2char, "int2char");
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    __name(intAt, "intAt");
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
      r.t = this.t;
      r.s = this.s;
    }
    __name(bnpCopyTo, "bnpCopyTo");
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0) this.data[0] = x;
      else if (x < -1) this.data[0] = x + this.DV;
      else this.t = 0;
    }
    __name(bnpFromInt, "bnpFromInt");
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    __name(nbv, "nbv");
    function bnpFromString(s, b2) {
      var k;
      if (b2 == 16) k = 4;
      else if (b2 == 8) k = 3;
      else if (b2 == 256) k = 8;
      else if (b2 == 2) k = 1;
      else if (b2 == 32) k = 5;
      else if (b2 == 4) k = 2;
      else {
        this.fromRadix(s, b2);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi2 = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-") mi2 = true;
          continue;
        }
        mi2 = false;
        if (sh == 0)
          this.data[this.t++] = x;
        else if (sh + k > this.DB) {
          this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this.data[this.t++] = x >> this.DB - sh;
        } else
          this.data[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    __name(bnpFromString, "bnpFromString");
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
    }
    __name(bnpClamp, "bnpClamp");
    function bnToString(b2) {
      if (this.s < 0) return "-" + this.negate().toString(b2);
      var k;
      if (b2 == 16) k = 4;
      else if (b2 == 8) k = 3;
      else if (b2 == 2) k = 1;
      else if (b2 == 32) k = 5;
      else if (b2 == 4) k = 2;
      else return this.toRadix(b2);
      var km = (1 << k) - 1, d2, m2 = false, r = "", i = this.t;
      var p2 = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i] >> p2) > 0) {
          m2 = true;
          r = int2char(d2);
        }
        while (i >= 0) {
          if (p2 < k) {
            d2 = (this.data[i] & (1 << p2) - 1) << k - p2;
            d2 |= this.data[--i] >> (p2 += this.DB - k);
          } else {
            d2 = this.data[i] >> (p2 -= k) & km;
            if (p2 <= 0) {
              p2 += this.DB;
              --i;
            }
          }
          if (d2 > 0) m2 = true;
          if (m2) r += int2char(d2);
        }
      }
      return m2 ? r : "0";
    }
    __name(bnToString, "bnToString");
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    __name(bnNegate, "bnNegate");
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    __name(bnAbs, "bnAbs");
    function bnCompareTo(a2) {
      var r = this.s - a2.s;
      if (r != 0) return r;
      var i = this.t;
      r = i - a2.t;
      if (r != 0) return this.s < 0 ? -r : r;
      while (--i >= 0) if ((r = this.data[i] - a2.data[i]) != 0) return r;
      return 0;
    }
    __name(bnCompareTo, "bnCompareTo");
    function nbits(x) {
      var r = 1, t;
      if ((t = x >>> 16) != 0) {
        x = t;
        r += 16;
      }
      if ((t = x >> 8) != 0) {
        x = t;
        r += 8;
      }
      if ((t = x >> 4) != 0) {
        x = t;
        r += 4;
      }
      if ((t = x >> 2) != 0) {
        x = t;
        r += 2;
      }
      if ((t = x >> 1) != 0) {
        x = t;
        r += 1;
      }
      return r;
    }
    __name(nbits, "nbits");
    function bnBitLength() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
    }
    __name(bnBitLength, "bnBitLength");
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
      for (i = n - 1; i >= 0; --i) r.data[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    __name(bnpDLShiftTo, "bnpDLShiftTo");
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    __name(bnpDRShiftTo, "bnpDRShiftTo");
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds2 = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r.data[i + ds2 + 1] = this.data[i] >> cbs | c;
        c = (this.data[i] & bm) << bs;
      }
      for (i = ds2 - 1; i >= 0; --i) r.data[i] = 0;
      r.data[ds2] = c;
      r.t = this.t + ds2 + 1;
      r.s = this.s;
      r.clamp();
    }
    __name(bnpLShiftTo, "bnpLShiftTo");
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds2 = Math.floor(n / this.DB);
      if (ds2 >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r.data[0] = this.data[ds2] >> bs;
      for (var i = ds2 + 1; i < this.t; ++i) {
        r.data[i - ds2 - 1] |= (this.data[i] & bm) << cbs;
        r.data[i - ds2] = this.data[i] >> bs;
      }
      if (bs > 0) r.data[this.t - ds2 - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds2;
      r.clamp();
    }
    __name(bnpRShiftTo, "bnpRShiftTo");
    function bnpSubTo(a2, r) {
      var i = 0, c = 0, m2 = Math.min(a2.t, this.t);
      while (i < m2) {
        c += this.data[i] - a2.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a2.t < this.t) {
        c -= a2.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a2.t) {
          c -= a2.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a2.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1) r.data[i++] = this.DV + c;
      else if (c > 0) r.data[i++] = c;
      r.t = i;
      r.clamp();
    }
    __name(bnpSubTo, "bnpSubTo");
    function bnpMultiplyTo(a2, r) {
      var x = this.abs(), y = a2.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0) r.data[i] = 0;
      for (i = 0; i < y.t; ++i) r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a2.s) BigInteger.ZERO.subTo(r, r);
    }
    __name(bnpMultiplyTo, "bnpMultiplyTo");
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0) r.data[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
        if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r.data[i + x.t] -= x.DV;
          r.data[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    __name(bnpSquareTo, "bnpSquareTo");
    function bnpDivRemTo(m2, q, r) {
      var pm = m2.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
      }
      if (r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m2.s;
      var nsh = this.DB - nbits(pm.data[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y.data[ys - 1];
      if (y0 == 0) return;
      var yt2 = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt2, d2 = (1 << this.F1) / yt2, e = 1 << this.F2;
      var i = r.t, j = i - ys, t = q == null ? nbi() : q;
      y.dlShiftTo(j, t);
      if (r.compareTo(t) >= 0) {
        r.data[r.t++] = 1;
        r.subTo(t, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t);
      t.subTo(y, y);
      while (y.t < ys) y.data[y.t++] = 0;
      while (--j >= 0) {
        var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
        if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t);
          r.subTo(t, r);
          while (r.data[i] < --qd) r.subTo(t, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms) BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0) r.rShiftTo(nsh, r);
      if (ts < 0) BigInteger.ZERO.subTo(r, r);
    }
    __name(bnpDivRemTo, "bnpDivRemTo");
    function bnMod(a2) {
      var r = nbi();
      this.abs().divRemTo(a2, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a2.subTo(r, r);
      return r;
    }
    __name(bnMod, "bnMod");
    function Classic(m2) {
      this.m = m2;
    }
    __name(Classic, "Classic");
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    __name(cConvert, "cConvert");
    function cRevert(x) {
      return x;
    }
    __name(cRevert, "cRevert");
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    __name(cReduce, "cReduce");
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    __name(cMulTo, "cMulTo");
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(cSqrTo, "cSqrTo");
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1) return 0;
      var x = this.data[0];
      if ((x & 1) == 0) return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    __name(bnpInvDigit, "bnpInvDigit");
    function Montgomery(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    __name(Montgomery, "Montgomery");
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
      return r;
    }
    __name(montConvert, "montConvert");
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    __name(montRevert, "montRevert");
    function montReduce(x) {
      while (x.t <= this.mt2)
        x.data[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x.data[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x.data[j] >= x.DV) {
          x.data[j] -= x.DV;
          x.data[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    __name(montReduce, "montReduce");
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(montSqrTo, "montSqrTo");
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    __name(montMulTo, "montMulTo");
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
    }
    __name(bnpIsEven, "bnpIsEven");
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
        else {
          var t = r;
          r = r2;
          r2 = t;
        }
      }
      return z2.revert(r);
    }
    __name(bnpExp, "bnpExp");
    function bnModPowInt(e, m2) {
      var z2;
      if (e < 256 || m2.isEven()) z2 = new Classic(m2);
      else z2 = new Montgomery(m2);
      return this.exp(e, z2);
    }
    __name(bnModPowInt, "bnModPowInt");
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    __name(bnClone, "bnClone");
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1) return this.data[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this.data[0];
      else if (this.t == 0) return 0;
      return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
    }
    __name(bnIntValue, "bnIntValue");
    function bnByteValue() {
      return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
    }
    __name(bnByteValue, "bnByteValue");
    function bnShortValue() {
      return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
    }
    __name(bnShortValue, "bnShortValue");
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    __name(bnpChunkSize, "bnpChunkSize");
    function bnSigNum() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
      else return 1;
    }
    __name(bnSigNum, "bnSigNum");
    function bnpToRadix(b2) {
      if (b2 == null) b2 = 10;
      if (this.signum() == 0 || b2 < 2 || b2 > 36) return "0";
      var cs = this.chunkSize(b2);
      var a2 = Math.pow(b2, cs);
      var d2 = nbv(a2), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d2, y, z2);
      while (y.signum() > 0) {
        r = (a2 + z2.intValue()).toString(b2).substr(1) + r;
        y.divRemTo(d2, y, z2);
      }
      return z2.intValue().toString(b2) + r;
    }
    __name(bnpToRadix, "bnpToRadix");
    function bnpFromRadix(s, b2) {
      this.fromInt(0);
      if (b2 == null) b2 = 10;
      var cs = this.chunkSize(b2);
      var d2 = Math.pow(b2, cs), mi2 = false, j = 0, w2 = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0) mi2 = true;
          continue;
        }
        w2 = b2 * w2 + x;
        if (++j >= cs) {
          this.dMultiply(d2);
          this.dAddOffset(w2, 0);
          j = 0;
          w2 = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b2, j));
        this.dAddOffset(w2, 0);
      }
      if (mi2) BigInteger.ZERO.subTo(this, this);
    }
    __name(bnpFromRadix, "bnpFromRadix");
    function bnpFromNumber(a2, b2, c) {
      if ("number" == typeof b2) {
        if (a2 < 2) this.fromInt(1);
        else {
          this.fromNumber(a2, c);
          if (!this.testBit(a2 - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a2 - 1), op_or, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b2)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a2) this.subTo(BigInteger.ONE.shiftLeft(a2 - 1), this);
          }
        }
      } else {
        var x = new Array(), t = a2 & 7;
        x.length = (a2 >> 3) + 1;
        b2.nextBytes(x);
        if (t > 0) x[0] &= (1 << t) - 1;
        else x[0] = 0;
        this.fromString(x, 256);
      }
    }
    __name(bnpFromNumber, "bnpFromNumber");
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p2 = this.DB - i * this.DB % 8, d2, k = 0;
      if (i-- > 0) {
        if (p2 < this.DB && (d2 = this.data[i] >> p2) != (this.s & this.DM) >> p2)
          r[k++] = d2 | this.s << this.DB - p2;
        while (i >= 0) {
          if (p2 < 8) {
            d2 = (this.data[i] & (1 << p2) - 1) << 8 - p2;
            d2 |= this.data[--i] >> (p2 += this.DB - 8);
          } else {
            d2 = this.data[i] >> (p2 -= 8) & 255;
            if (p2 <= 0) {
              p2 += this.DB;
              --i;
            }
          }
          if ((d2 & 128) != 0) d2 |= -256;
          if (k == 0 && (this.s & 128) != (d2 & 128)) ++k;
          if (k > 0 || d2 != this.s) r[k++] = d2;
        }
      }
      return r;
    }
    __name(bnToByteArray, "bnToByteArray");
    function bnEquals(a2) {
      return this.compareTo(a2) == 0;
    }
    __name(bnEquals, "bnEquals");
    function bnMin(a2) {
      return this.compareTo(a2) < 0 ? this : a2;
    }
    __name(bnMin, "bnMin");
    function bnMax(a2) {
      return this.compareTo(a2) > 0 ? this : a2;
    }
    __name(bnMax, "bnMax");
    function bnpBitwiseTo(a2, op, r) {
      var i, f, m2 = Math.min(a2.t, this.t);
      for (i = 0; i < m2; ++i) r.data[i] = op(this.data[i], a2.data[i]);
      if (a2.t < this.t) {
        f = a2.s & this.DM;
        for (i = m2; i < this.t; ++i) r.data[i] = op(this.data[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m2; i < a2.t; ++i) r.data[i] = op(f, a2.data[i]);
        r.t = a2.t;
      }
      r.s = op(this.s, a2.s);
      r.clamp();
    }
    __name(bnpBitwiseTo, "bnpBitwiseTo");
    function op_and(x, y) {
      return x & y;
    }
    __name(op_and, "op_and");
    function bnAnd(a2) {
      var r = nbi();
      this.bitwiseTo(a2, op_and, r);
      return r;
    }
    __name(bnAnd, "bnAnd");
    function op_or(x, y) {
      return x | y;
    }
    __name(op_or, "op_or");
    function bnOr(a2) {
      var r = nbi();
      this.bitwiseTo(a2, op_or, r);
      return r;
    }
    __name(bnOr, "bnOr");
    function op_xor(x, y) {
      return x ^ y;
    }
    __name(op_xor, "op_xor");
    function bnXor(a2) {
      var r = nbi();
      this.bitwiseTo(a2, op_xor, r);
      return r;
    }
    __name(bnXor, "bnXor");
    function op_andnot(x, y) {
      return x & ~y;
    }
    __name(op_andnot, "op_andnot");
    function bnAndNot(a2) {
      var r = nbi();
      this.bitwiseTo(a2, op_andnot, r);
      return r;
    }
    __name(bnAndNot, "bnAndNot");
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    __name(bnNot, "bnNot");
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0) this.rShiftTo(-n, r);
      else this.lShiftTo(n, r);
      return r;
    }
    __name(bnShiftLeft, "bnShiftLeft");
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0) this.lShiftTo(-n, r);
      else this.rShiftTo(n, r);
      return r;
    }
    __name(bnShiftRight, "bnShiftRight");
    function lbit(x) {
      if (x == 0) return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0) ++r;
      return r;
    }
    __name(lbit, "lbit");
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    __name(bnGetLowestSetBit, "bnGetLowestSetBit");
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    __name(cbit, "cbit");
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
      return r;
    }
    __name(bnBitCount, "bnBitCount");
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t) return this.s != 0;
      return (this.data[j] & 1 << n % this.DB) != 0;
    }
    __name(bnTestBit, "bnTestBit");
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    __name(bnpChangeBit, "bnpChangeBit");
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    __name(bnSetBit, "bnSetBit");
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    __name(bnClearBit, "bnClearBit");
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    __name(bnFlipBit, "bnFlipBit");
    function bnpAddTo(a2, r) {
      var i = 0, c = 0, m2 = Math.min(a2.t, this.t);
      while (i < m2) {
        c += this.data[i] + a2.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a2.t < this.t) {
        c += a2.s;
        while (i < this.t) {
          c += this.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a2.t) {
          c += a2.data[i];
          r.data[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a2.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0) r.data[i++] = c;
      else if (c < -1) r.data[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    __name(bnpAddTo, "bnpAddTo");
    function bnAdd(a2) {
      var r = nbi();
      this.addTo(a2, r);
      return r;
    }
    __name(bnAdd, "bnAdd");
    function bnSubtract(a2) {
      var r = nbi();
      this.subTo(a2, r);
      return r;
    }
    __name(bnSubtract, "bnSubtract");
    function bnMultiply(a2) {
      var r = nbi();
      this.multiplyTo(a2, r);
      return r;
    }
    __name(bnMultiply, "bnMultiply");
    function bnDivide(a2) {
      var r = nbi();
      this.divRemTo(a2, r, null);
      return r;
    }
    __name(bnDivide, "bnDivide");
    function bnRemainder(a2) {
      var r = nbi();
      this.divRemTo(a2, null, r);
      return r;
    }
    __name(bnRemainder, "bnRemainder");
    function bnDivideAndRemainder(a2) {
      var q = nbi(), r = nbi();
      this.divRemTo(a2, q, r);
      return new Array(q, r);
    }
    __name(bnDivideAndRemainder, "bnDivideAndRemainder");
    function bnpDMultiply(n) {
      this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    __name(bnpDMultiply, "bnpDMultiply");
    function bnpDAddOffset(n, w2) {
      if (n == 0) return;
      while (this.t <= w2) this.data[this.t++] = 0;
      this.data[w2] += n;
      while (this.data[w2] >= this.DV) {
        this.data[w2] -= this.DV;
        if (++w2 >= this.t) this.data[this.t++] = 0;
        ++this.data[w2];
      }
    }
    __name(bnpDAddOffset, "bnpDAddOffset");
    function NullExp() {
    }
    __name(NullExp, "NullExp");
    function nNop(x) {
      return x;
    }
    __name(nNop, "nNop");
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    __name(nMulTo, "nMulTo");
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    __name(nSqrTo, "nSqrTo");
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    __name(bnPow, "bnPow");
    function bnpMultiplyLowerTo(a2, n, r) {
      var i = Math.min(this.t + a2.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0) r.data[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i) r.data[i + this.t] = this.am(0, a2.data[i], r, i, 0, this.t);
      for (j = Math.min(a2.t, n); i < j; ++i) this.am(0, a2.data[i], r, i, 0, n - i);
      r.clamp();
    }
    __name(bnpMultiplyLowerTo, "bnpMultiplyLowerTo");
    function bnpMultiplyUpperTo(a2, n, r) {
      --n;
      var i = r.t = this.t + a2.t - n;
      r.s = 0;
      while (--i >= 0) r.data[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a2.t; ++i)
        r.data[this.t + i - n] = this.am(n - i, a2.data[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    __name(bnpMultiplyUpperTo, "bnpMultiplyUpperTo");
    function Barrett(m2) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    __name(Barrett, "Barrett");
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
      else if (x.compareTo(this.m) < 0) return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    __name(barrettConvert, "barrettConvert");
    function barrettRevert(x) {
      return x;
    }
    __name(barrettRevert, "barrettRevert");
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    __name(barrettReduce, "barrettReduce");
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    __name(barrettSqrTo, "barrettSqrTo");
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    __name(barrettMulTo, "barrettMulTo");
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m2) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0) return r;
      else if (i < 18) k = 1;
      else if (i < 48) k = 3;
      else if (i < 144) k = 4;
      else if (i < 768) k = 5;
      else k = 6;
      if (i < 8)
        z2 = new Classic(m2);
      else if (m2.isEven())
        z2 = new Barrett(m2);
      else
        z2 = new Montgomery(m2);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w2, is1 = true, r2 = nbi(), t;
      i = nbits(e.data[j]) - 1;
      while (j >= 0) {
        if (i >= k1) w2 = e.data[j] >> i - k1 & km;
        else {
          w2 = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0) w2 |= e.data[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w2].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0) z2.sqrTo(r, r2);
          else {
            t = r;
            r = r2;
            r2 = t;
          }
          z2.mulTo(r2, g[w2], r);
        }
        while (j >= 0 && (e.data[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t = r;
          r = r2;
          r2 = t;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    __name(bnModPow, "bnModPow");
    function bnGCD(a2) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a2.s < 0 ? a2.negate() : a2.clone();
      if (x.compareTo(y) < 0) {
        var t = x;
        x = y;
        y = t;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0) return x;
      if (i < g) g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0) y.lShiftTo(g, y);
      return y;
    }
    __name(bnGCD, "bnGCD");
    function bnpModInt(n) {
      if (n <= 0) return 0;
      var d2 = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d2 == 0) r = this.data[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d2 * r + this.data[i]) % n;
      return r;
    }
    __name(bnpModInt, "bnpModInt");
    function bnModInverse(m2) {
      var ac2 = m2.isEven();
      if (this.isEven() && ac2 || m2.signum() == 0) return BigInteger.ZERO;
      var u = m2.clone(), v2 = this.clone();
      var a2 = nbv(1), b2 = nbv(0), c = nbv(0), d2 = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac2) {
            if (!a2.isEven() || !b2.isEven()) {
              a2.addTo(this, a2);
              b2.subTo(m2, b2);
            }
            a2.rShiftTo(1, a2);
          } else if (!b2.isEven()) b2.subTo(m2, b2);
          b2.rShiftTo(1, b2);
        }
        while (v2.isEven()) {
          v2.rShiftTo(1, v2);
          if (ac2) {
            if (!c.isEven() || !d2.isEven()) {
              c.addTo(this, c);
              d2.subTo(m2, d2);
            }
            c.rShiftTo(1, c);
          } else if (!d2.isEven()) d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u.compareTo(v2) >= 0) {
          u.subTo(v2, u);
          if (ac2) a2.subTo(c, a2);
          b2.subTo(d2, b2);
        } else {
          v2.subTo(u, v2);
          if (ac2) c.subTo(a2, c);
          d2.subTo(b2, d2);
        }
      }
      if (v2.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
      if (d2.signum() < 0) d2.addTo(m2, d2);
      else return d2;
      if (d2.signum() < 0) return d2.add(m2);
      else return d2;
    }
    __name(bnModInverse, "bnModInverse");
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x.data[0] == lowprimes[i]) return true;
        return false;
      }
      if (x.isEven()) return false;
      i = 1;
      while (i < lowprimes.length) {
        var m2 = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m2 < lplim) m2 *= lowprimes[j++];
        m2 = x.modInt(m2);
        while (i < j) if (m2 % lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }
    __name(bnIsProbablePrime, "bnIsProbablePrime");
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0) return false;
      var r = n1.shiftRight(k);
      var prng = bnGetPrng();
      var a2;
      for (var i = 0; i < t; ++i) {
        do {
          a2 = new BigInteger(this.bitLength(), prng);
        } while (a2.compareTo(BigInteger.ONE) <= 0 || a2.compareTo(n1) >= 0);
        var y = a2.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if (y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    __name(bnpMillerRabin, "bnpMillerRabin");
    function bnGetPrng() {
      return {
        // x is an array to fill with bytes
        nextBytes: /* @__PURE__ */ __name(function(x) {
          for (var i = 0; i < x.length; ++i) {
            x[i] = Math.floor(Math.random() * 256);
          }
        }, "nextBytes")
      };
    }
    __name(bnGetPrng, "bnGetPrng");
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
  }
});

// node_modules/node-forge/lib/sha1.js
var require_sha12 = __commonJS({
  "node_modules/node-forge/lib/sha1.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_md();
    require_util4();
    var sha1 = module.exports = forge.sha1 = forge.sha1 || {};
    forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
    sha1.create = function() {
      if (!_initialized) {
        _init();
      }
      var _state = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      var md = {
        algorithm: "sha1",
        blockLength: 64,
        digestLength: 20,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 8
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength64 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _state = {
          h0: 1732584193,
          h1: 4023233417,
          h2: 2562383102,
          h3: 271733878,
          h4: 3285377520
        };
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_state, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var s2 = {
          h0: _state.h0,
          h1: _state.h1,
          h2: _state.h2,
          h3: _state.h3,
          h4: _state.h4
        };
        _update(s2, _w, finalBlock);
        var rval = forge.util.createBuffer();
        rval.putInt32(s2.h0);
        rval.putInt32(s2.h1);
        rval.putInt32(s2.h2);
        rval.putInt32(s2.h3);
        rval.putInt32(s2.h4);
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 64);
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s, w2, bytes) {
      var t, a2, b2, c, d2, e, f, i;
      var len = bytes.length();
      while (len >= 64) {
        a2 = s.h0;
        b2 = s.h1;
        c = s.h2;
        d2 = s.h3;
        e = s.h4;
        for (i = 0; i < 16; ++i) {
          t = bytes.getInt32();
          w2[i] = t;
          f = d2 ^ b2 & (c ^ d2);
          t = (a2 << 5 | a2 >>> 27) + f + e + 1518500249 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i < 20; ++i) {
          t = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
          t = t << 1 | t >>> 31;
          w2[i] = t;
          f = d2 ^ b2 & (c ^ d2);
          t = (a2 << 5 | a2 >>> 27) + f + e + 1518500249 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i < 32; ++i) {
          t = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
          t = t << 1 | t >>> 31;
          w2[i] = t;
          f = b2 ^ c ^ d2;
          t = (a2 << 5 | a2 >>> 27) + f + e + 1859775393 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i < 40; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b2 ^ c ^ d2;
          t = (a2 << 5 | a2 >>> 27) + f + e + 1859775393 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i < 60; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b2 & c | d2 & (b2 ^ c);
          t = (a2 << 5 | a2 >>> 27) + f + e + 2400959708 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        for (; i < 80; ++i) {
          t = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
          t = t << 2 | t >>> 30;
          w2[i] = t;
          f = b2 ^ c ^ d2;
          t = (a2 << 5 | a2 >>> 27) + f + e + 3395469782 + t;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) >>> 0;
          b2 = a2;
          a2 = t;
        }
        s.h0 = s.h0 + a2 | 0;
        s.h1 = s.h1 + b2 | 0;
        s.h2 = s.h2 + c | 0;
        s.h3 = s.h3 + d2 | 0;
        s.h4 = s.h4 + e | 0;
        len -= 64;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS({
  "node_modules/node-forge/lib/pkcs1.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    require_random();
    require_sha12();
    var pkcs1 = module.exports = forge.pkcs1 = forge.pkcs1 || {};
    pkcs1.encode_rsa_oaep = function(key, message2, options) {
      var label;
      var seed;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        seed = arguments[3] || void 0;
        md = arguments[4] || void 0;
      } else if (options) {
        label = options.label || void 0;
        seed = options.seed || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      if (!md) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      var maxLength = keyLength - 2 * md.digestLength - 2;
      if (message2.length > maxLength) {
        var error3 = new Error("RSAES-OAEP input message length is too long.");
        error3.length = message2.length;
        error3.maxLength = maxLength;
        throw error3;
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest();
      var PS = "";
      var PS_length = maxLength - message2.length;
      for (var i = 0; i < PS_length; i++) {
        PS += "\0";
      }
      var DB = lHash.getBytes() + PS + "" + message2;
      if (!seed) {
        seed = forge.random.getBytes(md.digestLength);
      } else if (seed.length !== md.digestLength) {
        var error3 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
        error3.seedLength = seed.length;
        error3.digestLength = md.digestLength;
        throw error3;
      }
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
      return "\0" + maskedSeed + maskedDB;
    };
    pkcs1.decode_rsa_oaep = function(key, em, options) {
      var label;
      var md;
      var mgf1Md;
      if (typeof options === "string") {
        label = options;
        md = arguments[3] || void 0;
      } else if (options) {
        label = options.label || void 0;
        md = options.md || void 0;
        if (options.mgf1 && options.mgf1.md) {
          mgf1Md = options.mgf1.md;
        }
      }
      var keyLength = Math.ceil(key.n.bitLength() / 8);
      if (em.length !== keyLength) {
        var error3 = new Error("RSAES-OAEP encoded message length is invalid.");
        error3.length = em.length;
        error3.expectedLength = keyLength;
        throw error3;
      }
      if (md === void 0) {
        md = forge.md.sha1.create();
      } else {
        md.start();
      }
      if (!mgf1Md) {
        mgf1Md = md;
      }
      if (keyLength < 2 * md.digestLength + 2) {
        throw new Error("RSAES-OAEP key is too short for the hash function.");
      }
      if (!label) {
        label = "";
      }
      md.update(label, "raw");
      var lHash = md.digest().getBytes();
      var y = em.charAt(0);
      var maskedSeed = em.substring(1, md.digestLength + 1);
      var maskedDB = em.substring(1 + md.digestLength);
      var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
      var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
      var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
      var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
      var lHashPrime = db.substring(0, md.digestLength);
      var error3 = y !== "\0";
      for (var i = 0; i < md.digestLength; ++i) {
        error3 |= lHash.charAt(i) !== lHashPrime.charAt(i);
      }
      var in_ps = 1;
      var index = md.digestLength;
      for (var j = md.digestLength; j < db.length; j++) {
        var code = db.charCodeAt(j);
        var is_0 = code & 1 ^ 1;
        var error_mask = in_ps ? 65534 : 0;
        error3 |= code & error_mask;
        in_ps = in_ps & is_0;
        index += in_ps;
      }
      if (error3 || db.charCodeAt(index) !== 1) {
        throw new Error("Invalid RSAES-OAEP padding.");
      }
      return db.substring(index + 1);
    };
    function rsa_mgf1(seed, maskLength, hash2) {
      if (!hash2) {
        hash2 = forge.md.sha1.create();
      }
      var t = "";
      var count3 = Math.ceil(maskLength / hash2.digestLength);
      for (var i = 0; i < count3; ++i) {
        var c = String.fromCharCode(
          i >> 24 & 255,
          i >> 16 & 255,
          i >> 8 & 255,
          i & 255
        );
        hash2.start();
        hash2.update(seed + c);
        t += hash2.digest().getBytes();
      }
      return t.substring(0, maskLength);
    }
    __name(rsa_mgf1, "rsa_mgf1");
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS({
  "node_modules/node-forge/lib/prime.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    require_jsbn();
    require_random();
    (function() {
      if (forge.prime) {
        module.exports = forge.prime;
        return;
      }
      var prime = module.exports = forge.prime = forge.prime || {};
      var BigInteger = forge.jsbn.BigInteger;
      var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var op_or = /* @__PURE__ */ __name(function(x, y) {
        return x | y;
      }, "op_or");
      prime.generateProbablePrime = function(bits, options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        var algorithm = options.algorithm || "PRIMEINC";
        if (typeof algorithm === "string") {
          algorithm = { name: algorithm };
        }
        algorithm.options = algorithm.options || {};
        var prng = options.prng || forge.random;
        var rng = {
          // x is an array to fill with bytes
          nextBytes: /* @__PURE__ */ __name(function(x) {
            var b2 = prng.getBytesSync(x.length);
            for (var i = 0; i < x.length; ++i) {
              x[i] = b2.charCodeAt(i);
            }
          }, "nextBytes")
        };
        if (algorithm.name === "PRIMEINC") {
          return primeincFindPrime(bits, rng, algorithm.options, callback);
        }
        throw new Error("Invalid prime generation algorithm: " + algorithm.name);
      };
      function primeincFindPrime(bits, rng, options, callback) {
        if ("workers" in options) {
          return primeincFindPrimeWithWorkers(bits, rng, options, callback);
        }
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      __name(primeincFindPrime, "primeincFindPrime");
      function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
        var num = generateRandom(bits, rng);
        var deltaIdx = 0;
        var mrTests = getMillerRabinTests(num.bitLength());
        if ("millerRabinTests" in options) {
          mrTests = options.millerRabinTests;
        }
        var maxBlockTime = 10;
        if ("maxBlockTime" in options) {
          maxBlockTime = options.maxBlockTime;
        }
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      }
      __name(primeincFindPrimeWithoutWorkers, "primeincFindPrimeWithoutWorkers");
      function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
        var start = +/* @__PURE__ */ new Date();
        do {
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          if (num.isProbablePrime(mrTests)) {
            return callback(null, num);
          }
          num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
        forge.util.setImmediate(function() {
          _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
        });
      }
      __name(_primeinc, "_primeinc");
      function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
        if (typeof Worker === "undefined") {
          return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
        }
        var num = generateRandom(bits, rng);
        var numWorkers = options.workers;
        var workLoad = options.workLoad || 100;
        var range = workLoad * 30 / 8;
        var workerScript = options.workerScript || "forge/prime.worker.js";
        if (numWorkers === -1) {
          return forge.util.estimateCores(function(err, cores) {
            if (err) {
              cores = 2;
            }
            numWorkers = cores - 1;
            generate();
          });
        }
        generate();
        function generate() {
          numWorkers = Math.max(1, numWorkers);
          var workers = [];
          for (var i = 0; i < numWorkers; ++i) {
            workers[i] = new Worker(workerScript);
          }
          var running = numWorkers;
          for (var i = 0; i < numWorkers; ++i) {
            workers[i].addEventListener("message", workerMessage);
          }
          var found = false;
          function workerMessage(e) {
            if (found) {
              return;
            }
            --running;
            var data = e.data;
            if (data.found) {
              for (var i2 = 0; i2 < workers.length; ++i2) {
                workers[i2].terminate();
              }
              found = true;
              return callback(null, new BigInteger(data.prime, 16));
            }
            if (num.bitLength() > bits) {
              num = generateRandom(bits, rng);
            }
            var hex = num.toString(16);
            e.target.postMessage({
              hex,
              workLoad
            });
            num.dAddOffset(range, 0);
          }
          __name(workerMessage, "workerMessage");
        }
        __name(generate, "generate");
      }
      __name(primeincFindPrimeWithWorkers, "primeincFindPrimeWithWorkers");
      function generateRandom(bits, rng) {
        var num = new BigInteger(bits, rng);
        var bits1 = bits - 1;
        if (!num.testBit(bits1)) {
          num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
        }
        num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
        return num;
      }
      __name(generateRandom, "generateRandom");
      function getMillerRabinTests(bits) {
        if (bits <= 100) return 27;
        if (bits <= 150) return 18;
        if (bits <= 200) return 15;
        if (bits <= 250) return 12;
        if (bits <= 300) return 9;
        if (bits <= 350) return 8;
        if (bits <= 400) return 7;
        if (bits <= 500) return 6;
        if (bits <= 600) return 5;
        if (bits <= 800) return 4;
        if (bits <= 1250) return 3;
        return 2;
      }
      __name(getMillerRabinTests, "getMillerRabinTests");
    })();
  }
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS({
  "node_modules/node-forge/lib/rsa.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    require_jsbn();
    require_oids();
    require_pkcs1();
    require_prime();
    require_random();
    require_util4();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var _crypto = forge.util.isNodejs ? require_crypto2() : null;
    var asn1 = forge.asn1;
    var util = forge.util;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
    var pki = forge.pki;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    var rsaPrivateKeyValidator = {
      // RSAPrivateKey
      name: "RSAPrivateKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "RSAPrivateKey.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // modulus (n)
        name: "RSAPrivateKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPrivateKey.publicExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPublicExponent"
      }, {
        // privateExponent (d)
        name: "RSAPrivateKey.privateExponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrivateExponent"
      }, {
        // prime1 (p)
        name: "RSAPrivateKey.prime1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime1"
      }, {
        // prime2 (q)
        name: "RSAPrivateKey.prime2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyPrime2"
      }, {
        // exponent1 (d mod (p-1))
        name: "RSAPrivateKey.exponent1",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent1"
      }, {
        // exponent2 (d mod (q-1))
        name: "RSAPrivateKey.exponent2",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyExponent2"
      }, {
        // coefficient ((inverse of q) mod p)
        name: "RSAPrivateKey.coefficient",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyCoefficient"
      }]
    };
    var rsaPublicKeyValidator = {
      // RSAPublicKey
      name: "RSAPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // modulus (n)
        name: "RSAPublicKey.modulus",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyModulus"
      }, {
        // publicExponent (e)
        name: "RSAPublicKey.exponent",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "publicKeyExponent"
      }]
    };
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [{
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      }, {
        // subjectPublicKey
        name: "SubjectPublicKeyInfo.subjectPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        value: [{
          // RSAPublicKey
          name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "rsaPublicKey"
        }]
      }]
    };
    var digestInfoValidator = {
      name: "DigestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "DigestInfo.DigestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "algorithmIdentifier"
        }, {
          // NULL paramters
          name: "DigestInfo.DigestAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.NULL,
          // captured only to check existence for md2 and md5
          capture: "parameters",
          optional: true,
          constructed: false
        }]
      }, {
        // digest
        name: "DigestInfo.digest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "digest"
      }]
    };
    var emsaPkcs1v15encode = /* @__PURE__ */ __name(function(md) {
      var oid;
      if (md.algorithm in pki.oids) {
        oid = pki.oids[md.algorithm];
      } else {
        var error3 = new Error("Unknown message digest algorithm.");
        error3.algorithm = md.algorithm;
        throw error3;
      }
      var oidBytes = asn1.oidToDer(oid).getBytes();
      var digestInfo = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var digestAlgorithm = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        oidBytes
      ));
      digestAlgorithm.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.NULL,
        false,
        ""
      ));
      var digest2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        md.digest().getBytes()
      );
      digestInfo.value.push(digestAlgorithm);
      digestInfo.value.push(digest2);
      return asn1.toDer(digestInfo).getBytes();
    }, "emsaPkcs1v15encode");
    var _modPow = /* @__PURE__ */ __name(function(x, key, pub) {
      if (pub) {
        return x.modPow(key.e, key.n);
      }
      if (!key.p || !key.q) {
        return x.modPow(key.d, key.n);
      }
      if (!key.dP) {
        key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
      }
      if (!key.dQ) {
        key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
      }
      if (!key.qInv) {
        key.qInv = key.q.modInverse(key.p);
      }
      var r;
      do {
        r = new BigInteger(
          forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)),
          16
        );
      } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
      x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
      var xp = x.mod(key.p).modPow(key.dP, key.p);
      var xq = x.mod(key.q).modPow(key.dQ, key.q);
      while (xp.compareTo(xq) < 0) {
        xp = xp.add(key.p);
      }
      var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
      y = y.multiply(r.modInverse(key.n)).mod(key.n);
      return y;
    }, "_modPow");
    pki.rsa.encrypt = function(m2, key, bt) {
      var pub = bt;
      var eb;
      var k = Math.ceil(key.n.bitLength() / 8);
      if (bt !== false && bt !== true) {
        pub = bt === 2;
        eb = _encodePkcs1_v1_5(m2, key, bt);
      } else {
        eb = forge.util.createBuffer();
        eb.putBytes(m2);
      }
      var x = new BigInteger(eb.toHex(), 16);
      var y = _modPow(x, key, pub);
      var yhex = y.toString(16);
      var ed = forge.util.createBuffer();
      var zeros = k - Math.ceil(yhex.length / 2);
      while (zeros > 0) {
        ed.putByte(0);
        --zeros;
      }
      ed.putBytes(forge.util.hexToBytes(yhex));
      return ed.getBytes();
    };
    pki.rsa.decrypt = function(ed, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      if (ed.length !== k) {
        var error3 = new Error("Encrypted message length is invalid.");
        error3.length = ed.length;
        error3.expected = k;
        throw error3;
      }
      var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
      if (y.compareTo(key.n) >= 0) {
        throw new Error("Encrypted message is invalid.");
      }
      var x = _modPow(y, key, pub);
      var xhex = x.toString(16);
      var eb = forge.util.createBuffer();
      var zeros = k - Math.ceil(xhex.length / 2);
      while (zeros > 0) {
        eb.putByte(0);
        --zeros;
      }
      eb.putBytes(forge.util.hexToBytes(xhex));
      if (ml !== false) {
        return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
      }
      return eb.getBytes();
    };
    pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
      if (typeof bits === "string") {
        bits = parseInt(bits, 10);
      }
      bits = bits || 2048;
      options = options || {};
      var prng = options.prng || forge.random;
      var rng = {
        // x is an array to fill with bytes
        nextBytes: /* @__PURE__ */ __name(function(x) {
          var b2 = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b2.charCodeAt(i);
          }
        }, "nextBytes")
      };
      var algorithm = options.algorithm || "PRIMEINC";
      var rval;
      if (algorithm === "PRIMEINC") {
        rval = {
          algorithm,
          state: 0,
          bits,
          rng,
          eInt: e || 65537,
          e: new BigInteger(null),
          p: null,
          q: null,
          qBits: bits >> 1,
          pBits: bits - (bits >> 1),
          pqState: 0,
          num: null,
          keys: null
        };
        rval.e.fromInt(rval.eInt);
      } else {
        throw new Error("Invalid key generation algorithm: " + algorithm);
      }
      return rval;
    };
    pki.rsa.stepKeyPairGenerationState = function(state, n) {
      if (!("algorithm" in state)) {
        state.algorithm = "PRIMEINC";
      }
      var THIRTY = new BigInteger(null);
      THIRTY.fromInt(30);
      var deltaIdx = 0;
      var op_or = /* @__PURE__ */ __name(function(x, y) {
        return x | y;
      }, "op_or");
      var t1 = +/* @__PURE__ */ new Date();
      var t2;
      var total = 0;
      while (state.keys === null && (n <= 0 || total < n)) {
        if (state.state === 0) {
          var bits = state.p === null ? state.pBits : state.qBits;
          var bits1 = bits - 1;
          if (state.pqState === 0) {
            state.num = new BigInteger(bits, state.rng);
            if (!state.num.testBit(bits1)) {
              state.num.bitwiseTo(
                BigInteger.ONE.shiftLeft(bits1),
                op_or,
                state.num
              );
            }
            state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
            deltaIdx = 0;
            ++state.pqState;
          } else if (state.pqState === 1) {
            if (state.num.bitLength() > bits) {
              state.pqState = 0;
            } else if (state.num.isProbablePrime(
              _getMillerRabinTests(state.num.bitLength())
            )) {
              ++state.pqState;
            } else {
              state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
            }
          } else if (state.pqState === 2) {
            state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
          } else if (state.pqState === 3) {
            state.pqState = 0;
            if (state.p === null) {
              state.p = state.num;
            } else {
              state.q = state.num;
            }
            if (state.p !== null && state.q !== null) {
              ++state.state;
            }
            state.num = null;
          }
        } else if (state.state === 1) {
          if (state.p.compareTo(state.q) < 0) {
            state.num = state.p;
            state.p = state.q;
            state.q = state.num;
          }
          ++state.state;
        } else if (state.state === 2) {
          state.p1 = state.p.subtract(BigInteger.ONE);
          state.q1 = state.q.subtract(BigInteger.ONE);
          state.phi = state.p1.multiply(state.q1);
          ++state.state;
        } else if (state.state === 3) {
          if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
            ++state.state;
          } else {
            state.p = null;
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 4) {
          state.n = state.p.multiply(state.q);
          if (state.n.bitLength() === state.bits) {
            ++state.state;
          } else {
            state.q = null;
            state.state = 0;
          }
        } else if (state.state === 5) {
          var d2 = state.e.modInverse(state.phi);
          state.keys = {
            privateKey: pki.rsa.setPrivateKey(
              state.n,
              state.e,
              d2,
              state.p,
              state.q,
              d2.mod(state.p1),
              d2.mod(state.q1),
              state.q.modInverse(state.p)
            ),
            publicKey: pki.rsa.setPublicKey(state.n, state.e)
          };
        }
        t2 = +/* @__PURE__ */ new Date();
        total += t2 - t1;
        t1 = t2;
      }
      return state.keys !== null;
    };
    pki.rsa.generateKeyPair = function(bits, e, options, callback) {
      if (arguments.length === 1) {
        if (typeof bits === "object") {
          options = bits;
          bits = void 0;
        } else if (typeof bits === "function") {
          callback = bits;
          bits = void 0;
        }
      } else if (arguments.length === 2) {
        if (typeof bits === "number") {
          if (typeof e === "function") {
            callback = e;
            e = void 0;
          } else if (typeof e !== "number") {
            options = e;
            e = void 0;
          }
        } else {
          options = bits;
          callback = e;
          bits = void 0;
          e = void 0;
        }
      } else if (arguments.length === 3) {
        if (typeof e === "number") {
          if (typeof options === "function") {
            callback = options;
            options = void 0;
          }
        } else {
          callback = options;
          options = e;
          e = void 0;
        }
      }
      options = options || {};
      if (bits === void 0) {
        bits = options.bits || 2048;
      }
      if (e === void 0) {
        e = options.e || 65537;
      }
      if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
        if (callback) {
          if (_detectNodeCrypto("generateKeyPair")) {
            return _crypto.generateKeyPair("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            }, function(err, pub, priv) {
              if (err) {
                return callback(err);
              }
              callback(null, {
                privateKey: pki.privateKeyFromPem(priv),
                publicKey: pki.publicKeyFromPem(pub)
              });
            });
          }
          if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
            return util.globalScope.crypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]).then(function(pair) {
              return util.globalScope.crypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
            }).then(void 0, function(err) {
              callback(err);
            }).then(function(pkcs8) {
              if (pkcs8) {
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              }
            });
          }
          if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
            var genOp = util.globalScope.msCrypto.subtle.generateKey({
              name: "RSASSA-PKCS1-v1_5",
              modulusLength: bits,
              publicExponent: _intToUint8Array(e),
              hash: { name: "SHA-256" }
            }, true, ["sign", "verify"]);
            genOp.oncomplete = function(e2) {
              var pair = e2.target.result;
              var exportOp = util.globalScope.msCrypto.subtle.exportKey(
                "pkcs8",
                pair.privateKey
              );
              exportOp.oncomplete = function(e3) {
                var pkcs8 = e3.target.result;
                var privateKey = pki.privateKeyFromAsn1(
                  asn1.fromDer(forge.util.createBuffer(pkcs8))
                );
                callback(null, {
                  privateKey,
                  publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
                });
              };
              exportOp.onerror = function(err) {
                callback(err);
              };
            };
            genOp.onerror = function(err) {
              callback(err);
            };
            return;
          }
        } else {
          if (_detectNodeCrypto("generateKeyPairSync")) {
            var keypair = _crypto.generateKeyPairSync("rsa", {
              modulusLength: bits,
              publicExponent: e,
              publicKeyEncoding: {
                type: "spki",
                format: "pem"
              },
              privateKeyEncoding: {
                type: "pkcs8",
                format: "pem"
              }
            });
            return {
              privateKey: pki.privateKeyFromPem(keypair.privateKey),
              publicKey: pki.publicKeyFromPem(keypair.publicKey)
            };
          }
        }
      }
      var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
      if (!callback) {
        pki.rsa.stepKeyPairGenerationState(state, 0);
        return state.keys;
      }
      _generateKeyPair(state, options, callback);
    };
    pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
      var key = {
        n,
        e
      };
      key.encrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = {
            encode: /* @__PURE__ */ __name(function(m2, key2, pub) {
              return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
            }, "encode")
          };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            encode: /* @__PURE__ */ __name(function(m2, key2) {
              return forge.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
            }, "encode")
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { encode: /* @__PURE__ */ __name(function(e3) {
            return e3;
          }, "encode") };
        } else if (typeof scheme === "string") {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        var e2 = scheme.encode(data, key, true);
        return pki.rsa.encrypt(e2, key, true);
      };
      key.verify = function(digest2, signature, scheme, options) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSASSA-PKCS1-V1_5";
        }
        if (options === void 0) {
          options = {
            _parseAllDigestBytes: true
          };
        }
        if (!("_parseAllDigestBytes" in options)) {
          options._parseAllDigestBytes = true;
        }
        if (scheme === "RSASSA-PKCS1-V1_5") {
          scheme = {
            verify: /* @__PURE__ */ __name(function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              var obj = asn1.fromDer(d3, {
                parseAllBytes: options._parseAllDigestBytes
              });
              var capture = {};
              var errors = [];
              if (!asn1.validate(obj, digestInfoValidator, capture, errors)) {
                var error3 = new Error(
                  "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
                );
                error3.errors = errors;
                throw error3;
              }
              var oid = asn1.derToOid(capture.algorithmIdentifier);
              if (!(oid === forge.oids.md2 || oid === forge.oids.md5 || oid === forge.oids.sha1 || oid === forge.oids.sha224 || oid === forge.oids.sha256 || oid === forge.oids.sha384 || oid === forge.oids.sha512 || oid === forge.oids["sha512-224"] || oid === forge.oids["sha512-256"])) {
                var error3 = new Error(
                  "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
                );
                error3.oid = oid;
                throw error3;
              }
              if (oid === forge.oids.md2 || oid === forge.oids.md5) {
                if (!("parameters" in capture)) {
                  throw new Error(
                    "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
                  );
                }
              }
              return digest3 === capture.digest;
            }, "verify")
          };
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = {
            verify: /* @__PURE__ */ __name(function(digest3, d3) {
              d3 = _decodePkcs1_v1_5(d3, key, true);
              return digest3 === d3;
            }, "verify")
          };
        }
        var d2 = pki.rsa.decrypt(signature, key, true, false);
        return scheme.verify(digest2, d2, key.n.bitLength());
      };
      return key;
    };
    pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d2, p2, q, dP, dQ, qInv) {
      var key = {
        n,
        e,
        d: d2,
        p: p2,
        q,
        dP,
        dQ,
        qInv
      };
      key.decrypt = function(data, scheme, schemeOptions) {
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        } else if (scheme === void 0) {
          scheme = "RSAES-PKCS1-V1_5";
        }
        var d3 = pki.rsa.decrypt(data, key, false, false);
        if (scheme === "RSAES-PKCS1-V1_5") {
          scheme = { decode: _decodePkcs1_v1_5 };
        } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
          scheme = {
            decode: /* @__PURE__ */ __name(function(d4, key2) {
              return forge.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
            }, "decode")
          };
        } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
          scheme = { decode: /* @__PURE__ */ __name(function(d4) {
            return d4;
          }, "decode") };
        } else {
          throw new Error('Unsupported encryption scheme: "' + scheme + '".');
        }
        return scheme.decode(d3, key, false);
      };
      key.sign = function(md, scheme) {
        var bt = false;
        if (typeof scheme === "string") {
          scheme = scheme.toUpperCase();
        }
        if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
          scheme = { encode: emsaPkcs1v15encode };
          bt = 1;
        } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
          scheme = { encode: /* @__PURE__ */ __name(function() {
            return md;
          }, "encode") };
          bt = 1;
        }
        var d3 = scheme.encode(md, key.n.bitLength());
        return pki.rsa.encrypt(d3, key, bt);
      };
      return key;
    };
    pki.wrapRsaPrivateKey = function(rsaKey) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // privateKeyAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // PrivateKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          asn1.toDer(rsaKey).getBytes()
        )
      ]);
    };
    pki.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
        obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
      }
      capture = {};
      errors = [];
      if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
        var error3 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
        error3.errors = errors;
        throw error3;
      }
      var n, e, d2, p2, q, dP, dQ, qInv;
      n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
      e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
      d2 = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
      p2 = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
      q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
      dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
      dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
      qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
      return pki.setRsaPrivateKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16),
        new BigInteger(d2, 16),
        new BigInteger(p2, 16),
        new BigInteger(q, 16),
        new BigInteger(dP, 16),
        new BigInteger(dQ, 16),
        new BigInteger(qInv, 16)
      );
    };
    pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (0 = only 2 primes, 1 multiple primes)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(0).getBytes()
        ),
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        ),
        // privateExponent (d)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.d)
        ),
        // privateKeyPrime1 (p)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.p)
        ),
        // privateKeyPrime2 (q)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.q)
        ),
        // privateKeyExponent1 (dP)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dP)
        ),
        // privateKeyExponent2 (dQ)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.dQ)
        ),
        // coefficient (qInv)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.qInv)
        )
      ]);
    };
    pki.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
        var oid = asn1.derToOid(capture.publicKeyOid);
        if (oid !== pki.oids.rsaEncryption) {
          var error3 = new Error("Cannot read public key. Unknown OID.");
          error3.oid = oid;
          throw error3;
        }
        obj = capture.rsaPublicKey;
      }
      errors = [];
      if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
        var error3 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
        error3.errors = errors;
        throw error3;
      }
      var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
      var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
      return pki.setRsaPublicKey(
        new BigInteger(n, 16),
        new BigInteger(e, 16)
      );
    };
    pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.rsaEncryption).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // subjectPublicKey
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
          pki.publicKeyToRSAPublicKey(key)
        ])
      ]);
    };
    pki.publicKeyToRSAPublicKey = function(key) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // modulus (n)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.n)
        ),
        // publicExponent (e)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          _bnToBytes(key.e)
        )
      ]);
    };
    function _encodePkcs1_v1_5(m2, key, bt) {
      var eb = forge.util.createBuffer();
      var k = Math.ceil(key.n.bitLength() / 8);
      if (m2.length > k - 11) {
        var error3 = new Error("Message is too long for PKCS#1 v1.5 padding.");
        error3.length = m2.length;
        error3.max = k - 11;
        throw error3;
      }
      eb.putByte(0);
      eb.putByte(bt);
      var padNum = k - 3 - m2.length;
      var padByte;
      if (bt === 0 || bt === 1) {
        padByte = bt === 0 ? 0 : 255;
        for (var i = 0; i < padNum; ++i) {
          eb.putByte(padByte);
        }
      } else {
        while (padNum > 0) {
          var numZeros = 0;
          var padBytes = forge.random.getBytes(padNum);
          for (var i = 0; i < padNum; ++i) {
            padByte = padBytes.charCodeAt(i);
            if (padByte === 0) {
              ++numZeros;
            } else {
              eb.putByte(padByte);
            }
          }
          padNum = numZeros;
        }
      }
      eb.putByte(0);
      eb.putBytes(m2);
      return eb;
    }
    __name(_encodePkcs1_v1_5, "_encodePkcs1_v1_5");
    function _decodePkcs1_v1_5(em, key, pub, ml) {
      var k = Math.ceil(key.n.bitLength() / 8);
      var eb = forge.util.createBuffer(em);
      var first = eb.getByte();
      var bt = eb.getByte();
      if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
        throw new Error("Encryption block is invalid.");
      }
      var padNum = 0;
      if (bt === 0) {
        padNum = k - 3 - ml;
        for (var i = 0; i < padNum; ++i) {
          if (eb.getByte() !== 0) {
            throw new Error("Encryption block is invalid.");
          }
        }
      } else if (bt === 1) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() !== 255) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      } else if (bt === 2) {
        padNum = 0;
        while (eb.length() > 1) {
          if (eb.getByte() === 0) {
            --eb.read;
            break;
          }
          ++padNum;
        }
      }
      var zero = eb.getByte();
      if (zero !== 0 || padNum !== k - 3 - eb.length()) {
        throw new Error("Encryption block is invalid.");
      }
      return eb.getBytes();
    }
    __name(_decodePkcs1_v1_5, "_decodePkcs1_v1_5");
    function _generateKeyPair(state, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var opts = {
        algorithm: {
          name: options.algorithm || "PRIMEINC",
          options: {
            workers: options.workers || 2,
            workLoad: options.workLoad || 100,
            workerScript: options.workerScript
          }
        }
      };
      if ("prng" in options) {
        opts.prng = options.prng;
      }
      generate();
      function generate() {
        getPrime(state.pBits, function(err, num) {
          if (err) {
            return callback(err);
          }
          state.p = num;
          if (state.q !== null) {
            return finish(err, state.q);
          }
          getPrime(state.qBits, finish);
        });
      }
      __name(generate, "generate");
      function getPrime(bits, callback2) {
        forge.prime.generateProbablePrime(bits, opts, callback2);
      }
      __name(getPrime, "getPrime");
      function finish(err, num) {
        if (err) {
          return callback(err);
        }
        state.q = num;
        if (state.p.compareTo(state.q) < 0) {
          var tmp = state.p;
          state.p = state.q;
          state.q = tmp;
        }
        if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = null;
          generate();
          return;
        }
        if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
          state.p = state.q = null;
          generate();
          return;
        }
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() !== state.bits) {
          state.q = null;
          getPrime(state.qBits, finish);
          return;
        }
        var d2 = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(
            state.n,
            state.e,
            d2,
            state.p,
            state.q,
            d2.mod(state.p1),
            d2.mod(state.q1),
            state.q.modInverse(state.p)
          ),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
        callback(null, state.keys);
      }
      __name(finish, "finish");
    }
    __name(_generateKeyPair, "_generateKeyPair");
    function _bnToBytes(b2) {
      var hex = b2.toString(16);
      if (hex[0] >= "8") {
        hex = "00" + hex;
      }
      var bytes = forge.util.hexToBytes(hex);
      if (bytes.length > 1 && // leading 0x00 for positive integer
      (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
        return bytes.substr(1);
      }
      return bytes;
    }
    __name(_bnToBytes, "_bnToBytes");
    function _getMillerRabinTests(bits) {
      if (bits <= 100) return 27;
      if (bits <= 150) return 18;
      if (bits <= 200) return 15;
      if (bits <= 250) return 12;
      if (bits <= 300) return 9;
      if (bits <= 350) return 8;
      if (bits <= 400) return 7;
      if (bits <= 500) return 6;
      if (bits <= 600) return 5;
      if (bits <= 800) return 4;
      if (bits <= 1250) return 3;
      return 2;
    }
    __name(_getMillerRabinTests, "_getMillerRabinTests");
    function _detectNodeCrypto(fn) {
      return forge.util.isNodejs && typeof _crypto[fn] === "function";
    }
    __name(_detectNodeCrypto, "_detectNodeCrypto");
    function _detectSubtleCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
    }
    __name(_detectSubtleCrypto, "_detectSubtleCrypto");
    function _detectSubtleMsCrypto(fn) {
      return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
    }
    __name(_detectSubtleMsCrypto, "_detectSubtleMsCrypto");
    function _intToUint8Array(x) {
      var bytes = forge.util.hexToBytes(x.toString(16));
      var buffer = new Uint8Array(bytes.length);
      for (var i = 0; i < bytes.length; ++i) {
        buffer[i] = bytes.charCodeAt(i);
      }
      return buffer;
    }
    __name(_intToUint8Array, "_intToUint8Array");
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS({
  "node_modules/node-forge/lib/pbe.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_oids();
    require_pbkdf2();
    require_pem();
    require_random();
    require_rc2();
    require_rsa();
    require_util4();
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var asn1 = forge.asn1;
    var pki = forge.pki = forge.pki || {};
    module.exports = pki.pbe = forge.pbe = forge.pbe || {};
    var oids = pki.oids;
    var encryptedPrivateKeyValidator = {
      name: "EncryptedPrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encryptionOid"
        }, {
          name: "AlgorithmIdentifier.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "encryptionParams"
        }]
      }, {
        // encryptedData
        name: "EncryptedPrivateKeyInfo.encryptedData",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encryptedData"
      }]
    };
    var PBES2AlgorithmsValidator = {
      name: "PBES2Algorithms",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.keyDerivationFunc.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "kdfOid"
        }, {
          name: "PBES2Algorithms.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "PBES2Algorithms.params.salt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "kdfSalt"
          }, {
            name: "PBES2Algorithms.params.iterationCount",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "kdfIterationCount"
          }, {
            name: "PBES2Algorithms.params.keyLength",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "keyLength"
          }, {
            // prf
            name: "PBES2Algorithms.params.prf",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            value: [{
              name: "PBES2Algorithms.params.prf.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "prfOid"
            }]
          }]
        }]
      }, {
        name: "PBES2Algorithms.encryptionScheme",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.encryptionScheme.oid",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encOid"
        }, {
          name: "PBES2Algorithms.encryptionScheme.iv",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "encIv"
        }]
      }]
    };
    var pkcs12PbeParamsValidator = {
      name: "pkcs-12PbeParams",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "pkcs-12PbeParams.salt",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "salt"
      }, {
        name: "pkcs-12PbeParams.iterations",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "iterations"
      }]
    };
    pki.encryptPrivateKeyInfo = function(obj, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || "aes128";
      options.prfAlgorithm = options.prfAlgorithm || "sha1";
      var salt = forge.random.getBytesSync(options.saltSize);
      var count3 = options.count;
      var countBytes = asn1.integerToDer(count3);
      var dkLen;
      var encryptionAlgorithm;
      var encryptedData;
      if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
        var ivLen, encOid, cipherFn;
        switch (options.algorithm) {
          case "aes128":
            dkLen = 16;
            ivLen = 16;
            encOid = oids["aes128-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes192":
            dkLen = 24;
            ivLen = 16;
            encOid = oids["aes192-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "aes256":
            dkLen = 32;
            ivLen = 16;
            encOid = oids["aes256-CBC"];
            cipherFn = forge.aes.createEncryptionCipher;
            break;
          case "des":
            dkLen = 8;
            ivLen = 8;
            encOid = oids["desCBC"];
            cipherFn = forge.des.createEncryptionCipher;
            break;
          default:
            var error3 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
            error3.algorithm = options.algorithm;
            throw error3;
        }
        var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
        var md = prfAlgorithmToMessageDigest(prfAlgorithm);
        var dk = forge.pkcs5.pbkdf2(password, salt, count3, dkLen, md);
        var iv = forge.random.getBytesSync(ivLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()
            ),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // keyDerivationFunc
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()
                ),
                // PBKDF2-params
                params
              ]),
              // encryptionScheme
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(encOid).getBytes()
                ),
                // iv
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  iv
                )
              ])
            ])
          ]
        );
      } else if (options.algorithm === "3des") {
        dkLen = 24;
        var saltBytes = new forge.util.ByteBuffer(salt);
        var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count3, dkLen);
        var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count3, dkLen);
        var cipher = forge.des.createEncryptionCipher(dk);
        cipher.start(iv);
        cipher.update(asn1.toDer(obj));
        cipher.finish();
        encryptedData = cipher.output.getBytes();
        encryptionAlgorithm = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
            ),
            // pkcs-12PbeParams
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // salt
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
              // iteration count
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                countBytes.getBytes()
              )
            ])
          ]
        );
      } else {
        var error3 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error3.algorithm = options.algorithm;
        throw error3;
      }
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // encryptionAlgorithm
        encryptionAlgorithm,
        // encryptedData
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          encryptedData
        )
      ]);
      return rval;
    };
    pki.decryptPrivateKeyInfo = function(obj, password) {
      var rval = null;
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
        var error3 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error3.errors = errors;
        throw error3;
      }
      var oid = asn1.derToOid(capture.encryptionOid);
      var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
      var encrypted = forge.util.createBuffer(capture.encryptedData);
      cipher.update(encrypted);
      if (cipher.finish()) {
        rval = asn1.fromDer(cipher.output);
      }
      return rval;
    };
    pki.encryptedPrivateKeyToPem = function(epki, maxline) {
      var msg = {
        type: "ENCRYPTED PRIVATE KEY",
        body: asn1.toDer(epki).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.encryptedPrivateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY") {
        var error3 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
      }
      return asn1.fromDer(msg.body);
    };
    pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
      options = options || {};
      if (!options.legacy) {
        var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
        rval = pki.encryptPrivateKeyInfo(rval, password, options);
        return pki.encryptedPrivateKeyToPem(rval);
      }
      var algorithm;
      var iv;
      var dkLen;
      var cipherFn;
      switch (options.algorithm) {
        case "aes128":
          algorithm = "AES-128-CBC";
          dkLen = 16;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          algorithm = "AES-192-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          algorithm = "AES-256-CBC";
          dkLen = 32;
          iv = forge.random.getBytesSync(16);
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "3des":
          algorithm = "DES-EDE3-CBC";
          dkLen = 24;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        case "des":
          algorithm = "DES-CBC";
          dkLen = 8;
          iv = forge.random.getBytesSync(8);
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error3 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
          error3.algorithm = options.algorithm;
          throw error3;
      }
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
      cipher.finish();
      var msg = {
        type: "RSA PRIVATE KEY",
        procType: {
          version: "4",
          type: "ENCRYPTED"
        },
        dekInfo: {
          algorithm,
          parameters: forge.util.bytesToHex(iv).toUpperCase()
        },
        body: cipher.output.getBytes()
      };
      return forge.pem.encode(msg);
    };
    pki.decryptRsaPrivateKey = function(pem, password) {
      var rval = null;
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error3 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
        error3.headerType = error3;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        var dkLen;
        var cipherFn;
        switch (msg.dekInfo.algorithm) {
          case "DES-CBC":
            dkLen = 8;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "DES-EDE3-CBC":
            dkLen = 24;
            cipherFn = forge.des.createDecryptionCipher;
            break;
          case "AES-128-CBC":
            dkLen = 16;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-192-CBC":
            dkLen = 24;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "AES-256-CBC":
            dkLen = 32;
            cipherFn = forge.aes.createDecryptionCipher;
            break;
          case "RC2-40-CBC":
            dkLen = 5;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge.rc2.createDecryptionCipher(key, 40);
            }, "cipherFn");
            break;
          case "RC2-64-CBC":
            dkLen = 8;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge.rc2.createDecryptionCipher(key, 64);
            }, "cipherFn");
            break;
          case "RC2-128-CBC":
            dkLen = 16;
            cipherFn = /* @__PURE__ */ __name(function(key) {
              return forge.rc2.createDecryptionCipher(key, 128);
            }, "cipherFn");
            break;
          default:
            var error3 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
            error3.algorithm = msg.dekInfo.algorithm;
            throw error3;
        }
        var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
        var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
        var cipher = cipherFn(dk);
        cipher.start(iv);
        cipher.update(forge.util.createBuffer(msg.body));
        if (cipher.finish()) {
          rval = cipher.output.getBytes();
        } else {
          return rval;
        }
      } else {
        rval = msg.body;
      }
      if (msg.type === "ENCRYPTED PRIVATE KEY") {
        rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
      } else {
        rval = asn1.fromDer(rval);
      }
      if (rval !== null) {
        rval = pki.privateKeyFromAsn1(rval);
      }
      return rval;
    };
    pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
      var j, l;
      if (typeof md === "undefined" || md === null) {
        if (!("sha1" in forge.md)) {
          throw new Error('"sha1" hash algorithm unavailable.');
        }
        md = forge.md.sha1.create();
      }
      var u = md.digestLength;
      var v2 = md.blockLength;
      var result = new forge.util.ByteBuffer();
      var passBuf = new forge.util.ByteBuffer();
      if (password !== null && password !== void 0) {
        for (l = 0; l < password.length; l++) {
          passBuf.putInt16(password.charCodeAt(l));
        }
        passBuf.putInt16(0);
      }
      var p2 = passBuf.length();
      var s = salt.length();
      var D2 = new forge.util.ByteBuffer();
      D2.fillWithByte(id, v2);
      var Slen = v2 * Math.ceil(s / v2);
      var S2 = new forge.util.ByteBuffer();
      for (l = 0; l < Slen; l++) {
        S2.putByte(salt.at(l % s));
      }
      var Plen = v2 * Math.ceil(p2 / v2);
      var P = new forge.util.ByteBuffer();
      for (l = 0; l < Plen; l++) {
        P.putByte(passBuf.at(l % p2));
      }
      var I2 = S2;
      I2.putBuffer(P);
      var c = Math.ceil(n / u);
      for (var i = 1; i <= c; i++) {
        var buf = new forge.util.ByteBuffer();
        buf.putBytes(D2.bytes());
        buf.putBytes(I2.bytes());
        for (var round = 0; round < iter; round++) {
          md.start();
          md.update(buf.getBytes());
          buf = md.digest();
        }
        var B = new forge.util.ByteBuffer();
        for (l = 0; l < v2; l++) {
          B.putByte(buf.at(l % u));
        }
        var k = Math.ceil(s / v2) + Math.ceil(p2 / v2);
        var Inew = new forge.util.ByteBuffer();
        for (j = 0; j < k; j++) {
          var chunk = new forge.util.ByteBuffer(I2.getBytes(v2));
          var x = 511;
          for (l = B.length() - 1; l >= 0; l--) {
            x = x >> 8;
            x += B.at(l) + chunk.at(l);
            chunk.setAt(l, x & 255);
          }
          Inew.putBuffer(chunk);
        }
        I2 = Inew;
        result.putBuffer(buf);
      }
      result.truncate(result.length() - n);
      return result;
    };
    pki.pbe.getCipher = function(oid, params, password) {
      switch (oid) {
        case pki.oids["pkcs5PBES2"]:
          return pki.pbe.getCipherForPBES2(oid, params, password);
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
        default:
          var error3 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
          error3.oid = oid;
          error3.supportedOids = [
            "pkcs5PBES2",
            "pbeWithSHAAnd3-KeyTripleDES-CBC",
            "pbewithSHAAnd40BitRC2-CBC"
          ];
          throw error3;
      }
    };
    pki.pbe.getCipherForPBES2 = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
        var error3 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error3.errors = errors;
        throw error3;
      }
      oid = asn1.derToOid(capture.kdfOid);
      if (oid !== pki.oids["pkcs5PBKDF2"]) {
        var error3 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
        error3.oid = oid;
        error3.supportedOids = ["pkcs5PBKDF2"];
        throw error3;
      }
      oid = asn1.derToOid(capture.encOid);
      if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
        var error3 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
        error3.oid = oid;
        error3.supportedOids = [
          "aes128-CBC",
          "aes192-CBC",
          "aes256-CBC",
          "des-EDE3-CBC",
          "desCBC"
        ];
        throw error3;
      }
      var salt = capture.kdfSalt;
      var count3 = forge.util.createBuffer(capture.kdfIterationCount);
      count3 = count3.getInt(count3.length() << 3);
      var dkLen;
      var cipherFn;
      switch (pki.oids[oid]) {
        case "aes128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "aes256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "des-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "desCBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var dk = forge.pkcs5.pbkdf2(password, salt, count3, dkLen, md);
      var iv = capture.encIv;
      var cipher = cipherFn(dk);
      cipher.start(iv);
      return cipher;
    };
    pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
        var error3 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
        error3.errors = errors;
        throw error3;
      }
      var salt = forge.util.createBuffer(capture.salt);
      var count3 = forge.util.createBuffer(capture.iterations);
      count3 = count3.getInt(count3.length() << 3);
      var dkLen, dIvLen, cipherFn;
      switch (oid) {
        case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
          dkLen = 24;
          dIvLen = 8;
          cipherFn = forge.des.startDecrypting;
          break;
        case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
          dkLen = 5;
          dIvLen = 8;
          cipherFn = /* @__PURE__ */ __name(function(key2, iv2) {
            var cipher = forge.rc2.createDecryptionCipher(key2, 40);
            cipher.start(iv2, null);
            return cipher;
          }, "cipherFn");
          break;
        default:
          var error3 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
          error3.oid = oid;
          throw error3;
      }
      var md = prfOidToMessageDigest(capture.prfOid);
      var key = pki.pbe.generatePkcs12Key(password, salt, 1, count3, dkLen, md);
      md.start();
      var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count3, dIvLen, md);
      return cipherFn(key, iv);
    };
    pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
      if (typeof md === "undefined" || md === null) {
        if (!("md5" in forge.md)) {
          throw new Error('"md5" hash algorithm unavailable.');
        }
        md = forge.md.md5.create();
      }
      if (salt === null) {
        salt = "";
      }
      var digests = [hash2(md, password + salt)];
      for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
        digests.push(hash2(md, digests[i - 1] + password + salt));
      }
      return digests.join("").substr(0, dkLen);
    };
    function hash2(md, bytes) {
      return md.start().update(bytes).digest().getBytes();
    }
    __name(hash2, "hash");
    function prfOidToMessageDigest(prfOid) {
      var prfAlgorithm;
      if (!prfOid) {
        prfAlgorithm = "hmacWithSHA1";
      } else {
        prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
        if (!prfAlgorithm) {
          var error3 = new Error("Unsupported PRF OID.");
          error3.oid = prfOid;
          error3.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error3;
        }
      }
      return prfAlgorithmToMessageDigest(prfAlgorithm);
    }
    __name(prfOidToMessageDigest, "prfOidToMessageDigest");
    function prfAlgorithmToMessageDigest(prfAlgorithm) {
      var factory = forge.md;
      switch (prfAlgorithm) {
        case "hmacWithSHA224":
          factory = forge.md.sha512;
        case "hmacWithSHA1":
        case "hmacWithSHA256":
        case "hmacWithSHA384":
        case "hmacWithSHA512":
          prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
          break;
        default:
          var error3 = new Error("Unsupported PRF algorithm.");
          error3.algorithm = prfAlgorithm;
          error3.supported = [
            "hmacWithSHA1",
            "hmacWithSHA224",
            "hmacWithSHA256",
            "hmacWithSHA384",
            "hmacWithSHA512"
          ];
          throw error3;
      }
      if (!factory || !(prfAlgorithm in factory)) {
        throw new Error("Unknown hash algorithm: " + prfAlgorithm);
      }
      return factory[prfAlgorithm].create();
    }
    __name(prfAlgorithmToMessageDigest, "prfAlgorithmToMessageDigest");
    function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
      var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // salt
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          salt
        ),
        // iteration count
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          countBytes.getBytes()
        )
      ]);
      if (prfAlgorithm !== "hmacWithSHA1") {
        params.value.push(
          // key length
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(dkLen.toString(16))
          ),
          // AlgorithmIdentifier
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // algorithm
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()
            ),
            // parameters (null)
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
          ])
        );
      }
      return params;
    }
    __name(createPbkdf2Params, "createPbkdf2Params");
  }
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS({
  "node_modules/node-forge/lib/pkcs7asn1.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    require_util4();
    var asn1 = forge.asn1;
    var p7v = module.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
    forge.pkcs7 = forge.pkcs7 || {};
    forge.pkcs7.asn1 = p7v;
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "ContentInfo.ContentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        captureAsn1: "content"
      }]
    };
    p7v.contentInfoValidator = contentInfoValidator;
    var encryptedContentInfoValidator = {
      name: "EncryptedContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          captureAsn1: "encParameter"
        }]
      }, {
        name: "EncryptedContentInfo.encryptedContent",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        /* The PKCS#7 structure output by OpenSSL somewhat differs from what
         * other implementations do generate.
         *
         * OpenSSL generates a structure like this:
         * SEQUENCE {
         *    ...
         *    [0]
         *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *       ...
         * }
         *
         * Whereas other implementations (and this PKCS#7 module) generate:
         * SEQUENCE {
         *    ...
         *    [0] {
         *       OCTET STRING
         *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
         *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
         *          ...
         *    }
         * }
         *
         * In order to support both, we just capture the context specific
         * field here.  The OCTET STRING bit is removed below.
         */
        capture: "encryptedContent",
        captureAsn1: "encryptedContentAsn1"
      }]
    };
    p7v.envelopedDataValidator = {
      name: "EnvelopedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EnvelopedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "EnvelopedData.RecipientInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "recipientInfos"
      }].concat(encryptedContentInfoValidator)
    };
    p7v.encryptedDataValidator = {
      name: "EncryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }].concat(encryptedContentInfoValidator)
    };
    var signerValidator = {
      name: "SignerInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false
      }, {
        name: "SignerInfo.issuerAndSerialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.issuerAndSerialNumber.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "SignerInfo.issuerAndSerialNumber.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "SignerInfo.digestAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "SignerInfo.digestAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "digestAlgorithm"
        }, {
          name: "SignerInfo.digestAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "digestParameter",
          optional: true
        }]
      }, {
        name: "SignerInfo.authenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "authenticatedAttributes"
      }, {
        name: "SignerInfo.digestEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        capture: "signatureAlgorithm"
      }, {
        name: "SignerInfo.encryptedDigest",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "signature"
      }, {
        name: "SignerInfo.unauthenticatedAttributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        capture: "unauthenticatedAttributes"
      }]
    };
    p7v.signedDataValidator = {
      name: "SignedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "SignedData.Version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        {
          name: "SignedData.DigestAlgorithms",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          constructed: true,
          captureAsn1: "digestAlgorithms"
        },
        contentInfoValidator,
        {
          name: "SignedData.Certificates",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          optional: true,
          captureAsn1: "certificates"
        },
        {
          name: "SignedData.CertificateRevocationLists",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          optional: true,
          captureAsn1: "crls"
        },
        {
          name: "SignedData.SignerInfos",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SET,
          capture: "signerInfos",
          optional: true,
          value: [signerValidator]
        }
      ]
    };
    p7v.recipientInfoValidator = {
      name: "RecipientInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      }, {
        name: "RecipientInfo.issuerAndSerial",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.issuerAndSerial.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "issuer"
        }, {
          name: "RecipientInfo.issuerAndSerial.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "serial"
        }]
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "encAlgorithm"
        }, {
          name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
          tagClass: asn1.Class.UNIVERSAL,
          constructed: false,
          captureAsn1: "encParameter",
          optional: true
        }]
      }, {
        name: "RecipientInfo.encryptedKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encKey"
      }]
    };
  }
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS({
  "node_modules/node-forge/lib/mgf1.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    forge.mgf = forge.mgf || {};
    var mgf1 = module.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
    mgf1.create = function(md) {
      var mgf = {
        /**
         * Generate mask of specified length.
         *
         * @param {String} seed The seed for mask generation.
         * @param maskLen Number of bytes to generate.
         * @return {String} The generated mask.
         */
        generate: /* @__PURE__ */ __name(function(seed, maskLen) {
          var t = new forge.util.ByteBuffer();
          var len = Math.ceil(maskLen / md.digestLength);
          for (var i = 0; i < len; i++) {
            var c = new forge.util.ByteBuffer();
            c.putInt32(i);
            md.start();
            md.update(seed + c.getBytes());
            t.putBuffer(md.digest());
          }
          t.truncate(t.length() - maskLen);
          return t.getBytes();
        }, "generate")
      };
      return mgf;
    };
  }
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS({
  "node_modules/node-forge/lib/mgf.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_mgf1();
    module.exports = forge.mgf = forge.mgf || {};
    forge.mgf.mgf1 = forge.mgf1;
  }
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS({
  "node_modules/node-forge/lib/pss.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_random();
    require_util4();
    var pss = module.exports = forge.pss = forge.pss || {};
    pss.create = function(options) {
      if (arguments.length === 3) {
        options = {
          md: arguments[0],
          mgf: arguments[1],
          saltLength: arguments[2]
        };
      }
      var hash2 = options.md;
      var mgf = options.mgf;
      var hLen = hash2.digestLength;
      var salt_ = options.salt || null;
      if (typeof salt_ === "string") {
        salt_ = forge.util.createBuffer(salt_);
      }
      var sLen;
      if ("saltLength" in options) {
        sLen = options.saltLength;
      } else if (salt_ !== null) {
        sLen = salt_.length();
      } else {
        throw new Error("Salt length not specified or specific salt not given.");
      }
      if (salt_ !== null && salt_.length() !== sLen) {
        throw new Error("Given salt length does not match length of given salt.");
      }
      var prng = options.prng || forge.random;
      var pssobj = {};
      pssobj.encode = function(md, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        var mHash = md.digest().getBytes();
        if (emLen < hLen + sLen + 2) {
          throw new Error("Message is too long to encrypt.");
        }
        var salt;
        if (salt_ === null) {
          salt = prng.getBytesSync(sLen);
        } else {
          salt = salt_.bytes();
        }
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h = hash2.digest().getBytes();
        var ps2 = new forge.util.ByteBuffer();
        ps2.fillWithByte(0, emLen - sLen - hLen - 2);
        ps2.putByte(1);
        ps2.putBytes(salt);
        var db = ps2.getBytes();
        var maskLen = emLen - hLen - 1;
        var dbMask = mgf.generate(h, maskLen);
        var maskedDB = "";
        for (i = 0; i < maskLen; i++) {
          maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        var mask = 65280 >> 8 * emLen - emBits & 255;
        maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
        return maskedDB + h + String.fromCharCode(188);
      };
      pssobj.verify = function(mHash, em, modBits) {
        var i;
        var emBits = modBits - 1;
        var emLen = Math.ceil(emBits / 8);
        em = em.substr(-emLen);
        if (emLen < hLen + sLen + 2) {
          throw new Error("Inconsistent parameters to PSS signature verification.");
        }
        if (em.charCodeAt(emLen - 1) !== 188) {
          throw new Error("Encoded message does not end in 0xBC.");
        }
        var maskLen = emLen - hLen - 1;
        var maskedDB = em.substr(0, maskLen);
        var h = em.substr(maskLen, hLen);
        var mask = 65280 >> 8 * emLen - emBits & 255;
        if ((maskedDB.charCodeAt(0) & mask) !== 0) {
          throw new Error("Bits beyond keysize not zero as expected.");
        }
        var dbMask = mgf.generate(h, maskLen);
        var db = "";
        for (i = 0; i < maskLen; i++) {
          db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
        }
        db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
        var checkLen = emLen - hLen - sLen - 2;
        for (i = 0; i < checkLen; i++) {
          if (db.charCodeAt(i) !== 0) {
            throw new Error("Leftmost octets not zero as expected");
          }
        }
        if (db.charCodeAt(checkLen) !== 1) {
          throw new Error("Inconsistent PSS signature, 0x01 marker not found");
        }
        var salt = db.substr(-sLen);
        var m_ = new forge.util.ByteBuffer();
        m_.fillWithByte(0, 8);
        m_.putBytes(mHash);
        m_.putBytes(salt);
        hash2.start();
        hash2.update(m_.getBytes());
        var h_ = hash2.digest().getBytes();
        return h === h_;
      };
      return pssobj;
    };
  }
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS({
  "node_modules/node-forge/lib/x509.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_md();
    require_mgf();
    require_oids();
    require_pem();
    require_pss();
    require_rsa();
    require_util4();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    var oids = pki.oids;
    var _shortNames = {};
    _shortNames["CN"] = oids["commonName"];
    _shortNames["commonName"] = "CN";
    _shortNames["C"] = oids["countryName"];
    _shortNames["countryName"] = "C";
    _shortNames["L"] = oids["localityName"];
    _shortNames["localityName"] = "L";
    _shortNames["ST"] = oids["stateOrProvinceName"];
    _shortNames["stateOrProvinceName"] = "ST";
    _shortNames["O"] = oids["organizationName"];
    _shortNames["organizationName"] = "O";
    _shortNames["OU"] = oids["organizationalUnitName"];
    _shortNames["organizationalUnitName"] = "OU";
    _shortNames["E"] = oids["emailAddress"];
    _shortNames["emailAddress"] = "E";
    var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
    var x509CertificateValidator = {
      name: "Certificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.TBSCertificate",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "tbsCertificate",
        value: [
          {
            name: "Certificate.TBSCertificate.version",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 0,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.version.integer",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.INTEGER,
              constructed: false,
              capture: "certVersion"
            }]
          },
          {
            name: "Certificate.TBSCertificate.serialNumber",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certSerialNumber"
          },
          {
            name: "Certificate.TBSCertificate.signature",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "Certificate.TBSCertificate.signature.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "certinfoSignatureOid"
            }, {
              name: "Certificate.TBSCertificate.signature.parameters",
              tagClass: asn1.Class.UNIVERSAL,
              optional: true,
              captureAsn1: "certinfoSignatureParams"
            }]
          },
          {
            name: "Certificate.TBSCertificate.issuer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certIssuer"
          },
          {
            name: "Certificate.TBSCertificate.validity",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            // Note: UTC and generalized times may both appear so the capture
            // names are based on their detected order, the names used below
            // are only for the common case, which validity time really means
            // "notBefore" and which means "notAfter" will be determined by order
            value: [{
              // notBefore (Time) (UTC time case)
              name: "Certificate.TBSCertificate.validity.notBefore (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity1UTCTime"
            }, {
              // notBefore (Time) (generalized time case)
              name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity2GeneralizedTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (utc)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.UTCTIME,
              constructed: false,
              optional: true,
              capture: "certValidity3UTCTime"
            }, {
              // notAfter (Time) (only UTC time is supported)
              name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.GENERALIZEDTIME,
              constructed: false,
              optional: true,
              capture: "certValidity4GeneralizedTime"
            }]
          },
          {
            // Name (subject) (RDNSequence)
            name: "Certificate.TBSCertificate.subject",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            captureAsn1: "certSubject"
          },
          // SubjectPublicKeyInfo
          publicKeyValidator,
          {
            // issuerUniqueID (optional)
            name: "Certificate.TBSCertificate.issuerUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 1,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.issuerUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certIssuerUniqueId"
            }]
          },
          {
            // subjectUniqueID (optional)
            name: "Certificate.TBSCertificate.subjectUniqueID",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 2,
            constructed: true,
            optional: true,
            value: [{
              name: "Certificate.TBSCertificate.subjectUniqueID.id",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.BITSTRING,
              constructed: false,
              // TODO: support arbitrary bit length ids
              captureBitStringValue: "certSubjectUniqueId"
            }]
          },
          {
            // Extensions (optional)
            name: "Certificate.TBSCertificate.extensions",
            tagClass: asn1.Class.CONTEXT_SPECIFIC,
            type: 3,
            constructed: true,
            captureAsn1: "certExtensions",
            optional: true
          }
        ]
      }, {
        // AlgorithmIdentifier (signature algorithm)
        name: "Certificate.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          // algorithm
          name: "Certificate.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "certSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certSignatureParams"
        }]
      }, {
        // SignatureValue
        name: "Certificate.signatureValue",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "certSignature"
      }]
    };
    var rsassaPssParameterValidator = {
      name: "rsapss",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "hashOid"
            /* parameter block omitted, for SHA1 NULL anyhow. */
          }]
        }]
      }, {
        name: "rsapss.maskGenAlgorithm",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenOid"
          }, {
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false,
              capture: "maskGenHashOid"
              /* parameter block omitted, for SHA1 NULL anyhow. */
            }]
          }]
        }]
      }, {
        name: "rsapss.saltLength",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 2,
        optional: true,
        value: [{
          name: "rsapss.saltLength.saltLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "saltLength"
        }]
      }, {
        name: "rsapss.trailerField",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 3,
        optional: true,
        value: [{
          name: "rsapss.trailer.trailer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.INTEGER,
          constructed: false,
          capture: "trailer"
        }]
      }]
    };
    var certificationRequestInfoValidator = {
      name: "CertificationRequestInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfo",
      value: [
        {
          name: "CertificationRequestInfo.integer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certificationRequestInfoVersion"
        },
        {
          // Name (subject) (RDNSequence)
          name: "CertificationRequestInfo.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certificationRequestInfoSubject"
        },
        // SubjectPublicKeyInfo
        publicKeyValidator,
        {
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          capture: "certificationRequestInfoAttributes",
          value: [{
            name: "CertificationRequestInfo.attributes",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            value: [{
              name: "CertificationRequestInfo.attributes.type",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OID,
              constructed: false
            }, {
              name: "CertificationRequestInfo.attributes.value",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SET,
              constructed: true
            }]
          }]
        }
      ]
    };
    var certificationRequestValidator = {
      name: "CertificationRequest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "csr",
      value: [
        certificationRequestInfoValidator,
        {
          // AlgorithmIdentifier (signature algorithm)
          name: "CertificationRequest.signatureAlgorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            // algorithm
            name: "CertificationRequest.signatureAlgorithm.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "csrSignatureOid"
          }, {
            name: "CertificationRequest.signatureAlgorithm.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "csrSignatureParams"
          }]
        },
        {
          // signature
          name: "CertificationRequest.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          captureBitStringValue: "csrSignature"
        }
      ]
    };
    pki.RDNAttributesAsArray = function(rdn, md) {
      var rval = [];
      var set, attr, obj;
      for (var si = 0; si < rdn.value.length; ++si) {
        set = rdn.value[si];
        for (var i = 0; i < set.value.length; ++i) {
          obj = {};
          attr = set.value[i];
          obj.type = asn1.derToOid(attr.value[0].value);
          obj.value = attr.value[1].value;
          obj.valueTagClass = attr.value[1].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (md) {
            md.update(obj.type);
            md.update(obj.value);
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    pki.CRIAttributesAsArray = function(attributes) {
      var rval = [];
      for (var si = 0; si < attributes.length; ++si) {
        var seq = attributes[si];
        var type2 = asn1.derToOid(seq.value[0].value);
        var values = seq.value[1].value;
        for (var vi2 = 0; vi2 < values.length; ++vi2) {
          var obj = {};
          obj.type = type2;
          obj.value = values[vi2].value;
          obj.valueTagClass = values[vi2].type;
          if (obj.type in oids) {
            obj.name = oids[obj.type];
            if (obj.name in _shortNames) {
              obj.shortName = _shortNames[obj.name];
            }
          }
          if (obj.type === oids.extensionRequest) {
            obj.extensions = [];
            for (var ei = 0; ei < obj.value.length; ++ei) {
              obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
            }
          }
          rval.push(obj);
        }
      }
      return rval;
    };
    function _getAttribute(obj, options) {
      if (typeof options === "string") {
        options = { shortName: options };
      }
      var rval = null;
      var attr;
      for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
        attr = obj.attributes[i];
        if (options.type && options.type === attr.type) {
          rval = attr;
        } else if (options.name && options.name === attr.name) {
          rval = attr;
        } else if (options.shortName && options.shortName === attr.shortName) {
          rval = attr;
        }
      }
      return rval;
    }
    __name(_getAttribute, "_getAttribute");
    var _readSignatureParameters = /* @__PURE__ */ __name(function(oid, obj, fillDefaults) {
      var params = {};
      if (oid !== oids["RSASSA-PSS"]) {
        return params;
      }
      if (fillDefaults) {
        params = {
          hash: {
            algorithmOid: oids["sha1"]
          },
          mgf: {
            algorithmOid: oids["mgf1"],
            hash: {
              algorithmOid: oids["sha1"]
            }
          },
          saltLength: 20
        };
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
        var error3 = new Error("Cannot read RSASSA-PSS parameter block.");
        error3.errors = errors;
        throw error3;
      }
      if (capture.hashOid !== void 0) {
        params.hash = params.hash || {};
        params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
      }
      if (capture.maskGenOid !== void 0) {
        params.mgf = params.mgf || {};
        params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
        params.mgf.hash = params.mgf.hash || {};
        params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
      }
      if (capture.saltLength !== void 0) {
        params.saltLength = capture.saltLength.charCodeAt(0);
      }
      return params;
    }, "_readSignatureParameters");
    var _createSignatureDigest = /* @__PURE__ */ __name(function(options) {
      switch (oids[options.signatureOid]) {
        case "sha1WithRSAEncryption":
        // deprecated alias
        case "sha1WithRSASignature":
          return forge.md.sha1.create();
        case "md5WithRSAEncryption":
          return forge.md.md5.create();
        case "sha256WithRSAEncryption":
          return forge.md.sha256.create();
        case "sha384WithRSAEncryption":
          return forge.md.sha384.create();
        case "sha512WithRSAEncryption":
          return forge.md.sha512.create();
        case "RSASSA-PSS":
          return forge.md.sha256.create();
        default:
          var error3 = new Error(
            "Could not compute " + options.type + " digest. Unknown signature OID."
          );
          error3.signatureOid = options.signatureOid;
          throw error3;
      }
    }, "_createSignatureDigest");
    var _verifySignature = /* @__PURE__ */ __name(function(options) {
      var cert2 = options.certificate;
      var scheme;
      switch (cert2.signatureOid) {
        case oids.sha1WithRSAEncryption:
        // deprecated alias
        case oids.sha1WithRSASignature:
          break;
        case oids["RSASSA-PSS"]:
          var hash2, mgf;
          hash2 = oids[cert2.signatureParameters.mgf.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error3 = new Error("Unsupported MGF hash function.");
            error3.oid = cert2.signatureParameters.mgf.hash.algorithmOid;
            error3.name = hash2;
            throw error3;
          }
          mgf = oids[cert2.signatureParameters.mgf.algorithmOid];
          if (mgf === void 0 || forge.mgf[mgf] === void 0) {
            var error3 = new Error("Unsupported MGF function.");
            error3.oid = cert2.signatureParameters.mgf.algorithmOid;
            error3.name = mgf;
            throw error3;
          }
          mgf = forge.mgf[mgf].create(forge.md[hash2].create());
          hash2 = oids[cert2.signatureParameters.hash.algorithmOid];
          if (hash2 === void 0 || forge.md[hash2] === void 0) {
            var error3 = new Error("Unsupported RSASSA-PSS hash function.");
            error3.oid = cert2.signatureParameters.hash.algorithmOid;
            error3.name = hash2;
            throw error3;
          }
          scheme = forge.pss.create(
            forge.md[hash2].create(),
            mgf,
            cert2.signatureParameters.saltLength
          );
          break;
      }
      return cert2.publicKey.verify(
        options.md.digest().getBytes(),
        options.signature,
        scheme
      );
    }, "_verifySignature");
    pki.certificateFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
        var error3 = new Error(
          'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
        );
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error(
          "Could not convert certificate from PEM; PEM is encrypted."
        );
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificateFromAsn1(obj, computeHash);
    };
    pki.certificateToPem = function(cert2, maxline) {
      var msg = {
        type: "CERTIFICATE",
        body: asn1.toDer(pki.certificateToAsn1(cert2)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
        var error3 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert public key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.publicKeyFromAsn1(obj);
    };
    pki.publicKeyToPem = function(key, maxline) {
      var msg = {
        type: "PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
      var msg = {
        type: "RSA PUBLIC KEY",
        body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.sha1.create();
      var type2 = options.type || "RSAPublicKey";
      var bytes;
      switch (type2) {
        case "RSAPublicKey":
          bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
          break;
        case "SubjectPublicKeyInfo":
          bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
          break;
        default:
          throw new Error('Unknown fingerprint type "' + options.type + '".');
      }
      md.start();
      md.update(bytes);
      var digest2 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest2.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest2.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest2;
    };
    pki.certificationRequestFromPem = function(pem, computeHash, strict) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "CERTIFICATE REQUEST") {
        var error3 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body, strict);
      return pki.certificationRequestFromAsn1(obj, computeHash);
    };
    pki.certificationRequestToPem = function(csr, maxline) {
      var msg = {
        type: "CERTIFICATE REQUEST",
        body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.createCertificate = function() {
      var cert2 = {};
      cert2.version = 2;
      cert2.serialNumber = "00";
      cert2.signatureOid = null;
      cert2.signature = null;
      cert2.siginfo = {};
      cert2.siginfo.algorithmOid = null;
      cert2.validity = {};
      cert2.validity.notBefore = /* @__PURE__ */ new Date();
      cert2.validity.notAfter = /* @__PURE__ */ new Date();
      cert2.issuer = {};
      cert2.issuer.getField = function(sn) {
        return _getAttribute(cert2.issuer, sn);
      };
      cert2.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.issuer.attributes.push(attr);
      };
      cert2.issuer.attributes = [];
      cert2.issuer.hash = null;
      cert2.subject = {};
      cert2.subject.getField = function(sn) {
        return _getAttribute(cert2.subject, sn);
      };
      cert2.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.subject.attributes.push(attr);
      };
      cert2.subject.attributes = [];
      cert2.subject.hash = null;
      cert2.extensions = [];
      cert2.publicKey = null;
      cert2.md = null;
      cert2.setSubject = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert2.subject.attributes = attrs;
        delete cert2.subject.uniqueId;
        if (uniqueId) {
          cert2.subject.uniqueId = uniqueId;
        }
        cert2.subject.hash = null;
      };
      cert2.setIssuer = function(attrs, uniqueId) {
        _fillMissingFields(attrs);
        cert2.issuer.attributes = attrs;
        delete cert2.issuer.uniqueId;
        if (uniqueId) {
          cert2.issuer.uniqueId = uniqueId;
        }
        cert2.issuer.hash = null;
      };
      cert2.setExtensions = function(exts) {
        for (var i = 0; i < exts.length; ++i) {
          _fillMissingExtensionFields(exts[i], { cert: cert2 });
        }
        cert2.extensions = exts;
      };
      cert2.getExtension = function(options) {
        if (typeof options === "string") {
          options = { name: options };
        }
        var rval = null;
        var ext;
        for (var i = 0; rval === null && i < cert2.extensions.length; ++i) {
          ext = cert2.extensions[i];
          if (options.id && ext.id === options.id) {
            rval = ext;
          } else if (options.name && ext.name === options.name) {
            rval = ext;
          }
        }
        return rval;
      };
      cert2.sign = function(key, md) {
        cert2.md = md || forge.md.sha1.create();
        var algorithmOid = oids[cert2.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error3 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
          error3.algorithm = cert2.md.algorithm;
          throw error3;
        }
        cert2.signatureOid = cert2.siginfo.algorithmOid = algorithmOid;
        cert2.tbsCertificate = pki.getTBSCertificate(cert2);
        var bytes = asn1.toDer(cert2.tbsCertificate);
        cert2.md.update(bytes.getBytes());
        cert2.signature = key.sign(cert2.md);
      };
      cert2.verify = function(child) {
        var rval = false;
        if (!cert2.issued(child)) {
          var issuer = child.issuer;
          var subject = cert2.subject;
          var error3 = new Error(
            "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
          );
          error3.expectedIssuer = subject.attributes;
          error3.actualIssuer = issuer.attributes;
          throw error3;
        }
        var md = child.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: child.signatureOid,
            type: "certificate"
          });
          var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
          var bytes = asn1.toDer(tbsCertificate);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: cert2,
            md,
            signature: child.signature
          });
        }
        return rval;
      };
      cert2.isIssuer = function(parent) {
        var rval = false;
        var i = cert2.issuer;
        var s = parent.subject;
        if (i.hash && s.hash) {
          rval = i.hash === s.hash;
        } else if (i.attributes.length === s.attributes.length) {
          rval = true;
          var iattr, sattr;
          for (var n = 0; rval && n < i.attributes.length; ++n) {
            iattr = i.attributes[n];
            sattr = s.attributes[n];
            if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
              rval = false;
            }
          }
        }
        return rval;
      };
      cert2.issued = function(child) {
        return child.isIssuer(cert2);
      };
      cert2.generateSubjectKeyIdentifier = function() {
        return pki.getPublicKeyFingerprint(cert2.publicKey, { type: "RSAPublicKey" });
      };
      cert2.verifySubjectKeyIdentifier = function() {
        var oid = oids["subjectKeyIdentifier"];
        for (var i = 0; i < cert2.extensions.length; ++i) {
          var ext = cert2.extensions[i];
          if (ext.id === oid) {
            var ski = cert2.generateSubjectKeyIdentifier().getBytes();
            return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
          }
        }
        return false;
      };
      return cert2;
    };
    pki.certificateFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
        var error3 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
        error3.errors = errors;
        throw error3;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var cert2 = pki.createCertificate();
      cert2.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
      var serial = forge.util.createBuffer(capture.certSerialNumber);
      cert2.serialNumber = serial.toHex();
      cert2.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
      cert2.signatureParameters = _readSignatureParameters(
        cert2.signatureOid,
        capture.certSignatureParams,
        true
      );
      cert2.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
      cert2.siginfo.parameters = _readSignatureParameters(
        cert2.siginfo.algorithmOid,
        capture.certinfoSignatureParams,
        false
      );
      cert2.signature = capture.certSignature;
      var validity = [];
      if (capture.certValidity1UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
      }
      if (capture.certValidity2GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity2GeneralizedTime
        ));
      }
      if (capture.certValidity3UTCTime !== void 0) {
        validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
      }
      if (capture.certValidity4GeneralizedTime !== void 0) {
        validity.push(asn1.generalizedTimeToDate(
          capture.certValidity4GeneralizedTime
        ));
      }
      if (validity.length > 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
      }
      if (validity.length < 2) {
        throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
      }
      cert2.validity.notBefore = validity[0];
      cert2.validity.notAfter = validity[1];
      cert2.tbsCertificate = capture.tbsCertificate;
      if (computeHash) {
        cert2.md = _createSignatureDigest({
          signatureOid: cert2.signatureOid,
          type: "certificate"
        });
        var bytes = asn1.toDer(cert2.tbsCertificate);
        cert2.md.update(bytes.getBytes());
      }
      var imd = forge.md.sha1.create();
      var ibytes = asn1.toDer(capture.certIssuer);
      imd.update(ibytes.getBytes());
      cert2.issuer.getField = function(sn) {
        return _getAttribute(cert2.issuer, sn);
      };
      cert2.issuer.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.issuer.attributes.push(attr);
      };
      cert2.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer);
      if (capture.certIssuerUniqueId) {
        cert2.issuer.uniqueId = capture.certIssuerUniqueId;
      }
      cert2.issuer.hash = imd.digest().toHex();
      var smd = forge.md.sha1.create();
      var sbytes = asn1.toDer(capture.certSubject);
      smd.update(sbytes.getBytes());
      cert2.subject.getField = function(sn) {
        return _getAttribute(cert2.subject, sn);
      };
      cert2.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        cert2.subject.attributes.push(attr);
      };
      cert2.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject);
      if (capture.certSubjectUniqueId) {
        cert2.subject.uniqueId = capture.certSubjectUniqueId;
      }
      cert2.subject.hash = smd.digest().toHex();
      if (capture.certExtensions) {
        cert2.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
      } else {
        cert2.extensions = [];
      }
      cert2.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      return cert2;
    };
    pki.certificateExtensionsFromAsn1 = function(exts) {
      var rval = [];
      for (var i = 0; i < exts.value.length; ++i) {
        var extseq = exts.value[i];
        for (var ei = 0; ei < extseq.value.length; ++ei) {
          rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
        }
      }
      return rval;
    };
    pki.certificateExtensionFromAsn1 = function(ext) {
      var e = {};
      e.id = asn1.derToOid(ext.value[0].value);
      e.critical = false;
      if (ext.value[1].type === asn1.Type.BOOLEAN) {
        e.critical = ext.value[1].value.charCodeAt(0) !== 0;
        e.value = ext.value[2].value;
      } else {
        e.value = ext.value[1].value;
      }
      if (e.id in oids) {
        e.name = oids[e.id];
        if (e.name === "keyUsage") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          var b3 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
            b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
          }
          e.digitalSignature = (b2 & 128) === 128;
          e.nonRepudiation = (b2 & 64) === 64;
          e.keyEncipherment = (b2 & 32) === 32;
          e.dataEncipherment = (b2 & 16) === 16;
          e.keyAgreement = (b2 & 8) === 8;
          e.keyCertSign = (b2 & 4) === 4;
          e.cRLSign = (b2 & 2) === 2;
          e.encipherOnly = (b2 & 1) === 1;
          e.decipherOnly = (b3 & 128) === 128;
        } else if (e.name === "basicConstraints") {
          var ev = asn1.fromDer(e.value);
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
            e.cA = ev.value[0].value.charCodeAt(0) !== 0;
          } else {
            e.cA = false;
          }
          var value = null;
          if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
            value = ev.value[0].value;
          } else if (ev.value.length > 1) {
            value = ev.value[1].value;
          }
          if (value !== null) {
            e.pathLenConstraint = asn1.derToInteger(value);
          }
        } else if (e.name === "extKeyUsage") {
          var ev = asn1.fromDer(e.value);
          for (var vi2 = 0; vi2 < ev.value.length; ++vi2) {
            var oid = asn1.derToOid(ev.value[vi2].value);
            if (oid in oids) {
              e[oids[oid]] = true;
            } else {
              e[oid] = true;
            }
          }
        } else if (e.name === "nsCertType") {
          var ev = asn1.fromDer(e.value);
          var b2 = 0;
          if (ev.value.length > 1) {
            b2 = ev.value.charCodeAt(1);
          }
          e.client = (b2 & 128) === 128;
          e.server = (b2 & 64) === 64;
          e.email = (b2 & 32) === 32;
          e.objsign = (b2 & 16) === 16;
          e.reserved = (b2 & 8) === 8;
          e.sslCA = (b2 & 4) === 4;
          e.emailCA = (b2 & 2) === 2;
          e.objCA = (b2 & 1) === 1;
        } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
          e.altNames = [];
          var gn2;
          var ev = asn1.fromDer(e.value);
          for (var n = 0; n < ev.value.length; ++n) {
            gn2 = ev.value[n];
            var altName = {
              type: gn2.type,
              value: gn2.value
            };
            e.altNames.push(altName);
            switch (gn2.type) {
              // rfc822Name
              case 1:
              // dNSName
              case 2:
              // uniformResourceIdentifier (URI)
              case 6:
                break;
              // IPAddress
              case 7:
                altName.ip = forge.util.bytesToIP(gn2.value);
                break;
              // registeredID
              case 8:
                altName.oid = asn1.derToOid(gn2.value);
                break;
              default:
            }
          }
        } else if (e.name === "subjectKeyIdentifier") {
          var ev = asn1.fromDer(e.value);
          e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
        }
      }
      return e;
    };
    pki.certificationRequestFromAsn1 = function(obj, computeHash) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
        var error3 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
        error3.errors = errors;
        throw error3;
      }
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        throw new Error("Cannot read public key. OID is not RSA.");
      }
      var csr = pki.createCertificationRequest();
      csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
      csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.signatureParameters = _readSignatureParameters(
        csr.signatureOid,
        capture.csrSignatureParams,
        true
      );
      csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
      csr.siginfo.parameters = _readSignatureParameters(
        csr.siginfo.algorithmOid,
        capture.csrSignatureParams,
        false
      );
      csr.signature = capture.csrSignature;
      csr.certificationRequestInfo = capture.certificationRequestInfo;
      if (computeHash) {
        csr.md = _createSignatureDigest({
          signatureOid: csr.signatureOid,
          type: "certification request"
        });
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
      }
      var smd = forge.md.sha1.create();
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = pki.RDNAttributesAsArray(
        capture.certificationRequestInfoSubject,
        smd
      );
      csr.subject.hash = smd.digest().toHex();
      csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.attributes = pki.CRIAttributesAsArray(
        capture.certificationRequestInfoAttributes || []
      );
      return csr;
    };
    pki.createCertificationRequest = function() {
      var csr = {};
      csr.version = 0;
      csr.signatureOid = null;
      csr.signature = null;
      csr.siginfo = {};
      csr.siginfo.algorithmOid = null;
      csr.subject = {};
      csr.subject.getField = function(sn) {
        return _getAttribute(csr.subject, sn);
      };
      csr.subject.addField = function(attr) {
        _fillMissingFields([attr]);
        csr.subject.attributes.push(attr);
      };
      csr.subject.attributes = [];
      csr.subject.hash = null;
      csr.publicKey = null;
      csr.attributes = [];
      csr.getAttribute = function(sn) {
        return _getAttribute(csr, sn);
      };
      csr.addAttribute = function(attr) {
        _fillMissingFields([attr]);
        csr.attributes.push(attr);
      };
      csr.md = null;
      csr.setSubject = function(attrs) {
        _fillMissingFields(attrs);
        csr.subject.attributes = attrs;
        csr.subject.hash = null;
      };
      csr.setAttributes = function(attrs) {
        _fillMissingFields(attrs);
        csr.attributes = attrs;
      };
      csr.sign = function(key, md) {
        csr.md = md || forge.md.sha1.create();
        var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
        if (!algorithmOid) {
          var error3 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
          error3.algorithm = csr.md.algorithm;
          throw error3;
        }
        csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
        csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(csr.certificationRequestInfo);
        csr.md.update(bytes.getBytes());
        csr.signature = key.sign(csr.md);
      };
      csr.verify = function() {
        var rval = false;
        var md = csr.md;
        if (md === null) {
          md = _createSignatureDigest({
            signatureOid: csr.signatureOid,
            type: "certification request"
          });
          var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
          var bytes = asn1.toDer(cri);
          md.update(bytes.getBytes());
        }
        if (md !== null) {
          rval = _verifySignature({
            certificate: csr,
            md,
            signature: csr.signature
          });
        }
        return rval;
      };
      return csr;
    };
    function _dnToAsn1(obj) {
      var rval = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        []
      );
      var attr, set;
      var attrs = obj.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.PRINTABLESTRING;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
          if (valueTagClass === asn1.Type.UTF8) {
            value = forge.util.encodeUtf8(value);
          }
        }
        set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // AttributeType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(attr.type).getBytes()
            ),
            // AttributeValue
            asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
          ])
        ]);
        rval.value.push(set);
      }
      return rval;
    }
    __name(_dnToAsn1, "_dnToAsn1");
    function _fillMissingFields(attrs) {
      var attr;
      for (var i = 0; i < attrs.length; ++i) {
        attr = attrs[i];
        if (typeof attr.name === "undefined") {
          if (attr.type && attr.type in pki.oids) {
            attr.name = pki.oids[attr.type];
          } else if (attr.shortName && attr.shortName in _shortNames) {
            attr.name = pki.oids[_shortNames[attr.shortName]];
          }
        }
        if (typeof attr.type === "undefined") {
          if (attr.name && attr.name in pki.oids) {
            attr.type = pki.oids[attr.name];
          } else {
            var error3 = new Error("Attribute type not specified.");
            error3.attribute = attr;
            throw error3;
          }
        }
        if (typeof attr.shortName === "undefined") {
          if (attr.name && attr.name in _shortNames) {
            attr.shortName = _shortNames[attr.name];
          }
        }
        if (attr.type === oids.extensionRequest) {
          attr.valueConstructed = true;
          attr.valueTagClass = asn1.Type.SEQUENCE;
          if (!attr.value && attr.extensions) {
            attr.value = [];
            for (var ei = 0; ei < attr.extensions.length; ++ei) {
              attr.value.push(pki.certificateExtensionToAsn1(
                _fillMissingExtensionFields(attr.extensions[ei])
              ));
            }
          }
        }
        if (typeof attr.value === "undefined") {
          var error3 = new Error("Attribute value not specified.");
          error3.attribute = attr;
          throw error3;
        }
      }
    }
    __name(_fillMissingFields, "_fillMissingFields");
    function _fillMissingExtensionFields(e, options) {
      options = options || {};
      if (typeof e.name === "undefined") {
        if (e.id && e.id in pki.oids) {
          e.name = pki.oids[e.id];
        }
      }
      if (typeof e.id === "undefined") {
        if (e.name && e.name in pki.oids) {
          e.id = pki.oids[e.name];
        } else {
          var error3 = new Error("Extension ID not specified.");
          error3.extension = e;
          throw error3;
        }
      }
      if (typeof e.value !== "undefined") {
        return e;
      }
      if (e.name === "keyUsage") {
        var unused = 0;
        var b2 = 0;
        var b3 = 0;
        if (e.digitalSignature) {
          b2 |= 128;
          unused = 7;
        }
        if (e.nonRepudiation) {
          b2 |= 64;
          unused = 6;
        }
        if (e.keyEncipherment) {
          b2 |= 32;
          unused = 5;
        }
        if (e.dataEncipherment) {
          b2 |= 16;
          unused = 4;
        }
        if (e.keyAgreement) {
          b2 |= 8;
          unused = 3;
        }
        if (e.keyCertSign) {
          b2 |= 4;
          unused = 2;
        }
        if (e.cRLSign) {
          b2 |= 2;
          unused = 1;
        }
        if (e.encipherOnly) {
          b2 |= 1;
          unused = 0;
        }
        if (e.decipherOnly) {
          b3 |= 128;
          unused = 7;
        }
        var value = String.fromCharCode(unused);
        if (b3 !== 0) {
          value += String.fromCharCode(b2) + String.fromCharCode(b3);
        } else if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "basicConstraints") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        if (e.cA) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.BOOLEAN,
            false,
            String.fromCharCode(255)
          ));
        }
        if ("pathLenConstraint" in e) {
          e.value.value.push(asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(e.pathLenConstraint).getBytes()
          ));
        }
      } else if (e.name === "extKeyUsage") {
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var seq = e.value.value;
        for (var key in e) {
          if (e[key] !== true) {
            continue;
          }
          if (key in oids) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(oids[key]).getBytes()
            ));
          } else if (key.indexOf(".") !== -1) {
            seq.push(asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(key).getBytes()
            ));
          }
        }
      } else if (e.name === "nsCertType") {
        var unused = 0;
        var b2 = 0;
        if (e.client) {
          b2 |= 128;
          unused = 7;
        }
        if (e.server) {
          b2 |= 64;
          unused = 6;
        }
        if (e.email) {
          b2 |= 32;
          unused = 5;
        }
        if (e.objsign) {
          b2 |= 16;
          unused = 4;
        }
        if (e.reserved) {
          b2 |= 8;
          unused = 3;
        }
        if (e.sslCA) {
          b2 |= 4;
          unused = 2;
        }
        if (e.emailCA) {
          b2 |= 2;
          unused = 1;
        }
        if (e.objCA) {
          b2 |= 1;
          unused = 0;
        }
        var value = String.fromCharCode(unused);
        if (b2 !== 0) {
          value += String.fromCharCode(b2);
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          value
        );
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error3 = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error3.extension = e;
              throw error3;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          e.value.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
      } else if (e.name === "nsComment" && options.cert) {
        if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
          throw new Error('Invalid "nsComment" content.');
        }
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.IA5STRING,
          false,
          e.comment
        );
      } else if (e.name === "subjectKeyIdentifier" && options.cert) {
        var ski = options.cert.generateSubjectKeyIdentifier();
        e.subjectKeyIdentifier = ski.toHex();
        e.value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          ski.getBytes()
        );
      } else if (e.name === "authorityKeyIdentifier" && options.cert) {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        if (e.keyIdentifier) {
          var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
          );
        }
        if (e.authorityCertIssuer) {
          var authorityCertIssuer = [
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
              _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
            ])
          ];
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
          );
        }
        if (e.serialNumber) {
          var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
          seq.push(
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
          );
        }
      } else if (e.name === "cRLDistributionPoints") {
        e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
        var seq = e.value.value;
        var subSeq = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          []
        );
        var fullNameGeneralNames = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var altName;
        for (var n = 0; n < e.altNames.length; ++n) {
          altName = e.altNames[n];
          var value = altName.value;
          if (altName.type === 7 && altName.ip) {
            value = forge.util.bytesFromIP(altName.ip);
            if (value === null) {
              var error3 = new Error(
                'Extension "ip" value is not a valid IPv4 or IPv6 address.'
              );
              error3.extension = e;
              throw error3;
            }
          } else if (altName.type === 8) {
            if (altName.oid) {
              value = asn1.oidToDer(asn1.oidToDer(altName.oid));
            } else {
              value = asn1.oidToDer(value);
            }
          }
          fullNameGeneralNames.value.push(asn1.create(
            asn1.Class.CONTEXT_SPECIFIC,
            altName.type,
            false,
            value
          ));
        }
        subSeq.value.push(asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          [fullNameGeneralNames]
        ));
        seq.push(subSeq);
      }
      if (typeof e.value === "undefined") {
        var error3 = new Error("Extension value not specified.");
        error3.extension = e;
        throw error3;
      }
      return e;
    }
    __name(_fillMissingExtensionFields, "_fillMissingExtensionFields");
    function _signatureParametersToAsn1(oid, params) {
      switch (oid) {
        case oids["RSASSA-PSS"]:
          var parts = [];
          if (params.hash.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.hash.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ]));
          }
          if (params.mgf.algorithmOid !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(params.mgf.algorithmOid).getBytes()
                ),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                  asn1.create(
                    asn1.Class.UNIVERSAL,
                    asn1.Type.OID,
                    false,
                    asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()
                  ),
                  asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
                ])
              ])
            ]));
          }
          if (params.saltLength !== void 0) {
            parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(params.saltLength).getBytes()
              )
            ]));
          }
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
        default:
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
      }
    }
    __name(_signatureParametersToAsn1, "_signatureParametersToAsn1");
    function _CRIAttributesToAsn1(csr) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      if (csr.attributes.length === 0) {
        return rval;
      }
      var attrs = csr.attributes;
      for (var i = 0; i < attrs.length; ++i) {
        var attr = attrs[i];
        var value = attr.value;
        var valueTagClass = asn1.Type.UTF8;
        if ("valueTagClass" in attr) {
          valueTagClass = attr.valueTagClass;
        }
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
        var valueConstructed = false;
        if ("valueConstructed" in attr) {
          valueConstructed = attr.valueConstructed;
        }
        var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // AttributeType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(attr.type).getBytes()
          ),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
            // AttributeValue
            asn1.create(
              asn1.Class.UNIVERSAL,
              valueTagClass,
              valueConstructed,
              value
            )
          ])
        ]);
        rval.value.push(seq);
      }
      return rval;
    }
    __name(_CRIAttributesToAsn1, "_CRIAttributesToAsn1");
    var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    function _dateToAsn1(date) {
      if (date >= jan_1_1950 && date < jan_1_2050) {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.UTCTIME,
          false,
          asn1.dateToUtcTime(date)
        );
      } else {
        return asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.GENERALIZEDTIME,
          false,
          asn1.dateToGeneralizedTime(date)
        );
      }
    }
    __name(_dateToAsn1, "_dateToAsn1");
    pki.getTBSCertificate = function(cert2) {
      var notBefore = _dateToAsn1(cert2.validity.notBefore);
      var notAfter = _dateToAsn1(cert2.validity.notAfter);
      var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          // integer
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(cert2.version).getBytes()
          )
        ]),
        // serialNumber
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          forge.util.hexToBytes(cert2.serialNumber)
        ),
        // signature
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert2.siginfo.algorithmOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(
            cert2.siginfo.algorithmOid,
            cert2.siginfo.parameters
          )
        ]),
        // issuer
        _dnToAsn1(cert2.issuer),
        // validity
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          notBefore,
          notAfter
        ]),
        // subject
        _dnToAsn1(cert2.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(cert2.publicKey)
      ]);
      if (cert2.issuer.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert2.issuer.uniqueId
            )
          ])
        );
      }
      if (cert2.subject.uniqueId) {
        tbs.value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.BITSTRING,
              false,
              // TODO: support arbitrary bit length ids
              String.fromCharCode(0) + cert2.subject.uniqueId
            )
          ])
        );
      }
      if (cert2.extensions.length > 0) {
        tbs.value.push(pki.certificateExtensionsToAsn1(cert2.extensions));
      }
      return tbs;
    };
    pki.getCertificationRequestInfo = function(csr) {
      var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(csr.version).getBytes()
        ),
        // subject
        _dnToAsn1(csr.subject),
        // SubjectPublicKeyInfo
        pki.publicKeyToAsn1(csr.publicKey),
        // attributes
        _CRIAttributesToAsn1(csr)
      ]);
      return cri;
    };
    pki.distinguishedNameToAsn1 = function(dn) {
      return _dnToAsn1(dn);
    };
    pki.certificateToAsn1 = function(cert2) {
      var tbsCertificate = cert2.tbsCertificate || pki.getTBSCertificate(cert2);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // TBSCertificate
        tbsCertificate,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(cert2.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(cert2.signatureOid, cert2.signatureParameters)
        ]),
        // SignatureValue
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + cert2.signature
        )
      ]);
    };
    pki.certificateExtensionsToAsn1 = function(exts) {
      var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      rval.value.push(seq);
      for (var i = 0; i < exts.length; ++i) {
        seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
      }
      return rval;
    };
    pki.certificateExtensionToAsn1 = function(ext) {
      var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ext.id).getBytes()
      ));
      if (ext.critical) {
        extseq.value.push(asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BOOLEAN,
          false,
          String.fromCharCode(255)
        ));
      }
      var value = ext.value;
      if (typeof ext.value !== "string") {
        value = asn1.toDer(value).getBytes();
      }
      extseq.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        value
      ));
      return extseq;
    };
    pki.certificationRequestToAsn1 = function(csr) {
      var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // CertificationRequestInfo
        cri,
        // AlgorithmIdentifier (signature algorithm)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(csr.signatureOid).getBytes()
          ),
          // parameters
          _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
        ]),
        // signature
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.BITSTRING,
          false,
          String.fromCharCode(0) + csr.signature
        )
      ]);
    };
    pki.createCaStore = function(certs) {
      var caStore = {
        // stored certificates
        certs: {}
      };
      caStore.getIssuer = function(cert3) {
        var rval = getBySubject(cert3.issuer);
        return rval;
      };
      caStore.addCertificate = function(cert3) {
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        ensureSubjectHasHash(cert3.subject);
        if (!caStore.hasCertificate(cert3)) {
          if (cert3.subject.hash in caStore.certs) {
            var tmp = caStore.certs[cert3.subject.hash];
            if (!forge.util.isArray(tmp)) {
              tmp = [tmp];
            }
            tmp.push(cert3);
            caStore.certs[cert3.subject.hash] = tmp;
          } else {
            caStore.certs[cert3.subject.hash] = cert3;
          }
        }
      };
      caStore.hasCertificate = function(cert3) {
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        var match = getBySubject(cert3.subject);
        if (!match) {
          return false;
        }
        if (!forge.util.isArray(match)) {
          match = [match];
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert3)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            return true;
          }
        }
        return false;
      };
      caStore.listAllCertificates = function() {
        var certList = [];
        for (var hash2 in caStore.certs) {
          if (caStore.certs.hasOwnProperty(hash2)) {
            var value = caStore.certs[hash2];
            if (!forge.util.isArray(value)) {
              certList.push(value);
            } else {
              for (var i2 = 0; i2 < value.length; ++i2) {
                certList.push(value[i2]);
              }
            }
          }
        }
        return certList;
      };
      caStore.removeCertificate = function(cert3) {
        var result;
        if (typeof cert3 === "string") {
          cert3 = forge.pki.certificateFromPem(cert3);
        }
        ensureSubjectHasHash(cert3.subject);
        if (!caStore.hasCertificate(cert3)) {
          return null;
        }
        var match = getBySubject(cert3.subject);
        if (!forge.util.isArray(match)) {
          result = caStore.certs[cert3.subject.hash];
          delete caStore.certs[cert3.subject.hash];
          return result;
        }
        var der1 = asn1.toDer(pki.certificateToAsn1(cert3)).getBytes();
        for (var i2 = 0; i2 < match.length; ++i2) {
          var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
          if (der1 === der2) {
            result = match[i2];
            match.splice(i2, 1);
          }
        }
        if (match.length === 0) {
          delete caStore.certs[cert3.subject.hash];
        }
        return result;
      };
      function getBySubject(subject) {
        ensureSubjectHasHash(subject);
        return caStore.certs[subject.hash] || null;
      }
      __name(getBySubject, "getBySubject");
      function ensureSubjectHasHash(subject) {
        if (!subject.hash) {
          var md = forge.md.sha1.create();
          subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
          subject.hash = md.digest().toHex();
        }
      }
      __name(ensureSubjectHasHash, "ensureSubjectHasHash");
      if (certs) {
        for (var i = 0; i < certs.length; ++i) {
          var cert2 = certs[i];
          caStore.addCertificate(cert2);
        }
      }
      return caStore;
    };
    pki.certificateError = {
      bad_certificate: "forge.pki.BadCertificate",
      unsupported_certificate: "forge.pki.UnsupportedCertificate",
      certificate_revoked: "forge.pki.CertificateRevoked",
      certificate_expired: "forge.pki.CertificateExpired",
      certificate_unknown: "forge.pki.CertificateUnknown",
      unknown_ca: "forge.pki.UnknownCertificateAuthority"
    };
    pki.verifyCertificateChain = function(caStore, chain, options) {
      if (typeof options === "function") {
        options = { verify: options };
      }
      options = options || {};
      chain = chain.slice(0);
      var certs = chain.slice(0);
      var validityCheckDate = options.validityCheckDate;
      if (typeof validityCheckDate === "undefined") {
        validityCheckDate = /* @__PURE__ */ new Date();
      }
      var first = true;
      var error3 = null;
      var depth = 0;
      do {
        var cert2 = chain.shift();
        var parent = null;
        var selfSigned = false;
        if (validityCheckDate) {
          if (validityCheckDate < cert2.validity.notBefore || validityCheckDate > cert2.validity.notAfter) {
            error3 = {
              message: "Certificate is not valid yet or has expired.",
              error: pki.certificateError.certificate_expired,
              notBefore: cert2.validity.notBefore,
              notAfter: cert2.validity.notAfter,
              // TODO: we might want to reconsider renaming 'now' to
              // 'validityCheckDate' should this API be changed in the future.
              now: validityCheckDate
            };
          }
        }
        if (error3 === null) {
          parent = chain[0] || caStore.getIssuer(cert2);
          if (parent === null) {
            if (cert2.isIssuer(cert2)) {
              selfSigned = true;
              parent = cert2;
            }
          }
          if (parent) {
            var parents = parent;
            if (!forge.util.isArray(parents)) {
              parents = [parents];
            }
            var verified = false;
            while (!verified && parents.length > 0) {
              parent = parents.shift();
              try {
                verified = parent.verify(cert2);
              } catch (ex) {
              }
            }
            if (!verified) {
              error3 = {
                message: "Certificate signature is invalid.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error3 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert2)) {
            error3 = {
              message: "Certificate is not trusted.",
              error: pki.certificateError.unknown_ca
            };
          }
        }
        if (error3 === null && parent && !cert2.isIssuer(parent)) {
          error3 = {
            message: "Certificate issuer is invalid.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error3 === null) {
          var se = {
            keyUsage: true,
            basicConstraints: true
          };
          for (var i = 0; error3 === null && i < cert2.extensions.length; ++i) {
            var ext = cert2.extensions[i];
            if (ext.critical && !(ext.name in se)) {
              error3 = {
                message: "Certificate has an unsupported critical extension.",
                error: pki.certificateError.unsupported_certificate
              };
            }
          }
        }
        if (error3 === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
          var bcExt = cert2.getExtension("basicConstraints");
          var keyUsageExt = cert2.getExtension("keyUsage");
          if (keyUsageExt !== null) {
            if (!keyUsageExt.keyCertSign || bcExt === null) {
              error3 = {
                message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
          if (error3 === null && bcExt !== null && !bcExt.cA) {
            error3 = {
              message: "Certificate basicConstraints indicates the certificate is not a CA.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (error3 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
            var pathLen = depth - 1;
            if (pathLen > bcExt.pathLenConstraint) {
              error3 = {
                message: "Certificate basicConstraints pathLenConstraint violated.",
                error: pki.certificateError.bad_certificate
              };
            }
          }
        }
        var vfd = error3 === null ? true : error3.error;
        var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
        if (ret === true) {
          error3 = null;
        } else {
          if (vfd === true) {
            error3 = {
              message: "The application rejected the certificate.",
              error: pki.certificateError.bad_certificate
            };
          }
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error3.message = ret.message;
              }
              if (ret.error) {
                error3.error = ret.error;
              }
            } else if (typeof ret === "string") {
              error3.error = ret;
            }
          }
          throw error3;
        }
        first = false;
        ++depth;
      } while (chain.length > 0);
      return true;
    };
  }
});

// node_modules/node-forge/lib/pkcs12.js
var require_pkcs12 = __commonJS({
  "node_modules/node-forge/lib/pkcs12.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_oids();
    require_pkcs7asn1();
    require_pbe();
    require_random();
    require_rsa();
    require_sha12();
    require_util4();
    require_x509();
    var asn1 = forge.asn1;
    var pki = forge.pki;
    var p12 = module.exports = forge.pkcs12 = forge.pkcs12 || {};
    var contentInfoValidator = {
      name: "ContentInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      // a ContentInfo
      constructed: true,
      value: [{
        name: "ContentInfo.contentType",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "contentType"
      }, {
        name: "ContentInfo.content",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "content"
      }]
    };
    var pfxValidator = {
      name: "PFX",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [
        {
          name: "PFX.version",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "version"
        },
        contentInfoValidator,
        {
          name: "PFX.macData",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          captureAsn1: "mac",
          value: [{
            name: "PFX.macData.mac",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            // DigestInfo
            constructed: true,
            value: [{
              name: "PFX.macData.mac.digestAlgorithm",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.SEQUENCE,
              // DigestAlgorithmIdentifier
              constructed: true,
              value: [{
                name: "PFX.macData.mac.digestAlgorithm.algorithm",
                tagClass: asn1.Class.UNIVERSAL,
                type: asn1.Type.OID,
                constructed: false,
                capture: "macAlgorithm"
              }, {
                name: "PFX.macData.mac.digestAlgorithm.parameters",
                tagClass: asn1.Class.UNIVERSAL,
                captureAsn1: "macAlgorithmParameters"
              }]
            }, {
              name: "PFX.macData.mac.digest",
              tagClass: asn1.Class.UNIVERSAL,
              type: asn1.Type.OCTETSTRING,
              constructed: false,
              capture: "macDigest"
            }]
          }, {
            name: "PFX.macData.macSalt",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OCTETSTRING,
            constructed: false,
            capture: "macSalt"
          }, {
            name: "PFX.macData.iterations",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            optional: true,
            capture: "macIterations"
          }]
        }
      ]
    };
    var safeBagValidator = {
      name: "SafeBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SafeBag.bagId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "bagId"
      }, {
        name: "SafeBag.bagValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        captureAsn1: "bagValue"
      }, {
        name: "SafeBag.bagAttributes",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        optional: true,
        capture: "bagAttributes"
      }]
    };
    var attributeValidator = {
      name: "Attribute",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Attribute.attrId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "oid"
      }, {
        name: "Attribute.attrValues",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        capture: "values"
      }]
    };
    var certBagValidator = {
      name: "CertBag",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "CertBag.certId",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certId"
      }, {
        name: "CertBag.certValue",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        constructed: true,
        /* So far we only support X.509 certificates (which are wrapped in
           an OCTET STRING, hence hard code that here). */
        value: [{
          name: "CertBag.certValue[0]",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Class.OCTETSTRING,
          constructed: false,
          capture: "cert"
        }]
      }]
    };
    function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
      var result = [];
      for (var i = 0; i < safeContents.length; i++) {
        for (var j = 0; j < safeContents[i].safeBags.length; j++) {
          var bag = safeContents[i].safeBags[j];
          if (bagType !== void 0 && bag.type !== bagType) {
            continue;
          }
          if (attrName === null) {
            result.push(bag);
            continue;
          }
          if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
            result.push(bag);
          }
        }
      }
      return result;
    }
    __name(_getBagsByAttribute, "_getBagsByAttribute");
    p12.pkcs12FromAsn1 = function(obj, strict, password) {
      if (typeof strict === "string") {
        password = strict;
        strict = true;
      } else if (strict === void 0) {
        strict = true;
      }
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, pfxValidator, capture, errors)) {
        var error3 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
        error3.errors = error3;
        throw error3;
      }
      var pfx = {
        version: capture.version.charCodeAt(0),
        safeContents: [],
        /**
         * Gets bags with matching attributes.
         *
         * @param filter the attributes to filter by:
         *          [localKeyId] the localKeyId to search for.
         *          [localKeyIdHex] the localKeyId in hex to search for.
         *          [friendlyName] the friendly name to search for.
         *          [bagType] bag type to narrow each attribute search by.
         *
         * @return a map of attribute type to an array of matching bags or, if no
         *           attribute was given but a bag type, the map key will be the
         *           bag type.
         */
        getBags: /* @__PURE__ */ __name(function(filter) {
          var rval = {};
          var localKeyId;
          if ("localKeyId" in filter) {
            localKeyId = filter.localKeyId;
          } else if ("localKeyIdHex" in filter) {
            localKeyId = forge.util.hexToBytes(filter.localKeyIdHex);
          }
          if (localKeyId === void 0 && !("friendlyName" in filter) && "bagType" in filter) {
            rval[filter.bagType] = _getBagsByAttribute(
              pfx.safeContents,
              null,
              null,
              filter.bagType
            );
          }
          if (localKeyId !== void 0) {
            rval.localKeyId = _getBagsByAttribute(
              pfx.safeContents,
              "localKeyId",
              localKeyId,
              filter.bagType
            );
          }
          if ("friendlyName" in filter) {
            rval.friendlyName = _getBagsByAttribute(
              pfx.safeContents,
              "friendlyName",
              filter.friendlyName,
              filter.bagType
            );
          }
          return rval;
        }, "getBags"),
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching friendlyName attribute.
         *
         * @param friendlyName the friendly name to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching friendlyName attribute.
         */
        getBagsByFriendlyName: /* @__PURE__ */ __name(function(friendlyName, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "friendlyName",
            friendlyName,
            bagType
          );
        }, "getBagsByFriendlyName"),
        /**
         * DEPRECATED: use getBags() instead.
         *
         * Get bags with matching localKeyId attribute.
         *
         * @param localKeyId the localKeyId to search for.
         * @param [bagType] bag type to narrow search by.
         *
         * @return an array of bags with matching localKeyId attribute.
         */
        getBagsByLocalKeyId: /* @__PURE__ */ __name(function(localKeyId, bagType) {
          return _getBagsByAttribute(
            pfx.safeContents,
            "localKeyId",
            localKeyId,
            bagType
          );
        }, "getBagsByLocalKeyId")
      };
      if (capture.version.charCodeAt(0) !== 3) {
        var error3 = new Error("PKCS#12 PFX of version other than 3 not supported.");
        error3.version = capture.version.charCodeAt(0);
        throw error3;
      }
      if (asn1.derToOid(capture.contentType) !== pki.oids.data) {
        var error3 = new Error("Only PKCS#12 PFX in password integrity mode supported.");
        error3.oid = asn1.derToOid(capture.contentType);
        throw error3;
      }
      var data = capture.content.value[0];
      if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
        throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
      }
      data = _decodePkcs7Data(data);
      if (capture.mac) {
        var md = null;
        var macKeyBytes = 0;
        var macAlgorithm = asn1.derToOid(capture.macAlgorithm);
        switch (macAlgorithm) {
          case pki.oids.sha1:
            md = forge.md.sha1.create();
            macKeyBytes = 20;
            break;
          case pki.oids.sha256:
            md = forge.md.sha256.create();
            macKeyBytes = 32;
            break;
          case pki.oids.sha384:
            md = forge.md.sha384.create();
            macKeyBytes = 48;
            break;
          case pki.oids.sha512:
            md = forge.md.sha512.create();
            macKeyBytes = 64;
            break;
          case pki.oids.md5:
            md = forge.md.md5.create();
            macKeyBytes = 16;
            break;
        }
        if (md === null) {
          throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
        }
        var macSalt = new forge.util.ByteBuffer(capture.macSalt);
        var macIterations = "macIterations" in capture ? parseInt(forge.util.bytesToHex(capture.macIterations), 16) : 1;
        var macKey = p12.generateKey(
          password,
          macSalt,
          3,
          macIterations,
          macKeyBytes,
          md
        );
        var mac = forge.hmac.create();
        mac.start(md, macKey);
        mac.update(data.value);
        var macValue = mac.getMac();
        if (macValue.getBytes() !== capture.macDigest) {
          throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
        }
      }
      _decodeAuthenticatedSafe(pfx, data.value, strict, password);
      return pfx;
    };
    function _decodePkcs7Data(data) {
      if (data.composed || data.constructed) {
        var value = forge.util.createBuffer();
        for (var i = 0; i < data.value.length; ++i) {
          value.putBytes(data.value[i].value);
        }
        data.composed = data.constructed = false;
        data.value = value.getBytes();
      }
      return data;
    }
    __name(_decodePkcs7Data, "_decodePkcs7Data");
    function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
      authSafe = asn1.fromDer(authSafe, strict);
      if (authSafe.tagClass !== asn1.Class.UNIVERSAL || authSafe.type !== asn1.Type.SEQUENCE || authSafe.constructed !== true) {
        throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
      }
      for (var i = 0; i < authSafe.value.length; i++) {
        var contentInfo = authSafe.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(contentInfo, contentInfoValidator, capture, errors)) {
          var error3 = new Error("Cannot read ContentInfo.");
          error3.errors = errors;
          throw error3;
        }
        var obj = {
          encrypted: false
        };
        var safeContents = null;
        var data = capture.content.value[0];
        switch (asn1.derToOid(capture.contentType)) {
          case pki.oids.data:
            if (data.tagClass !== asn1.Class.UNIVERSAL || data.type !== asn1.Type.OCTETSTRING) {
              throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
            }
            safeContents = _decodePkcs7Data(data).value;
            break;
          case pki.oids.encryptedData:
            safeContents = _decryptSafeContents(data, password);
            obj.encrypted = true;
            break;
          default:
            var error3 = new Error("Unsupported PKCS#12 contentType.");
            error3.contentType = asn1.derToOid(capture.contentType);
            throw error3;
        }
        obj.safeBags = _decodeSafeContents(safeContents, strict, password);
        pfx.safeContents.push(obj);
      }
    }
    __name(_decodeAuthenticatedSafe, "_decodeAuthenticatedSafe");
    function _decryptSafeContents(data, password) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(
        data,
        forge.pkcs7.asn1.encryptedDataValidator,
        capture,
        errors
      )) {
        var error3 = new Error("Cannot read EncryptedContentInfo.");
        error3.errors = errors;
        throw error3;
      }
      var oid = asn1.derToOid(capture.contentType);
      if (oid !== pki.oids.data) {
        var error3 = new Error(
          "PKCS#12 EncryptedContentInfo ContentType is not Data."
        );
        error3.oid = oid;
        throw error3;
      }
      oid = asn1.derToOid(capture.encAlgorithm);
      var cipher = pki.pbe.getCipher(oid, capture.encParameter, password);
      var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
      var encrypted = forge.util.createBuffer(encryptedContentAsn1.value);
      cipher.update(encrypted);
      if (!cipher.finish()) {
        throw new Error("Failed to decrypt PKCS#12 SafeContents.");
      }
      return cipher.output.getBytes();
    }
    __name(_decryptSafeContents, "_decryptSafeContents");
    function _decodeSafeContents(safeContents, strict, password) {
      if (!strict && safeContents.length === 0) {
        return [];
      }
      safeContents = asn1.fromDer(safeContents, strict);
      if (safeContents.tagClass !== asn1.Class.UNIVERSAL || safeContents.type !== asn1.Type.SEQUENCE || safeContents.constructed !== true) {
        throw new Error(
          "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
        );
      }
      var res = [];
      for (var i = 0; i < safeContents.value.length; i++) {
        var safeBag = safeContents.value[i];
        var capture = {};
        var errors = [];
        if (!asn1.validate(safeBag, safeBagValidator, capture, errors)) {
          var error3 = new Error("Cannot read SafeBag.");
          error3.errors = errors;
          throw error3;
        }
        var bag = {
          type: asn1.derToOid(capture.bagId),
          attributes: _decodeBagAttributes(capture.bagAttributes)
        };
        res.push(bag);
        var validator, decoder2;
        var bagAsn1 = capture.bagValue.value[0];
        switch (bag.type) {
          case pki.oids.pkcs8ShroudedKeyBag:
            bagAsn1 = pki.decryptPrivateKeyInfo(bagAsn1, password);
            if (bagAsn1 === null) {
              throw new Error(
                "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
              );
            }
          /* fall through */
          case pki.oids.keyBag:
            try {
              bag.key = pki.privateKeyFromAsn1(bagAsn1);
            } catch (e) {
              bag.key = null;
              bag.asn1 = bagAsn1;
            }
            continue;
          /* Nothing more to do. */
          case pki.oids.certBag:
            validator = certBagValidator;
            decoder2 = /* @__PURE__ */ __name(function() {
              if (asn1.derToOid(capture.certId) !== pki.oids.x509Certificate) {
                var error4 = new Error(
                  "Unsupported certificate type, only X.509 supported."
                );
                error4.oid = asn1.derToOid(capture.certId);
                throw error4;
              }
              var certAsn1 = asn1.fromDer(capture.cert, strict);
              try {
                bag.cert = pki.certificateFromAsn1(certAsn1, true);
              } catch (e) {
                bag.cert = null;
                bag.asn1 = certAsn1;
              }
            }, "decoder");
            break;
          default:
            var error3 = new Error("Unsupported PKCS#12 SafeBag type.");
            error3.oid = bag.type;
            throw error3;
        }
        if (validator !== void 0 && !asn1.validate(bagAsn1, validator, capture, errors)) {
          var error3 = new Error("Cannot read PKCS#12 " + validator.name);
          error3.errors = errors;
          throw error3;
        }
        decoder2();
      }
      return res;
    }
    __name(_decodeSafeContents, "_decodeSafeContents");
    function _decodeBagAttributes(attributes) {
      var decodedAttrs = {};
      if (attributes !== void 0) {
        for (var i = 0; i < attributes.length; ++i) {
          var capture = {};
          var errors = [];
          if (!asn1.validate(attributes[i], attributeValidator, capture, errors)) {
            var error3 = new Error("Cannot read PKCS#12 BagAttribute.");
            error3.errors = errors;
            throw error3;
          }
          var oid = asn1.derToOid(capture.oid);
          if (pki.oids[oid] === void 0) {
            continue;
          }
          decodedAttrs[pki.oids[oid]] = [];
          for (var j = 0; j < capture.values.length; ++j) {
            decodedAttrs[pki.oids[oid]].push(capture.values[j].value);
          }
        }
      }
      return decodedAttrs;
    }
    __name(_decodeBagAttributes, "_decodeBagAttributes");
    p12.toPkcs12Asn1 = function(key, cert2, password, options) {
      options = options || {};
      options.saltSize = options.saltSize || 8;
      options.count = options.count || 2048;
      options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
      if (!("useMac" in options)) {
        options.useMac = true;
      }
      if (!("localKeyId" in options)) {
        options.localKeyId = null;
      }
      if (!("generateLocalKeyId" in options)) {
        options.generateLocalKeyId = true;
      }
      var localKeyId = options.localKeyId;
      var bagAttrs;
      if (localKeyId !== null) {
        localKeyId = forge.util.hexToBytes(localKeyId);
      } else if (options.generateLocalKeyId) {
        if (cert2) {
          var pairedCert = forge.util.isArray(cert2) ? cert2[0] : cert2;
          if (typeof pairedCert === "string") {
            pairedCert = pki.certificateFromPem(pairedCert);
          }
          var sha1 = forge.md.sha1.create();
          sha1.update(asn1.toDer(pki.certificateToAsn1(pairedCert)).getBytes());
          localKeyId = sha1.digest().getBytes();
        } else {
          localKeyId = forge.random.getBytes(20);
        }
      }
      var attrs = [];
      if (localKeyId !== null) {
        attrs.push(
          // localKeyID
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.localKeyId).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                localKeyId
              )
            ])
          ])
        );
      }
      if ("friendlyName" in options) {
        attrs.push(
          // friendlyName
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // attrId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.friendlyName).getBytes()
            ),
            // attrValues
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.BMPSTRING,
                false,
                options.friendlyName
              )
            ])
          ])
        );
      }
      if (attrs.length > 0) {
        bagAttrs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, attrs);
      }
      var contents = [];
      var chain = [];
      if (cert2 !== null) {
        if (forge.util.isArray(cert2)) {
          chain = cert2;
        } else {
          chain = [cert2];
        }
      }
      var certSafeBags = [];
      for (var i = 0; i < chain.length; ++i) {
        cert2 = chain[i];
        if (typeof cert2 === "string") {
          cert2 = pki.certificateFromPem(cert2);
        }
        var certBagAttrs = i === 0 ? bagAttrs : void 0;
        var certAsn1 = pki.certificateToAsn1(cert2);
        var certSafeBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // bagId
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(pki.oids.certBag).getBytes()
          ),
          // bagValue
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            // CertBag
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // certId
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.x509Certificate).getBytes()
              ),
              // certValue (x509Certificate)
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  asn1.toDer(certAsn1).getBytes()
                )
              ])
            ])
          ]),
          // bagAttributes (OPTIONAL)
          certBagAttrs
        ]);
        certSafeBags.push(certSafeBag);
      }
      if (certSafeBags.length > 0) {
        var certSafeContents = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          certSafeBags
        );
        var certCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(certSafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(certCI);
      }
      var keyBag = null;
      if (key !== null) {
        var pkAsn1 = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(key));
        if (password === null) {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.keyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // PrivateKeyInfo
              pkAsn1
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        } else {
          keyBag = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // bagId
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(pki.oids.pkcs8ShroudedKeyBag).getBytes()
            ),
            // bagValue
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              // EncryptedPrivateKeyInfo
              pki.encryptPrivateKeyInfo(pkAsn1, password, options)
            ]),
            // bagAttributes (OPTIONAL)
            bagAttrs
          ]);
        }
        var keySafeContents = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [keyBag]);
        var keyCI = (
          // PKCS#7 ContentInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // contentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              // OID for the content type is 'data'
              asn1.oidToDer(pki.oids.data).getBytes()
            ),
            // content
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OCTETSTRING,
                false,
                asn1.toDer(keySafeContents).getBytes()
              )
            ])
          ])
        );
        contents.push(keyCI);
      }
      var safe = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        contents
      );
      var macData;
      if (options.useMac) {
        var sha1 = forge.md.sha1.create();
        var macSalt = new forge.util.ByteBuffer(
          forge.random.getBytes(options.saltSize)
        );
        var count3 = options.count;
        var key = p12.generateKey(password, macSalt, 3, count3, 20);
        var mac = forge.hmac.create();
        mac.start(sha1, key);
        mac.update(asn1.toDer(safe).getBytes());
        var macValue = mac.getMac();
        macData = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // mac DigestInfo
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // digestAlgorithm
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm = SHA-1
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(pki.oids.sha1).getBytes()
              ),
              // parameters = Null
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ]),
            // digest
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              macValue.getBytes()
            )
          ]),
          // macSalt OCTET STRING
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            macSalt.getBytes()
          ),
          // iterations INTEGER (XXX: Only support count < 65536)
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(count3).getBytes()
          )
        ]);
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version (3)
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(3).getBytes()
        ),
        // PKCS#7 ContentInfo
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // contentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            // OID for the content type is 'data'
            asn1.oidToDer(pki.oids.data).getBytes()
          ),
          // content
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OCTETSTRING,
              false,
              asn1.toDer(safe).getBytes()
            )
          ])
        ]),
        macData
      ]);
    };
    p12.generateKey = forge.pbe.generatePkcs12Key;
  }
});

// node_modules/node-forge/lib/pki.js
var require_pki = __commonJS({
  "node_modules/node-forge/lib/pki.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    require_oids();
    require_pbe();
    require_pem();
    require_pbkdf2();
    require_pkcs12();
    require_pss();
    require_rsa();
    require_util4();
    require_x509();
    var asn1 = forge.asn1;
    var pki = module.exports = forge.pki = forge.pki || {};
    pki.pemToDer = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PEM to DER; PEM is encrypted.");
      }
      return forge.util.createBuffer(msg.body);
    };
    pki.privateKeyFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
        var error3 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert private key from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return pki.privateKeyFromAsn1(obj);
    };
    pki.privateKeyToPem = function(key, maxline) {
      var msg = {
        type: "RSA PRIVATE KEY",
        body: asn1.toDer(pki.privateKeyToAsn1(key)).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
    pki.privateKeyInfoToPem = function(pki2, maxline) {
      var msg = {
        type: "PRIVATE KEY",
        body: asn1.toDer(pki2).getBytes()
      };
      return forge.pem.encode(msg, { maxline });
    };
  }
});

// node_modules/node-forge/lib/tls.js
var require_tls2 = __commonJS({
  "node_modules/node-forge/lib/tls.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    require_hmac();
    require_md52();
    require_pem();
    require_pki();
    require_random();
    require_sha12();
    require_util4();
    var prf_TLS1 = /* @__PURE__ */ __name(function(secret, label, seed, length) {
      var rval = forge.util.createBuffer();
      var idx = secret.length >> 1;
      var slen = idx + (secret.length & 1);
      var s1 = secret.substr(0, slen);
      var s2 = secret.substr(idx, slen);
      var ai = forge.util.createBuffer();
      var hmac = forge.hmac.create();
      seed = label + seed;
      var md5itr = Math.ceil(length / 16);
      var sha1itr = Math.ceil(length / 20);
      hmac.start("MD5", s1);
      var md5bytes = forge.util.createBuffer();
      ai.putBytes(seed);
      for (var i = 0; i < md5itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        md5bytes.putBuffer(hmac.digest());
      }
      hmac.start("SHA1", s2);
      var sha1bytes = forge.util.createBuffer();
      ai.clear();
      ai.putBytes(seed);
      for (var i = 0; i < sha1itr; ++i) {
        hmac.start(null, null);
        hmac.update(ai.getBytes());
        ai.putBuffer(hmac.digest());
        hmac.start(null, null);
        hmac.update(ai.bytes() + seed);
        sha1bytes.putBuffer(hmac.digest());
      }
      rval.putBytes(forge.util.xorBytes(
        md5bytes.getBytes(),
        sha1bytes.getBytes(),
        length
      ));
      return rval;
    }, "prf_TLS1");
    var hmac_sha1 = /* @__PURE__ */ __name(function(key2, seqNum, record) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key2);
      var b2 = forge.util.createBuffer();
      b2.putInt32(seqNum[0]);
      b2.putInt32(seqNum[1]);
      b2.putByte(record.type);
      b2.putByte(record.version.major);
      b2.putByte(record.version.minor);
      b2.putInt16(record.length);
      b2.putBytes(record.fragment.bytes());
      hmac.update(b2.getBytes());
      return hmac.digest().getBytes();
    }, "hmac_sha1");
    var deflate2 = /* @__PURE__ */ __name(function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.deflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    }, "deflate");
    var inflate2 = /* @__PURE__ */ __name(function(c, record, s) {
      var rval = false;
      try {
        var bytes = c.inflate(record.fragment.getBytes());
        record.fragment = forge.util.createBuffer(bytes);
        record.length = bytes.length;
        rval = true;
      } catch (ex) {
      }
      return rval;
    }, "inflate");
    var readVector = /* @__PURE__ */ __name(function(b2, lenBytes) {
      var len = 0;
      switch (lenBytes) {
        case 1:
          len = b2.getByte();
          break;
        case 2:
          len = b2.getInt16();
          break;
        case 3:
          len = b2.getInt24();
          break;
        case 4:
          len = b2.getInt32();
          break;
      }
      return forge.util.createBuffer(b2.getBytes(len));
    }, "readVector");
    var writeVector = /* @__PURE__ */ __name(function(b2, lenBytes, v2) {
      b2.putInt(v2.length(), lenBytes << 3);
      b2.putBuffer(v2);
    }, "writeVector");
    var tls = {};
    tls.Versions = {
      TLS_1_0: { major: 3, minor: 1 },
      TLS_1_1: { major: 3, minor: 2 },
      TLS_1_2: { major: 3, minor: 3 }
    };
    tls.SupportedVersions = [
      tls.Versions.TLS_1_1,
      tls.Versions.TLS_1_0
    ];
    tls.Version = tls.SupportedVersions[0];
    tls.MaxFragment = 16384 - 1024;
    tls.ConnectionEnd = {
      server: 0,
      client: 1
    };
    tls.PRFAlgorithm = {
      tls_prf_sha256: 0
    };
    tls.BulkCipherAlgorithm = {
      none: null,
      rc4: 0,
      des3: 1,
      aes: 2
    };
    tls.CipherType = {
      stream: 0,
      block: 1,
      aead: 2
    };
    tls.MACAlgorithm = {
      none: null,
      hmac_md5: 0,
      hmac_sha1: 1,
      hmac_sha256: 2,
      hmac_sha384: 3,
      hmac_sha512: 4
    };
    tls.CompressionMethod = {
      none: 0,
      deflate: 1
    };
    tls.ContentType = {
      change_cipher_spec: 20,
      alert: 21,
      handshake: 22,
      application_data: 23,
      heartbeat: 24
    };
    tls.HandshakeType = {
      hello_request: 0,
      client_hello: 1,
      server_hello: 2,
      certificate: 11,
      server_key_exchange: 12,
      certificate_request: 13,
      server_hello_done: 14,
      certificate_verify: 15,
      client_key_exchange: 16,
      finished: 20
    };
    tls.Alert = {};
    tls.Alert.Level = {
      warning: 1,
      fatal: 2
    };
    tls.Alert.Description = {
      close_notify: 0,
      unexpected_message: 10,
      bad_record_mac: 20,
      decryption_failed: 21,
      record_overflow: 22,
      decompression_failure: 30,
      handshake_failure: 40,
      bad_certificate: 42,
      unsupported_certificate: 43,
      certificate_revoked: 44,
      certificate_expired: 45,
      certificate_unknown: 46,
      illegal_parameter: 47,
      unknown_ca: 48,
      access_denied: 49,
      decode_error: 50,
      decrypt_error: 51,
      export_restriction: 60,
      protocol_version: 70,
      insufficient_security: 71,
      internal_error: 80,
      user_canceled: 90,
      no_renegotiation: 100
    };
    tls.HeartbeatMessageType = {
      heartbeat_request: 1,
      heartbeat_response: 2
    };
    tls.CipherSuites = {};
    tls.getCipherSuite = function(twoBytes) {
      var rval = null;
      for (var key2 in tls.CipherSuites) {
        var cs = tls.CipherSuites[key2];
        if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
          rval = cs;
          break;
        }
      }
      return rval;
    };
    tls.handleUnexpected = function(c, record) {
      var ignore = !c.open && c.entity === tls.ConnectionEnd.client;
      if (!ignore) {
        c.error(c, {
          message: "Unexpected message. Received TLS record out of order.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unexpected_message
          }
        });
      }
    };
    tls.handleHelloRequest = function(c, record, length) {
      if (!c.handshaking && c.handshakes > 0) {
        tls.queue(c, tls.createAlert(c, {
          level: tls.Alert.Level.warning,
          description: tls.Alert.Description.no_renegotiation
        }));
        tls.flush(c);
      }
      c.process();
    };
    tls.parseHelloMessage = function(c, record, length) {
      var msg = null;
      var client = c.entity === tls.ConnectionEnd.client;
      if (length < 38) {
        c.error(c, {
          message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else {
        var b2 = record.fragment;
        var remaining = b2.length();
        msg = {
          version: {
            major: b2.getByte(),
            minor: b2.getByte()
          },
          random: forge.util.createBuffer(b2.getBytes(32)),
          session_id: readVector(b2, 1),
          extensions: []
        };
        if (client) {
          msg.cipher_suite = b2.getBytes(2);
          msg.compression_method = b2.getByte();
        } else {
          msg.cipher_suites = readVector(b2, 2);
          msg.compression_methods = readVector(b2, 1);
        }
        remaining = length - (remaining - b2.length());
        if (remaining > 0) {
          var exts = readVector(b2, 2);
          while (exts.length() > 0) {
            msg.extensions.push({
              type: [exts.getByte(), exts.getByte()],
              data: readVector(exts, 2)
            });
          }
          if (!client) {
            for (var i = 0; i < msg.extensions.length; ++i) {
              var ext = msg.extensions[i];
              if (ext.type[0] === 0 && ext.type[1] === 0) {
                var snl = readVector(ext.data, 2);
                while (snl.length() > 0) {
                  var snType = snl.getByte();
                  if (snType !== 0) {
                    break;
                  }
                  c.session.extensions.server_name.serverNameList.push(
                    readVector(snl, 2).getBytes()
                  );
                }
              }
            }
          }
        }
        if (c.session.version) {
          if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
            return c.error(c, {
              message: "TLS version change is disallowed during renegotiation.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        if (client) {
          c.session.cipherSuite = tls.getCipherSuite(msg.cipher_suite);
        } else {
          var tmp = forge.util.createBuffer(msg.cipher_suites.bytes());
          while (tmp.length() > 0) {
            c.session.cipherSuite = tls.getCipherSuite(tmp.getBytes(2));
            if (c.session.cipherSuite !== null) {
              break;
            }
          }
        }
        if (c.session.cipherSuite === null) {
          return c.error(c, {
            message: "No cipher suites in common.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.handshake_failure
            },
            cipherSuite: forge.util.bytesToHex(msg.cipher_suite)
          });
        }
        if (client) {
          c.session.compressionMethod = msg.compression_method;
        } else {
          c.session.compressionMethod = tls.CompressionMethod.none;
        }
      }
      return msg;
    };
    tls.createSecurityParameters = function(c, msg) {
      var client = c.entity === tls.ConnectionEnd.client;
      var msgRandom = msg.random.bytes();
      var cRandom = client ? c.session.sp.client_random : msgRandom;
      var sRandom = client ? msgRandom : tls.createRandom().getBytes();
      c.session.sp = {
        entity: c.entity,
        prf_algorithm: tls.PRFAlgorithm.tls_prf_sha256,
        bulk_cipher_algorithm: null,
        cipher_type: null,
        enc_key_length: null,
        block_length: null,
        fixed_iv_length: null,
        record_iv_length: null,
        mac_algorithm: null,
        mac_length: null,
        mac_key_length: null,
        compression_algorithm: c.session.compressionMethod,
        pre_master_secret: null,
        master_secret: null,
        client_random: cRandom,
        server_random: sRandom
      };
    };
    tls.handleServerHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      if (msg.version.minor <= c.version.minor) {
        c.version.minor = msg.version.minor;
      } else {
        return c.error(c, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.protocol_version
          }
        });
      }
      c.session.version = c.version;
      var sessionId = msg.session_id.bytes();
      if (sessionId.length > 0 && sessionId === c.session.id) {
        c.expect = SCC;
        c.session.resuming = true;
        c.session.sp.server_random = msg.random.bytes();
      } else {
        c.expect = SCE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.session.id = sessionId;
      c.process();
    };
    tls.handleClientHello = function(c, record, length) {
      var msg = tls.parseHelloMessage(c, record, length);
      if (c.fail) {
        return;
      }
      var sessionId = msg.session_id.bytes();
      var session = null;
      if (c.sessionCache) {
        session = c.sessionCache.getSession(sessionId);
        if (session === null) {
          sessionId = "";
        } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
          session = null;
          sessionId = "";
        }
      }
      if (sessionId.length === 0) {
        sessionId = forge.random.getBytes(32);
      }
      c.session.id = sessionId;
      c.session.clientHelloVersion = msg.version;
      c.session.sp = {};
      if (session) {
        c.version = c.session.version = session.version;
        c.session.sp = session.sp;
      } else {
        var version3;
        for (var i = 1; i < tls.SupportedVersions.length; ++i) {
          version3 = tls.SupportedVersions[i];
          if (version3.minor <= msg.version.minor) {
            break;
          }
        }
        c.version = { major: version3.major, minor: version3.minor };
        c.session.version = c.version;
      }
      if (session !== null) {
        c.expect = CCC;
        c.session.resuming = true;
        c.session.sp.client_random = msg.random.bytes();
      } else {
        c.expect = c.verifyClient !== false ? CCE : CKE;
        c.session.resuming = false;
        tls.createSecurityParameters(c, msg);
      }
      c.open = true;
      tls.queue(c, tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createServerHello(c)
      }));
      if (c.session.resuming) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.pending = tls.createConnectionState(c);
        c.state.current.write = c.state.pending.write;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      } else {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        }));
        if (!c.fail) {
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerKeyExchange(c)
          }));
          if (c.verifyClient !== false) {
            tls.queue(c, tls.createRecord(c, {
              type: tls.ContentType.handshake,
              data: tls.createCertificateRequest(c)
            }));
          }
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createServerHelloDone(c)
          }));
        }
      }
      tls.flush(c);
      c.process();
    };
    tls.handleCertificate = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid Certificate message. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_list: readVector(b2, 3)
      };
      var cert2, asn1;
      var certs = [];
      try {
        while (msg.certificate_list.length() > 0) {
          cert2 = readVector(msg.certificate_list, 3);
          asn1 = forge.asn1.fromDer(cert2);
          cert2 = forge.pki.certificateFromAsn1(asn1, true);
          certs.push(cert2);
        }
      } catch (ex) {
        return c.error(c, {
          message: "Could not parse certificate list.",
          cause: ex,
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.bad_certificate
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if ((client || c.verifyClient === true) && certs.length === 0) {
        c.error(c, {
          message: client ? "No server certificate provided." : "No client certificate provided.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      } else if (certs.length === 0) {
        c.expect = client ? SKE : CKE;
      } else {
        if (client) {
          c.session.serverCertificate = certs[0];
        } else {
          c.session.clientCertificate = certs[0];
        }
        if (tls.verifyCertificateChain(c, certs)) {
          c.expect = client ? SKE : CKE;
        }
      }
      c.process();
    };
    tls.handleServerKeyExchange = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      c.expect = SCR;
      c.process();
    };
    tls.handleClientKeyExchange = function(c, record, length) {
      if (length < 48) {
        return c.error(c, {
          message: "Invalid key parameters. Only RSA is supported.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.unsupported_certificate
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        enc_pre_master_secret: readVector(b2, 2).getBytes()
      };
      var privateKey = null;
      if (c.getPrivateKey) {
        try {
          privateKey = c.getPrivateKey(c, c.session.serverCertificate);
          privateKey = forge.pki.privateKeyFromPem(privateKey);
        } catch (ex) {
          c.error(c, {
            message: "Could not get private key.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
      }
      if (privateKey === null) {
        return c.error(c, {
          message: "No private key set.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.internal_error
          }
        });
      }
      try {
        var sp = c.session.sp;
        sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
        var version3 = c.session.clientHelloVersion;
        if (version3.major !== sp.pre_master_secret.charCodeAt(0) || version3.minor !== sp.pre_master_secret.charCodeAt(1)) {
          throw new Error("TLS version rollback attack detected.");
        }
      } catch (ex) {
        sp.pre_master_secret = forge.random.getBytes(48);
      }
      c.expect = CCC;
      if (c.session.clientCertificate !== null) {
        c.expect = CCV;
      }
      c.process();
    };
    tls.handleCertificateRequest = function(c, record, length) {
      if (length < 3) {
        return c.error(c, {
          message: "Invalid CertificateRequest. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      var msg = {
        certificate_types: readVector(b2, 1),
        certificate_authorities: readVector(b2, 2)
      };
      c.session.certificateRequest = msg;
      c.expect = SHD;
      c.process();
    };
    tls.handleCertificateVerify = function(c, record, length) {
      if (length < 2) {
        return c.error(c, {
          message: "Invalid CertificateVerify. Message too short.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var msg = {
        signature: readVector(b2, 2).getBytes()
      };
      var verify3 = forge.util.createBuffer();
      verify3.putBuffer(c.session.md5.digest());
      verify3.putBuffer(c.session.sha1.digest());
      verify3 = verify3.getBytes();
      try {
        var cert2 = c.session.clientCertificate;
        if (!cert2.publicKey.verify(verify3, msg.signature, "NONE")) {
          throw new Error("CertificateVerify signature does not match.");
        }
        c.session.md5.update(msgBytes);
        c.session.sha1.update(msgBytes);
      } catch (ex) {
        return c.error(c, {
          message: "Bad signature in CertificateVerify.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.handshake_failure
          }
        });
      }
      c.expect = CCC;
      c.process();
    };
    tls.handleServerHelloDone = function(c, record, length) {
      if (length > 0) {
        return c.error(c, {
          message: "Invalid ServerHelloDone message. Invalid length.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.record_overflow
          }
        });
      }
      if (c.serverCertificate === null) {
        var error3 = {
          message: "No server certificate provided. Not enough security.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.insufficient_security
          }
        };
        var depth = 0;
        var ret = c.verify(c, error3.alert.description, depth, []);
        if (ret !== true) {
          if (ret || ret === 0) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              if (ret.message) {
                error3.message = ret.message;
              }
              if (ret.alert) {
                error3.alert.description = ret.alert;
              }
            } else if (typeof ret === "number") {
              error3.alert.description = ret;
            }
          }
          return c.error(c, error3);
        }
      }
      if (c.session.certificateRequest !== null) {
        record = tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createCertificate(c)
        });
        tls.queue(c, record);
      }
      record = tls.createRecord(c, {
        type: tls.ContentType.handshake,
        data: tls.createClientKeyExchange(c)
      });
      tls.queue(c, record);
      c.expect = SER;
      var callback = /* @__PURE__ */ __name(function(c2, signature) {
        if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
          tls.queue(c2, tls.createRecord(c2, {
            type: tls.ContentType.handshake,
            data: tls.createCertificateVerify(c2, signature)
          }));
        }
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c2.state.pending = tls.createConnectionState(c2);
        c2.state.current.write = c2.state.pending.write;
        tls.queue(c2, tls.createRecord(c2, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c2)
        }));
        c2.expect = SCC;
        tls.flush(c2);
        c2.process();
      }, "callback");
      if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
        return callback(c, null);
      }
      tls.getClientSignature(c, callback);
    };
    tls.handleChangeCipherSpec = function(c, record) {
      if (record.fragment.getByte() !== 1) {
        return c.error(c, {
          message: "Invalid ChangeCipherSpec message received.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.illegal_parameter
          }
        });
      }
      var client = c.entity === tls.ConnectionEnd.client;
      if (c.session.resuming && client || !c.session.resuming && !client) {
        c.state.pending = tls.createConnectionState(c);
      }
      c.state.current.read = c.state.pending.read;
      if (!c.session.resuming && client || c.session.resuming && !client) {
        c.state.pending = null;
      }
      c.expect = client ? SFI : CFI;
      c.process();
    };
    tls.handleFinished = function(c, record, length) {
      var b2 = record.fragment;
      b2.read -= 4;
      var msgBytes = b2.bytes();
      b2.read += 4;
      var vd = record.fragment.getBytes();
      b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var label = client ? "server finished" : "client finished";
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      if (b2.getBytes() !== vd) {
        return c.error(c, {
          message: "Invalid verify_data in Finished message.",
          send: true,
          alert: {
            level: tls.Alert.Level.fatal,
            description: tls.Alert.Description.decrypt_error
          }
        });
      }
      c.session.md5.update(msgBytes);
      c.session.sha1.update(msgBytes);
      if (c.session.resuming && client || !c.session.resuming && !client) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.change_cipher_spec,
          data: tls.createChangeCipherSpec()
        }));
        c.state.current.write = c.state.pending.write;
        c.state.pending = null;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.handshake,
          data: tls.createFinished(c)
        }));
      }
      c.expect = client ? SAD : CAD;
      c.handshaking = false;
      ++c.handshakes;
      c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
      tls.flush(c);
      c.isConnected = true;
      c.connected(c);
      c.process();
    };
    tls.handleAlert = function(c, record) {
      var b2 = record.fragment;
      var alert = {
        level: b2.getByte(),
        description: b2.getByte()
      };
      var msg;
      switch (alert.description) {
        case tls.Alert.Description.close_notify:
          msg = "Connection closed.";
          break;
        case tls.Alert.Description.unexpected_message:
          msg = "Unexpected message.";
          break;
        case tls.Alert.Description.bad_record_mac:
          msg = "Bad record MAC.";
          break;
        case tls.Alert.Description.decryption_failed:
          msg = "Decryption failed.";
          break;
        case tls.Alert.Description.record_overflow:
          msg = "Record overflow.";
          break;
        case tls.Alert.Description.decompression_failure:
          msg = "Decompression failed.";
          break;
        case tls.Alert.Description.handshake_failure:
          msg = "Handshake failure.";
          break;
        case tls.Alert.Description.bad_certificate:
          msg = "Bad certificate.";
          break;
        case tls.Alert.Description.unsupported_certificate:
          msg = "Unsupported certificate.";
          break;
        case tls.Alert.Description.certificate_revoked:
          msg = "Certificate revoked.";
          break;
        case tls.Alert.Description.certificate_expired:
          msg = "Certificate expired.";
          break;
        case tls.Alert.Description.certificate_unknown:
          msg = "Certificate unknown.";
          break;
        case tls.Alert.Description.illegal_parameter:
          msg = "Illegal parameter.";
          break;
        case tls.Alert.Description.unknown_ca:
          msg = "Unknown certificate authority.";
          break;
        case tls.Alert.Description.access_denied:
          msg = "Access denied.";
          break;
        case tls.Alert.Description.decode_error:
          msg = "Decode error.";
          break;
        case tls.Alert.Description.decrypt_error:
          msg = "Decrypt error.";
          break;
        case tls.Alert.Description.export_restriction:
          msg = "Export restriction.";
          break;
        case tls.Alert.Description.protocol_version:
          msg = "Unsupported protocol version.";
          break;
        case tls.Alert.Description.insufficient_security:
          msg = "Insufficient security.";
          break;
        case tls.Alert.Description.internal_error:
          msg = "Internal error.";
          break;
        case tls.Alert.Description.user_canceled:
          msg = "User canceled.";
          break;
        case tls.Alert.Description.no_renegotiation:
          msg = "Renegotiation not supported.";
          break;
        default:
          msg = "Unknown error.";
          break;
      }
      if (alert.description === tls.Alert.Description.close_notify) {
        return c.close();
      }
      c.error(c, {
        message: msg,
        send: false,
        // origin is the opposite end
        origin: c.entity === tls.ConnectionEnd.client ? "server" : "client",
        alert
      });
      c.process();
    };
    tls.handleHandshake = function(c, record) {
      var b2 = record.fragment;
      var type2 = b2.getByte();
      var length = b2.getInt24();
      if (length > b2.length()) {
        c.fragmented = record;
        record.fragment = forge.util.createBuffer();
        b2.read -= 4;
        return c.process();
      }
      c.fragmented = null;
      b2.read -= 4;
      var bytes = b2.bytes(length + 4);
      b2.read += 4;
      if (type2 in hsTable[c.entity][c.expect]) {
        if (c.entity === tls.ConnectionEnd.server && !c.open && !c.fail) {
          c.handshaking = true;
          c.session = {
            version: null,
            extensions: {
              server_name: {
                serverNameList: []
              }
            },
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            clientCertificate: null,
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
        }
        if (type2 !== tls.HandshakeType.hello_request && type2 !== tls.HandshakeType.certificate_verify && type2 !== tls.HandshakeType.finished) {
          c.session.md5.update(bytes);
          c.session.sha1.update(bytes);
        }
        hsTable[c.entity][c.expect][type2](c, record, length);
      } else {
        tls.handleUnexpected(c, record);
      }
    };
    tls.handleApplicationData = function(c, record) {
      c.data.putBuffer(record.fragment);
      c.dataReady(c);
      c.process();
    };
    tls.handleHeartbeat = function(c, record) {
      var b2 = record.fragment;
      var type2 = b2.getByte();
      var length = b2.getInt16();
      var payload = b2.getBytes(length);
      if (type2 === tls.HeartbeatMessageType.heartbeat_request) {
        if (c.handshaking || length > payload.length) {
          return c.process();
        }
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_response,
            payload
          )
        }));
        tls.flush(c);
      } else if (type2 === tls.HeartbeatMessageType.heartbeat_response) {
        if (payload !== c.expectedHeartbeatPayload) {
          return c.process();
        }
        if (c.heartbeatReceived) {
          c.heartbeatReceived(c, forge.util.createBuffer(payload));
        }
      }
      c.process();
    };
    var SHE = 0;
    var SCE = 1;
    var SKE = 2;
    var SCR = 3;
    var SHD = 4;
    var SCC = 5;
    var SFI = 6;
    var SAD = 7;
    var SER = 8;
    var CHE = 0;
    var CCE = 1;
    var CKE = 2;
    var CCV = 3;
    var CCC = 4;
    var CFI = 5;
    var CAD = 6;
    var __ = tls.handleUnexpected;
    var R0 = tls.handleChangeCipherSpec;
    var R1 = tls.handleAlert;
    var R2 = tls.handleHandshake;
    var R3 = tls.handleApplicationData;
    var R4 = tls.handleHeartbeat;
    var ctTable = [];
    ctTable[tls.ConnectionEnd.client] = [
      //      CC,AL,HS,AD,HB
      /*SHE*/
      [__, R1, R2, __, R4],
      /*SCE*/
      [__, R1, R2, __, R4],
      /*SKE*/
      [__, R1, R2, __, R4],
      /*SCR*/
      [__, R1, R2, __, R4],
      /*SHD*/
      [__, R1, R2, __, R4],
      /*SCC*/
      [R0, R1, __, __, R4],
      /*SFI*/
      [__, R1, R2, __, R4],
      /*SAD*/
      [__, R1, R2, R3, R4],
      /*SER*/
      [__, R1, R2, __, R4]
    ];
    ctTable[tls.ConnectionEnd.server] = [
      //      CC,AL,HS,AD
      /*CHE*/
      [__, R1, R2, __, R4],
      /*CCE*/
      [__, R1, R2, __, R4],
      /*CKE*/
      [__, R1, R2, __, R4],
      /*CCV*/
      [__, R1, R2, __, R4],
      /*CCC*/
      [R0, R1, __, __, R4],
      /*CFI*/
      [__, R1, R2, __, R4],
      /*CAD*/
      [__, R1, R2, R3, R4],
      /*CER*/
      [__, R1, R2, __, R4]
    ];
    var H0 = tls.handleHelloRequest;
    var H1 = tls.handleServerHello;
    var H2 = tls.handleCertificate;
    var H3 = tls.handleServerKeyExchange;
    var H4 = tls.handleCertificateRequest;
    var H5 = tls.handleServerHelloDone;
    var H6 = tls.handleFinished;
    var hsTable = [];
    hsTable[tls.ConnectionEnd.client] = [
      //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
      /*SHE*/
      [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SCE*/
      [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
      /*SKE*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
      /*SCR*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
      /*SHD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
      /*SCC*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SFI*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*SAD*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*SER*/
      [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    var H7 = tls.handleClientHello;
    var H8 = tls.handleClientKeyExchange;
    var H9 = tls.handleCertificateVerify;
    hsTable[tls.ConnectionEnd.server] = [
      //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
      /*CHE*/
      [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CCE*/
      [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
      /*CKE*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
      /*CCV*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
      /*CCC*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CFI*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
      /*CAD*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
      /*CER*/
      [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
    ];
    tls.generateKeys = function(c, sp) {
      var prf = prf_TLS1;
      var random = sp.client_random + sp.server_random;
      if (!c.session.resuming) {
        sp.master_secret = prf(
          sp.pre_master_secret,
          "master secret",
          random,
          48
        ).bytes();
        sp.pre_master_secret = null;
      }
      random = sp.server_random + sp.client_random;
      var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
      var tls10 = c.version.major === tls.Versions.TLS_1_0.major && c.version.minor === tls.Versions.TLS_1_0.minor;
      if (tls10) {
        length += 2 * sp.fixed_iv_length;
      }
      var km = prf(sp.master_secret, "key expansion", random, length);
      var rval = {
        client_write_MAC_key: km.getBytes(sp.mac_key_length),
        server_write_MAC_key: km.getBytes(sp.mac_key_length),
        client_write_key: km.getBytes(sp.enc_key_length),
        server_write_key: km.getBytes(sp.enc_key_length)
      };
      if (tls10) {
        rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
        rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
      }
      return rval;
    };
    tls.createConnectionState = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var createMode = /* @__PURE__ */ __name(function() {
        var mode = {
          // two 32-bit numbers, first is most significant
          sequenceNumber: [0, 0],
          macKey: null,
          macLength: 0,
          macFunction: null,
          cipherState: null,
          cipherFunction: /* @__PURE__ */ __name(function(record) {
            return true;
          }, "cipherFunction"),
          compressionState: null,
          compressFunction: /* @__PURE__ */ __name(function(record) {
            return true;
          }, "compressFunction"),
          updateSequenceNumber: /* @__PURE__ */ __name(function() {
            if (mode.sequenceNumber[1] === 4294967295) {
              mode.sequenceNumber[1] = 0;
              ++mode.sequenceNumber[0];
            } else {
              ++mode.sequenceNumber[1];
            }
          }, "updateSequenceNumber")
        };
        return mode;
      }, "createMode");
      var state = {
        read: createMode(),
        write: createMode()
      };
      state.read.update = function(c2, record) {
        if (!state.read.cipherFunction(record, state.read)) {
          c2.error(c2, {
            message: "Could not decrypt record or bad MAC.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              // doesn't matter if decryption failed or MAC was
              // invalid, return the same error so as not to reveal
              // which one occurred
              description: tls.Alert.Description.bad_record_mac
            }
          });
        } else if (!state.read.compressFunction(c2, record, state.read)) {
          c2.error(c2, {
            message: "Could not decompress record.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.decompression_failure
            }
          });
        }
        return !c2.fail;
      };
      state.write.update = function(c2, record) {
        if (!state.write.compressFunction(c2, record, state.write)) {
          c2.error(c2, {
            message: "Could not compress record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else if (!state.write.cipherFunction(record, state.write)) {
          c2.error(c2, {
            message: "Could not encrypt record.",
            send: false,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        }
        return !c2.fail;
      };
      if (c.session) {
        var sp = c.session.sp;
        c.session.cipherSuite.initSecurityParameters(sp);
        sp.keys = tls.generateKeys(c, sp);
        state.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
        state.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
        c.session.cipherSuite.initConnectionState(state, c, sp);
        switch (sp.compression_algorithm) {
          case tls.CompressionMethod.none:
            break;
          case tls.CompressionMethod.deflate:
            state.read.compressFunction = inflate2;
            state.write.compressFunction = deflate2;
            break;
          default:
            throw new Error("Unsupported compression algorithm.");
        }
      }
      return state;
    };
    tls.createRandom = function() {
      var d2 = /* @__PURE__ */ new Date();
      var utc = +d2 + d2.getTimezoneOffset() * 6e4;
      var rval = forge.util.createBuffer();
      rval.putInt32(utc);
      rval.putBytes(forge.random.getBytes(28));
      return rval;
    };
    tls.createRecord = function(c, options) {
      if (!options.data) {
        return null;
      }
      var record = {
        type: options.type,
        version: {
          major: c.version.major,
          minor: c.version.minor
        },
        length: options.data.length(),
        fragment: options.data
      };
      return record;
    };
    tls.createAlert = function(c, alert) {
      var b2 = forge.util.createBuffer();
      b2.putByte(alert.level);
      b2.putByte(alert.description);
      return tls.createRecord(c, {
        type: tls.ContentType.alert,
        data: b2
      });
    };
    tls.createClientHello = function(c) {
      c.session.clientHelloVersion = {
        major: c.version.major,
        minor: c.version.minor
      };
      var cipherSuites = forge.util.createBuffer();
      for (var i = 0; i < c.cipherSuites.length; ++i) {
        var cs = c.cipherSuites[i];
        cipherSuites.putByte(cs.id[0]);
        cipherSuites.putByte(cs.id[1]);
      }
      var cSuites = cipherSuites.length();
      var compressionMethods = forge.util.createBuffer();
      compressionMethods.putByte(tls.CompressionMethod.none);
      var cMethods = compressionMethods.length();
      var extensions = forge.util.createBuffer();
      if (c.virtualHost) {
        var ext = forge.util.createBuffer();
        ext.putByte(0);
        ext.putByte(0);
        var serverName = forge.util.createBuffer();
        serverName.putByte(0);
        writeVector(serverName, 2, forge.util.createBuffer(c.virtualHost));
        var snList = forge.util.createBuffer();
        writeVector(snList, 2, serverName);
        writeVector(ext, 2, snList);
        extensions.putBuffer(ext);
      }
      var extLength = extensions.length();
      if (extLength > 0) {
        extLength += 2;
      }
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + cSuites + // cipher suites vector
      1 + cMethods + // compression methods vector
      extLength;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.client_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      writeVector(rval, 2, cipherSuites);
      writeVector(rval, 1, compressionMethods);
      if (extLength > 0) {
        writeVector(rval, 2, extensions);
      }
      return rval;
    };
    tls.createServerHello = function(c) {
      var sessionId = c.session.id;
      var length = sessionId.length + 1 + // session ID vector
      2 + // version (major + minor)
      4 + 28 + // random time and random bytes
      2 + // chosen cipher suite
      1;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello);
      rval.putInt24(length);
      rval.putByte(c.version.major);
      rval.putByte(c.version.minor);
      rval.putBytes(c.session.sp.server_random);
      writeVector(rval, 1, forge.util.createBuffer(sessionId));
      rval.putByte(c.session.cipherSuite.id[0]);
      rval.putByte(c.session.cipherSuite.id[1]);
      rval.putByte(c.session.compressionMethod);
      return rval;
    };
    tls.createCertificate = function(c) {
      var client = c.entity === tls.ConnectionEnd.client;
      var cert2 = null;
      if (c.getCertificate) {
        var hint;
        if (client) {
          hint = c.session.certificateRequest;
        } else {
          hint = c.session.extensions.server_name.serverNameList;
        }
        cert2 = c.getCertificate(c, hint);
      }
      var certList = forge.util.createBuffer();
      if (cert2 !== null) {
        try {
          if (!forge.util.isArray(cert2)) {
            cert2 = [cert2];
          }
          var asn1 = null;
          for (var i = 0; i < cert2.length; ++i) {
            var msg = forge.pem.decode(cert2[i])[0];
            if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
              var error3 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
              error3.headerType = msg.type;
              throw error3;
            }
            if (msg.procType && msg.procType.type === "ENCRYPTED") {
              throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
            }
            var der = forge.util.createBuffer(msg.body);
            if (asn1 === null) {
              asn1 = forge.asn1.fromDer(der.bytes(), false);
            }
            var certBuffer = forge.util.createBuffer();
            writeVector(certBuffer, 3, der);
            certList.putBuffer(certBuffer);
          }
          cert2 = forge.pki.certificateFromAsn1(asn1);
          if (client) {
            c.session.clientCertificate = cert2;
          } else {
            c.session.serverCertificate = cert2;
          }
        } catch (ex) {
          return c.error(c, {
            message: "Could not send certificate list.",
            cause: ex,
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.bad_certificate
            }
          });
        }
      }
      var length = 3 + certList.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate);
      rval.putInt24(length);
      writeVector(rval, 3, certList);
      return rval;
    };
    tls.createClientKeyExchange = function(c) {
      var b2 = forge.util.createBuffer();
      b2.putByte(c.session.clientHelloVersion.major);
      b2.putByte(c.session.clientHelloVersion.minor);
      b2.putBytes(forge.random.getBytes(46));
      var sp = c.session.sp;
      sp.pre_master_secret = b2.getBytes();
      var key2 = c.session.serverCertificate.publicKey;
      b2 = key2.encrypt(sp.pre_master_secret);
      var length = b2.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.client_key_exchange);
      rval.putInt24(length);
      rval.putInt16(b2.length);
      rval.putBytes(b2);
      return rval;
    };
    tls.createServerKeyExchange = function(c) {
      var length = 0;
      var rval = forge.util.createBuffer();
      if (length > 0) {
        rval.putByte(tls.HandshakeType.server_key_exchange);
        rval.putInt24(length);
      }
      return rval;
    };
    tls.getClientSignature = function(c, callback) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      b2 = b2.getBytes();
      c.getSignature = c.getSignature || function(c2, b3, callback2) {
        var privateKey = null;
        if (c2.getPrivateKey) {
          try {
            privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
            privateKey = forge.pki.privateKeyFromPem(privateKey);
          } catch (ex) {
            c2.error(c2, {
              message: "Could not get private key.",
              cause: ex,
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.internal_error
              }
            });
          }
        }
        if (privateKey === null) {
          c2.error(c2, {
            message: "No private key set.",
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: tls.Alert.Description.internal_error
            }
          });
        } else {
          b3 = privateKey.sign(b3, null);
        }
        callback2(c2, b3);
      };
      c.getSignature(c, b2, callback);
    };
    tls.createCertificateVerify = function(c, signature) {
      var length = signature.length + 2;
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_verify);
      rval.putInt24(length);
      rval.putInt16(signature.length);
      rval.putBytes(signature);
      return rval;
    };
    tls.createCertificateRequest = function(c) {
      var certTypes = forge.util.createBuffer();
      certTypes.putByte(1);
      var cAs = forge.util.createBuffer();
      for (var key2 in c.caStore.certs) {
        var cert2 = c.caStore.certs[key2];
        var dn = forge.pki.distinguishedNameToAsn1(cert2.subject);
        var byteBuffer = forge.asn1.toDer(dn);
        cAs.putInt16(byteBuffer.length());
        cAs.putBuffer(byteBuffer);
      }
      var length = 1 + certTypes.length() + 2 + cAs.length();
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.certificate_request);
      rval.putInt24(length);
      writeVector(rval, 1, certTypes);
      writeVector(rval, 2, cAs);
      return rval;
    };
    tls.createServerHelloDone = function(c) {
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.server_hello_done);
      rval.putInt24(0);
      return rval;
    };
    tls.createChangeCipherSpec = function() {
      var rval = forge.util.createBuffer();
      rval.putByte(1);
      return rval;
    };
    tls.createFinished = function(c) {
      var b2 = forge.util.createBuffer();
      b2.putBuffer(c.session.md5.digest());
      b2.putBuffer(c.session.sha1.digest());
      var client = c.entity === tls.ConnectionEnd.client;
      var sp = c.session.sp;
      var vdl = 12;
      var prf = prf_TLS1;
      var label = client ? "client finished" : "server finished";
      b2 = prf(sp.master_secret, label, b2.getBytes(), vdl);
      var rval = forge.util.createBuffer();
      rval.putByte(tls.HandshakeType.finished);
      rval.putInt24(b2.length());
      rval.putBuffer(b2);
      return rval;
    };
    tls.createHeartbeat = function(type2, payload, payloadLength) {
      if (typeof payloadLength === "undefined") {
        payloadLength = payload.length;
      }
      var rval = forge.util.createBuffer();
      rval.putByte(type2);
      rval.putInt16(payloadLength);
      rval.putBytes(payload);
      var plaintextLength = rval.length();
      var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
      rval.putBytes(forge.random.getBytes(paddingLength));
      return rval;
    };
    tls.queue = function(c, record) {
      if (!record) {
        return;
      }
      if (record.fragment.length() === 0) {
        if (record.type === tls.ContentType.handshake || record.type === tls.ContentType.alert || record.type === tls.ContentType.change_cipher_spec) {
          return;
        }
      }
      if (record.type === tls.ContentType.handshake) {
        var bytes = record.fragment.bytes();
        c.session.md5.update(bytes);
        c.session.sha1.update(bytes);
        bytes = null;
      }
      var records;
      if (record.fragment.length() <= tls.MaxFragment) {
        records = [record];
      } else {
        records = [];
        var data = record.fragment.bytes();
        while (data.length > tls.MaxFragment) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data.slice(0, tls.MaxFragment))
          }));
          data = data.slice(tls.MaxFragment);
        }
        if (data.length > 0) {
          records.push(tls.createRecord(c, {
            type: record.type,
            data: forge.util.createBuffer(data)
          }));
        }
      }
      for (var i = 0; i < records.length && !c.fail; ++i) {
        var rec = records[i];
        var s = c.state.current.write;
        if (s.update(c, rec)) {
          c.records.push(rec);
        }
      }
    };
    tls.flush = function(c) {
      for (var i = 0; i < c.records.length; ++i) {
        var record = c.records[i];
        c.tlsData.putByte(record.type);
        c.tlsData.putByte(record.version.major);
        c.tlsData.putByte(record.version.minor);
        c.tlsData.putInt16(record.fragment.length());
        c.tlsData.putBuffer(c.records[i].fragment);
      }
      c.records = [];
      return c.tlsDataReady(c);
    };
    var _certErrorToAlertDesc = /* @__PURE__ */ __name(function(error3) {
      switch (error3) {
        case true:
          return true;
        case forge.pki.certificateError.bad_certificate:
          return tls.Alert.Description.bad_certificate;
        case forge.pki.certificateError.unsupported_certificate:
          return tls.Alert.Description.unsupported_certificate;
        case forge.pki.certificateError.certificate_revoked:
          return tls.Alert.Description.certificate_revoked;
        case forge.pki.certificateError.certificate_expired:
          return tls.Alert.Description.certificate_expired;
        case forge.pki.certificateError.certificate_unknown:
          return tls.Alert.Description.certificate_unknown;
        case forge.pki.certificateError.unknown_ca:
          return tls.Alert.Description.unknown_ca;
        default:
          return tls.Alert.Description.bad_certificate;
      }
    }, "_certErrorToAlertDesc");
    var _alertDescToCertError = /* @__PURE__ */ __name(function(desc) {
      switch (desc) {
        case true:
          return true;
        case tls.Alert.Description.bad_certificate:
          return forge.pki.certificateError.bad_certificate;
        case tls.Alert.Description.unsupported_certificate:
          return forge.pki.certificateError.unsupported_certificate;
        case tls.Alert.Description.certificate_revoked:
          return forge.pki.certificateError.certificate_revoked;
        case tls.Alert.Description.certificate_expired:
          return forge.pki.certificateError.certificate_expired;
        case tls.Alert.Description.certificate_unknown:
          return forge.pki.certificateError.certificate_unknown;
        case tls.Alert.Description.unknown_ca:
          return forge.pki.certificateError.unknown_ca;
        default:
          return forge.pki.certificateError.bad_certificate;
      }
    }, "_alertDescToCertError");
    tls.verifyCertificateChain = function(c, chain) {
      try {
        var options = {};
        for (var key2 in c.verifyOptions) {
          options[key2] = c.verifyOptions[key2];
        }
        options.verify = function(vfd, depth, chain2) {
          var desc = _certErrorToAlertDesc(vfd);
          var ret = c.verify(c, vfd, depth, chain2);
          if (ret !== true) {
            if (typeof ret === "object" && !forge.util.isArray(ret)) {
              var error3 = new Error("The application rejected the certificate.");
              error3.send = true;
              error3.alert = {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.bad_certificate
              };
              if (ret.message) {
                error3.message = ret.message;
              }
              if (ret.alert) {
                error3.alert.description = ret.alert;
              }
              throw error3;
            }
            if (ret !== vfd) {
              ret = _alertDescToCertError(ret);
            }
          }
          return ret;
        };
        forge.pki.verifyCertificateChain(c.caStore, chain, options);
      } catch (ex) {
        var err = ex;
        if (typeof err !== "object" || forge.util.isArray(err)) {
          err = {
            send: true,
            alert: {
              level: tls.Alert.Level.fatal,
              description: _certErrorToAlertDesc(ex)
            }
          };
        }
        if (!("send" in err)) {
          err.send = true;
        }
        if (!("alert" in err)) {
          err.alert = {
            level: tls.Alert.Level.fatal,
            description: _certErrorToAlertDesc(err.error)
          };
        }
        c.error(c, err);
      }
      return !c.fail;
    };
    tls.createSessionCache = function(cache, capacity) {
      var rval = null;
      if (cache && cache.getSession && cache.setSession && cache.order) {
        rval = cache;
      } else {
        rval = {};
        rval.cache = cache || {};
        rval.capacity = Math.max(capacity || 100, 1);
        rval.order = [];
        for (var key2 in cache) {
          if (rval.order.length <= capacity) {
            rval.order.push(key2);
          } else {
            delete cache[key2];
          }
        }
        rval.getSession = function(sessionId) {
          var session = null;
          var key3 = null;
          if (sessionId) {
            key3 = forge.util.bytesToHex(sessionId);
          } else if (rval.order.length > 0) {
            key3 = rval.order[0];
          }
          if (key3 !== null && key3 in rval.cache) {
            session = rval.cache[key3];
            delete rval.cache[key3];
            for (var i in rval.order) {
              if (rval.order[i] === key3) {
                rval.order.splice(i, 1);
                break;
              }
            }
          }
          return session;
        };
        rval.setSession = function(sessionId, session) {
          if (rval.order.length === rval.capacity) {
            var key3 = rval.order.shift();
            delete rval.cache[key3];
          }
          var key3 = forge.util.bytesToHex(sessionId);
          rval.order.push(key3);
          rval.cache[key3] = session;
        };
      }
      return rval;
    };
    tls.createConnection = function(options) {
      var caStore = null;
      if (options.caStore) {
        if (forge.util.isArray(options.caStore)) {
          caStore = forge.pki.createCaStore(options.caStore);
        } else {
          caStore = options.caStore;
        }
      } else {
        caStore = forge.pki.createCaStore();
      }
      var cipherSuites = options.cipherSuites || null;
      if (cipherSuites === null) {
        cipherSuites = [];
        for (var key2 in tls.CipherSuites) {
          cipherSuites.push(tls.CipherSuites[key2]);
        }
      }
      var entity = options.server || false ? tls.ConnectionEnd.server : tls.ConnectionEnd.client;
      var sessionCache = options.sessionCache ? tls.createSessionCache(options.sessionCache) : null;
      var c = {
        version: { major: tls.Version.major, minor: tls.Version.minor },
        entity,
        sessionId: options.sessionId,
        caStore,
        sessionCache,
        cipherSuites,
        connected: options.connected,
        virtualHost: options.virtualHost || null,
        verifyClient: options.verifyClient || false,
        verify: options.verify || function(cn, vfd, dpth, cts) {
          return vfd;
        },
        verifyOptions: options.verifyOptions || {},
        getCertificate: options.getCertificate || null,
        getPrivateKey: options.getPrivateKey || null,
        getSignature: options.getSignature || null,
        input: forge.util.createBuffer(),
        tlsData: forge.util.createBuffer(),
        data: forge.util.createBuffer(),
        tlsDataReady: options.tlsDataReady,
        dataReady: options.dataReady,
        heartbeatReceived: options.heartbeatReceived,
        closed: options.closed,
        error: /* @__PURE__ */ __name(function(c2, ex) {
          ex.origin = ex.origin || (c2.entity === tls.ConnectionEnd.client ? "client" : "server");
          if (ex.send) {
            tls.queue(c2, tls.createAlert(c2, ex.alert));
            tls.flush(c2);
          }
          var fatal = ex.fatal !== false;
          if (fatal) {
            c2.fail = true;
          }
          options.error(c2, ex);
          if (fatal) {
            c2.close(false);
          }
        }, "error"),
        deflate: options.deflate || null,
        inflate: options.inflate || null
      };
      c.reset = function(clearFail) {
        c.version = { major: tls.Version.major, minor: tls.Version.minor };
        c.record = null;
        c.session = null;
        c.peerCertificate = null;
        c.state = {
          pending: null,
          current: null
        };
        c.expect = c.entity === tls.ConnectionEnd.client ? SHE : CHE;
        c.fragmented = null;
        c.records = [];
        c.open = false;
        c.handshakes = 0;
        c.handshaking = false;
        c.isConnected = false;
        c.fail = !(clearFail || typeof clearFail === "undefined");
        c.input.clear();
        c.tlsData.clear();
        c.data.clear();
        c.state.current = tls.createConnectionState(c);
      };
      c.reset();
      var _update = /* @__PURE__ */ __name(function(c2, record) {
        var aligned = record.type - tls.ContentType.change_cipher_spec;
        var handlers = ctTable[c2.entity][c2.expect];
        if (aligned in handlers) {
          handlers[aligned](c2, record);
        } else {
          tls.handleUnexpected(c2, record);
        }
      }, "_update");
      var _readRecordHeader = /* @__PURE__ */ __name(function(c2) {
        var rval = 0;
        var b2 = c2.input;
        var len = b2.length();
        if (len < 5) {
          rval = 5 - len;
        } else {
          c2.record = {
            type: b2.getByte(),
            version: {
              major: b2.getByte(),
              minor: b2.getByte()
            },
            length: b2.getInt16(),
            fragment: forge.util.createBuffer(),
            ready: false
          };
          var compatibleVersion = c2.record.version.major === c2.version.major;
          if (compatibleVersion && c2.session && c2.session.version) {
            compatibleVersion = c2.record.version.minor === c2.version.minor;
          }
          if (!compatibleVersion) {
            c2.error(c2, {
              message: "Incompatible TLS version.",
              send: true,
              alert: {
                level: tls.Alert.Level.fatal,
                description: tls.Alert.Description.protocol_version
              }
            });
          }
        }
        return rval;
      }, "_readRecordHeader");
      var _readRecord = /* @__PURE__ */ __name(function(c2) {
        var rval = 0;
        var b2 = c2.input;
        var len = b2.length();
        if (len < c2.record.length) {
          rval = c2.record.length - len;
        } else {
          c2.record.fragment.putBytes(b2.getBytes(c2.record.length));
          b2.compact();
          var s = c2.state.current.read;
          if (s.update(c2, c2.record)) {
            if (c2.fragmented !== null) {
              if (c2.fragmented.type === c2.record.type) {
                c2.fragmented.fragment.putBuffer(c2.record.fragment);
                c2.record = c2.fragmented;
              } else {
                c2.error(c2, {
                  message: "Invalid fragmented record.",
                  send: true,
                  alert: {
                    level: tls.Alert.Level.fatal,
                    description: tls.Alert.Description.unexpected_message
                  }
                });
              }
            }
            c2.record.ready = true;
          }
        }
        return rval;
      }, "_readRecord");
      c.handshake = function(sessionId) {
        if (c.entity !== tls.ConnectionEnd.client) {
          c.error(c, {
            message: "Cannot initiate handshake as a server.",
            fatal: false
          });
        } else if (c.handshaking) {
          c.error(c, {
            message: "Handshake already in progress.",
            fatal: false
          });
        } else {
          if (c.fail && !c.open && c.handshakes === 0) {
            c.fail = false;
          }
          c.handshaking = true;
          sessionId = sessionId || "";
          var session = null;
          if (sessionId.length > 0) {
            if (c.sessionCache) {
              session = c.sessionCache.getSession(sessionId);
            }
            if (session === null) {
              sessionId = "";
            }
          }
          if (sessionId.length === 0 && c.sessionCache) {
            session = c.sessionCache.getSession();
            if (session !== null) {
              sessionId = session.id;
            }
          }
          c.session = {
            id: sessionId,
            version: null,
            cipherSuite: null,
            compressionMethod: null,
            serverCertificate: null,
            certificateRequest: null,
            clientCertificate: null,
            sp: {},
            md5: forge.md.md5.create(),
            sha1: forge.md.sha1.create()
          };
          if (session) {
            c.version = session.version;
            c.session.sp = session.sp;
          }
          c.session.sp.client_random = tls.createRandom().getBytes();
          c.open = true;
          tls.queue(c, tls.createRecord(c, {
            type: tls.ContentType.handshake,
            data: tls.createClientHello(c)
          }));
          tls.flush(c);
        }
      };
      c.process = function(data) {
        var rval = 0;
        if (data) {
          c.input.putBytes(data);
        }
        if (!c.fail) {
          if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
            c.record = null;
          }
          if (c.record === null) {
            rval = _readRecordHeader(c);
          }
          if (!c.fail && c.record !== null && !c.record.ready) {
            rval = _readRecord(c);
          }
          if (!c.fail && c.record !== null && c.record.ready) {
            _update(c, c.record);
          }
        }
        return rval;
      };
      c.prepare = function(data) {
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.application_data,
          data: forge.util.createBuffer(data)
        }));
        return tls.flush(c);
      };
      c.prepareHeartbeatRequest = function(payload, payloadLength) {
        if (payload instanceof forge.util.ByteBuffer) {
          payload = payload.bytes();
        }
        if (typeof payloadLength === "undefined") {
          payloadLength = payload.length;
        }
        c.expectedHeartbeatPayload = payload;
        tls.queue(c, tls.createRecord(c, {
          type: tls.ContentType.heartbeat,
          data: tls.createHeartbeat(
            tls.HeartbeatMessageType.heartbeat_request,
            payload,
            payloadLength
          )
        }));
        return tls.flush(c);
      };
      c.close = function(clearFail) {
        if (!c.fail && c.sessionCache && c.session) {
          var session = {
            id: c.session.id,
            version: c.session.version,
            sp: c.session.sp
          };
          session.sp.keys = null;
          c.sessionCache.setSession(session.id, session);
        }
        if (c.open) {
          c.open = false;
          c.input.clear();
          if (c.isConnected || c.handshaking) {
            c.isConnected = c.handshaking = false;
            tls.queue(c, tls.createAlert(c, {
              level: tls.Alert.Level.warning,
              description: tls.Alert.Description.close_notify
            }));
            tls.flush(c);
          }
          c.closed(c);
        }
        c.reset(clearFail);
      };
      return c;
    };
    module.exports = forge.tls = forge.tls || {};
    for (key in tls) {
      if (typeof tls[key] !== "function") {
        forge.tls[key] = tls[key];
      }
    }
    var key;
    forge.tls.prf_tls1 = prf_TLS1;
    forge.tls.hmac_sha1 = hmac_sha1;
    forge.tls.createSessionCache = tls.createSessionCache;
    forge.tls.createConnection = tls.createConnection;
  }
});

// node_modules/node-forge/lib/aesCipherSuites.js
var require_aesCipherSuites = __commonJS({
  "node_modules/node-forge/lib/aesCipherSuites.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_tls2();
    var tls = module.exports = forge.tls;
    tls.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
      id: [0, 47],
      name: "TLS_RSA_WITH_AES_128_CBC_SHA",
      initSecurityParameters: /* @__PURE__ */ __name(function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 16;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      }, "initSecurityParameters"),
      initConnectionState
    };
    tls.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
      id: [0, 53],
      name: "TLS_RSA_WITH_AES_256_CBC_SHA",
      initSecurityParameters: /* @__PURE__ */ __name(function(sp) {
        sp.bulk_cipher_algorithm = tls.BulkCipherAlgorithm.aes;
        sp.cipher_type = tls.CipherType.block;
        sp.enc_key_length = 32;
        sp.block_length = 16;
        sp.fixed_iv_length = 16;
        sp.record_iv_length = 16;
        sp.mac_algorithm = tls.MACAlgorithm.hmac_sha1;
        sp.mac_length = 20;
        sp.mac_key_length = 20;
      }, "initSecurityParameters"),
      initConnectionState
    };
    function initConnectionState(state, c, sp) {
      var client = c.entity === forge.tls.ConnectionEnd.client;
      state.read.cipherState = {
        init: false,
        cipher: forge.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
        iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
      };
      state.write.cipherState = {
        init: false,
        cipher: forge.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
        iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
      };
      state.read.cipherFunction = decrypt_aes_cbc_sha1;
      state.write.cipherFunction = encrypt_aes_cbc_sha1;
      state.read.macLength = state.write.macLength = sp.mac_length;
      state.read.macFunction = state.write.macFunction = tls.hmac_sha1;
    }
    __name(initConnectionState, "initConnectionState");
    function encrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var mac = s.macFunction(s.macKey, s.sequenceNumber, record);
      record.fragment.putBytes(mac);
      s.updateSequenceNumber();
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = forge.random.getBytesSync(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      if (record.version.minor >= tls.Versions.TLS_1_1.minor) {
        cipher.output.putBytes(iv);
      }
      cipher.update(record.fragment);
      if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
        record.fragment = cipher.output;
        record.length = record.fragment.length();
        rval = true;
      }
      return rval;
    }
    __name(encrypt_aes_cbc_sha1, "encrypt_aes_cbc_sha1");
    function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt4) {
      if (!decrypt4) {
        var padding = blockSize - input.length() % blockSize;
        input.fillWithByte(padding - 1, padding);
      }
      return true;
    }
    __name(encrypt_aes_cbc_sha1_padding, "encrypt_aes_cbc_sha1_padding");
    function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt4) {
      var rval = true;
      if (decrypt4) {
        var len = output.length();
        var paddingLength = output.last();
        for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
          rval = rval && output.at(i) == paddingLength;
        }
        if (rval) {
          output.truncate(paddingLength + 1);
        }
      }
      return rval;
    }
    __name(decrypt_aes_cbc_sha1_padding, "decrypt_aes_cbc_sha1_padding");
    function decrypt_aes_cbc_sha1(record, s) {
      var rval = false;
      var iv;
      if (record.version.minor === tls.Versions.TLS_1_0.minor) {
        iv = s.cipherState.init ? null : s.cipherState.iv;
      } else {
        iv = record.fragment.getBytes(16);
      }
      s.cipherState.init = true;
      var cipher = s.cipherState.cipher;
      cipher.start({ iv });
      cipher.update(record.fragment);
      rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
      var macLen = s.macLength;
      var mac = forge.random.getBytesSync(macLen);
      var len = cipher.output.length();
      if (len >= macLen) {
        record.fragment = cipher.output.getBytes(len - macLen);
        mac = cipher.output.getBytes(macLen);
      } else {
        record.fragment = cipher.output.getBytes();
      }
      record.fragment = forge.util.createBuffer(record.fragment);
      record.length = record.fragment.length();
      var mac2 = s.macFunction(s.macKey, s.sequenceNumber, record);
      s.updateSequenceNumber();
      rval = compareMacs(s.macKey, mac, mac2) && rval;
      return rval;
    }
    __name(decrypt_aes_cbc_sha1, "decrypt_aes_cbc_sha1");
    function compareMacs(key, mac1, mac2) {
      var hmac = forge.hmac.create();
      hmac.start("SHA1", key);
      hmac.update(mac1);
      mac1 = hmac.digest().getBytes();
      hmac.start(null, null);
      hmac.update(mac2);
      mac2 = hmac.digest().getBytes();
      return mac1 === mac2;
    }
    __name(compareMacs, "compareMacs");
  }
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS({
  "node_modules/node-forge/lib/sha512.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_md();
    require_util4();
    var sha512 = module.exports = forge.sha512 = forge.sha512 || {};
    forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
    var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
    sha384.create = function() {
      return sha512.create("SHA-384");
    };
    forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
    forge.sha512.sha256 = forge.sha512.sha256 || {
      create: /* @__PURE__ */ __name(function() {
        return sha512.create("SHA-512/256");
      }, "create")
    };
    forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
    forge.sha512.sha224 = forge.sha512.sha224 || {
      create: /* @__PURE__ */ __name(function() {
        return sha512.create("SHA-512/224");
      }, "create")
    };
    forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
    sha512.create = function(algorithm) {
      if (!_initialized) {
        _init();
      }
      if (typeof algorithm === "undefined") {
        algorithm = "SHA-512";
      }
      if (!(algorithm in _states)) {
        throw new Error("Invalid SHA-512 algorithm: " + algorithm);
      }
      var _state = _states[algorithm];
      var _h = null;
      var _input = forge.util.createBuffer();
      var _w = new Array(80);
      for (var wi2 = 0; wi2 < 80; ++wi2) {
        _w[wi2] = new Array(2);
      }
      var digestLength = 64;
      switch (algorithm) {
        case "SHA-384":
          digestLength = 48;
          break;
        case "SHA-512/256":
          digestLength = 32;
          break;
        case "SHA-512/224":
          digestLength = 28;
          break;
      }
      var md = {
        // SHA-512 => sha512
        algorithm: algorithm.replace("-", "").toLowerCase(),
        blockLength: 128,
        digestLength,
        // 56-bit length of message so far (does not including padding)
        messageLength: 0,
        // true message length
        fullMessageLength: null,
        // size of message length in bytes
        messageLengthSize: 16
      };
      md.start = function() {
        md.messageLength = 0;
        md.fullMessageLength = md.messageLength128 = [];
        var int32s = md.messageLengthSize / 4;
        for (var i = 0; i < int32s; ++i) {
          md.fullMessageLength.push(0);
        }
        _input = forge.util.createBuffer();
        _h = new Array(_state.length);
        for (var i = 0; i < _state.length; ++i) {
          _h[i] = _state[i].slice(0);
        }
        return md;
      };
      md.start();
      md.update = function(msg, encoding) {
        if (encoding === "utf8") {
          msg = forge.util.encodeUtf8(msg);
        }
        var len = msg.length;
        md.messageLength += len;
        len = [len / 4294967296 >>> 0, len >>> 0];
        for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
          md.fullMessageLength[i] += len[1];
          len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
          md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
          len[0] = len[1] / 4294967296 >>> 0;
        }
        _input.putBytes(msg);
        _update(_h, _w, _input);
        if (_input.read > 2048 || _input.length() === 0) {
          _input.compact();
        }
        return md;
      };
      md.digest = function() {
        var finalBlock = forge.util.createBuffer();
        finalBlock.putBytes(_input.bytes());
        var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
        var overflow = remaining & md.blockLength - 1;
        finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
        var next, carry;
        var bits = md.fullMessageLength[0] * 8;
        for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
          next = md.fullMessageLength[i + 1] * 8;
          carry = next / 4294967296 >>> 0;
          bits += carry;
          finalBlock.putInt32(bits >>> 0);
          bits = next >>> 0;
        }
        finalBlock.putInt32(bits);
        var h = new Array(_h.length);
        for (var i = 0; i < _h.length; ++i) {
          h[i] = _h[i].slice(0);
        }
        _update(h, _w, finalBlock);
        var rval = forge.util.createBuffer();
        var hlen;
        if (algorithm === "SHA-512") {
          hlen = h.length;
        } else if (algorithm === "SHA-384") {
          hlen = h.length - 2;
        } else {
          hlen = h.length - 4;
        }
        for (var i = 0; i < hlen; ++i) {
          rval.putInt32(h[i][0]);
          if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
            rval.putInt32(h[i][1]);
          }
        }
        return rval;
      };
      return md;
    };
    var _padding = null;
    var _initialized = false;
    var _k = null;
    var _states = null;
    function _init() {
      _padding = String.fromCharCode(128);
      _padding += forge.util.fillString(String.fromCharCode(0), 128);
      _k = [
        [1116352408, 3609767458],
        [1899447441, 602891725],
        [3049323471, 3964484399],
        [3921009573, 2173295548],
        [961987163, 4081628472],
        [1508970993, 3053834265],
        [2453635748, 2937671579],
        [2870763221, 3664609560],
        [3624381080, 2734883394],
        [310598401, 1164996542],
        [607225278, 1323610764],
        [1426881987, 3590304994],
        [1925078388, 4068182383],
        [2162078206, 991336113],
        [2614888103, 633803317],
        [3248222580, 3479774868],
        [3835390401, 2666613458],
        [4022224774, 944711139],
        [264347078, 2341262773],
        [604807628, 2007800933],
        [770255983, 1495990901],
        [1249150122, 1856431235],
        [1555081692, 3175218132],
        [1996064986, 2198950837],
        [2554220882, 3999719339],
        [2821834349, 766784016],
        [2952996808, 2566594879],
        [3210313671, 3203337956],
        [3336571891, 1034457026],
        [3584528711, 2466948901],
        [113926993, 3758326383],
        [338241895, 168717936],
        [666307205, 1188179964],
        [773529912, 1546045734],
        [1294757372, 1522805485],
        [1396182291, 2643833823],
        [1695183700, 2343527390],
        [1986661051, 1014477480],
        [2177026350, 1206759142],
        [2456956037, 344077627],
        [2730485921, 1290863460],
        [2820302411, 3158454273],
        [3259730800, 3505952657],
        [3345764771, 106217008],
        [3516065817, 3606008344],
        [3600352804, 1432725776],
        [4094571909, 1467031594],
        [275423344, 851169720],
        [430227734, 3100823752],
        [506948616, 1363258195],
        [659060556, 3750685593],
        [883997877, 3785050280],
        [958139571, 3318307427],
        [1322822218, 3812723403],
        [1537002063, 2003034995],
        [1747873779, 3602036899],
        [1955562222, 1575990012],
        [2024104815, 1125592928],
        [2227730452, 2716904306],
        [2361852424, 442776044],
        [2428436474, 593698344],
        [2756734187, 3733110249],
        [3204031479, 2999351573],
        [3329325298, 3815920427],
        [3391569614, 3928383900],
        [3515267271, 566280711],
        [3940187606, 3454069534],
        [4118630271, 4000239992],
        [116418474, 1914138554],
        [174292421, 2731055270],
        [289380356, 3203993006],
        [460393269, 320620315],
        [685471733, 587496836],
        [852142971, 1086792851],
        [1017036298, 365543100],
        [1126000580, 2618297676],
        [1288033470, 3409855158],
        [1501505948, 4234509866],
        [1607167915, 987167468],
        [1816402316, 1246189591]
      ];
      _states = {};
      _states["SHA-512"] = [
        [1779033703, 4089235720],
        [3144134277, 2227873595],
        [1013904242, 4271175723],
        [2773480762, 1595750129],
        [1359893119, 2917565137],
        [2600822924, 725511199],
        [528734635, 4215389547],
        [1541459225, 327033209]
      ];
      _states["SHA-384"] = [
        [3418070365, 3238371032],
        [1654270250, 914150663],
        [2438529370, 812702999],
        [355462360, 4144912697],
        [1731405415, 4290775857],
        [2394180231, 1750603025],
        [3675008525, 1694076839],
        [1203062813, 3204075428]
      ];
      _states["SHA-512/256"] = [
        [573645204, 4230739756],
        [2673172387, 3360449730],
        [596883563, 1867755857],
        [2520282905, 1497426621],
        [2519219938, 2827943907],
        [3193839141, 1401305490],
        [721525244, 746961066],
        [246885852, 2177182882]
      ];
      _states["SHA-512/224"] = [
        [2352822216, 424955298],
        [1944164710, 2312950998],
        [502970286, 855612546],
        [1738396948, 1479516111],
        [258812777, 2077511080],
        [2011393907, 79989058],
        [1067287976, 1780299464],
        [286451373, 2446758561]
      ];
      _initialized = true;
    }
    __name(_init, "_init");
    function _update(s, w2, bytes) {
      var t1_hi, t1_lo;
      var t2_hi, t2_lo;
      var s0_hi, s0_lo;
      var s1_hi, s1_lo;
      var ch_hi, ch_lo;
      var maj_hi, maj_lo;
      var a_hi, a_lo;
      var b_hi, b_lo;
      var c_hi, c_lo;
      var d_hi, d_lo;
      var e_hi, e_lo;
      var f_hi, f_lo;
      var g_hi, g_lo;
      var h_hi, h_lo;
      var i, hi, lo, w22, w7, w15, w16;
      var len = bytes.length();
      while (len >= 128) {
        for (i = 0; i < 16; ++i) {
          w2[i][0] = bytes.getInt32() >>> 0;
          w2[i][1] = bytes.getInt32() >>> 0;
        }
        for (; i < 80; ++i) {
          w22 = w2[i - 2];
          hi = w22[0];
          lo = w22[1];
          t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
          (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
          hi >>> 6) >>> 0;
          t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
          (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
          (hi << 26 | lo >>> 6)) >>> 0;
          w15 = w2[i - 15];
          hi = w15[0];
          lo = w15[1];
          t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
          (hi >>> 8 | lo << 24) ^ // ROTR 8
          hi >>> 7) >>> 0;
          t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
          (hi << 24 | lo >>> 8) ^ // ROTR 8
          (hi << 25 | lo >>> 7)) >>> 0;
          w7 = w2[i - 7];
          w16 = w2[i - 16];
          lo = t1_lo + w7[1] + t2_lo + w16[1];
          w2[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
          w2[i][1] = lo >>> 0;
        }
        a_hi = s[0][0];
        a_lo = s[0][1];
        b_hi = s[1][0];
        b_lo = s[1][1];
        c_hi = s[2][0];
        c_lo = s[2][1];
        d_hi = s[3][0];
        d_lo = s[3][1];
        e_hi = s[4][0];
        e_lo = s[4][1];
        f_hi = s[5][0];
        f_lo = s[5][1];
        g_hi = s[6][0];
        g_lo = s[6][1];
        h_hi = s[7][0];
        h_lo = s[7][1];
        for (i = 0; i < 80; ++i) {
          s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
          (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
          (e_lo >>> 9 | e_hi << 23)) >>> 0;
          s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
          (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
          (e_lo << 23 | e_hi >>> 9)) >>> 0;
          ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
          ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
          s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
          (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo >>> 7 | a_hi << 25)) >>> 0;
          s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
          (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
          (a_lo << 25 | a_hi >>> 7)) >>> 0;
          maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
          maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
          lo = h_lo + s1_lo + ch_lo + _k[i][1] + w2[i][1];
          t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w2[i][0] + (lo / 4294967296 >>> 0) >>> 0;
          t1_lo = lo >>> 0;
          lo = s0_lo + maj_lo;
          t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
          t2_lo = lo >>> 0;
          h_hi = g_hi;
          h_lo = g_lo;
          g_hi = f_hi;
          g_lo = f_lo;
          f_hi = e_hi;
          f_lo = e_lo;
          lo = d_lo + t1_lo;
          e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
          e_lo = lo >>> 0;
          d_hi = c_hi;
          d_lo = c_lo;
          c_hi = b_hi;
          c_lo = b_lo;
          b_hi = a_hi;
          b_lo = a_lo;
          lo = t1_lo + t2_lo;
          a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
          a_lo = lo >>> 0;
        }
        lo = s[0][1] + a_lo;
        s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[0][1] = lo >>> 0;
        lo = s[1][1] + b_lo;
        s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[1][1] = lo >>> 0;
        lo = s[2][1] + c_lo;
        s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[2][1] = lo >>> 0;
        lo = s[3][1] + d_lo;
        s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[3][1] = lo >>> 0;
        lo = s[4][1] + e_lo;
        s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[4][1] = lo >>> 0;
        lo = s[5][1] + f_lo;
        s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[5][1] = lo >>> 0;
        lo = s[6][1] + g_lo;
        s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[6][1] = lo >>> 0;
        lo = s[7][1] + h_lo;
        s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
        s[7][1] = lo >>> 0;
        len -= 128;
      }
    }
    __name(_update, "_update");
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS({
  "node_modules/node-forge/lib/asn1-validator.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_asn1();
    var asn1 = forge.asn1;
    exports.privateKeyValidator = {
      // PrivateKeyInfo
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        // Version (INTEGER)
        name: "PrivateKeyInfo.version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "privateKeyVersion"
      }, {
        // privateKeyAlgorithm
        name: "PrivateKeyInfo.privateKeyAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "privateKeyOid"
        }]
      }, {
        // PrivateKey
        name: "PrivateKeyInfo",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "privateKey"
      }]
    };
    exports.publicKeyValidator = {
      name: "SubjectPublicKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "subjectPublicKeyInfo",
      value: [
        {
          name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "AlgorithmIdentifier.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "publicKeyOid"
          }]
        },
        // capture group for ed25519PublicKey
        {
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          composed: true,
          captureBitStringValue: "ed25519PublicKey"
        }
        // FIXME: this is capture group for rsaPublicKey, use it in this API or
        // discard?
        /* {
          // subjectPublicKey
          name: 'SubjectPublicKeyInfo.subjectPublicKey',
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.BITSTRING,
          constructed: false,
          value: [{
            // RSAPublicKey
            name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SEQUENCE,
            constructed: true,
            optional: true,
            captureAsn1: 'rsaPublicKey'
          }]
        } */
      ]
    };
  }
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/node-forge/lib/ed25519.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_jsbn();
    require_random();
    require_sha512();
    require_util4();
    var asn1Validator = require_asn1_validator();
    var publicKeyValidator = asn1Validator.publicKeyValidator;
    var privateKeyValidator = asn1Validator.privateKeyValidator;
    if (typeof BigInteger === "undefined") {
      BigInteger = forge.jsbn.BigInteger;
    }
    var BigInteger;
    var ByteBuffer = forge.util.ByteBuffer;
    var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
    forge.pki = forge.pki || {};
    module.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
    var ed25519 = forge.ed25519;
    ed25519.constants = {};
    ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
    ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
    ed25519.constants.SEED_BYTE_LENGTH = 32;
    ed25519.constants.SIGN_BYTE_LENGTH = 64;
    ed25519.constants.HASH_BYTE_LENGTH = 64;
    ed25519.generateKeyPair = function(options) {
      options = options || {};
      var seed = options.seed;
      if (seed === void 0) {
        seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
      } else if (typeof seed === "string") {
        if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
          throw new TypeError(
            '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
          );
        }
      } else if (!(seed instanceof Uint8Array)) {
        throw new TypeError(
          '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
        );
      }
      seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
      for (var i = 0; i < 32; ++i) {
        sk[i] = seed[i];
      }
      crypto_sign_keypair(pk, sk);
      return { publicKey: pk, privateKey: sk };
    };
    ed25519.privateKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
      if (!valid) {
        var error3 = new Error("Invalid Key.");
        error3.errors = errors;
        throw error3;
      }
      var oid = forge.asn1.derToOid(capture.privateKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var privateKey = capture.privateKey;
      var privateKeyBytes = messageToNativeBuffer({
        message: forge.asn1.fromDer(privateKey).value,
        encoding: "binary"
      });
      return { privateKeyBytes };
    };
    ed25519.publicKeyFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
      if (!valid) {
        var error3 = new Error("Invalid Key.");
        error3.errors = errors;
        throw error3;
      }
      var oid = forge.asn1.derToOid(capture.publicKeyOid);
      var ed25519Oid = forge.oids.EdDSA25519;
      if (oid !== ed25519Oid) {
        throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
      }
      var publicKeyBytes = capture.ed25519PublicKey;
      if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new Error("Key length is invalid.");
      }
      return messageToNativeBuffer({
        message: publicKeyBytes,
        encoding: "binary"
      });
    };
    ed25519.publicKeyFromPrivateKey = function(options) {
      options = options || {};
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
      for (var i = 0; i < pk.length; ++i) {
        pk[i] = privateKey[32 + i];
      }
      return pk;
    };
    ed25519.sign = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      var privateKey = messageToNativeBuffer({
        message: options.privateKey,
        encoding: "binary"
      });
      if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
        var keyPair = ed25519.generateKeyPair({ seed: privateKey });
        privateKey = keyPair.privateKey;
      } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
        );
      }
      var signedMsg = new NativeBuffer(
        ed25519.constants.SIGN_BYTE_LENGTH + msg.length
      );
      crypto_sign(signedMsg, msg, msg.length, privateKey);
      var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
      for (var i = 0; i < sig.length; ++i) {
        sig[i] = signedMsg[i];
      }
      return sig;
    };
    ed25519.verify = function(options) {
      options = options || {};
      var msg = messageToNativeBuffer(options);
      if (options.signature === void 0) {
        throw new TypeError(
          '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
        );
      }
      var sig = messageToNativeBuffer({
        message: options.signature,
        encoding: "binary"
      });
      if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
        throw new TypeError(
          '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
        );
      }
      var publicKey = messageToNativeBuffer({
        message: options.publicKey,
        encoding: "binary"
      });
      if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
        throw new TypeError(
          '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
        );
      }
      var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var m2 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
      var i;
      for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
        sm[i] = sig[i];
      }
      for (i = 0; i < msg.length; ++i) {
        sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
      }
      return crypto_sign_open(m2, sm, sm.length, publicKey) >= 0;
    };
    function messageToNativeBuffer(options) {
      var message2 = options.message;
      if (message2 instanceof Uint8Array || message2 instanceof NativeBuffer) {
        return message2;
      }
      var encoding = options.encoding;
      if (message2 === void 0) {
        if (options.md) {
          message2 = options.md.digest().getBytes();
          encoding = "binary";
        } else {
          throw new TypeError('"options.message" or "options.md" not specified.');
        }
      }
      if (typeof message2 === "string" && !encoding) {
        throw new TypeError('"options.encoding" must be "binary" or "utf8".');
      }
      if (typeof message2 === "string") {
        if (typeof Buffer !== "undefined") {
          return Buffer.from(message2, encoding);
        }
        message2 = new ByteBuffer(message2, encoding);
      } else if (!(message2 instanceof ByteBuffer)) {
        throw new TypeError(
          '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
        );
      }
      var buffer = new NativeBuffer(message2.length());
      for (var i = 0; i < buffer.length; ++i) {
        buffer[i] = message2.at(i);
      }
      return buffer;
    }
    __name(messageToNativeBuffer, "messageToNativeBuffer");
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      30883,
      4953,
      19914,
      30187,
      55467,
      16705,
      2637,
      112,
      59544,
      30585,
      16505,
      36039,
      65139,
      11119,
      27886,
      20995
    ]);
    var D22 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    var I2 = gf([
      41136,
      18958,
      6951,
      50414,
      58488,
      44335,
      6150,
      12099,
      55207,
      15867,
      153,
      11085,
      57099,
      20417,
      9344,
      11139
    ]);
    function sha512(msg, msgLen) {
      var md = forge.md.sha512.create();
      var buffer = new ByteBuffer(msg);
      md.update(buffer.getBytes(msgLen), "binary");
      var hash2 = md.digest().getBytes();
      if (typeof Buffer !== "undefined") {
        return Buffer.from(hash2, "binary");
      }
      var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
      for (var i = 0; i < 64; ++i) {
        out[i] = hash2.charCodeAt(i);
      }
      return out;
    }
    __name(sha512, "sha512");
    function crypto_sign_keypair(pk, sk) {
      var p2 = [gf(), gf(), gf(), gf()];
      var i;
      var d2 = sha512(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      scalarbase(p2, d2);
      pack(pk, p2);
      for (i = 0; i < 32; ++i) {
        sk[i + 32] = pk[i];
      }
      return 0;
    }
    __name(crypto_sign_keypair, "crypto_sign_keypair");
    function crypto_sign(sm, m2, n, sk) {
      var i, j, x = new Float64Array(64);
      var p2 = [gf(), gf(), gf(), gf()];
      var d2 = sha512(sk, 32);
      d2[0] &= 248;
      d2[31] &= 127;
      d2[31] |= 64;
      var smlen = n + 64;
      for (i = 0; i < n; ++i) {
        sm[64 + i] = m2[i];
      }
      for (i = 0; i < 32; ++i) {
        sm[32 + i] = d2[32 + i];
      }
      var r = sha512(sm.subarray(32), n + 32);
      reduce(r);
      scalarbase(p2, r);
      pack(sm, p2);
      for (i = 32; i < 64; ++i) {
        sm[i] = sk[i];
      }
      var h = sha512(sm, n + 64);
      reduce(h);
      for (i = 32; i < 64; ++i) {
        x[i] = 0;
      }
      for (i = 0; i < 32; ++i) {
        x[i] = r[i];
      }
      for (i = 0; i < 32; ++i) {
        for (j = 0; j < 32; j++) {
          x[i + j] += h[i] * d2[j];
        }
      }
      modL(sm.subarray(32), x);
      return smlen;
    }
    __name(crypto_sign, "crypto_sign");
    function crypto_sign_open(m2, sm, n, pk) {
      var i, mlen;
      var t = new NativeBuffer(32);
      var p2 = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
      mlen = -1;
      if (n < 64) {
        return -1;
      }
      if (unpackneg(q, pk)) {
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m2[i] = sm[i];
      }
      for (i = 0; i < 32; ++i) {
        m2[i + 32] = pk[i];
      }
      var h = sha512(m2, n);
      reduce(h);
      scalarmult(p2, q, h);
      scalarbase(q, sm.subarray(32));
      add(p2, q);
      pack(t, p2);
      n -= 64;
      if (crypto_verify_32(sm, 0, t, 0)) {
        for (i = 0; i < n; ++i) {
          m2[i] = 0;
        }
        return -1;
      }
      for (i = 0; i < n; ++i) {
        m2[i] = sm[i + 64];
      }
      mlen = n;
      return mlen;
    }
    __name(crypto_sign_open, "crypto_sign_open");
    function modL(r, x) {
      var carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; ++j) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; ++j) {
        x[j] -= carry * L[j];
      }
      for (i = 0; i < 32; ++i) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    __name(modL, "modL");
    function reduce(r) {
      var x = new Float64Array(64);
      for (var i = 0; i < 64; ++i) {
        x[i] = r[i];
        r[i] = 0;
      }
      modL(r, x);
    }
    __name(reduce, "reduce");
    function add(p2, q) {
      var a2 = gf(), b2 = gf(), c = gf(), d2 = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a2, p2[1], p2[0]);
      Z(t, q[1], q[0]);
      M(a2, a2, t);
      A(b2, p2[0], p2[1]);
      A(t, q[0], q[1]);
      M(b2, b2, t);
      M(c, p2[3], q[3]);
      M(c, c, D22);
      M(d2, p2[2], q[2]);
      A(d2, d2, d2);
      Z(e, b2, a2);
      Z(f, d2, c);
      A(g, d2, c);
      A(h, b2, a2);
      M(p2[0], e, f);
      M(p2[1], h, g);
      M(p2[2], g, f);
      M(p2[3], e, h);
    }
    __name(add, "add");
    function cswap(p2, q, b2) {
      for (var i = 0; i < 4; ++i) {
        sel25519(p2[i], q[i], b2);
      }
    }
    __name(cswap, "cswap");
    function pack(r, p2) {
      var tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p2[2]);
      M(tx, p2[0], zi);
      M(ty, p2[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    __name(pack, "pack");
    function pack25519(o, n) {
      var i, j, b2;
      var m2 = gf(), t = gf();
      for (i = 0; i < 16; ++i) {
        t[i] = n[i];
      }
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; ++j) {
        m2[0] = t[0] - 65517;
        for (i = 1; i < 15; ++i) {
          m2[i] = t[i] - 65535 - (m2[i - 1] >> 16 & 1);
          m2[i - 1] &= 65535;
        }
        m2[15] = t[15] - 32767 - (m2[14] >> 16 & 1);
        b2 = m2[15] >> 16 & 1;
        m2[14] &= 65535;
        sel25519(t, m2, 1 - b2);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    __name(pack25519, "pack25519");
    function unpackneg(r, p2) {
      var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
      set25519(r[2], gf1);
      unpack25519(r[1], p2);
      S2(num, r[1]);
      M(den, num, D2);
      Z(num, num, r[2]);
      A(den, r[2], den);
      S2(den2, den);
      S2(den4, den2);
      M(den6, den4, den2);
      M(t, den6, num);
      M(t, t, den);
      pow2523(t, t);
      M(t, t, num);
      M(t, t, den);
      M(t, t, den);
      M(r[0], t, den);
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        M(r[0], r[0], I2);
      }
      S2(chk, r[0]);
      M(chk, chk, den);
      if (neq25519(chk, num)) {
        return -1;
      }
      if (par25519(r[0]) === p2[31] >> 7) {
        Z(r[0], gf0, r[0]);
      }
      M(r[3], r[0], r[1]);
      return 0;
    }
    __name(unpackneg, "unpackneg");
    function unpack25519(o, n) {
      var i;
      for (i = 0; i < 16; ++i) {
        o[i] = n[2 * i] + (n[2 * i + 1] << 8);
      }
      o[15] &= 32767;
    }
    __name(unpack25519, "unpack25519");
    function pow2523(o, i) {
      var c = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c[a2] = i[a2];
      }
      for (a2 = 250; a2 >= 0; --a2) {
        S2(c, c);
        if (a2 !== 1) {
          M(c, c, i);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o[a2] = c[a2];
      }
    }
    __name(pow2523, "pow2523");
    function neq25519(a2, b2) {
      var c = new NativeBuffer(32);
      var d2 = new NativeBuffer(32);
      pack25519(c, a2);
      pack25519(d2, b2);
      return crypto_verify_32(c, 0, d2, 0);
    }
    __name(neq25519, "neq25519");
    function crypto_verify_32(x, xi2, y, yi2) {
      return vn2(x, xi2, y, yi2, 32);
    }
    __name(crypto_verify_32, "crypto_verify_32");
    function vn2(x, xi2, y, yi2, n) {
      var i, d2 = 0;
      for (i = 0; i < n; ++i) {
        d2 |= x[xi2 + i] ^ y[yi2 + i];
      }
      return (1 & d2 - 1 >>> 8) - 1;
    }
    __name(vn2, "vn");
    function par25519(a2) {
      var d2 = new NativeBuffer(32);
      pack25519(d2, a2);
      return d2[0] & 1;
    }
    __name(par25519, "par25519");
    function scalarmult(p2, q, s) {
      var b2, i;
      set25519(p2[0], gf0);
      set25519(p2[1], gf1);
      set25519(p2[2], gf1);
      set25519(p2[3], gf0);
      for (i = 255; i >= 0; --i) {
        b2 = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p2, q, b2);
        add(q, p2);
        add(p2, p2);
        cswap(p2, q, b2);
      }
    }
    __name(scalarmult, "scalarmult");
    function scalarbase(p2, s) {
      var q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p2, q, s);
    }
    __name(scalarbase, "scalarbase");
    function set25519(r, a2) {
      var i;
      for (i = 0; i < 16; i++) {
        r[i] = a2[i] | 0;
      }
    }
    __name(set25519, "set25519");
    function inv25519(o, i) {
      var c = gf();
      var a2;
      for (a2 = 0; a2 < 16; ++a2) {
        c[a2] = i[a2];
      }
      for (a2 = 253; a2 >= 0; --a2) {
        S2(c, c);
        if (a2 !== 2 && a2 !== 4) {
          M(c, c, i);
        }
      }
      for (a2 = 0; a2 < 16; ++a2) {
        o[a2] = c[a2];
      }
    }
    __name(inv25519, "inv25519");
    function car25519(o) {
      var i, v2, c = 1;
      for (i = 0; i < 16; ++i) {
        v2 = o[i] + c + 65535;
        c = Math.floor(v2 / 65536);
        o[i] = v2 - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    __name(car25519, "car25519");
    function sel25519(p2, q, b2) {
      var t, c = ~(b2 - 1);
      for (var i = 0; i < 16; ++i) {
        t = c & (p2[i] ^ q[i]);
        p2[i] ^= t;
        q[i] ^= t;
      }
    }
    __name(sel25519, "sel25519");
    function gf(init) {
      var i, r = new Float64Array(16);
      if (init) {
        for (i = 0; i < init.length; ++i) {
          r[i] = init[i];
        }
      }
      return r;
    }
    __name(gf, "gf");
    function A(o, a2, b2) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a2[i] + b2[i];
      }
    }
    __name(A, "A");
    function Z(o, a2, b2) {
      for (var i = 0; i < 16; ++i) {
        o[i] = a2[i] - b2[i];
      }
    }
    __name(Z, "Z");
    function S2(o, a2) {
      M(o, a2, a2);
    }
    __name(S2, "S");
    function M(o, a2, b2) {
      var v2, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b2[0], b1 = b2[1], b22 = b2[2], b3 = b2[3], b4 = b2[4], b5 = b2[5], b6 = b2[6], b7 = b2[7], b8 = b2[8], b9 = b2[9], b10 = b2[10], b11 = b2[11], b12 = b2[12], b13 = b2[13], b14 = b2[14], b15 = b2[15];
      v2 = a2[0];
      t0 += v2 * b0;
      t1 += v2 * b1;
      t2 += v2 * b22;
      t3 += v2 * b3;
      t4 += v2 * b4;
      t5 += v2 * b5;
      t6 += v2 * b6;
      t7 += v2 * b7;
      t8 += v2 * b8;
      t9 += v2 * b9;
      t10 += v2 * b10;
      t11 += v2 * b11;
      t12 += v2 * b12;
      t13 += v2 * b13;
      t14 += v2 * b14;
      t15 += v2 * b15;
      v2 = a2[1];
      t1 += v2 * b0;
      t2 += v2 * b1;
      t3 += v2 * b22;
      t4 += v2 * b3;
      t5 += v2 * b4;
      t6 += v2 * b5;
      t7 += v2 * b6;
      t8 += v2 * b7;
      t9 += v2 * b8;
      t10 += v2 * b9;
      t11 += v2 * b10;
      t12 += v2 * b11;
      t13 += v2 * b12;
      t14 += v2 * b13;
      t15 += v2 * b14;
      t16 += v2 * b15;
      v2 = a2[2];
      t2 += v2 * b0;
      t3 += v2 * b1;
      t4 += v2 * b22;
      t5 += v2 * b3;
      t6 += v2 * b4;
      t7 += v2 * b5;
      t8 += v2 * b6;
      t9 += v2 * b7;
      t10 += v2 * b8;
      t11 += v2 * b9;
      t12 += v2 * b10;
      t13 += v2 * b11;
      t14 += v2 * b12;
      t15 += v2 * b13;
      t16 += v2 * b14;
      t17 += v2 * b15;
      v2 = a2[3];
      t3 += v2 * b0;
      t4 += v2 * b1;
      t5 += v2 * b22;
      t6 += v2 * b3;
      t7 += v2 * b4;
      t8 += v2 * b5;
      t9 += v2 * b6;
      t10 += v2 * b7;
      t11 += v2 * b8;
      t12 += v2 * b9;
      t13 += v2 * b10;
      t14 += v2 * b11;
      t15 += v2 * b12;
      t16 += v2 * b13;
      t17 += v2 * b14;
      t18 += v2 * b15;
      v2 = a2[4];
      t4 += v2 * b0;
      t5 += v2 * b1;
      t6 += v2 * b22;
      t7 += v2 * b3;
      t8 += v2 * b4;
      t9 += v2 * b5;
      t10 += v2 * b6;
      t11 += v2 * b7;
      t12 += v2 * b8;
      t13 += v2 * b9;
      t14 += v2 * b10;
      t15 += v2 * b11;
      t16 += v2 * b12;
      t17 += v2 * b13;
      t18 += v2 * b14;
      t19 += v2 * b15;
      v2 = a2[5];
      t5 += v2 * b0;
      t6 += v2 * b1;
      t7 += v2 * b22;
      t8 += v2 * b3;
      t9 += v2 * b4;
      t10 += v2 * b5;
      t11 += v2 * b6;
      t12 += v2 * b7;
      t13 += v2 * b8;
      t14 += v2 * b9;
      t15 += v2 * b10;
      t16 += v2 * b11;
      t17 += v2 * b12;
      t18 += v2 * b13;
      t19 += v2 * b14;
      t20 += v2 * b15;
      v2 = a2[6];
      t6 += v2 * b0;
      t7 += v2 * b1;
      t8 += v2 * b22;
      t9 += v2 * b3;
      t10 += v2 * b4;
      t11 += v2 * b5;
      t12 += v2 * b6;
      t13 += v2 * b7;
      t14 += v2 * b8;
      t15 += v2 * b9;
      t16 += v2 * b10;
      t17 += v2 * b11;
      t18 += v2 * b12;
      t19 += v2 * b13;
      t20 += v2 * b14;
      t21 += v2 * b15;
      v2 = a2[7];
      t7 += v2 * b0;
      t8 += v2 * b1;
      t9 += v2 * b22;
      t10 += v2 * b3;
      t11 += v2 * b4;
      t12 += v2 * b5;
      t13 += v2 * b6;
      t14 += v2 * b7;
      t15 += v2 * b8;
      t16 += v2 * b9;
      t17 += v2 * b10;
      t18 += v2 * b11;
      t19 += v2 * b12;
      t20 += v2 * b13;
      t21 += v2 * b14;
      t22 += v2 * b15;
      v2 = a2[8];
      t8 += v2 * b0;
      t9 += v2 * b1;
      t10 += v2 * b22;
      t11 += v2 * b3;
      t12 += v2 * b4;
      t13 += v2 * b5;
      t14 += v2 * b6;
      t15 += v2 * b7;
      t16 += v2 * b8;
      t17 += v2 * b9;
      t18 += v2 * b10;
      t19 += v2 * b11;
      t20 += v2 * b12;
      t21 += v2 * b13;
      t22 += v2 * b14;
      t23 += v2 * b15;
      v2 = a2[9];
      t9 += v2 * b0;
      t10 += v2 * b1;
      t11 += v2 * b22;
      t12 += v2 * b3;
      t13 += v2 * b4;
      t14 += v2 * b5;
      t15 += v2 * b6;
      t16 += v2 * b7;
      t17 += v2 * b8;
      t18 += v2 * b9;
      t19 += v2 * b10;
      t20 += v2 * b11;
      t21 += v2 * b12;
      t22 += v2 * b13;
      t23 += v2 * b14;
      t24 += v2 * b15;
      v2 = a2[10];
      t10 += v2 * b0;
      t11 += v2 * b1;
      t12 += v2 * b22;
      t13 += v2 * b3;
      t14 += v2 * b4;
      t15 += v2 * b5;
      t16 += v2 * b6;
      t17 += v2 * b7;
      t18 += v2 * b8;
      t19 += v2 * b9;
      t20 += v2 * b10;
      t21 += v2 * b11;
      t22 += v2 * b12;
      t23 += v2 * b13;
      t24 += v2 * b14;
      t25 += v2 * b15;
      v2 = a2[11];
      t11 += v2 * b0;
      t12 += v2 * b1;
      t13 += v2 * b22;
      t14 += v2 * b3;
      t15 += v2 * b4;
      t16 += v2 * b5;
      t17 += v2 * b6;
      t18 += v2 * b7;
      t19 += v2 * b8;
      t20 += v2 * b9;
      t21 += v2 * b10;
      t22 += v2 * b11;
      t23 += v2 * b12;
      t24 += v2 * b13;
      t25 += v2 * b14;
      t26 += v2 * b15;
      v2 = a2[12];
      t12 += v2 * b0;
      t13 += v2 * b1;
      t14 += v2 * b22;
      t15 += v2 * b3;
      t16 += v2 * b4;
      t17 += v2 * b5;
      t18 += v2 * b6;
      t19 += v2 * b7;
      t20 += v2 * b8;
      t21 += v2 * b9;
      t22 += v2 * b10;
      t23 += v2 * b11;
      t24 += v2 * b12;
      t25 += v2 * b13;
      t26 += v2 * b14;
      t27 += v2 * b15;
      v2 = a2[13];
      t13 += v2 * b0;
      t14 += v2 * b1;
      t15 += v2 * b22;
      t16 += v2 * b3;
      t17 += v2 * b4;
      t18 += v2 * b5;
      t19 += v2 * b6;
      t20 += v2 * b7;
      t21 += v2 * b8;
      t22 += v2 * b9;
      t23 += v2 * b10;
      t24 += v2 * b11;
      t25 += v2 * b12;
      t26 += v2 * b13;
      t27 += v2 * b14;
      t28 += v2 * b15;
      v2 = a2[14];
      t14 += v2 * b0;
      t15 += v2 * b1;
      t16 += v2 * b22;
      t17 += v2 * b3;
      t18 += v2 * b4;
      t19 += v2 * b5;
      t20 += v2 * b6;
      t21 += v2 * b7;
      t22 += v2 * b8;
      t23 += v2 * b9;
      t24 += v2 * b10;
      t25 += v2 * b11;
      t26 += v2 * b12;
      t27 += v2 * b13;
      t28 += v2 * b14;
      t29 += v2 * b15;
      v2 = a2[15];
      t15 += v2 * b0;
      t16 += v2 * b1;
      t17 += v2 * b22;
      t18 += v2 * b3;
      t19 += v2 * b4;
      t20 += v2 * b5;
      t21 += v2 * b6;
      t22 += v2 * b7;
      t23 += v2 * b8;
      t24 += v2 * b9;
      t25 += v2 * b10;
      t26 += v2 * b11;
      t27 += v2 * b12;
      t28 += v2 * b13;
      t29 += v2 * b14;
      t30 += v2 * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v2 = t0 + c + 65535;
      c = Math.floor(v2 / 65536);
      t0 = v2 - c * 65536;
      v2 = t1 + c + 65535;
      c = Math.floor(v2 / 65536);
      t1 = v2 - c * 65536;
      v2 = t2 + c + 65535;
      c = Math.floor(v2 / 65536);
      t2 = v2 - c * 65536;
      v2 = t3 + c + 65535;
      c = Math.floor(v2 / 65536);
      t3 = v2 - c * 65536;
      v2 = t4 + c + 65535;
      c = Math.floor(v2 / 65536);
      t4 = v2 - c * 65536;
      v2 = t5 + c + 65535;
      c = Math.floor(v2 / 65536);
      t5 = v2 - c * 65536;
      v2 = t6 + c + 65535;
      c = Math.floor(v2 / 65536);
      t6 = v2 - c * 65536;
      v2 = t7 + c + 65535;
      c = Math.floor(v2 / 65536);
      t7 = v2 - c * 65536;
      v2 = t8 + c + 65535;
      c = Math.floor(v2 / 65536);
      t8 = v2 - c * 65536;
      v2 = t9 + c + 65535;
      c = Math.floor(v2 / 65536);
      t9 = v2 - c * 65536;
      v2 = t10 + c + 65535;
      c = Math.floor(v2 / 65536);
      t10 = v2 - c * 65536;
      v2 = t11 + c + 65535;
      c = Math.floor(v2 / 65536);
      t11 = v2 - c * 65536;
      v2 = t12 + c + 65535;
      c = Math.floor(v2 / 65536);
      t12 = v2 - c * 65536;
      v2 = t13 + c + 65535;
      c = Math.floor(v2 / 65536);
      t13 = v2 - c * 65536;
      v2 = t14 + c + 65535;
      c = Math.floor(v2 / 65536);
      t14 = v2 - c * 65536;
      v2 = t15 + c + 65535;
      c = Math.floor(v2 / 65536);
      t15 = v2 - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    __name(M, "M");
  }
});

// node_modules/node-forge/lib/kem.js
var require_kem = __commonJS({
  "node_modules/node-forge/lib/kem.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    require_random();
    require_jsbn();
    module.exports = forge.kem = forge.kem || {};
    var BigInteger = forge.jsbn.BigInteger;
    forge.kem.rsa = {};
    forge.kem.rsa.create = function(kdf, options) {
      options = options || {};
      var prng = options.prng || forge.random;
      var kem = {};
      kem.encrypt = function(publicKey, keyLength) {
        var byteLength = Math.ceil(publicKey.n.bitLength() / 8);
        var r;
        do {
          r = new BigInteger(
            forge.util.bytesToHex(prng.getBytesSync(byteLength)),
            16
          ).mod(publicKey.n);
        } while (r.compareTo(BigInteger.ONE) <= 0);
        r = forge.util.hexToBytes(r.toString(16));
        var zeros = byteLength - r.length;
        if (zeros > 0) {
          r = forge.util.fillString(String.fromCharCode(0), zeros) + r;
        }
        var encapsulation = publicKey.encrypt(r, "NONE");
        var key = kdf.generate(r, keyLength);
        return { encapsulation, key };
      };
      kem.decrypt = function(privateKey, encapsulation, keyLength) {
        var r = privateKey.decrypt(encapsulation, "NONE");
        return kdf.generate(r, keyLength);
      };
      return kem;
    };
    forge.kem.kdf1 = function(md, digestLength) {
      _createKDF(this, md, 0, digestLength || md.digestLength);
    };
    forge.kem.kdf2 = function(md, digestLength) {
      _createKDF(this, md, 1, digestLength || md.digestLength);
    };
    function _createKDF(kdf, md, counterStart, digestLength) {
      kdf.generate = function(x, length) {
        var key = new forge.util.ByteBuffer();
        var k = Math.ceil(length / digestLength) + counterStart;
        var c = new forge.util.ByteBuffer();
        for (var i = counterStart; i < k; ++i) {
          c.putInt32(i);
          md.start();
          md.update(x + c.getBytes());
          var hash2 = md.digest();
          key.putBytes(hash2.getBytes(digestLength));
        }
        key.truncate(key.length() - length);
        return key.getBytes();
      };
    }
    __name(_createKDF, "_createKDF");
  }
});

// node_modules/node-forge/lib/log.js
var require_log = __commonJS({
  "node_modules/node-forge/lib/log.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_util4();
    module.exports = forge.log = forge.log || {};
    forge.log.levels = [
      "none",
      "error",
      "warning",
      "info",
      "debug",
      "verbose",
      "max"
    ];
    var sLevelInfo = {};
    var sLoggers = [];
    var sConsoleLogger = null;
    forge.log.LEVEL_LOCKED = 1 << 1;
    forge.log.NO_LEVEL_CHECK = 1 << 2;
    forge.log.INTERPOLATE = 1 << 3;
    for (i = 0; i < forge.log.levels.length; ++i) {
      level = forge.log.levels[i];
      sLevelInfo[level] = {
        index: i,
        name: level.toUpperCase()
      };
    }
    var level;
    var i;
    forge.log.logMessage = function(message2) {
      var messageLevelIndex = sLevelInfo[message2.level].index;
      for (var i2 = 0; i2 < sLoggers.length; ++i2) {
        var logger2 = sLoggers[i2];
        if (logger2.flags & forge.log.NO_LEVEL_CHECK) {
          logger2.f(message2);
        } else {
          var loggerLevelIndex = sLevelInfo[logger2.level].index;
          if (messageLevelIndex <= loggerLevelIndex) {
            logger2.f(logger2, message2);
          }
        }
      }
    };
    forge.log.prepareStandard = function(message2) {
      if (!("standard" in message2)) {
        message2.standard = sLevelInfo[message2.level].name + //' ' + +message.timestamp +
        " [" + message2.category + "] " + message2.message;
      }
    };
    forge.log.prepareFull = function(message2) {
      if (!("full" in message2)) {
        var args = [message2.message];
        args = args.concat([]);
        message2.full = forge.util.format.apply(this, args);
      }
    };
    forge.log.prepareStandardFull = function(message2) {
      if (!("standardFull" in message2)) {
        forge.log.prepareStandard(message2);
        message2.standardFull = message2.standard;
      }
    };
    if (true) {
      levels = ["error", "warning", "info", "debug", "verbose"];
      for (i = 0; i < levels.length; ++i) {
        (function(level2) {
          forge.log[level2] = function(category, message2) {
            var args = Array.prototype.slice.call(arguments).slice(2);
            var msg = {
              timestamp: /* @__PURE__ */ new Date(),
              level: level2,
              category,
              message: message2,
              "arguments": args
              /*standard*/
              /*full*/
              /*fullMessage*/
            };
            forge.log.logMessage(msg);
          };
        })(levels[i]);
      }
    }
    var levels;
    var i;
    forge.log.makeLogger = function(logFunction) {
      var logger2 = {
        flags: 0,
        f: logFunction
      };
      forge.log.setLevel(logger2, "none");
      return logger2;
    };
    forge.log.setLevel = function(logger2, level2) {
      var rval = false;
      if (logger2 && !(logger2.flags & forge.log.LEVEL_LOCKED)) {
        for (var i2 = 0; i2 < forge.log.levels.length; ++i2) {
          var aValidLevel = forge.log.levels[i2];
          if (level2 == aValidLevel) {
            logger2.level = level2;
            rval = true;
            break;
          }
        }
      }
      return rval;
    };
    forge.log.lock = function(logger2, lock2) {
      if (typeof lock2 === "undefined" || lock2) {
        logger2.flags |= forge.log.LEVEL_LOCKED;
      } else {
        logger2.flags &= ~forge.log.LEVEL_LOCKED;
      }
    };
    forge.log.addLogger = function(logger2) {
      sLoggers.push(logger2);
    };
    if (typeof console !== "undefined" && "log" in console) {
      if (console.error && console.warn && console.info && console.debug) {
        levelHandlers = {
          error: console.error,
          warning: console.warn,
          info: console.info,
          debug: console.debug,
          verbose: console.debug
        };
        f = /* @__PURE__ */ __name(function(logger2, message2) {
          forge.log.prepareStandard(message2);
          var handler = levelHandlers[message2.level];
          var args = [message2.standard];
          args = args.concat(message2["arguments"].slice());
          handler.apply(console, args);
        }, "f");
        logger = forge.log.makeLogger(f);
      } else {
        f = /* @__PURE__ */ __name(function(logger2, message2) {
          forge.log.prepareStandardFull(message2);
          console.log(message2.standardFull);
        }, "f");
        logger = forge.log.makeLogger(f);
      }
      forge.log.setLevel(logger, "debug");
      forge.log.addLogger(logger);
      sConsoleLogger = logger;
    } else {
      console = {
        log: /* @__PURE__ */ __name(function() {
        }, "log")
      };
    }
    var logger;
    var levelHandlers;
    var f;
    if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
      query = new URL(window.location.href).searchParams;
      if (query.has("console.level")) {
        forge.log.setLevel(
          sConsoleLogger,
          query.get("console.level").slice(-1)[0]
        );
      }
      if (query.has("console.lock")) {
        lock = query.get("console.lock").slice(-1)[0];
        if (lock == "true") {
          forge.log.lock(sConsoleLogger);
        }
      }
    }
    var query;
    var lock;
    forge.log.consoleLogger = sConsoleLogger;
  }
});

// node_modules/node-forge/lib/md.all.js
var require_md_all = __commonJS({
  "node_modules/node-forge/lib/md.all.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_md();
    require_md52();
    require_sha12();
    require_sha256();
    require_sha512();
  }
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS({
  "node_modules/node-forge/lib/pkcs7.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_asn1();
    require_des();
    require_oids();
    require_pem();
    require_pkcs7asn1();
    require_random();
    require_util4();
    require_x509();
    var asn1 = forge.asn1;
    var p7 = module.exports = forge.pkcs7 = forge.pkcs7 || {};
    p7.messageFromPem = function(pem) {
      var msg = forge.pem.decode(pem)[0];
      if (msg.type !== "PKCS7") {
        var error3 = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
        error3.headerType = msg.type;
        throw error3;
      }
      if (msg.procType && msg.procType.type === "ENCRYPTED") {
        throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
      }
      var obj = asn1.fromDer(msg.body);
      return p7.messageFromAsn1(obj);
    };
    p7.messageToPem = function(msg, maxline) {
      var pemObj = {
        type: "PKCS7",
        body: asn1.toDer(msg.toAsn1()).getBytes()
      };
      return forge.pem.encode(pemObj, { maxline });
    };
    p7.messageFromAsn1 = function(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
        var error3 = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
        error3.errors = errors;
        throw error3;
      }
      var contentType = asn1.derToOid(capture.contentType);
      var msg;
      switch (contentType) {
        case forge.pki.oids.envelopedData:
          msg = p7.createEnvelopedData();
          break;
        case forge.pki.oids.encryptedData:
          msg = p7.createEncryptedData();
          break;
        case forge.pki.oids.signedData:
          msg = p7.createSignedData();
          break;
        default:
          throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
      }
      msg.fromAsn1(capture.content.value[0]);
      return msg;
    };
    p7.createSignedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.signedData,
        version: 1,
        certificates: [],
        crls: [],
        // TODO: add json-formatted signer stuff here?
        signers: [],
        // populated during sign()
        digestAlgorithmIdentifiers: [],
        contentInfo: null,
        signerInfos: [],
        fromAsn1: /* @__PURE__ */ __name(function(obj) {
          _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
          msg.certificates = [];
          msg.crls = [];
          msg.digestAlgorithmIdentifiers = [];
          msg.contentInfo = null;
          msg.signerInfos = [];
          if (msg.rawCapture.certificates) {
            var certs = msg.rawCapture.certificates.value;
            for (var i = 0; i < certs.length; ++i) {
              msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
            }
          }
        }, "fromAsn1"),
        toAsn1: /* @__PURE__ */ __name(function() {
          if (!msg.contentInfo) {
            msg.sign();
          }
          var certs = [];
          for (var i = 0; i < msg.certificates.length; ++i) {
            certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
          }
          var crls = [];
          var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // Version
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.INTEGER,
                false,
                asn1.integerToDer(msg.version).getBytes()
              ),
              // DigestAlgorithmIdentifiers
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.SET,
                true,
                msg.digestAlgorithmIdentifiers
              ),
              // ContentInfo
              msg.contentInfo
            ])
          ]);
          if (certs.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
            );
          }
          if (crls.length > 0) {
            signedData.value[0].value.push(
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
            );
          }
          signedData.value[0].value.push(
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              msg.signerInfos
            )
          );
          return asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SEQUENCE,
            true,
            [
              // ContentType
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(msg.type).getBytes()
              ),
              // [0] SignedData
              signedData
            ]
          );
        }, "toAsn1"),
        /**
         * Add (another) entity to list of signers.
         *
         * Note: If authenticatedAttributes are provided, then, per RFC 2315,
         * they must include at least two attributes: content type and
         * message digest. The message digest attribute value will be
         * auto-calculated during signing and will be ignored if provided.
         *
         * Here's an example of providing these two attributes:
         *
         * forge.pkcs7.createSignedData();
         * p7.addSigner({
         *   issuer: cert.issuer.attributes,
         *   serialNumber: cert.serialNumber,
         *   key: privateKey,
         *   digestAlgorithm: forge.pki.oids.sha1,
         *   authenticatedAttributes: [{
         *     type: forge.pki.oids.contentType,
         *     value: forge.pki.oids.data
         *   }, {
         *     type: forge.pki.oids.messageDigest
         *   }]
         * });
         *
         * TODO: Support [subjectKeyIdentifier] as signer's ID.
         *
         * @param signer the signer information:
         *          key the signer's private key.
         *          [certificate] a certificate containing the public key
         *            associated with the signer's private key; use this option as
         *            an alternative to specifying signer.issuer and
         *            signer.serialNumber.
         *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
         *          [serialNumber] the signer's certificate's serial number in
         *           hexadecimal (eg: cert.serialNumber).
         *          [digestAlgorithm] the message digest OID, as a string, to use
         *            (eg: forge.pki.oids.sha1).
         *          [authenticatedAttributes] an optional array of attributes
         *            to also sign along with the content.
         */
        addSigner: /* @__PURE__ */ __name(function(signer) {
          var issuer = signer.issuer;
          var serialNumber = signer.serialNumber;
          if (signer.certificate) {
            var cert2 = signer.certificate;
            if (typeof cert2 === "string") {
              cert2 = forge.pki.certificateFromPem(cert2);
            }
            issuer = cert2.issuer.attributes;
            serialNumber = cert2.serialNumber;
          }
          var key = signer.key;
          if (!key) {
            throw new Error(
              "Could not add PKCS#7 signer; no private key specified."
            );
          }
          if (typeof key === "string") {
            key = forge.pki.privateKeyFromPem(key);
          }
          var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
          switch (digestAlgorithm) {
            case forge.pki.oids.sha1:
            case forge.pki.oids.sha256:
            case forge.pki.oids.sha384:
            case forge.pki.oids.sha512:
            case forge.pki.oids.md5:
              break;
            default:
              throw new Error(
                "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
              );
          }
          var authenticatedAttributes = signer.authenticatedAttributes || [];
          if (authenticatedAttributes.length > 0) {
            var contentType = false;
            var messageDigest = false;
            for (var i = 0; i < authenticatedAttributes.length; ++i) {
              var attr = authenticatedAttributes[i];
              if (!contentType && attr.type === forge.pki.oids.contentType) {
                contentType = true;
                if (messageDigest) {
                  break;
                }
                continue;
              }
              if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
                messageDigest = true;
                if (contentType) {
                  break;
                }
                continue;
              }
            }
            if (!contentType || !messageDigest) {
              throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
            }
          }
          msg.signers.push({
            key,
            version: 1,
            issuer,
            serialNumber,
            digestAlgorithm,
            signatureAlgorithm: forge.pki.oids.rsaEncryption,
            signature: null,
            authenticatedAttributes,
            unauthenticatedAttributes: []
          });
        }, "addSigner"),
        /**
         * Signs the content.
         * @param options Options to apply when signing:
         *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
         */
        sign: /* @__PURE__ */ __name(function(options) {
          options = options || {};
          if (typeof msg.content !== "object" || msg.contentInfo === null) {
            msg.contentInfo = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              [
                // ContentType
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OID,
                  false,
                  asn1.oidToDer(forge.pki.oids.data).getBytes()
                )
              ]
            );
            if ("content" in msg) {
              var content;
              if (msg.content instanceof forge.util.ByteBuffer) {
                content = msg.content.bytes();
              } else if (typeof msg.content === "string") {
                content = forge.util.encodeUtf8(msg.content);
              }
              if (options.detached) {
                msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
              } else {
                msg.contentInfo.value.push(
                  // [0] EXPLICIT content
                  asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                    asn1.create(
                      asn1.Class.UNIVERSAL,
                      asn1.Type.OCTETSTRING,
                      false,
                      content
                    )
                  ])
                );
              }
            }
          }
          if (msg.signers.length === 0) {
            return;
          }
          var mds = addDigestAlgorithmIds();
          addSignerInfos(mds);
        }, "sign"),
        verify: /* @__PURE__ */ __name(function() {
          throw new Error("PKCS#7 signature verification not yet implemented.");
        }, "verify"),
        /**
         * Add a certificate.
         *
         * @param cert the certificate to add.
         */
        addCertificate: /* @__PURE__ */ __name(function(cert2) {
          if (typeof cert2 === "string") {
            cert2 = forge.pki.certificateFromPem(cert2);
          }
          msg.certificates.push(cert2);
        }, "addCertificate"),
        /**
         * Add a certificate revokation list.
         *
         * @param crl the certificate revokation list to add.
         */
        addCertificateRevokationList: /* @__PURE__ */ __name(function(crl) {
          throw new Error("PKCS#7 CRL support not yet implemented.");
        }, "addCertificateRevokationList")
      };
      return msg;
      function addDigestAlgorithmIds() {
        var mds = {};
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          var oid = signer.digestAlgorithm;
          if (!(oid in mds)) {
            mds[oid] = forge.md[forge.pki.oids[oid]].create();
          }
          if (signer.authenticatedAttributes.length === 0) {
            signer.md = mds[oid];
          } else {
            signer.md = forge.md[forge.pki.oids[oid]].create();
          }
        }
        msg.digestAlgorithmIdentifiers = [];
        for (var oid in mds) {
          msg.digestAlgorithmIdentifiers.push(
            // AlgorithmIdentifier
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              // algorithm
              asn1.create(
                asn1.Class.UNIVERSAL,
                asn1.Type.OID,
                false,
                asn1.oidToDer(oid).getBytes()
              ),
              // parameters (null)
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          );
        }
        return mds;
      }
      __name(addDigestAlgorithmIds, "addDigestAlgorithmIds");
      function addSignerInfos(mds) {
        var content;
        if (msg.detachedContent) {
          content = msg.detachedContent;
        } else {
          content = msg.contentInfo.value[1];
          content = content.value[0];
        }
        if (!content) {
          throw new Error(
            "Could not sign PKCS#7 message; there is no content to sign."
          );
        }
        var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
        var bytes = asn1.toDer(content);
        bytes.getByte();
        asn1.getBerValueLength(bytes);
        bytes = bytes.getBytes();
        for (var oid in mds) {
          mds[oid].start().update(bytes);
        }
        var signingTime = /* @__PURE__ */ new Date();
        for (var i = 0; i < msg.signers.length; ++i) {
          var signer = msg.signers[i];
          if (signer.authenticatedAttributes.length === 0) {
            if (contentType !== forge.pki.oids.data) {
              throw new Error(
                "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
              );
            }
          } else {
            signer.authenticatedAttributesAsn1 = asn1.create(
              asn1.Class.CONTEXT_SPECIFIC,
              0,
              true,
              []
            );
            var attrsAsn1 = asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              []
            );
            for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
              var attr = signer.authenticatedAttributes[ai];
              if (attr.type === forge.pki.oids.messageDigest) {
                attr.value = mds[signer.digestAlgorithm].digest();
              } else if (attr.type === forge.pki.oids.signingTime) {
                if (!attr.value) {
                  attr.value = signingTime;
                }
              }
              attrsAsn1.value.push(_attributeToAsn1(attr));
              signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
            }
            bytes = asn1.toDer(attrsAsn1).getBytes();
            signer.md.start().update(bytes);
          }
          signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
        }
        msg.signerInfos = _signersToAsn1(msg.signers);
      }
      __name(addSignerInfos, "addSignerInfos");
    };
    p7.createEncryptedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.encryptedData,
        version: 0,
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EncryptedData content block (in ASN.1 format)
         *
         * @param obj The ASN.1 representation of the EncryptedData content block
         */
        fromAsn1: /* @__PURE__ */ __name(function(obj) {
          _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
        }, "fromAsn1"),
        /**
         * Decrypt encrypted content
         *
         * @param key The (symmetric) key as a byte buffer
         */
        decrypt: /* @__PURE__ */ __name(function(key) {
          if (key !== void 0) {
            msg.encryptedContent.key = key;
          }
          _decryptContent(msg);
        }, "decrypt")
      };
      return msg;
    };
    p7.createEnvelopedData = function() {
      var msg = null;
      msg = {
        type: forge.pki.oids.envelopedData,
        version: 0,
        recipients: [],
        encryptedContent: {
          algorithm: forge.pki.oids["aes256-CBC"]
        },
        /**
         * Reads an EnvelopedData content block (in ASN.1 format)
         *
         * @param obj the ASN.1 representation of the EnvelopedData content block.
         */
        fromAsn1: /* @__PURE__ */ __name(function(obj) {
          var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
          msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
        }, "fromAsn1"),
        toAsn1: /* @__PURE__ */ __name(function() {
          return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(msg.type).getBytes()
            ),
            // [0] EnvelopedData
            asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                // Version
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.INTEGER,
                  false,
                  asn1.integerToDer(msg.version).getBytes()
                ),
                // RecipientInfos
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SET,
                  true,
                  _recipientsToAsn1(msg.recipients)
                ),
                // EncryptedContentInfo
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.SEQUENCE,
                  true,
                  _encryptedContentToAsn1(msg.encryptedContent)
                )
              ])
            ])
          ]);
        }, "toAsn1"),
        /**
         * Find recipient by X.509 certificate's issuer.
         *
         * @param cert the certificate with the issuer to look for.
         *
         * @return the recipient object.
         */
        findRecipient: /* @__PURE__ */ __name(function(cert2) {
          var sAttr = cert2.issuer.attributes;
          for (var i = 0; i < msg.recipients.length; ++i) {
            var r = msg.recipients[i];
            var rAttr = r.issuer;
            if (r.serialNumber !== cert2.serialNumber) {
              continue;
            }
            if (rAttr.length !== sAttr.length) {
              continue;
            }
            var match = true;
            for (var j = 0; j < sAttr.length; ++j) {
              if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
                match = false;
                break;
              }
            }
            if (match) {
              return r;
            }
          }
          return null;
        }, "findRecipient"),
        /**
         * Decrypt enveloped content
         *
         * @param recipient The recipient object related to the private key
         * @param privKey The (RSA) private key object
         */
        decrypt: /* @__PURE__ */ __name(function(recipient, privKey) {
          if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
              case forge.pki.oids.desCBC:
                var key = privKey.decrypt(recipient.encryptedContent.content);
                msg.encryptedContent.key = forge.util.createBuffer(key);
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
          _decryptContent(msg);
        }, "decrypt"),
        /**
         * Add (another) entity to list of recipients.
         *
         * @param cert The certificate of the entity to add.
         */
        addRecipient: /* @__PURE__ */ __name(function(cert2) {
          msg.recipients.push({
            version: 0,
            issuer: cert2.issuer.attributes,
            serialNumber: cert2.serialNumber,
            encryptedContent: {
              // We simply assume rsaEncryption here, since forge.pki only
              // supports RSA so far.  If the PKI module supports other
              // ciphers one day, we need to modify this one as well.
              algorithm: forge.pki.oids.rsaEncryption,
              key: cert2.publicKey
            }
          });
        }, "addRecipient"),
        /**
         * Encrypt enveloped content.
         *
         * This function supports two optional arguments, cipher and key, which
         * can be used to influence symmetric encryption.  Unless cipher is
         * provided, the cipher specified in encryptedContent.algorithm is used
         * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
         * is (re-)used.  If that one's not set, a random key will be generated
         * automatically.
         *
         * @param [key] The key to be used for symmetric encryption.
         * @param [cipher] The OID of the symmetric cipher to use.
         */
        encrypt: /* @__PURE__ */ __name(function(key, cipher) {
          if (msg.encryptedContent.content === void 0) {
            cipher = cipher || msg.encryptedContent.algorithm;
            key = key || msg.encryptedContent.key;
            var keyLen, ivLen, ciphFn;
            switch (cipher) {
              case forge.pki.oids["aes128-CBC"]:
                keyLen = 16;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes192-CBC"]:
                keyLen = 24;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["aes256-CBC"]:
                keyLen = 32;
                ivLen = 16;
                ciphFn = forge.aes.createEncryptionCipher;
                break;
              case forge.pki.oids["des-EDE3-CBC"]:
                keyLen = 24;
                ivLen = 8;
                ciphFn = forge.des.createEncryptionCipher;
                break;
              default:
                throw new Error("Unsupported symmetric cipher, OID " + cipher);
            }
            if (key === void 0) {
              key = forge.util.createBuffer(forge.random.getBytes(keyLen));
            } else if (key.length() != keyLen) {
              throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
            }
            msg.encryptedContent.algorithm = cipher;
            msg.encryptedContent.key = key;
            msg.encryptedContent.parameter = forge.util.createBuffer(
              forge.random.getBytes(ivLen)
            );
            var ciph = ciphFn(key);
            ciph.start(msg.encryptedContent.parameter.copy());
            ciph.update(msg.content);
            if (!ciph.finish()) {
              throw new Error("Symmetric encryption failed.");
            }
            msg.encryptedContent.content = ciph.output;
          }
          for (var i = 0; i < msg.recipients.length; ++i) {
            var recipient = msg.recipients[i];
            if (recipient.encryptedContent.content !== void 0) {
              continue;
            }
            switch (recipient.encryptedContent.algorithm) {
              case forge.pki.oids.rsaEncryption:
                recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
                  msg.encryptedContent.key.data
                );
                break;
              default:
                throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
            }
          }
        }, "encrypt")
      };
      return msg;
    };
    function _recipientFromAsn1(obj) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
        var error3 = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
        error3.errors = errors;
        throw error3;
      }
      return {
        version: capture.version.charCodeAt(0),
        issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
        serialNumber: forge.util.createBuffer(capture.serial).toHex(),
        encryptedContent: {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: capture.encParameter ? capture.encParameter.value : void 0,
          content: capture.encKey
        }
      };
    }
    __name(_recipientFromAsn1, "_recipientFromAsn1");
    function _recipientToAsn1(obj) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // Version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // IssuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // Serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // KeyEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
          ),
          // Parameter, force NULL, only RSA supported for now.
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]),
        // EncryptedKey
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          obj.encryptedContent.content
        )
      ]);
    }
    __name(_recipientToAsn1, "_recipientToAsn1");
    function _recipientsFromAsn1(infos) {
      var ret = [];
      for (var i = 0; i < infos.length; ++i) {
        ret.push(_recipientFromAsn1(infos[i]));
      }
      return ret;
    }
    __name(_recipientsFromAsn1, "_recipientsFromAsn1");
    function _recipientsToAsn1(recipients) {
      var ret = [];
      for (var i = 0; i < recipients.length; ++i) {
        ret.push(_recipientToAsn1(recipients[i]));
      }
      return ret;
    }
    __name(_recipientsToAsn1, "_recipientsToAsn1");
    function _signerToAsn1(obj) {
      var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // version
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.INTEGER,
          false,
          asn1.integerToDer(obj.version).getBytes()
        ),
        // issuerAndSerialNumber
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // name
          forge.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
          // serial
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            forge.util.hexToBytes(obj.serialNumber)
          )
        ]),
        // digestAlgorithm
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(obj.digestAlgorithm).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      ]);
      if (obj.authenticatedAttributesAsn1) {
        rval.value.push(obj.authenticatedAttributesAsn1);
      }
      rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // algorithm
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(obj.signatureAlgorithm).getBytes()
        ),
        // parameters (null)
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
      rval.value.push(asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        obj.signature
      ));
      if (obj.unauthenticatedAttributes.length > 0) {
        var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
        for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
          var attr = obj.unauthenticatedAttributes[i];
          attrsAsn1.values.push(_attributeToAsn1(attr));
        }
        rval.value.push(attrsAsn1);
      }
      return rval;
    }
    __name(_signerToAsn1, "_signerToAsn1");
    function _signersToAsn1(signers) {
      var ret = [];
      for (var i = 0; i < signers.length; ++i) {
        ret.push(_signerToAsn1(signers[i]));
      }
      return ret;
    }
    __name(_signersToAsn1, "_signersToAsn1");
    function _attributeToAsn1(attr) {
      var value;
      if (attr.type === forge.pki.oids.contentType) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.value).getBytes()
        );
      } else if (attr.type === forge.pki.oids.messageDigest) {
        value = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OCTETSTRING,
          false,
          attr.value.bytes()
        );
      } else if (attr.type === forge.pki.oids.signingTime) {
        var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
        var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
        var date = attr.value;
        if (typeof date === "string") {
          var timestamp = Date.parse(date);
          if (!isNaN(timestamp)) {
            date = new Date(timestamp);
          } else if (date.length === 13) {
            date = asn1.utcTimeToDate(date);
          } else {
            date = asn1.generalizedTimeToDate(date);
          }
        }
        if (date >= jan_1_1950 && date < jan_1_2050) {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.UTCTIME,
            false,
            asn1.dateToUtcTime(date)
          );
        } else {
          value = asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.GENERALIZEDTIME,
            false,
            asn1.dateToGeneralizedTime(date)
          );
        }
      }
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // AttributeType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(attr.type).getBytes()
        ),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          // AttributeValue
          value
        ])
      ]);
    }
    __name(_attributeToAsn1, "_attributeToAsn1");
    function _encryptedContentToAsn1(ec) {
      return [
        // ContentType, always Data for the moment
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(forge.pki.oids.data).getBytes()
        ),
        // ContentEncryptionAlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(ec.algorithm).getBytes()
          ),
          // Parameters (IV)
          !ec.parameter ? void 0 : asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.parameter.getBytes()
          )
        ]),
        // [0] EncryptedContent
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OCTETSTRING,
            false,
            ec.content.getBytes()
          )
        ])
      ];
    }
    __name(_encryptedContentToAsn1, "_encryptedContentToAsn1");
    function _fromAsn1(msg, obj, validator) {
      var capture = {};
      var errors = [];
      if (!asn1.validate(obj, validator, capture, errors)) {
        var error3 = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
        error3.errors = error3;
        throw error3;
      }
      var contentType = asn1.derToOid(capture.contentType);
      if (contentType !== forge.pki.oids.data) {
        throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
      }
      if (capture.encryptedContent) {
        var content = "";
        if (forge.util.isArray(capture.encryptedContent)) {
          for (var i = 0; i < capture.encryptedContent.length; ++i) {
            if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
            }
            content += capture.encryptedContent[i].value;
          }
        } else {
          content = capture.encryptedContent;
        }
        msg.encryptedContent = {
          algorithm: asn1.derToOid(capture.encAlgorithm),
          parameter: forge.util.createBuffer(capture.encParameter.value),
          content: forge.util.createBuffer(content)
        };
      }
      if (capture.content) {
        var content = "";
        if (forge.util.isArray(capture.content)) {
          for (var i = 0; i < capture.content.length; ++i) {
            if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
              throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
            }
            content += capture.content[i].value;
          }
        } else {
          content = capture.content;
        }
        msg.content = forge.util.createBuffer(content);
      }
      msg.version = capture.version.charCodeAt(0);
      msg.rawCapture = capture;
      return capture;
    }
    __name(_fromAsn1, "_fromAsn1");
    function _decryptContent(msg) {
      if (msg.encryptedContent.key === void 0) {
        throw new Error("Symmetric key not available.");
      }
      if (msg.content === void 0) {
        var ciph;
        switch (msg.encryptedContent.algorithm) {
          case forge.pki.oids["aes128-CBC"]:
          case forge.pki.oids["aes192-CBC"]:
          case forge.pki.oids["aes256-CBC"]:
            ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
            break;
          case forge.pki.oids["desCBC"]:
          case forge.pki.oids["des-EDE3-CBC"]:
            ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
        }
        ciph.start(msg.encryptedContent.parameter);
        ciph.update(msg.encryptedContent.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric decryption failed.");
        }
        msg.content = ciph.output;
      }
    }
    __name(_decryptContent, "_decryptContent");
  }
});

// node_modules/node-forge/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/node-forge/lib/ssh.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var forge = require_forge();
    require_aes();
    require_hmac();
    require_md52();
    require_sha12();
    require_util4();
    var ssh = module.exports = forge.ssh = forge.ssh || {};
    ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
      comment = comment || "";
      passphrase = passphrase || "";
      var algorithm = "ssh-rsa";
      var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
      var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
      ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
      ppk += "Comment: " + comment + "\r\n";
      var pubbuffer = forge.util.createBuffer();
      _addStringToBuffer(pubbuffer, algorithm);
      _addBigIntegerToBuffer(pubbuffer, privateKey.e);
      _addBigIntegerToBuffer(pubbuffer, privateKey.n);
      var pub = forge.util.encode64(pubbuffer.bytes(), 64);
      var length = Math.floor(pub.length / 66) + 1;
      ppk += "Public-Lines: " + length + "\r\n";
      ppk += pub;
      var privbuffer = forge.util.createBuffer();
      _addBigIntegerToBuffer(privbuffer, privateKey.d);
      _addBigIntegerToBuffer(privbuffer, privateKey.p);
      _addBigIntegerToBuffer(privbuffer, privateKey.q);
      _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
      var priv;
      if (!passphrase) {
        priv = forge.util.encode64(privbuffer.bytes(), 64);
      } else {
        var encLen = privbuffer.length() + 16 - 1;
        encLen -= encLen % 16;
        var padding = _sha1(privbuffer.bytes());
        padding.truncate(padding.length() - encLen + privbuffer.length());
        privbuffer.putBuffer(padding);
        var aeskey = forge.util.createBuffer();
        aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
        aeskey.putBuffer(_sha1("\0\0\0", passphrase));
        var cipher = forge.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
        cipher.start(forge.util.createBuffer().fillWithByte(0, 16));
        cipher.update(privbuffer.copy());
        cipher.finish();
        var encrypted = cipher.output;
        encrypted.truncate(16);
        priv = forge.util.encode64(encrypted.bytes(), 64);
      }
      length = Math.floor(priv.length / 66) + 1;
      ppk += "\r\nPrivate-Lines: " + length + "\r\n";
      ppk += priv;
      var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
      var macbuffer = forge.util.createBuffer();
      _addStringToBuffer(macbuffer, algorithm);
      _addStringToBuffer(macbuffer, encryptionAlgorithm);
      _addStringToBuffer(macbuffer, comment);
      macbuffer.putInt32(pubbuffer.length());
      macbuffer.putBuffer(pubbuffer);
      macbuffer.putInt32(privbuffer.length());
      macbuffer.putBuffer(privbuffer);
      var hmac = forge.hmac.create();
      hmac.start("sha1", mackey);
      hmac.update(macbuffer.bytes());
      ppk += "\r\nPrivate-MAC: " + hmac.digest().toHex() + "\r\n";
      return ppk;
    };
    ssh.publicKeyToOpenSSH = function(key, comment) {
      var type2 = "ssh-rsa";
      comment = comment || "";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type2);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      return type2 + " " + forge.util.encode64(buffer.bytes()) + " " + comment;
    };
    ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
      if (!passphrase) {
        return forge.pki.privateKeyToPem(privateKey);
      }
      return forge.pki.encryptRsaPrivateKey(
        privateKey,
        passphrase,
        { legacy: true, algorithm: "aes128" }
      );
    };
    ssh.getPublicKeyFingerprint = function(key, options) {
      options = options || {};
      var md = options.md || forge.md.md5.create();
      var type2 = "ssh-rsa";
      var buffer = forge.util.createBuffer();
      _addStringToBuffer(buffer, type2);
      _addBigIntegerToBuffer(buffer, key.e);
      _addBigIntegerToBuffer(buffer, key.n);
      md.start();
      md.update(buffer.getBytes());
      var digest2 = md.digest();
      if (options.encoding === "hex") {
        var hex = digest2.toHex();
        if (options.delimiter) {
          return hex.match(/.{2}/g).join(options.delimiter);
        }
        return hex;
      } else if (options.encoding === "binary") {
        return digest2.getBytes();
      } else if (options.encoding) {
        throw new Error('Unknown encoding "' + options.encoding + '".');
      }
      return digest2;
    };
    function _addBigIntegerToBuffer(buffer, val) {
      var hexVal = val.toString(16);
      if (hexVal[0] >= "8") {
        hexVal = "00" + hexVal;
      }
      var bytes = forge.util.hexToBytes(hexVal);
      buffer.putInt32(bytes.length);
      buffer.putBytes(bytes);
    }
    __name(_addBigIntegerToBuffer, "_addBigIntegerToBuffer");
    function _addStringToBuffer(buffer, val) {
      buffer.putInt32(val.length);
      buffer.putString(val);
    }
    __name(_addStringToBuffer, "_addStringToBuffer");
    function _sha1() {
      var sha = forge.md.sha1.create();
      var num = arguments.length;
      for (var i = 0; i < num; ++i) {
        sha.update(arguments[i]);
      }
      return sha.digest();
    }
    __name(_sha1, "_sha1");
  }
});

// node_modules/node-forge/lib/index.js
var require_lib = __commonJS({
  "node_modules/node-forge/lib/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = require_forge();
    require_aes();
    require_aesCipherSuites();
    require_asn1();
    require_cipher();
    require_des();
    require_ed25519();
    require_hmac();
    require_kem();
    require_log();
    require_md_all();
    require_mgf1();
    require_pbkdf2();
    require_pem();
    require_pkcs1();
    require_pkcs12();
    require_pkcs7();
    require_pki();
    require_prime();
    require_prng();
    require_pss();
    require_random();
    require_rc2();
    require_ssh();
    require_tls2();
    require_util4();
  }
});

// node_modules/firebase-admin/lib/app/credential-internal.js
var require_credential_internal = __commonJS({
  "node_modules/firebase-admin/lib/app/credential-internal.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ImpersonatedServiceAccountCredential = exports.RefreshTokenCredential = exports.ServiceAccountCredential = exports.ApplicationDefaultCredential = void 0;
    exports.isApplicationDefault = isApplicationDefault;
    exports.getApplicationDefault = getApplicationDefault;
    var fs = require_fs();
    var google_auth_library_1 = require_src4();
    var error_1 = require_error();
    var util = require_validator();
    var SCOPES = [
      "https://www.googleapis.com/auth/cloud-platform",
      "https://www.googleapis.com/auth/firebase.database",
      "https://www.googleapis.com/auth/firebase.messaging",
      "https://www.googleapis.com/auth/identitytoolkit",
      "https://www.googleapis.com/auth/userinfo.email"
    ];
    var ApplicationDefaultCredential = class {
      static {
        __name(this, "ApplicationDefaultCredential");
      }
      constructor(httpAgent) {
        this.googleAuth = new google_auth_library_1.GoogleAuth({
          scopes: SCOPES,
          clientOptions: {
            transporterOptions: {
              agent: httpAgent
            }
          }
        });
      }
      async getAccessToken() {
        if (!this.authClient) {
          this.authClient = await this.googleAuth.getClient();
        }
        await this.authClient.getAccessToken();
        const credentials = this.authClient.credentials;
        this.quotaProjectId = this.authClient.quotaProjectId;
        return populateCredential(credentials);
      }
      async getProjectId() {
        if (!this.projectId) {
          this.projectId = await this.googleAuth.getProjectId();
        }
        return Promise.resolve(this.projectId);
      }
      getQuotaProjectId() {
        if (!this.quotaProjectId) {
          this.quotaProjectId = this.authClient?.quotaProjectId;
        }
        return this.quotaProjectId;
      }
      async isComputeEngineCredential() {
        if (!this.authClient) {
          this.authClient = await this.googleAuth.getClient();
        }
        return Promise.resolve(this.authClient instanceof google_auth_library_1.Compute);
      }
      /**
       * getIDToken returns a OIDC token from the compute metadata service
       * that can be used to make authenticated calls to audience
       * @param audience the URL the returned ID token will be used to call.
      */
      async getIDToken(audience) {
        if (await this.isComputeEngineCredential()) {
          return this.authClient.fetchIdToken(audience);
        } else {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Credentials type should be Compute Engine Credentials.");
        }
      }
      async getServiceAccountEmail() {
        if (this.accountId) {
          return Promise.resolve(this.accountId);
        }
        const { client_email: clientEmail } = await this.googleAuth.getCredentials();
        this.accountId = clientEmail ?? "";
        return Promise.resolve(this.accountId);
      }
    };
    exports.ApplicationDefaultCredential = ApplicationDefaultCredential;
    var ServiceAccountCredential = class {
      static {
        __name(this, "ServiceAccountCredential");
      }
      /**
       * Creates a new ServiceAccountCredential from the given parameters.
       *
       * @param serviceAccountPathOrObject - Service account json object or path to a service account json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optional boolean indicating whether this credential was implicitly discovered from the
       *   environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(serviceAccountPathOrObject, httpAgent, implicit = false) {
        this.serviceAccountPathOrObject = serviceAccountPathOrObject;
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        const serviceAccount = typeof serviceAccountPathOrObject === "string" ? ServiceAccount.fromPath(serviceAccountPathOrObject) : new ServiceAccount(serviceAccountPathOrObject);
        this.projectId = serviceAccount.projectId;
        this.privateKey = serviceAccount.privateKey;
        this.clientEmail = serviceAccount.clientEmail;
      }
      getGoogleAuth() {
        if (this.googleAuth) {
          return this.googleAuth;
        }
        const { auth, client } = populateGoogleAuth(this.serviceAccountPathOrObject, this.httpAgent);
        this.googleAuth = auth;
        this.authClient = client;
        return this.googleAuth;
      }
      async getAccessToken() {
        const googleAuth = this.getGoogleAuth();
        if (this.authClient === void 0) {
          this.authClient = await googleAuth.getClient();
        }
        await this.authClient.getAccessToken();
        const credentials = this.authClient.credentials;
        return populateCredential(credentials);
      }
    };
    exports.ServiceAccountCredential = ServiceAccountCredential;
    var ServiceAccount = class _ServiceAccount {
      static {
        __name(this, "ServiceAccount");
      }
      static fromPath(filePath) {
        try {
          return new _ServiceAccount(JSON.parse(fs.readFileSync(filePath, "utf8")));
        } catch (error3) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse service account json file: " + error3);
        }
      }
      constructor(json) {
        if (!util.isNonNullObject(json)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Service account must be an object.");
        }
        copyAttr(this, json, "projectId", "project_id");
        copyAttr(this, json, "privateKey", "private_key");
        copyAttr(this, json, "clientEmail", "client_email");
        let errorMessage;
        if (!util.isNonEmptyString(this.projectId)) {
          errorMessage = 'Service account object must contain a string "project_id" property.';
        } else if (!util.isNonEmptyString(this.privateKey)) {
          errorMessage = 'Service account object must contain a string "private_key" property.';
        } else if (!util.isNonEmptyString(this.clientEmail)) {
          errorMessage = 'Service account object must contain a string "client_email" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
        const forge = require_lib();
        try {
          forge.pki.privateKeyFromPem(this.privateKey);
        } catch (error3) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse private key: " + error3);
        }
      }
    };
    var RefreshTokenCredential = class {
      static {
        __name(this, "RefreshTokenCredential");
      }
      /**
       * Creates a new RefreshTokenCredential from the given parameters.
       *
       * @param refreshTokenPathOrObject - Refresh token json object or path to a refresh token
       *   (user credentials) json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optinal boolean indicating whether this credential was implicitly
       *   discovered from the environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(refreshTokenPathOrObject, httpAgent, implicit = false) {
        this.refreshTokenPathOrObject = refreshTokenPathOrObject;
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        typeof refreshTokenPathOrObject === "string" ? RefreshToken.validateFromPath(refreshTokenPathOrObject) : RefreshToken.validateFromJSON(refreshTokenPathOrObject);
      }
      getGoogleAuth() {
        if (this.googleAuth) {
          return this.googleAuth;
        }
        const { auth, client } = populateGoogleAuth(this.refreshTokenPathOrObject, this.httpAgent);
        this.googleAuth = auth;
        this.authClient = client;
        return this.googleAuth;
      }
      async getAccessToken() {
        const googleAuth = this.getGoogleAuth();
        if (this.authClient === void 0) {
          this.authClient = await googleAuth.getClient();
        }
        await this.authClient.getAccessToken();
        const credentials = this.authClient.credentials;
        return populateCredential(credentials);
      }
    };
    exports.RefreshTokenCredential = RefreshTokenCredential;
    var RefreshToken = class _RefreshToken {
      static {
        __name(this, "RefreshToken");
      }
      /*
       * Tries to load a RefreshToken from a path. Throws if the path doesn't exist or the
       * data at the path is invalid.
       */
      static validateFromPath(filePath) {
        try {
          _RefreshToken.validateFromJSON(JSON.parse(fs.readFileSync(filePath, "utf8")));
        } catch (error3) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse refresh token file: " + error3);
        }
      }
      static validateFromJSON(json) {
        const creds = { clientId: "", clientSecret: "", refreshToken: "", type: "" };
        copyAttr(creds, json, "clientId", "client_id");
        copyAttr(creds, json, "clientSecret", "client_secret");
        copyAttr(creds, json, "refreshToken", "refresh_token");
        copyAttr(creds, json, "type", "type");
        let errorMessage;
        if (!util.isNonEmptyString(creds.clientId)) {
          errorMessage = 'Refresh token must contain a "client_id" property.';
        } else if (!util.isNonEmptyString(creds.clientSecret)) {
          errorMessage = 'Refresh token must contain a "client_secret" property.';
        } else if (!util.isNonEmptyString(creds.refreshToken)) {
          errorMessage = 'Refresh token must contain a "refresh_token" property.';
        } else if (!util.isNonEmptyString(creds.type)) {
          errorMessage = 'Refresh token must contain a "type" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
      }
    };
    var ImpersonatedServiceAccountCredential = class {
      static {
        __name(this, "ImpersonatedServiceAccountCredential");
      }
      /**
       * Creates a new ImpersonatedServiceAccountCredential from the given parameters.
       *
       * @param impersonatedServiceAccountPathOrObject - Impersonated Service account json object or
       * path to a service account json file.
       * @param httpAgent - Optional http.Agent to use when calling the remote token server.
       * @param implicit - An optional boolean indicating whether this credential was implicitly
       *   discovered from the environment, as opposed to being explicitly specified by the developer.
       *
       * @constructor
       */
      constructor(impersonatedServiceAccountPathOrObject, httpAgent, implicit = false) {
        this.impersonatedServiceAccountPathOrObject = impersonatedServiceAccountPathOrObject;
        this.httpAgent = httpAgent;
        this.implicit = implicit;
        typeof impersonatedServiceAccountPathOrObject === "string" ? ImpersonatedServiceAccount.validateFromPath(impersonatedServiceAccountPathOrObject) : ImpersonatedServiceAccount.validateFromJSON(impersonatedServiceAccountPathOrObject);
      }
      getGoogleAuth() {
        if (this.googleAuth) {
          return this.googleAuth;
        }
        const { auth, client } = populateGoogleAuth(this.impersonatedServiceAccountPathOrObject, this.httpAgent);
        this.googleAuth = auth;
        this.authClient = client;
        return this.googleAuth;
      }
      async getAccessToken() {
        const googleAuth = this.getGoogleAuth();
        if (this.authClient === void 0) {
          this.authClient = await googleAuth.getClient();
        }
        await this.authClient.getAccessToken();
        const credentials = this.authClient.credentials;
        return populateCredential(credentials);
      }
    };
    exports.ImpersonatedServiceAccountCredential = ImpersonatedServiceAccountCredential;
    var ImpersonatedServiceAccount = class _ImpersonatedServiceAccount {
      static {
        __name(this, "ImpersonatedServiceAccount");
      }
      /*
       * Tries to load a ImpersonatedServiceAccount from a path. Throws if the path doesn't exist or the
       * data at the path is invalid.
       */
      static validateFromPath(filePath) {
        try {
          _ImpersonatedServiceAccount.validateFromJSON(JSON.parse(fs.readFileSync(filePath, "utf8")));
        } catch (error3) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse impersonated service account file: " + error3);
        }
      }
      static validateFromJSON(json) {
        const { client_id: clientId, client_secret: clientSecret, refresh_token: refreshToken2, type: type2 } = json["source_credentials"];
        let errorMessage;
        if (!util.isNonEmptyString(clientId)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_id" property.';
        } else if (!util.isNonEmptyString(clientSecret)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.client_secret" property.';
        } else if (!util.isNonEmptyString(refreshToken2)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.refresh_token" property.';
        } else if (!util.isNonEmptyString(type2)) {
          errorMessage = 'Impersonated Service Account must contain a "source_credentials.type" property.';
        }
        if (typeof errorMessage !== "undefined") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }
      }
    };
    function isApplicationDefault(credential) {
      return credential instanceof ApplicationDefaultCredential || credential instanceof RefreshTokenCredential && credential.implicit;
    }
    __name(isApplicationDefault, "isApplicationDefault");
    function getApplicationDefault(httpAgent) {
      return new ApplicationDefaultCredential(httpAgent);
    }
    __name(getApplicationDefault, "getApplicationDefault");
    function copyAttr(to, from, key, alt) {
      const tmp = from[key] || from[alt];
      if (typeof tmp !== "undefined") {
        to[key] = tmp;
      }
    }
    __name(copyAttr, "copyAttr");
    function populateGoogleAuth(keyFile, httpAgent) {
      let client;
      const auth = new google_auth_library_1.GoogleAuth({
        scopes: SCOPES,
        clientOptions: {
          transporterOptions: {
            agent: httpAgent
          }
        },
        keyFile: typeof keyFile === "string" ? keyFile : void 0
      });
      if (typeof keyFile === "object") {
        if (!util.isNonNullObject(keyFile)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Service account must be an object.");
        }
        copyAttr(keyFile, keyFile, "project_id", "projectId");
        copyAttr(keyFile, keyFile, "private_key", "privateKey");
        copyAttr(keyFile, keyFile, "client_email", "clientEmail");
        client = auth.fromJSON(keyFile);
      }
      return { auth, client };
    }
    __name(populateGoogleAuth, "populateGoogleAuth");
    function populateCredential(credentials) {
      const accessToken = credentials?.access_token;
      const expiryDate = credentials?.expiry_date;
      if (typeof accessToken !== "string")
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse Google auth credential: access_token must be a non empty string.");
      if (typeof expiryDate !== "number")
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, "Failed to parse Google auth credential: Invalid expiry_date.");
      return {
        ...credentials,
        access_token: accessToken,
        // inverse operation of following
        // https://github.com/googleapis/google-auth-library-nodejs/blob/5ed910513451c82e2551777a3e2212964799ef8e/src/auth/baseexternalclient.ts#L446-L446
        expires_in: Math.floor((expiryDate - (/* @__PURE__ */ new Date()).getTime()) / 1e3)
      };
    }
    __name(populateCredential, "populateCredential");
  }
});

// node_modules/firebase-admin/package.json
var require_package3 = __commonJS({
  "node_modules/firebase-admin/package.json"(exports, module) {
    module.exports = {
      name: "firebase-admin",
      version: "13.0.1",
      description: "Firebase admin SDK for Node.js",
      author: "Firebase <firebase-support@google.com> (https://firebase.google.com/)",
      license: "Apache-2.0",
      homepage: "https://firebase.google.com/",
      engines: {
        node: ">=18"
      },
      scripts: {
        build: "gulp build",
        "build:tests": "gulp compile_test",
        prepare: "npm run build && npm run esm-wrap",
        lint: "run-p lint:src lint:test",
        test: "run-s lint test:unit",
        integration: "run-s build test:integration",
        "test:unit": "mocha test/unit/*.spec.ts --require ts-node/register",
        "test:integration": "mocha test/integration/*.ts --slow 5000 --timeout 20000 --require ts-node/register",
        "test:coverage": "nyc npm run test:unit",
        "lint:src": "eslint src/ --ext .ts",
        "lint:test": "eslint test/ --ext .ts",
        apidocs: "run-s api-extractor:local api-documenter",
        "api-extractor": "node generate-reports.js",
        "api-extractor:local": "npm run build && node generate-reports.js --local",
        "esm-wrap": "node generate-esm-wrapper.js",
        "api-documenter": "run-s api-documenter:markdown api-documenter:toc api-documenter:post",
        "api-documenter:markdown": "api-documenter-fire markdown --input temp --output docgen/markdown -s --project admin",
        "api-documenter:toc": "api-documenter-fire toc --input temp --output docgen/markdown -p /docs/reference/admin/node -s",
        "api-documenter:post": "node docgen/post-process.js"
      },
      nyc: {
        extension: [
          ".ts"
        ],
        include: [
          "src"
        ],
        exclude: [
          "**/*.d.ts"
        ],
        all: true
      },
      keywords: [
        "admin",
        "database",
        "Firebase",
        "realtime",
        "authentication"
      ],
      repository: {
        type: "git",
        url: "https://github.com/firebase/firebase-admin-node"
      },
      main: "lib/index.js",
      files: [
        "lib/",
        "LICENSE",
        "README.md",
        "package.json"
      ],
      types: "./lib/index.d.ts",
      typesVersions: {
        "*": {
          app: [
            "lib/app"
          ],
          "app-check": [
            "lib/app-check"
          ],
          auth: [
            "lib/auth"
          ],
          eventarc: [
            "lib/eventarc"
          ],
          extensions: [
            "lib/extensions"
          ],
          database: [
            "lib/database"
          ],
          "data-connect": [
            "lib/data-connect"
          ],
          firestore: [
            "lib/firestore"
          ],
          functions: [
            "lib/functions"
          ],
          installations: [
            "lib/installations"
          ],
          "instance-id": [
            "lib/instance-id"
          ],
          "machine-learning": [
            "lib/machine-learning"
          ],
          messaging: [
            "lib/messaging"
          ],
          "project-management": [
            "lib/project-management"
          ],
          "remote-config": [
            "lib/remote-config"
          ],
          "security-rules": [
            "lib/security-rules"
          ],
          storage: [
            "lib/storage"
          ]
        }
      },
      exports: {
        ".": "./lib/index.js",
        "./app": {
          types: "./lib/app/index.d.ts",
          require: "./lib/app/index.js",
          import: "./lib/esm/app/index.js"
        },
        "./app-check": {
          types: "./lib/app-check/index.d.ts",
          require: "./lib/app-check/index.js",
          import: "./lib/esm/app-check/index.js"
        },
        "./auth": {
          types: "./lib/auth/index.d.ts",
          require: "./lib/auth/index.js",
          import: "./lib/esm/auth/index.js"
        },
        "./database": {
          types: "./lib/database/index.d.ts",
          require: "./lib/database/index.js",
          import: "./lib/esm/database/index.js"
        },
        "./data-connect": {
          types: "./lib/data-connect/index.d.ts",
          require: "./lib/data-connect/index.js",
          import: "./lib/esm/data-connect/index.js"
        },
        "./eventarc": {
          types: "./lib/eventarc/index.d.ts",
          require: "./lib/eventarc/index.js",
          import: "./lib/esm/eventarc/index.js"
        },
        "./extensions": {
          types: "./lib/extensions/index.d.ts",
          require: "./lib/extensions/index.js",
          import: "./lib/esm/extensions/index.js"
        },
        "./firestore": {
          types: "./lib/firestore/index.d.ts",
          require: "./lib/firestore/index.js",
          import: "./lib/esm/firestore/index.js"
        },
        "./functions": {
          types: "./lib/functions/index.d.ts",
          require: "./lib/functions/index.js",
          import: "./lib/esm/functions/index.js"
        },
        "./installations": {
          types: "./lib/installations/index.d.ts",
          require: "./lib/installations/index.js",
          import: "./lib/esm/installations/index.js"
        },
        "./instance-id": {
          types: "./lib/instance-id/index.d.ts",
          require: "./lib/instance-id/index.js",
          import: "./lib/esm/instance-id/index.js"
        },
        "./machine-learning": {
          types: "./lib/machine-learning/index.d.ts",
          require: "./lib/machine-learning/index.js",
          import: "./lib/esm/machine-learning/index.js"
        },
        "./messaging": {
          types: "./lib/messaging/index.d.ts",
          require: "./lib/messaging/index.js",
          import: "./lib/esm/messaging/index.js"
        },
        "./project-management": {
          types: "./lib/project-management/index.d.ts",
          require: "./lib/project-management/index.js",
          import: "./lib/esm/project-management/index.js"
        },
        "./remote-config": {
          types: "./lib/remote-config/index.d.ts",
          require: "./lib/remote-config/index.js",
          import: "./lib/esm/remote-config/index.js"
        },
        "./security-rules": {
          types: "./lib/security-rules/index.d.ts",
          require: "./lib/security-rules/index.js",
          import: "./lib/esm/security-rules/index.js"
        },
        "./storage": {
          types: "./lib/storage/index.d.ts",
          require: "./lib/storage/index.js",
          import: "./lib/esm/storage/index.js"
        }
      },
      dependencies: {
        "@fastify/busboy": "^3.0.0",
        "@firebase/database-compat": "^2.0.0",
        "@firebase/database-types": "^1.0.6",
        "@types/node": "^22.8.7",
        "farmhash-modern": "^1.1.0",
        "google-auth-library": "^9.14.2",
        jsonwebtoken: "^9.0.0",
        "jwks-rsa": "^3.1.0",
        "node-forge": "^1.3.1",
        uuid: "^11.0.2"
      },
      optionalDependencies: {
        "@google-cloud/firestore": "^7.10.0",
        "@google-cloud/storage": "^7.14.0"
      },
      devDependencies: {
        "@firebase/api-documenter": "^0.4.0",
        "@firebase/app-compat": "^0.2.1",
        "@firebase/auth-compat": "^0.5.13",
        "@firebase/auth-types": "^0.12.0",
        "@microsoft/api-extractor": "^7.11.2",
        "@types/bcrypt": "^5.0.0",
        "@types/chai": "^4.0.0",
        "@types/chai-as-promised": "^7.1.0",
        "@types/firebase-token-generator": "^2.0.28",
        "@types/jsonwebtoken": "8.5.1",
        "@types/lodash": "^4.14.104",
        "@types/minimist": "^1.2.2",
        "@types/mocha": "^10.0.0",
        "@types/nock": "^11.1.0",
        "@types/request": "^2.47.0",
        "@types/request-promise": "^4.1.41",
        "@types/sinon": "^17.0.2",
        "@types/sinon-chai": "^3.0.0",
        "@types/uuid": "^10.0.0",
        "@typescript-eslint/eslint-plugin": "^7.16.1",
        "@typescript-eslint/parser": "^7.16.1",
        bcrypt: "^5.0.0",
        chai: "^4.2.0",
        "chai-as-promised": "^7.0.0",
        "chai-exclude": "^2.1.0",
        chalk: "^4.1.1",
        "child-process-promise": "^2.2.1",
        del: "^6.0.0",
        eslint: "^8.56.0",
        "firebase-token-generator": "^2.0.0",
        gulp: "^5.0.0",
        "gulp-filter": "^7.0.0",
        "gulp-header": "^2.0.9",
        "gulp-typescript": "^5.0.1",
        "http-message-parser": "^0.0.34",
        lodash: "^4.17.15",
        minimist: "^1.2.6",
        mocha: "^10.0.0",
        mz: "^2.7.0",
        nock: "^13.0.0",
        "npm-run-all": "^4.1.5",
        nyc: "^17.0.0",
        request: "^2.75.0",
        "request-promise": "^4.1.1",
        "run-sequence": "^2.2.1",
        sinon: "^18.0.0",
        "sinon-chai": "^3.0.0",
        "ts-node": "^10.2.0",
        typescript: "5.5.4",
        yargs: "^17.0.1"
      }
    };
  }
});

// node_modules/firebase-admin/lib/utils/index.js
var require_utils = __commonJS({
  "node_modules/firebase-admin/lib/utils/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getSdkVersion = getSdkVersion;
    exports.getMetricsHeader = getMetricsHeader;
    exports.renameProperties = renameProperties;
    exports.addReadonlyGetter = addReadonlyGetter;
    exports.getExplicitProjectId = getExplicitProjectId;
    exports.findProjectId = findProjectId;
    exports.getExplicitServiceAccountEmail = getExplicitServiceAccountEmail;
    exports.findServiceAccountEmail = findServiceAccountEmail;
    exports.toWebSafeBase64 = toWebSafeBase64;
    exports.formatString = formatString;
    exports.generateUpdateMask = generateUpdateMask;
    exports.transformMillisecondsToSecondsString = transformMillisecondsToSecondsString;
    exports.parseResourceName = parseResourceName;
    var credential_internal_1 = require_credential_internal();
    var validator = require_validator();
    var sdkVersion;
    function getSdkVersion() {
      if (!sdkVersion) {
        const { version: version3 } = require_package3();
        sdkVersion = version3;
      }
      return sdkVersion;
    }
    __name(getSdkVersion, "getSdkVersion");
    function getMetricsHeader() {
      return `gl-node/${process.versions.node} fire-admin/${getSdkVersion()}`;
    }
    __name(getMetricsHeader, "getMetricsHeader");
    function renameProperties(obj, keyMap) {
      Object.keys(keyMap).forEach((oldKey) => {
        if (oldKey in obj) {
          const newKey = keyMap[oldKey];
          obj[newKey] = obj[oldKey];
          delete obj[oldKey];
        }
      });
    }
    __name(renameProperties, "renameProperties");
    function addReadonlyGetter(obj, prop, value) {
      Object.defineProperty(obj, prop, {
        value,
        // Make this property read-only.
        writable: false,
        // Include this property during enumeration of obj's properties.
        enumerable: true
      });
    }
    __name(addReadonlyGetter, "addReadonlyGetter");
    function getExplicitProjectId(app) {
      const options = app.options;
      if (validator.isNonEmptyString(options.projectId)) {
        return options.projectId;
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.projectId;
      }
      const projectId = process.env.GOOGLE_CLOUD_PROJECT || process.env.GCLOUD_PROJECT;
      if (validator.isNonEmptyString(projectId)) {
        return projectId;
      }
      return null;
    }
    __name(getExplicitProjectId, "getExplicitProjectId");
    function findProjectId(app) {
      const projectId = getExplicitProjectId(app);
      if (projectId) {
        return Promise.resolve(projectId);
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ApplicationDefaultCredential) {
        return credential.getProjectId();
      }
      return Promise.resolve(null);
    }
    __name(findProjectId, "findProjectId");
    function getExplicitServiceAccountEmail(app) {
      const options = app.options;
      if (validator.isNonEmptyString(options.serviceAccountId)) {
        return options.serviceAccountId;
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return credential.clientEmail;
      }
      return null;
    }
    __name(getExplicitServiceAccountEmail, "getExplicitServiceAccountEmail");
    function findServiceAccountEmail(app) {
      const accountId = getExplicitServiceAccountEmail(app);
      if (accountId) {
        return Promise.resolve(accountId);
      }
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ApplicationDefaultCredential) {
        return credential.getServiceAccountEmail();
      }
      return Promise.resolve(null);
    }
    __name(findServiceAccountEmail, "findServiceAccountEmail");
    function toWebSafeBase64(data) {
      return data.toString("base64").replace(/\//g, "_").replace(/\+/g, "-");
    }
    __name(toWebSafeBase64, "toWebSafeBase64");
    function formatString(str, params) {
      let formatted = str;
      Object.keys(params || {}).forEach((key) => {
        formatted = formatted.replace(new RegExp("{" + key + "}", "g"), params[key]);
      });
      return formatted;
    }
    __name(formatString, "formatString");
    function generateUpdateMask(obj, terminalPaths = [], root = "") {
      const updateMask = [];
      if (!validator.isNonNullObject(obj)) {
        return updateMask;
      }
      for (const key in obj) {
        if (typeof obj[key] !== "undefined") {
          const nextPath = root ? `${root}.${key}` : key;
          if (terminalPaths.indexOf(nextPath) !== -1) {
            updateMask.push(key);
          } else {
            const maskList = generateUpdateMask(obj[key], terminalPaths, nextPath);
            if (maskList.length > 0) {
              maskList.forEach((mask) => {
                updateMask.push(`${key}.${mask}`);
              });
            } else {
              updateMask.push(key);
            }
          }
        }
      }
      return updateMask;
    }
    __name(generateUpdateMask, "generateUpdateMask");
    function transformMillisecondsToSecondsString(milliseconds) {
      let duration;
      const seconds = Math.floor(milliseconds / 1e3);
      const nanos = Math.floor((milliseconds - seconds * 1e3) * 1e6);
      if (nanos > 0) {
        let nanoString = nanos.toString();
        while (nanoString.length < 9) {
          nanoString = "0" + nanoString;
        }
        duration = `${seconds}.${nanoString}s`;
      } else {
        duration = `${seconds}s`;
      }
      return duration;
    }
    __name(transformMillisecondsToSecondsString, "transformMillisecondsToSecondsString");
    function parseResourceName(resourceName, resourceIdKey) {
      if (!resourceName.includes("/")) {
        return { resourceId: resourceName };
      }
      const CHANNEL_NAME_REGEX = new RegExp(`^(projects/([^/]+)/)?locations/([^/]+)/${resourceIdKey}/([^/]+)$`);
      const match = CHANNEL_NAME_REGEX.exec(resourceName);
      if (match === null) {
        throw new Error("Invalid resource name format.");
      }
      const projectId = match[2];
      const locationId = match[3];
      const resourceId = match[4];
      return { projectId, locationId, resourceId };
    }
    __name(parseResourceName, "parseResourceName");
  }
});

// node_modules/firebase-admin/lib/app/firebase-app.js
var require_firebase_app = __commonJS({
  "node_modules/firebase-admin/lib/app/firebase-app.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseApp = exports.FirebaseAppInternals = void 0;
    var credential_internal_1 = require_credential_internal();
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var TOKEN_EXPIRY_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var FirebaseAppInternals = class {
      static {
        __name(this, "FirebaseAppInternals");
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      constructor(credential_) {
        this.credential_ = credential_;
        this.tokenListeners_ = [];
        this.isRefreshing = false;
      }
      getToken(forceRefresh = false) {
        if (forceRefresh || this.shouldRefresh()) {
          this.promiseToCachedToken_ = this.refreshToken();
        }
        return this.promiseToCachedToken_;
      }
      getCachedToken() {
        return this.cachedToken_ || null;
      }
      refreshToken() {
        this.isRefreshing = true;
        return Promise.resolve(this.credential_.getAccessToken()).then((result) => {
          if (!validator.isNonNullObject(result) || typeof result.expires_in !== "number" || typeof result.access_token !== "string") {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, `Invalid access token generated: "${JSON.stringify(result)}". Valid access tokens must be an object with the "expires_in" (number) and "access_token" (string) properties.`);
          }
          const token = {
            accessToken: result.access_token,
            expirationTime: Date.now() + result.expires_in * 1e3
          };
          if (!this.cachedToken_ || this.cachedToken_.accessToken !== token.accessToken || this.cachedToken_.expirationTime !== token.expirationTime) {
            this.cachedToken_ = token;
            this.tokenListeners_.forEach((listener) => {
              listener(token.accessToken);
            });
          }
          return token;
        }).catch((error3) => {
          let errorMessage = typeof error3 === "string" ? error3 : error3.message;
          errorMessage = `Credential implementation provided to initializeApp() via the "credential" property failed to fetch a valid Google OAuth2 access token with the following error: "${errorMessage}".`;
          if (errorMessage.indexOf("invalid_grant") !== -1) {
            errorMessage += " There are two likely causes: (1) your server time is not properly synced or (2) your certificate key file has been revoked. To solve (1), re-sync the time on your server. To solve (2), make sure the key ID for your key file is still present at https://console.firebase.google.com/iam-admin/serviceaccounts/project. If not, generate a new key file at https://console.firebase.google.com/project/_/settings/serviceaccounts/adminsdk.";
          }
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_CREDENTIAL, errorMessage);
        }).finally(() => {
          this.isRefreshing = false;
        });
      }
      shouldRefresh() {
        return (!this.cachedToken_ || this.cachedToken_.expirationTime - Date.now() <= TOKEN_EXPIRY_THRESHOLD_MILLIS) && !this.isRefreshing;
      }
      /**
       * Adds a listener that is called each time a token changes.
       *
       * @param listener - The listener that will be called with each new token.
       */
      addAuthTokenListener(listener) {
        this.tokenListeners_.push(listener);
        if (this.cachedToken_) {
          listener(this.cachedToken_.accessToken);
        }
      }
      /**
       * Removes a token listener.
       *
       * @param listener - The listener to remove.
       */
      removeAuthTokenListener(listener) {
        this.tokenListeners_ = this.tokenListeners_.filter((other) => other !== listener);
      }
    };
    exports.FirebaseAppInternals = FirebaseAppInternals;
    var FirebaseApp = class {
      static {
        __name(this, "FirebaseApp");
      }
      constructor(options, name, appStore) {
        this.appStore = appStore;
        this.services_ = {};
        this.isDeleted_ = false;
        this.name_ = name;
        this.options_ = (0, deep_copy_1.deepCopy)(options);
        if (!validator.isNonNullObject(this.options_)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". Options must be a non-null object.`);
        }
        const hasCredential = "credential" in this.options_;
        if (!hasCredential) {
          this.options_.credential = (0, credential_internal_1.getApplicationDefault)(this.options_.httpAgent);
        }
        const credential = this.options_.credential;
        if (typeof credential !== "object" || credential === null || typeof credential.getAccessToken !== "function") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, `Invalid Firebase app options passed as the first argument to initializeApp() for the app named "${this.name_}". The "credential" property must be an object which implements the Credential interface.`);
        }
        this.INTERNAL = new FirebaseAppInternals(credential);
      }
      /**
       * Returns the name of the FirebaseApp instance.
       *
       * @returns The name of the FirebaseApp instance.
       */
      get name() {
        this.checkDestroyed_();
        return this.name_;
      }
      /**
       * Returns the options for the FirebaseApp instance.
       *
       * @returns The options for the FirebaseApp instance.
       */
      get options() {
        this.checkDestroyed_();
        return (0, deep_copy_1.deepCopy)(this.options_);
      }
      /**
       * @internal
       */
      getOrInitService(name, init) {
        return this.ensureService_(name, () => init(this));
      }
      /**
       * Deletes the FirebaseApp instance.
       *
       * @returns An empty Promise fulfilled once the FirebaseApp instance is deleted.
       */
      delete() {
        this.checkDestroyed_();
        this.appStore?.removeApp(this.name);
        return Promise.all(Object.keys(this.services_).map((serviceName) => {
          const service = this.services_[serviceName];
          if (isStateful(service)) {
            return service.delete();
          }
          return Promise.resolve();
        })).then(() => {
          this.services_ = {};
          this.isDeleted_ = true;
        });
      }
      // eslint-disable-next-line @typescript-eslint/naming-convention
      ensureService_(serviceName, initializer) {
        this.checkDestroyed_();
        if (!(serviceName in this.services_)) {
          this.services_[serviceName] = initializer();
        }
        return this.services_[serviceName];
      }
      /**
       * Throws an Error if the FirebaseApp instance has already been deleted.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      checkDestroyed_() {
        if (this.isDeleted_) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.APP_DELETED, `Firebase app named "${this.name_}" has already been deleted.`);
        }
      }
    };
    exports.FirebaseApp = FirebaseApp;
    function isStateful(service) {
      return typeof service.delete === "function";
    }
    __name(isStateful, "isStateful");
  }
});

// node_modules/firebase-admin/lib/app/lifecycle.js
var require_lifecycle = __commonJS({
  "node_modules/firebase-admin/lib/app/lifecycle.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FIREBASE_CONFIG_VAR = exports.defaultAppStore = exports.AppStore = void 0;
    exports.initializeApp = initializeApp2;
    exports.getApp = getApp2;
    exports.getApps = getApps2;
    exports.deleteApp = deleteApp2;
    var fs = require_fs();
    var validator = require_validator();
    var error_1 = require_error();
    var credential_internal_1 = require_credential_internal();
    var firebase_app_1 = require_firebase_app();
    var DEFAULT_APP_NAME = "[DEFAULT]";
    var AppStore = class {
      static {
        __name(this, "AppStore");
      }
      constructor() {
        this.appStore = /* @__PURE__ */ new Map();
      }
      initializeApp(options, appName = DEFAULT_APP_NAME) {
        if (typeof options === "undefined") {
          options = loadOptionsFromEnvVar();
          options.credential = (0, credential_internal_1.getApplicationDefault)();
        }
        if (typeof appName !== "string" || appName === "") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
        } else if (this.appStore.has(appName)) {
          if (appName === DEFAULT_APP_NAME) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, "The default Firebase app already exists. This means you called initializeApp() more than once without providing an app name as the second argument. In most cases you only need to call initializeApp() once. But if you do want to initialize multiple apps, pass a second argument to initializeApp() to give each app a unique name.");
          } else {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.DUPLICATE_APP, `Firebase app named "${appName}" already exists. This means you called initializeApp() more than once with the same app name as the second argument. Make sure you provide a unique name every time you call initializeApp().`);
          }
        }
        const app = new firebase_app_1.FirebaseApp(options, appName, this);
        this.appStore.set(app.name, app);
        return app;
      }
      getApp(appName = DEFAULT_APP_NAME) {
        if (typeof appName !== "string" || appName === "") {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_NAME, `Invalid Firebase app name "${appName}" provided. App name must be a non-empty string.`);
        } else if (!this.appStore.has(appName)) {
          let errorMessage = appName === DEFAULT_APP_NAME ? "The default Firebase app does not exist. " : `Firebase app named "${appName}" does not exist. `;
          errorMessage += "Make sure you call initializeApp() before using any of the Firebase services.";
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NO_APP, errorMessage);
        }
        return this.appStore.get(appName);
      }
      getApps() {
        return Array.from(this.appStore.values());
      }
      deleteApp(app) {
        if (typeof app !== "object" || app === null || !("options" in app)) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "Invalid app argument.");
        }
        const existingApp = getApp2(app.name);
        return existingApp.delete();
      }
      clearAllApps() {
        const promises = [];
        this.getApps().forEach((app) => {
          promises.push(this.deleteApp(app));
        });
        return Promise.all(promises).then();
      }
      /**
       * Removes the specified App instance from the store. This is currently called by the
       * {@link FirebaseApp.delete} method. Can be removed once the app deletion is handled
       * entirely by the {@link deleteApp} top-level function.
       */
      removeApp(appName) {
        this.appStore.delete(appName);
      }
    };
    exports.AppStore = AppStore;
    exports.defaultAppStore = new AppStore();
    function initializeApp2(options, appName = DEFAULT_APP_NAME) {
      return exports.defaultAppStore.initializeApp(options, appName);
    }
    __name(initializeApp2, "initializeApp");
    function getApp2(appName = DEFAULT_APP_NAME) {
      return exports.defaultAppStore.getApp(appName);
    }
    __name(getApp2, "getApp");
    function getApps2() {
      return exports.defaultAppStore.getApps();
    }
    __name(getApps2, "getApps");
    function deleteApp2(app) {
      return exports.defaultAppStore.deleteApp(app);
    }
    __name(deleteApp2, "deleteApp");
    exports.FIREBASE_CONFIG_VAR = "FIREBASE_CONFIG";
    function loadOptionsFromEnvVar() {
      const config2 = process.env[exports.FIREBASE_CONFIG_VAR];
      if (!validator.isNonEmptyString(config2)) {
        return {};
      }
      try {
        const contents = config2.startsWith("{") ? config2 : fs.readFileSync(config2, "utf8");
        return JSON.parse(contents);
      } catch (error3) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_APP_OPTIONS, "Failed to parse app options file: " + error3);
      }
    }
    __name(loadOptionsFromEnvVar, "loadOptionsFromEnvVar");
  }
});

// node_modules/firebase-admin/lib/app/credential-factory.js
var require_credential_factory = __commonJS({
  "node_modules/firebase-admin/lib/app/credential-factory.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.applicationDefault = applicationDefault2;
    exports.cert = cert2;
    exports.refreshToken = refreshToken2;
    exports.clearGlobalAppDefaultCred = clearGlobalAppDefaultCred;
    var credential_internal_1 = require_credential_internal();
    var globalAppDefaultCred;
    var globalCertCreds = {};
    var globalRefreshTokenCreds = {};
    function applicationDefault2(httpAgent) {
      if (typeof globalAppDefaultCred === "undefined") {
        globalAppDefaultCred = (0, credential_internal_1.getApplicationDefault)(httpAgent);
      }
      return globalAppDefaultCred;
    }
    __name(applicationDefault2, "applicationDefault");
    function cert2(serviceAccountPathOrObject, httpAgent) {
      const stringifiedServiceAccount = JSON.stringify(serviceAccountPathOrObject);
      if (!(stringifiedServiceAccount in globalCertCreds)) {
        globalCertCreds[stringifiedServiceAccount] = new credential_internal_1.ServiceAccountCredential(serviceAccountPathOrObject, httpAgent);
      }
      return globalCertCreds[stringifiedServiceAccount];
    }
    __name(cert2, "cert");
    function refreshToken2(refreshTokenPathOrObject, httpAgent) {
      const stringifiedRefreshToken = JSON.stringify(refreshTokenPathOrObject);
      if (!(stringifiedRefreshToken in globalRefreshTokenCreds)) {
        globalRefreshTokenCreds[stringifiedRefreshToken] = new credential_internal_1.RefreshTokenCredential(refreshTokenPathOrObject, httpAgent);
      }
      return globalRefreshTokenCreds[stringifiedRefreshToken];
    }
    __name(refreshToken2, "refreshToken");
    function clearGlobalAppDefaultCred() {
      globalAppDefaultCred = void 0;
    }
    __name(clearGlobalAppDefaultCred, "clearGlobalAppDefaultCred");
  }
});

// node_modules/firebase-admin/lib/app/index.js
var require_app = __commonJS({
  "node_modules/firebase-admin/lib/app/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK_VERSION = exports.AppErrorCodes = exports.FirebaseAppError = exports.refreshToken = exports.cert = exports.applicationDefault = exports.deleteApp = exports.getApps = exports.getApp = exports.initializeApp = void 0;
    var utils_1 = require_utils();
    var lifecycle_1 = require_lifecycle();
    Object.defineProperty(exports, "initializeApp", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lifecycle_1.initializeApp;
    }, "get") });
    Object.defineProperty(exports, "getApp", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lifecycle_1.getApp;
    }, "get") });
    Object.defineProperty(exports, "getApps", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lifecycle_1.getApps;
    }, "get") });
    Object.defineProperty(exports, "deleteApp", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return lifecycle_1.deleteApp;
    }, "get") });
    var credential_factory_1 = require_credential_factory();
    Object.defineProperty(exports, "applicationDefault", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return credential_factory_1.applicationDefault;
    }, "get") });
    Object.defineProperty(exports, "cert", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return credential_factory_1.cert;
    }, "get") });
    Object.defineProperty(exports, "refreshToken", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return credential_factory_1.refreshToken;
    }, "get") });
    var error_1 = require_error();
    Object.defineProperty(exports, "FirebaseAppError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return error_1.FirebaseAppError;
    }, "get") });
    Object.defineProperty(exports, "AppErrorCodes", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return error_1.AppErrorCodes;
    }, "get") });
    exports.SDK_VERSION = (0, utils_1.getSdkVersion)();
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http2/constants.mjs
var NGHTTP2_ERR_FRAME_SIZE_ERROR, NGHTTP2_SESSION_SERVER, NGHTTP2_SESSION_CLIENT, NGHTTP2_STREAM_STATE_IDLE, NGHTTP2_STREAM_STATE_OPEN, NGHTTP2_STREAM_STATE_RESERVED_LOCAL, NGHTTP2_STREAM_STATE_RESERVED_REMOTE, NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL, NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE, NGHTTP2_STREAM_STATE_CLOSED, NGHTTP2_FLAG_NONE, NGHTTP2_FLAG_END_STREAM, NGHTTP2_FLAG_END_HEADERS, NGHTTP2_FLAG_ACK, NGHTTP2_FLAG_PADDED, NGHTTP2_FLAG_PRIORITY, DEFAULT_SETTINGS_HEADER_TABLE_SIZE, DEFAULT_SETTINGS_ENABLE_PUSH, DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS, DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE, DEFAULT_SETTINGS_MAX_FRAME_SIZE, DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE, DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL, MAX_MAX_FRAME_SIZE, MIN_MAX_FRAME_SIZE, MAX_INITIAL_WINDOW_SIZE, NGHTTP2_SETTINGS_HEADER_TABLE_SIZE, NGHTTP2_SETTINGS_ENABLE_PUSH, NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS, NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE, NGHTTP2_SETTINGS_MAX_FRAME_SIZE, NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE, NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL, PADDING_STRATEGY_NONE, PADDING_STRATEGY_ALIGNED, PADDING_STRATEGY_MAX, PADDING_STRATEGY_CALLBACK, NGHTTP2_NO_ERROR, NGHTTP2_PROTOCOL_ERROR, NGHTTP2_INTERNAL_ERROR, NGHTTP2_FLOW_CONTROL_ERROR, NGHTTP2_SETTINGS_TIMEOUT, NGHTTP2_STREAM_CLOSED, NGHTTP2_FRAME_SIZE_ERROR, NGHTTP2_REFUSED_STREAM, NGHTTP2_CANCEL, NGHTTP2_COMPRESSION_ERROR, NGHTTP2_CONNECT_ERROR, NGHTTP2_ENHANCE_YOUR_CALM, NGHTTP2_INADEQUATE_SECURITY, NGHTTP2_HTTP_1_1_REQUIRED, NGHTTP2_DEFAULT_WEIGHT, HTTP2_HEADER_STATUS, HTTP2_HEADER_METHOD, HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_SCHEME, HTTP2_HEADER_PATH, HTTP2_HEADER_PROTOCOL, HTTP2_HEADER_ACCEPT_ENCODING, HTTP2_HEADER_ACCEPT_LANGUAGE, HTTP2_HEADER_ACCEPT_RANGES, HTTP2_HEADER_ACCEPT, HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS, HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS, HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS, HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN, HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS, HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS, HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD, HTTP2_HEADER_AGE, HTTP2_HEADER_AUTHORIZATION, HTTP2_HEADER_CACHE_CONTROL, HTTP2_HEADER_CONNECTION, HTTP2_HEADER_CONTENT_DISPOSITION, HTTP2_HEADER_CONTENT_ENCODING, HTTP2_HEADER_CONTENT_LENGTH, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_COOKIE, HTTP2_HEADER_DATE, HTTP2_HEADER_ETAG, HTTP2_HEADER_FORWARDED, HTTP2_HEADER_HOST, HTTP2_HEADER_IF_MODIFIED_SINCE, HTTP2_HEADER_IF_NONE_MATCH, HTTP2_HEADER_IF_RANGE, HTTP2_HEADER_LAST_MODIFIED, HTTP2_HEADER_LINK, HTTP2_HEADER_LOCATION, HTTP2_HEADER_RANGE, HTTP2_HEADER_REFERER, HTTP2_HEADER_SERVER, HTTP2_HEADER_SET_COOKIE, HTTP2_HEADER_STRICT_TRANSPORT_SECURITY, HTTP2_HEADER_TRANSFER_ENCODING, HTTP2_HEADER_TE, HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS, HTTP2_HEADER_UPGRADE, HTTP2_HEADER_USER_AGENT, HTTP2_HEADER_VARY, HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS, HTTP2_HEADER_X_FRAME_OPTIONS, HTTP2_HEADER_KEEP_ALIVE, HTTP2_HEADER_PROXY_CONNECTION, HTTP2_HEADER_X_XSS_PROTECTION, HTTP2_HEADER_ALT_SVC, HTTP2_HEADER_CONTENT_SECURITY_POLICY, HTTP2_HEADER_EARLY_DATA, HTTP2_HEADER_EXPECT_CT, HTTP2_HEADER_ORIGIN, HTTP2_HEADER_PURPOSE, HTTP2_HEADER_TIMING_ALLOW_ORIGIN, HTTP2_HEADER_X_FORWARDED_FOR, HTTP2_HEADER_PRIORITY, HTTP2_HEADER_ACCEPT_CHARSET, HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE, HTTP2_HEADER_ALLOW, HTTP2_HEADER_CONTENT_LANGUAGE, HTTP2_HEADER_CONTENT_LOCATION, HTTP2_HEADER_CONTENT_MD5, HTTP2_HEADER_CONTENT_RANGE, HTTP2_HEADER_DNT, HTTP2_HEADER_EXPECT, HTTP2_HEADER_EXPIRES, HTTP2_HEADER_FROM, HTTP2_HEADER_IF_MATCH, HTTP2_HEADER_IF_UNMODIFIED_SINCE, HTTP2_HEADER_MAX_FORWARDS, HTTP2_HEADER_PREFER, HTTP2_HEADER_PROXY_AUTHENTICATE, HTTP2_HEADER_PROXY_AUTHORIZATION, HTTP2_HEADER_REFRESH, HTTP2_HEADER_RETRY_AFTER, HTTP2_HEADER_TRAILER, HTTP2_HEADER_TK, HTTP2_HEADER_VIA, HTTP2_HEADER_WARNING, HTTP2_HEADER_WWW_AUTHENTICATE, HTTP2_HEADER_HTTP2_SETTINGS, HTTP2_METHOD_ACL, HTTP2_METHOD_BASELINE_CONTROL, HTTP2_METHOD_BIND, HTTP2_METHOD_CHECKIN, HTTP2_METHOD_CHECKOUT, HTTP2_METHOD_CONNECT, HTTP2_METHOD_COPY, HTTP2_METHOD_DELETE, HTTP2_METHOD_GET, HTTP2_METHOD_HEAD, HTTP2_METHOD_LABEL, HTTP2_METHOD_LINK, HTTP2_METHOD_LOCK, HTTP2_METHOD_MERGE, HTTP2_METHOD_MKACTIVITY, HTTP2_METHOD_MKCALENDAR, HTTP2_METHOD_MKCOL, HTTP2_METHOD_MKREDIRECTREF, HTTP2_METHOD_MKWORKSPACE, HTTP2_METHOD_MOVE, HTTP2_METHOD_OPTIONS, HTTP2_METHOD_ORDERPATCH, HTTP2_METHOD_PATCH, HTTP2_METHOD_POST, HTTP2_METHOD_PRI, HTTP2_METHOD_PROPFIND, HTTP2_METHOD_PROPPATCH, HTTP2_METHOD_PUT, HTTP2_METHOD_REBIND, HTTP2_METHOD_REPORT, HTTP2_METHOD_SEARCH, HTTP2_METHOD_TRACE, HTTP2_METHOD_UNBIND, HTTP2_METHOD_UNCHECKOUT, HTTP2_METHOD_UNLINK, HTTP2_METHOD_UNLOCK, HTTP2_METHOD_UPDATE, HTTP2_METHOD_UPDATEREDIRECTREF, HTTP2_METHOD_VERSION_CONTROL, HTTP_STATUS_CONTINUE, HTTP_STATUS_SWITCHING_PROTOCOLS, HTTP_STATUS_PROCESSING, HTTP_STATUS_EARLY_HINTS, HTTP_STATUS_OK, HTTP_STATUS_CREATED, HTTP_STATUS_ACCEPTED, HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION, HTTP_STATUS_NO_CONTENT, HTTP_STATUS_RESET_CONTENT, HTTP_STATUS_PARTIAL_CONTENT, HTTP_STATUS_MULTI_STATUS, HTTP_STATUS_ALREADY_REPORTED, HTTP_STATUS_IM_USED, HTTP_STATUS_MULTIPLE_CHOICES, HTTP_STATUS_MOVED_PERMANENTLY, HTTP_STATUS_FOUND, HTTP_STATUS_SEE_OTHER, HTTP_STATUS_NOT_MODIFIED, HTTP_STATUS_USE_PROXY, HTTP_STATUS_TEMPORARY_REDIRECT, HTTP_STATUS_PERMANENT_REDIRECT, HTTP_STATUS_BAD_REQUEST, HTTP_STATUS_UNAUTHORIZED, HTTP_STATUS_PAYMENT_REQUIRED, HTTP_STATUS_FORBIDDEN, HTTP_STATUS_NOT_FOUND, HTTP_STATUS_METHOD_NOT_ALLOWED, HTTP_STATUS_NOT_ACCEPTABLE, HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED, HTTP_STATUS_REQUEST_TIMEOUT, HTTP_STATUS_CONFLICT, HTTP_STATUS_GONE, HTTP_STATUS_LENGTH_REQUIRED, HTTP_STATUS_PRECONDITION_FAILED, HTTP_STATUS_PAYLOAD_TOO_LARGE, HTTP_STATUS_URI_TOO_LONG, HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE, HTTP_STATUS_RANGE_NOT_SATISFIABLE, HTTP_STATUS_EXPECTATION_FAILED, HTTP_STATUS_TEAPOT, HTTP_STATUS_MISDIRECTED_REQUEST, HTTP_STATUS_UNPROCESSABLE_ENTITY, HTTP_STATUS_LOCKED, HTTP_STATUS_FAILED_DEPENDENCY, HTTP_STATUS_TOO_EARLY, HTTP_STATUS_UPGRADE_REQUIRED, HTTP_STATUS_PRECONDITION_REQUIRED, HTTP_STATUS_TOO_MANY_REQUESTS, HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE, HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS, HTTP_STATUS_INTERNAL_SERVER_ERROR, HTTP_STATUS_NOT_IMPLEMENTED, HTTP_STATUS_BAD_GATEWAY, HTTP_STATUS_SERVICE_UNAVAILABLE, HTTP_STATUS_GATEWAY_TIMEOUT, HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED, HTTP_STATUS_VARIANT_ALSO_NEGOTIATES, HTTP_STATUS_INSUFFICIENT_STORAGE, HTTP_STATUS_LOOP_DETECTED, HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED, HTTP_STATUS_NOT_EXTENDED, HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED;
var init_constants6 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/internal/http2/constants.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    NGHTTP2_ERR_FRAME_SIZE_ERROR = -522;
    NGHTTP2_SESSION_SERVER = 0;
    NGHTTP2_SESSION_CLIENT = 1;
    NGHTTP2_STREAM_STATE_IDLE = 1;
    NGHTTP2_STREAM_STATE_OPEN = 2;
    NGHTTP2_STREAM_STATE_RESERVED_LOCAL = 3;
    NGHTTP2_STREAM_STATE_RESERVED_REMOTE = 4;
    NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL = 5;
    NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE = 6;
    NGHTTP2_STREAM_STATE_CLOSED = 7;
    NGHTTP2_FLAG_NONE = 0;
    NGHTTP2_FLAG_END_STREAM = 1;
    NGHTTP2_FLAG_END_HEADERS = 4;
    NGHTTP2_FLAG_ACK = 1;
    NGHTTP2_FLAG_PADDED = 8;
    NGHTTP2_FLAG_PRIORITY = 32;
    DEFAULT_SETTINGS_HEADER_TABLE_SIZE = 4096;
    DEFAULT_SETTINGS_ENABLE_PUSH = 1;
    DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS = 4294967295;
    DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE = 65535;
    DEFAULT_SETTINGS_MAX_FRAME_SIZE = 16384;
    DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE = 65535;
    DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL = 0;
    MAX_MAX_FRAME_SIZE = 16777215;
    MIN_MAX_FRAME_SIZE = 16384;
    MAX_INITIAL_WINDOW_SIZE = 2147483647;
    NGHTTP2_SETTINGS_HEADER_TABLE_SIZE = 1;
    NGHTTP2_SETTINGS_ENABLE_PUSH = 2;
    NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS = 3;
    NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE = 4;
    NGHTTP2_SETTINGS_MAX_FRAME_SIZE = 5;
    NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE = 6;
    NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL = 8;
    PADDING_STRATEGY_NONE = 0;
    PADDING_STRATEGY_ALIGNED = 1;
    PADDING_STRATEGY_MAX = 2;
    PADDING_STRATEGY_CALLBACK = 1;
    NGHTTP2_NO_ERROR = 0;
    NGHTTP2_PROTOCOL_ERROR = 1;
    NGHTTP2_INTERNAL_ERROR = 2;
    NGHTTP2_FLOW_CONTROL_ERROR = 3;
    NGHTTP2_SETTINGS_TIMEOUT = 4;
    NGHTTP2_STREAM_CLOSED = 5;
    NGHTTP2_FRAME_SIZE_ERROR = 6;
    NGHTTP2_REFUSED_STREAM = 7;
    NGHTTP2_CANCEL = 8;
    NGHTTP2_COMPRESSION_ERROR = 9;
    NGHTTP2_CONNECT_ERROR = 10;
    NGHTTP2_ENHANCE_YOUR_CALM = 11;
    NGHTTP2_INADEQUATE_SECURITY = 12;
    NGHTTP2_HTTP_1_1_REQUIRED = 13;
    NGHTTP2_DEFAULT_WEIGHT = 16;
    HTTP2_HEADER_STATUS = ":status";
    HTTP2_HEADER_METHOD = ":method";
    HTTP2_HEADER_AUTHORITY = ":authority";
    HTTP2_HEADER_SCHEME = ":scheme";
    HTTP2_HEADER_PATH = ":path";
    HTTP2_HEADER_PROTOCOL = ":protocol";
    HTTP2_HEADER_ACCEPT_ENCODING = "accept-encoding";
    HTTP2_HEADER_ACCEPT_LANGUAGE = "accept-language";
    HTTP2_HEADER_ACCEPT_RANGES = "accept-ranges";
    HTTP2_HEADER_ACCEPT = "accept";
    HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS = "access-control-allow-credentials";
    HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS = "access-control-allow-headers";
    HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS = "access-control-allow-methods";
    HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN = "access-control-allow-origin";
    HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS = "access-control-expose-headers";
    HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS = "access-control-request-headers";
    HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD = "access-control-request-method";
    HTTP2_HEADER_AGE = "age";
    HTTP2_HEADER_AUTHORIZATION = "authorization";
    HTTP2_HEADER_CACHE_CONTROL = "cache-control";
    HTTP2_HEADER_CONNECTION = "connection";
    HTTP2_HEADER_CONTENT_DISPOSITION = "content-disposition";
    HTTP2_HEADER_CONTENT_ENCODING = "content-encoding";
    HTTP2_HEADER_CONTENT_LENGTH = "content-length";
    HTTP2_HEADER_CONTENT_TYPE = "content-type";
    HTTP2_HEADER_COOKIE = "cookie";
    HTTP2_HEADER_DATE = "date";
    HTTP2_HEADER_ETAG = "etag";
    HTTP2_HEADER_FORWARDED = "forwarded";
    HTTP2_HEADER_HOST = "host";
    HTTP2_HEADER_IF_MODIFIED_SINCE = "if-modified-since";
    HTTP2_HEADER_IF_NONE_MATCH = "if-none-match";
    HTTP2_HEADER_IF_RANGE = "if-range";
    HTTP2_HEADER_LAST_MODIFIED = "last-modified";
    HTTP2_HEADER_LINK = "link";
    HTTP2_HEADER_LOCATION = "location";
    HTTP2_HEADER_RANGE = "range";
    HTTP2_HEADER_REFERER = "referer";
    HTTP2_HEADER_SERVER = "server";
    HTTP2_HEADER_SET_COOKIE = "set-cookie";
    HTTP2_HEADER_STRICT_TRANSPORT_SECURITY = "strict-transport-security";
    HTTP2_HEADER_TRANSFER_ENCODING = "transfer-encoding";
    HTTP2_HEADER_TE = "te";
    HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS = "upgrade-insecure-requests";
    HTTP2_HEADER_UPGRADE = "upgrade";
    HTTP2_HEADER_USER_AGENT = "user-agent";
    HTTP2_HEADER_VARY = "vary";
    HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS = "x-content-type-options";
    HTTP2_HEADER_X_FRAME_OPTIONS = "x-frame-options";
    HTTP2_HEADER_KEEP_ALIVE = "keep-alive";
    HTTP2_HEADER_PROXY_CONNECTION = "proxy-connection";
    HTTP2_HEADER_X_XSS_PROTECTION = "x-xss-protection";
    HTTP2_HEADER_ALT_SVC = "alt-svc";
    HTTP2_HEADER_CONTENT_SECURITY_POLICY = "content-security-policy";
    HTTP2_HEADER_EARLY_DATA = "early-data";
    HTTP2_HEADER_EXPECT_CT = "expect-ct";
    HTTP2_HEADER_ORIGIN = "origin";
    HTTP2_HEADER_PURPOSE = "purpose";
    HTTP2_HEADER_TIMING_ALLOW_ORIGIN = "timing-allow-origin";
    HTTP2_HEADER_X_FORWARDED_FOR = "x-forwarded-for";
    HTTP2_HEADER_PRIORITY = "priority";
    HTTP2_HEADER_ACCEPT_CHARSET = "accept-charset";
    HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE = "access-control-max-age";
    HTTP2_HEADER_ALLOW = "allow";
    HTTP2_HEADER_CONTENT_LANGUAGE = "content-language";
    HTTP2_HEADER_CONTENT_LOCATION = "content-location";
    HTTP2_HEADER_CONTENT_MD5 = "content-md5";
    HTTP2_HEADER_CONTENT_RANGE = "content-range";
    HTTP2_HEADER_DNT = "dnt";
    HTTP2_HEADER_EXPECT = "expect";
    HTTP2_HEADER_EXPIRES = "expires";
    HTTP2_HEADER_FROM = "from";
    HTTP2_HEADER_IF_MATCH = "if-match";
    HTTP2_HEADER_IF_UNMODIFIED_SINCE = "if-unmodified-since";
    HTTP2_HEADER_MAX_FORWARDS = "max-forwards";
    HTTP2_HEADER_PREFER = "prefer";
    HTTP2_HEADER_PROXY_AUTHENTICATE = "proxy-authenticate";
    HTTP2_HEADER_PROXY_AUTHORIZATION = "proxy-authorization";
    HTTP2_HEADER_REFRESH = "refresh";
    HTTP2_HEADER_RETRY_AFTER = "retry-after";
    HTTP2_HEADER_TRAILER = "trailer";
    HTTP2_HEADER_TK = "tk";
    HTTP2_HEADER_VIA = "via";
    HTTP2_HEADER_WARNING = "warning";
    HTTP2_HEADER_WWW_AUTHENTICATE = "www-authenticate";
    HTTP2_HEADER_HTTP2_SETTINGS = "http2-settings";
    HTTP2_METHOD_ACL = "ACL";
    HTTP2_METHOD_BASELINE_CONTROL = "BASELINE-CONTROL";
    HTTP2_METHOD_BIND = "BIND";
    HTTP2_METHOD_CHECKIN = "CHECKIN";
    HTTP2_METHOD_CHECKOUT = "CHECKOUT";
    HTTP2_METHOD_CONNECT = "CONNECT";
    HTTP2_METHOD_COPY = "COPY";
    HTTP2_METHOD_DELETE = "DELETE";
    HTTP2_METHOD_GET = "GET";
    HTTP2_METHOD_HEAD = "HEAD";
    HTTP2_METHOD_LABEL = "LABEL";
    HTTP2_METHOD_LINK = "LINK";
    HTTP2_METHOD_LOCK = "LOCK";
    HTTP2_METHOD_MERGE = "MERGE";
    HTTP2_METHOD_MKACTIVITY = "MKACTIVITY";
    HTTP2_METHOD_MKCALENDAR = "MKCALENDAR";
    HTTP2_METHOD_MKCOL = "MKCOL";
    HTTP2_METHOD_MKREDIRECTREF = "MKREDIRECTREF";
    HTTP2_METHOD_MKWORKSPACE = "MKWORKSPACE";
    HTTP2_METHOD_MOVE = "MOVE";
    HTTP2_METHOD_OPTIONS = "OPTIONS";
    HTTP2_METHOD_ORDERPATCH = "ORDERPATCH";
    HTTP2_METHOD_PATCH = "PATCH";
    HTTP2_METHOD_POST = "POST";
    HTTP2_METHOD_PRI = "PRI";
    HTTP2_METHOD_PROPFIND = "PROPFIND";
    HTTP2_METHOD_PROPPATCH = "PROPPATCH";
    HTTP2_METHOD_PUT = "PUT";
    HTTP2_METHOD_REBIND = "REBIND";
    HTTP2_METHOD_REPORT = "REPORT";
    HTTP2_METHOD_SEARCH = "SEARCH";
    HTTP2_METHOD_TRACE = "TRACE";
    HTTP2_METHOD_UNBIND = "UNBIND";
    HTTP2_METHOD_UNCHECKOUT = "UNCHECKOUT";
    HTTP2_METHOD_UNLINK = "UNLINK";
    HTTP2_METHOD_UNLOCK = "UNLOCK";
    HTTP2_METHOD_UPDATE = "UPDATE";
    HTTP2_METHOD_UPDATEREDIRECTREF = "UPDATEREDIRECTREF";
    HTTP2_METHOD_VERSION_CONTROL = "VERSION-CONTROL";
    HTTP_STATUS_CONTINUE = 100;
    HTTP_STATUS_SWITCHING_PROTOCOLS = 101;
    HTTP_STATUS_PROCESSING = 102;
    HTTP_STATUS_EARLY_HINTS = 103;
    HTTP_STATUS_OK = 200;
    HTTP_STATUS_CREATED = 201;
    HTTP_STATUS_ACCEPTED = 202;
    HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION = 203;
    HTTP_STATUS_NO_CONTENT = 204;
    HTTP_STATUS_RESET_CONTENT = 205;
    HTTP_STATUS_PARTIAL_CONTENT = 206;
    HTTP_STATUS_MULTI_STATUS = 207;
    HTTP_STATUS_ALREADY_REPORTED = 208;
    HTTP_STATUS_IM_USED = 226;
    HTTP_STATUS_MULTIPLE_CHOICES = 300;
    HTTP_STATUS_MOVED_PERMANENTLY = 301;
    HTTP_STATUS_FOUND = 302;
    HTTP_STATUS_SEE_OTHER = 303;
    HTTP_STATUS_NOT_MODIFIED = 304;
    HTTP_STATUS_USE_PROXY = 305;
    HTTP_STATUS_TEMPORARY_REDIRECT = 307;
    HTTP_STATUS_PERMANENT_REDIRECT = 308;
    HTTP_STATUS_BAD_REQUEST = 400;
    HTTP_STATUS_UNAUTHORIZED = 401;
    HTTP_STATUS_PAYMENT_REQUIRED = 402;
    HTTP_STATUS_FORBIDDEN = 403;
    HTTP_STATUS_NOT_FOUND = 404;
    HTTP_STATUS_METHOD_NOT_ALLOWED = 405;
    HTTP_STATUS_NOT_ACCEPTABLE = 406;
    HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407;
    HTTP_STATUS_REQUEST_TIMEOUT = 408;
    HTTP_STATUS_CONFLICT = 409;
    HTTP_STATUS_GONE = 410;
    HTTP_STATUS_LENGTH_REQUIRED = 411;
    HTTP_STATUS_PRECONDITION_FAILED = 412;
    HTTP_STATUS_PAYLOAD_TOO_LARGE = 413;
    HTTP_STATUS_URI_TOO_LONG = 414;
    HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415;
    HTTP_STATUS_RANGE_NOT_SATISFIABLE = 416;
    HTTP_STATUS_EXPECTATION_FAILED = 417;
    HTTP_STATUS_TEAPOT = 418;
    HTTP_STATUS_MISDIRECTED_REQUEST = 421;
    HTTP_STATUS_UNPROCESSABLE_ENTITY = 422;
    HTTP_STATUS_LOCKED = 423;
    HTTP_STATUS_FAILED_DEPENDENCY = 424;
    HTTP_STATUS_TOO_EARLY = 425;
    HTTP_STATUS_UPGRADE_REQUIRED = 426;
    HTTP_STATUS_PRECONDITION_REQUIRED = 428;
    HTTP_STATUS_TOO_MANY_REQUESTS = 429;
    HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE = 431;
    HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS = 451;
    HTTP_STATUS_INTERNAL_SERVER_ERROR = 500;
    HTTP_STATUS_NOT_IMPLEMENTED = 501;
    HTTP_STATUS_BAD_GATEWAY = 502;
    HTTP_STATUS_SERVICE_UNAVAILABLE = 503;
    HTTP_STATUS_GATEWAY_TIMEOUT = 504;
    HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505;
    HTTP_STATUS_VARIANT_ALSO_NEGOTIATES = 506;
    HTTP_STATUS_INSUFFICIENT_STORAGE = 507;
    HTTP_STATUS_LOOP_DETECTED = 508;
    HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED = 509;
    HTTP_STATUS_NOT_EXTENDED = 510;
    HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED = 511;
  }
});

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http2.mjs
var constants3, createSecureServer, createServer5, connect2, performServerHandshake, Http2ServerRequest, Http2ServerResponse, getDefaultSettings, getPackedSettings, getUnpackedSettings, sensitiveHeaders, http2_default;
var init_http2 = __esm({
  "../../../../../../opt/homebrew/lib/node_modules/wrangler/node_modules/unenv/dist/runtime/node/http2.mjs"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_utils();
    init_constants6();
    constants3 = {
      NGHTTP2_ERR_FRAME_SIZE_ERROR,
      NGHTTP2_SESSION_SERVER,
      NGHTTP2_SESSION_CLIENT,
      NGHTTP2_STREAM_STATE_IDLE,
      NGHTTP2_STREAM_STATE_OPEN,
      NGHTTP2_STREAM_STATE_RESERVED_LOCAL,
      NGHTTP2_STREAM_STATE_RESERVED_REMOTE,
      NGHTTP2_STREAM_STATE_HALF_CLOSED_LOCAL,
      NGHTTP2_STREAM_STATE_HALF_CLOSED_REMOTE,
      NGHTTP2_STREAM_STATE_CLOSED,
      NGHTTP2_FLAG_NONE,
      NGHTTP2_FLAG_END_STREAM,
      NGHTTP2_FLAG_END_HEADERS,
      NGHTTP2_FLAG_ACK,
      NGHTTP2_FLAG_PADDED,
      NGHTTP2_FLAG_PRIORITY,
      DEFAULT_SETTINGS_HEADER_TABLE_SIZE,
      DEFAULT_SETTINGS_ENABLE_PUSH,
      DEFAULT_SETTINGS_MAX_CONCURRENT_STREAMS,
      DEFAULT_SETTINGS_INITIAL_WINDOW_SIZE,
      DEFAULT_SETTINGS_MAX_FRAME_SIZE,
      DEFAULT_SETTINGS_MAX_HEADER_LIST_SIZE,
      DEFAULT_SETTINGS_ENABLE_CONNECT_PROTOCOL,
      MAX_MAX_FRAME_SIZE,
      MIN_MAX_FRAME_SIZE,
      MAX_INITIAL_WINDOW_SIZE,
      NGHTTP2_SETTINGS_HEADER_TABLE_SIZE,
      NGHTTP2_SETTINGS_ENABLE_PUSH,
      NGHTTP2_SETTINGS_MAX_CONCURRENT_STREAMS,
      NGHTTP2_SETTINGS_INITIAL_WINDOW_SIZE,
      NGHTTP2_SETTINGS_MAX_FRAME_SIZE,
      NGHTTP2_SETTINGS_MAX_HEADER_LIST_SIZE,
      NGHTTP2_SETTINGS_ENABLE_CONNECT_PROTOCOL,
      PADDING_STRATEGY_NONE,
      PADDING_STRATEGY_ALIGNED,
      PADDING_STRATEGY_MAX,
      PADDING_STRATEGY_CALLBACK,
      NGHTTP2_NO_ERROR,
      NGHTTP2_PROTOCOL_ERROR,
      NGHTTP2_INTERNAL_ERROR,
      NGHTTP2_FLOW_CONTROL_ERROR,
      NGHTTP2_SETTINGS_TIMEOUT,
      NGHTTP2_STREAM_CLOSED,
      NGHTTP2_FRAME_SIZE_ERROR,
      NGHTTP2_REFUSED_STREAM,
      NGHTTP2_CANCEL,
      NGHTTP2_COMPRESSION_ERROR,
      NGHTTP2_CONNECT_ERROR,
      NGHTTP2_ENHANCE_YOUR_CALM,
      NGHTTP2_INADEQUATE_SECURITY,
      NGHTTP2_HTTP_1_1_REQUIRED,
      NGHTTP2_DEFAULT_WEIGHT,
      HTTP2_HEADER_STATUS,
      HTTP2_HEADER_METHOD,
      HTTP2_HEADER_AUTHORITY,
      HTTP2_HEADER_SCHEME,
      HTTP2_HEADER_PATH,
      HTTP2_HEADER_PROTOCOL,
      HTTP2_HEADER_ACCEPT_ENCODING,
      HTTP2_HEADER_ACCEPT_LANGUAGE,
      HTTP2_HEADER_ACCEPT_RANGES,
      HTTP2_HEADER_ACCEPT,
      HTTP2_HEADER_ACCESS_CONTROL_ALLOW_CREDENTIALS,
      HTTP2_HEADER_ACCESS_CONTROL_ALLOW_HEADERS,
      HTTP2_HEADER_ACCESS_CONTROL_ALLOW_METHODS,
      HTTP2_HEADER_ACCESS_CONTROL_ALLOW_ORIGIN,
      HTTP2_HEADER_ACCESS_CONTROL_EXPOSE_HEADERS,
      HTTP2_HEADER_ACCESS_CONTROL_REQUEST_HEADERS,
      HTTP2_HEADER_ACCESS_CONTROL_REQUEST_METHOD,
      HTTP2_HEADER_AGE,
      HTTP2_HEADER_AUTHORIZATION,
      HTTP2_HEADER_CACHE_CONTROL,
      HTTP2_HEADER_CONNECTION,
      HTTP2_HEADER_CONTENT_DISPOSITION,
      HTTP2_HEADER_CONTENT_ENCODING,
      HTTP2_HEADER_CONTENT_LENGTH,
      HTTP2_HEADER_CONTENT_TYPE,
      HTTP2_HEADER_COOKIE,
      HTTP2_HEADER_DATE,
      HTTP2_HEADER_ETAG,
      HTTP2_HEADER_FORWARDED,
      HTTP2_HEADER_HOST,
      HTTP2_HEADER_IF_MODIFIED_SINCE,
      HTTP2_HEADER_IF_NONE_MATCH,
      HTTP2_HEADER_IF_RANGE,
      HTTP2_HEADER_LAST_MODIFIED,
      HTTP2_HEADER_LINK,
      HTTP2_HEADER_LOCATION,
      HTTP2_HEADER_RANGE,
      HTTP2_HEADER_REFERER,
      HTTP2_HEADER_SERVER,
      HTTP2_HEADER_SET_COOKIE,
      HTTP2_HEADER_STRICT_TRANSPORT_SECURITY,
      HTTP2_HEADER_TRANSFER_ENCODING,
      HTTP2_HEADER_TE,
      HTTP2_HEADER_UPGRADE_INSECURE_REQUESTS,
      HTTP2_HEADER_UPGRADE,
      HTTP2_HEADER_USER_AGENT,
      HTTP2_HEADER_VARY,
      HTTP2_HEADER_X_CONTENT_TYPE_OPTIONS,
      HTTP2_HEADER_X_FRAME_OPTIONS,
      HTTP2_HEADER_KEEP_ALIVE,
      HTTP2_HEADER_PROXY_CONNECTION,
      HTTP2_HEADER_X_XSS_PROTECTION,
      HTTP2_HEADER_ALT_SVC,
      HTTP2_HEADER_CONTENT_SECURITY_POLICY,
      HTTP2_HEADER_EARLY_DATA,
      HTTP2_HEADER_EXPECT_CT,
      HTTP2_HEADER_ORIGIN,
      HTTP2_HEADER_PURPOSE,
      HTTP2_HEADER_TIMING_ALLOW_ORIGIN,
      HTTP2_HEADER_X_FORWARDED_FOR,
      HTTP2_HEADER_PRIORITY,
      HTTP2_HEADER_ACCEPT_CHARSET,
      HTTP2_HEADER_ACCESS_CONTROL_MAX_AGE,
      HTTP2_HEADER_ALLOW,
      HTTP2_HEADER_CONTENT_LANGUAGE,
      HTTP2_HEADER_CONTENT_LOCATION,
      HTTP2_HEADER_CONTENT_MD5,
      HTTP2_HEADER_CONTENT_RANGE,
      HTTP2_HEADER_DNT,
      HTTP2_HEADER_EXPECT,
      HTTP2_HEADER_EXPIRES,
      HTTP2_HEADER_FROM,
      HTTP2_HEADER_IF_MATCH,
      HTTP2_HEADER_IF_UNMODIFIED_SINCE,
      HTTP2_HEADER_MAX_FORWARDS,
      HTTP2_HEADER_PREFER,
      HTTP2_HEADER_PROXY_AUTHENTICATE,
      HTTP2_HEADER_PROXY_AUTHORIZATION,
      HTTP2_HEADER_REFRESH,
      HTTP2_HEADER_RETRY_AFTER,
      HTTP2_HEADER_TRAILER,
      HTTP2_HEADER_TK,
      HTTP2_HEADER_VIA,
      HTTP2_HEADER_WARNING,
      HTTP2_HEADER_WWW_AUTHENTICATE,
      HTTP2_HEADER_HTTP2_SETTINGS,
      HTTP2_METHOD_ACL,
      HTTP2_METHOD_BASELINE_CONTROL,
      HTTP2_METHOD_BIND,
      HTTP2_METHOD_CHECKIN,
      HTTP2_METHOD_CHECKOUT,
      HTTP2_METHOD_CONNECT,
      HTTP2_METHOD_COPY,
      HTTP2_METHOD_DELETE,
      HTTP2_METHOD_GET,
      HTTP2_METHOD_HEAD,
      HTTP2_METHOD_LABEL,
      HTTP2_METHOD_LINK,
      HTTP2_METHOD_LOCK,
      HTTP2_METHOD_MERGE,
      HTTP2_METHOD_MKACTIVITY,
      HTTP2_METHOD_MKCALENDAR,
      HTTP2_METHOD_MKCOL,
      HTTP2_METHOD_MKREDIRECTREF,
      HTTP2_METHOD_MKWORKSPACE,
      HTTP2_METHOD_MOVE,
      HTTP2_METHOD_OPTIONS,
      HTTP2_METHOD_ORDERPATCH,
      HTTP2_METHOD_PATCH,
      HTTP2_METHOD_POST,
      HTTP2_METHOD_PRI,
      HTTP2_METHOD_PROPFIND,
      HTTP2_METHOD_PROPPATCH,
      HTTP2_METHOD_PUT,
      HTTP2_METHOD_REBIND,
      HTTP2_METHOD_REPORT,
      HTTP2_METHOD_SEARCH,
      HTTP2_METHOD_TRACE,
      HTTP2_METHOD_UNBIND,
      HTTP2_METHOD_UNCHECKOUT,
      HTTP2_METHOD_UNLINK,
      HTTP2_METHOD_UNLOCK,
      HTTP2_METHOD_UPDATE,
      HTTP2_METHOD_UPDATEREDIRECTREF,
      HTTP2_METHOD_VERSION_CONTROL,
      HTTP_STATUS_CONTINUE,
      HTTP_STATUS_SWITCHING_PROTOCOLS,
      HTTP_STATUS_PROCESSING,
      HTTP_STATUS_EARLY_HINTS,
      HTTP_STATUS_OK,
      HTTP_STATUS_CREATED,
      HTTP_STATUS_ACCEPTED,
      HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION,
      HTTP_STATUS_NO_CONTENT,
      HTTP_STATUS_RESET_CONTENT,
      HTTP_STATUS_PARTIAL_CONTENT,
      HTTP_STATUS_MULTI_STATUS,
      HTTP_STATUS_ALREADY_REPORTED,
      HTTP_STATUS_IM_USED,
      HTTP_STATUS_MULTIPLE_CHOICES,
      HTTP_STATUS_MOVED_PERMANENTLY,
      HTTP_STATUS_FOUND,
      HTTP_STATUS_SEE_OTHER,
      HTTP_STATUS_NOT_MODIFIED,
      HTTP_STATUS_USE_PROXY,
      HTTP_STATUS_TEMPORARY_REDIRECT,
      HTTP_STATUS_PERMANENT_REDIRECT,
      HTTP_STATUS_BAD_REQUEST,
      HTTP_STATUS_UNAUTHORIZED,
      HTTP_STATUS_PAYMENT_REQUIRED,
      HTTP_STATUS_FORBIDDEN,
      HTTP_STATUS_NOT_FOUND,
      HTTP_STATUS_METHOD_NOT_ALLOWED,
      HTTP_STATUS_NOT_ACCEPTABLE,
      HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED,
      HTTP_STATUS_REQUEST_TIMEOUT,
      HTTP_STATUS_CONFLICT,
      HTTP_STATUS_GONE,
      HTTP_STATUS_LENGTH_REQUIRED,
      HTTP_STATUS_PRECONDITION_FAILED,
      HTTP_STATUS_PAYLOAD_TOO_LARGE,
      HTTP_STATUS_URI_TOO_LONG,
      HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE,
      HTTP_STATUS_RANGE_NOT_SATISFIABLE,
      HTTP_STATUS_EXPECTATION_FAILED,
      HTTP_STATUS_TEAPOT,
      HTTP_STATUS_MISDIRECTED_REQUEST,
      HTTP_STATUS_UNPROCESSABLE_ENTITY,
      HTTP_STATUS_LOCKED,
      HTTP_STATUS_FAILED_DEPENDENCY,
      HTTP_STATUS_TOO_EARLY,
      HTTP_STATUS_UPGRADE_REQUIRED,
      HTTP_STATUS_PRECONDITION_REQUIRED,
      HTTP_STATUS_TOO_MANY_REQUESTS,
      HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE,
      HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS,
      HTTP_STATUS_INTERNAL_SERVER_ERROR,
      HTTP_STATUS_NOT_IMPLEMENTED,
      HTTP_STATUS_BAD_GATEWAY,
      HTTP_STATUS_SERVICE_UNAVAILABLE,
      HTTP_STATUS_GATEWAY_TIMEOUT,
      HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED,
      HTTP_STATUS_VARIANT_ALSO_NEGOTIATES,
      HTTP_STATUS_INSUFFICIENT_STORAGE,
      HTTP_STATUS_LOOP_DETECTED,
      HTTP_STATUS_BANDWIDTH_LIMIT_EXCEEDED,
      HTTP_STATUS_NOT_EXTENDED,
      HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED
    };
    createSecureServer = /* @__PURE__ */ notImplemented("http2.createSecureServer");
    createServer5 = /* @__PURE__ */ notImplemented("http2.createServer");
    connect2 = /* @__PURE__ */ notImplemented("http2.connect");
    performServerHandshake = /* @__PURE__ */ notImplemented("http2.performServerHandshake ");
    Http2ServerRequest = /* @__PURE__ */ notImplementedClass("http2.Http2ServerRequest");
    Http2ServerResponse = /* @__PURE__ */ notImplementedClass("http2.Http2ServerResponse");
    getDefaultSettings = /* @__PURE__ */ __name(function() {
      return /* @__PURE__ */ Object.create({
        headerTableSize: 4096,
        enablePush: true,
        initialWindowSize: 65535,
        maxFrameSize: 16384,
        maxConcurrentStreams: 4294967295,
        maxHeaderSize: 65535,
        maxHeaderListSize: 65535,
        enableConnectProtocol: false
      });
    }, "getDefaultSettings");
    getPackedSettings = /* @__PURE__ */ __name(function() {
      return Buffer.from("");
    }, "getPackedSettings");
    getUnpackedSettings = /* @__PURE__ */ __name(function() {
      return /* @__PURE__ */ Object.create({});
    }, "getUnpackedSettings");
    sensitiveHeaders = /* @__PURE__ */ Symbol("nodejs.http2.sensitiveHeaders");
    http2_default = {
      constants: constants3,
      createSecureServer,
      createServer: createServer5,
      Http2ServerRequest,
      Http2ServerResponse,
      connect: connect2,
      getDefaultSettings,
      getPackedSettings,
      getUnpackedSettings,
      performServerHandshake,
      sensitiveHeaders
    };
  }
});

// node-built-in-modules:http2
var require_http2 = __commonJS({
  "node-built-in-modules:http2"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_http2();
    module.exports = http2_default;
  }
});

// node-built-in-modules:node:stream
import libDefault9 from "node:stream";
var require_node_stream = __commonJS({
  "node-built-in-modules:node:stream"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault9;
  }
});

// node-built-in-modules:node:util
var require_node_util = __commonJS({
  "node-built-in-modules:node:util"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_util2();
    module.exports = util_default;
  }
});

// node-built-in-modules:node:events
import libDefault10 from "node:events";
var require_node_events = __commonJS({
  "node-built-in-modules:node:events"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault10;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js
var require_sbmh = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/deps/streamsearch/sbmh.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { EventEmitter: EventEmitter3 } = require_node_events();
    var { inherits: inherits2 } = require_node_util();
    function SBMH(needle) {
      if (typeof needle === "string") {
        needle = Buffer.from(needle);
      }
      if (!Buffer.isBuffer(needle)) {
        throw new TypeError("The needle has to be a String or a Buffer.");
      }
      const needleLength = needle.length;
      const needleLastCharIndex = needleLength - 1;
      if (needleLength === 0) {
        throw new Error("The needle cannot be an empty String/Buffer.");
      }
      if (needleLength > 256) {
        throw new Error("The needle cannot have a length bigger than 256.");
      }
      this.maxMatches = Infinity;
      this.matches = 0;
      this._occ = new Uint8Array(256).fill(needleLength);
      this._lookbehind_size = 0;
      this._needle = needle;
      this._bufpos = 0;
      this._lookbehind = Buffer.alloc(needleLastCharIndex);
      for (var i = 0; i < needleLastCharIndex; ++i) {
        this._occ[needle[i]] = needleLastCharIndex - i;
      }
    }
    __name(SBMH, "SBMH");
    inherits2(SBMH, EventEmitter3);
    SBMH.prototype.reset = function() {
      this._lookbehind_size = 0;
      this.matches = 0;
      this._bufpos = 0;
    };
    SBMH.prototype.push = function(chunk, pos) {
      if (!Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, "binary");
      }
      const chlen = chunk.length;
      this._bufpos = pos || 0;
      let r;
      while (r !== chlen && this.matches < this.maxMatches) {
        r = this._sbmh_feed(chunk);
      }
      return r;
    };
    SBMH.prototype._sbmh_feed = function(data) {
      const len = data.length;
      const needle = this._needle;
      const needleLength = needle.length;
      const needleLastCharIndex = needleLength - 1;
      const needleLastChar = needle[needleLastCharIndex];
      let pos = -this._lookbehind_size;
      let ch;
      if (pos < 0) {
        while (pos < 0 && pos <= len - needleLength) {
          ch = this._sbmh_lookup_char(data, pos + needleLastCharIndex);
          if (ch === needleLastChar && this._sbmh_memcmp(data, pos, needleLastCharIndex)) {
            this._lookbehind_size = 0;
            ++this.matches;
            this.emit("info", true);
            return this._bufpos = pos + needleLength;
          }
          pos += this._occ[ch];
        }
        while (pos < 0 && !this._sbmh_memcmp(data, pos, len - pos)) {
          ++pos;
        }
        if (pos >= 0) {
          this.emit("info", false, this._lookbehind, 0, this._lookbehind_size);
          this._lookbehind_size = 0;
        } else {
          const bytesToCutOff = this._lookbehind_size + pos;
          if (bytesToCutOff > 0) {
            this.emit("info", false, this._lookbehind, 0, bytesToCutOff);
          }
          this._lookbehind_size -= bytesToCutOff;
          this._lookbehind.copy(this._lookbehind, 0, bytesToCutOff, this._lookbehind_size);
          data.copy(this._lookbehind, this._lookbehind_size);
          this._lookbehind_size += len;
          this._bufpos = len;
          return len;
        }
      }
      pos = data.indexOf(needle, pos + this._bufpos);
      if (pos !== -1) {
        ++this.matches;
        if (pos === 0) {
          this.emit("info", true);
        } else {
          this.emit("info", true, data, this._bufpos, pos);
        }
        return this._bufpos = pos + needleLength;
      }
      pos = len - needleLastCharIndex;
      if (pos < 0) {
        pos = 0;
      }
      while (pos !== len && (data[pos] !== needle[0] || Buffer.compare(
        data.subarray(pos + 1, len),
        needle.subarray(1, len - pos)
      ) !== 0)) {
        ++pos;
      }
      if (pos !== len) {
        data.copy(this._lookbehind, 0, pos, len);
        this._lookbehind_size = len - pos;
      }
      if (pos !== 0) {
        this.emit("info", false, data, this._bufpos, pos);
      }
      this._bufpos = len;
      return len;
    };
    SBMH.prototype._sbmh_lookup_char = function(data, pos) {
      return pos < 0 ? this._lookbehind[this._lookbehind_size + pos] : data[pos];
    };
    SBMH.prototype._sbmh_memcmp = function(data, pos, len) {
      for (var i = 0; i < len; ++i) {
        if (this._sbmh_lookup_char(data, pos + i) !== this._needle[i]) {
          return false;
        }
      }
      return true;
    };
    module.exports = SBMH;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js
var require_PartStream = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/PartStream.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var inherits2 = require_node_util().inherits;
    var ReadableStream = require_node_stream().Readable;
    function PartStream(opts) {
      ReadableStream.call(this, opts);
    }
    __name(PartStream, "PartStream");
    inherits2(PartStream, ReadableStream);
    PartStream.prototype._read = function(n) {
    };
    module.exports = PartStream;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/getLimit.js
var require_getLimit = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/getLimit.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function getLimit(limits, name, defaultLimit) {
      if (!limits || limits[name] === void 0 || limits[name] === null) {
        return defaultLimit;
      }
      if (typeof limits[name] !== "number" || isNaN(limits[name])) {
        throw new TypeError("Limit " + name + " is not a valid number");
      }
      return limits[name];
    }, "getLimit");
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js
var require_HeaderParser = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/HeaderParser.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var EventEmitter3 = require_node_events().EventEmitter;
    var inherits2 = require_node_util().inherits;
    var getLimit = require_getLimit();
    var StreamSearch = require_sbmh();
    var B_DCRLF = Buffer.from("\r\n\r\n");
    var RE_CRLF = /\r\n/g;
    var RE_HDR = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
    function HeaderParser(cfg) {
      EventEmitter3.call(this);
      cfg = cfg || {};
      const self2 = this;
      this.nread = 0;
      this.maxed = false;
      this.npairs = 0;
      this.maxHeaderPairs = getLimit(cfg, "maxHeaderPairs", 2e3);
      this.maxHeaderSize = getLimit(cfg, "maxHeaderSize", 80 * 1024);
      this.buffer = "";
      this.header = {};
      this.finished = false;
      this.ss = new StreamSearch(B_DCRLF);
      this.ss.on("info", function(isMatch, data, start, end) {
        if (data && !self2.maxed) {
          if (self2.nread + end - start >= self2.maxHeaderSize) {
            end = self2.maxHeaderSize - self2.nread + start;
            self2.nread = self2.maxHeaderSize;
            self2.maxed = true;
          } else {
            self2.nread += end - start;
          }
          self2.buffer += data.toString("binary", start, end);
        }
        if (isMatch) {
          self2._finish();
        }
      });
    }
    __name(HeaderParser, "HeaderParser");
    inherits2(HeaderParser, EventEmitter3);
    HeaderParser.prototype.push = function(data) {
      const r = this.ss.push(data);
      if (this.finished) {
        return r;
      }
    };
    HeaderParser.prototype.reset = function() {
      this.finished = false;
      this.buffer = "";
      this.header = {};
      this.ss.reset();
    };
    HeaderParser.prototype._finish = function() {
      if (this.buffer) {
        this._parseHeader();
      }
      this.ss.matches = this.ss.maxMatches;
      const header = this.header;
      this.header = {};
      this.buffer = "";
      this.finished = true;
      this.nread = this.npairs = 0;
      this.maxed = false;
      this.emit("header", header);
    };
    HeaderParser.prototype._parseHeader = function() {
      if (this.npairs === this.maxHeaderPairs) {
        return;
      }
      const lines = this.buffer.split(RE_CRLF);
      const len = lines.length;
      let m2, h;
      for (var i = 0; i < len; ++i) {
        if (lines[i].length === 0) {
          continue;
        }
        if (lines[i][0] === "	" || lines[i][0] === " ") {
          if (h) {
            this.header[h][this.header[h].length - 1] += lines[i];
            continue;
          }
        }
        const posColon = lines[i].indexOf(":");
        if (posColon === -1 || posColon === 0) {
          return;
        }
        m2 = RE_HDR.exec(lines[i]);
        h = m2[1].toLowerCase();
        this.header[h] = this.header[h] || [];
        this.header[h].push(m2[2] || "");
        if (++this.npairs === this.maxHeaderPairs) {
          break;
        }
      }
    };
    module.exports = HeaderParser;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js
var require_Dicer = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/deps/dicer/lib/Dicer.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var WritableStream = require_node_stream().Writable;
    var inherits2 = require_node_util().inherits;
    var StreamSearch = require_sbmh();
    var PartStream = require_PartStream();
    var HeaderParser = require_HeaderParser();
    var DASH = 45;
    var B_ONEDASH = Buffer.from("-");
    var B_CRLF = Buffer.from("\r\n");
    var EMPTY_FN = /* @__PURE__ */ __name(function() {
    }, "EMPTY_FN");
    function Dicer(cfg) {
      if (!(this instanceof Dicer)) {
        return new Dicer(cfg);
      }
      WritableStream.call(this, cfg);
      if (!cfg || !cfg.headerFirst && typeof cfg.boundary !== "string") {
        throw new TypeError("Boundary required");
      }
      if (typeof cfg.boundary === "string") {
        this.setBoundary(cfg.boundary);
      } else {
        this._bparser = void 0;
      }
      this._headerFirst = cfg.headerFirst;
      this._dashes = 0;
      this._parts = 0;
      this._finished = false;
      this._realFinish = false;
      this._isPreamble = true;
      this._justMatched = false;
      this._firstWrite = true;
      this._inHeader = true;
      this._part = void 0;
      this._cb = void 0;
      this._ignoreData = false;
      this._partOpts = { highWaterMark: cfg.partHwm };
      this._pause = false;
      const self2 = this;
      this._hparser = new HeaderParser(cfg);
      this._hparser.on("header", function(header) {
        self2._inHeader = false;
        self2._part.emit("header", header);
      });
    }
    __name(Dicer, "Dicer");
    inherits2(Dicer, WritableStream);
    Dicer.prototype.emit = function(ev) {
      if (ev === "finish" && !this._realFinish) {
        if (!this._finished) {
          const self2 = this;
          process.nextTick(function() {
            self2.emit("error", new Error("Unexpected end of multipart data"));
            if (self2._part && !self2._ignoreData) {
              const type2 = self2._isPreamble ? "Preamble" : "Part";
              self2._part.emit("error", new Error(type2 + " terminated early due to unexpected end of multipart data"));
              self2._part.push(null);
              process.nextTick(function() {
                self2._realFinish = true;
                self2.emit("finish");
                self2._realFinish = false;
              });
              return;
            }
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          });
        }
      } else {
        WritableStream.prototype.emit.apply(this, arguments);
      }
    };
    Dicer.prototype._write = function(data, encoding, cb) {
      if (!this._hparser && !this._bparser) {
        return cb();
      }
      if (this._headerFirst && this._isPreamble) {
        if (!this._part) {
          this._part = new PartStream(this._partOpts);
          if (this.listenerCount("preamble") !== 0) {
            this.emit("preamble", this._part);
          } else {
            this._ignore();
          }
        }
        const r = this._hparser.push(data);
        if (!this._inHeader && r !== void 0 && r < data.length) {
          data = data.slice(r);
        } else {
          return cb();
        }
      }
      if (this._firstWrite) {
        this._bparser.push(B_CRLF);
        this._firstWrite = false;
      }
      this._bparser.push(data);
      if (this._pause) {
        this._cb = cb;
      } else {
        cb();
      }
    };
    Dicer.prototype.reset = function() {
      this._part = void 0;
      this._bparser = void 0;
      this._hparser = void 0;
    };
    Dicer.prototype.setBoundary = function(boundary) {
      const self2 = this;
      this._bparser = new StreamSearch("\r\n--" + boundary);
      this._bparser.on("info", function(isMatch, data, start, end) {
        self2._oninfo(isMatch, data, start, end);
      });
    };
    Dicer.prototype._ignore = function() {
      if (this._part && !this._ignoreData) {
        this._ignoreData = true;
        this._part.on("error", EMPTY_FN);
        this._part.resume();
      }
    };
    Dicer.prototype._oninfo = function(isMatch, data, start, end) {
      let buf;
      const self2 = this;
      let i = 0;
      let r;
      let shouldWriteMore = true;
      if (!this._part && this._justMatched && data) {
        while (this._dashes < 2 && start + i < end) {
          if (data[start + i] === DASH) {
            ++i;
            ++this._dashes;
          } else {
            if (this._dashes) {
              buf = B_ONEDASH;
            }
            this._dashes = 0;
            break;
          }
        }
        if (this._dashes === 2) {
          if (start + i < end && this.listenerCount("trailer") !== 0) {
            this.emit("trailer", data.slice(start + i, end));
          }
          this.reset();
          this._finished = true;
          if (self2._parts === 0) {
            self2._realFinish = true;
            self2.emit("finish");
            self2._realFinish = false;
          }
        }
        if (this._dashes) {
          return;
        }
      }
      if (this._justMatched) {
        this._justMatched = false;
      }
      if (!this._part) {
        this._part = new PartStream(this._partOpts);
        this._part._read = function(n) {
          self2._unpause();
        };
        if (this._isPreamble && this.listenerCount("preamble") !== 0) {
          this.emit("preamble", this._part);
        } else if (this._isPreamble !== true && this.listenerCount("part") !== 0) {
          this.emit("part", this._part);
        } else {
          this._ignore();
        }
        if (!this._isPreamble) {
          this._inHeader = true;
        }
      }
      if (data && start < end && !this._ignoreData) {
        if (this._isPreamble || !this._inHeader) {
          if (buf) {
            shouldWriteMore = this._part.push(buf);
          }
          shouldWriteMore = this._part.push(data.slice(start, end));
          if (!shouldWriteMore) {
            this._pause = true;
          }
        } else if (!this._isPreamble && this._inHeader) {
          if (buf) {
            this._hparser.push(buf);
          }
          r = this._hparser.push(data.slice(start, end));
          if (!this._inHeader && r !== void 0 && r < end) {
            this._oninfo(false, data, start + r, end);
          }
        }
      }
      if (isMatch) {
        this._hparser.reset();
        if (this._isPreamble) {
          this._isPreamble = false;
        } else {
          if (start !== end) {
            ++this._parts;
            this._part.on("end", function() {
              if (--self2._parts === 0) {
                if (self2._finished) {
                  self2._realFinish = true;
                  self2.emit("finish");
                  self2._realFinish = false;
                } else {
                  self2._unpause();
                }
              }
            });
          }
        }
        this._part.push(null);
        this._part = void 0;
        this._ignoreData = false;
        this._justMatched = true;
        this._dashes = 0;
      }
    };
    Dicer.prototype._unpause = function() {
      if (!this._pause) {
        return;
      }
      this._pause = false;
      if (this._cb) {
        const cb = this._cb;
        this._cb = void 0;
        cb();
      }
    };
    module.exports = Dicer;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/decodeText.js
var require_decodeText = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/decodeText.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var utf8Decoder = new TextDecoder("utf-8");
    var textDecoders = /* @__PURE__ */ new Map([
      ["utf-8", utf8Decoder],
      ["utf8", utf8Decoder]
    ]);
    function getDecoder(charset) {
      let lc;
      while (true) {
        switch (charset) {
          case "utf-8":
          case "utf8":
            return decoders.utf8;
          case "latin1":
          case "ascii":
          // TODO: Make these a separate, strict decoder?
          case "us-ascii":
          case "iso-8859-1":
          case "iso8859-1":
          case "iso88591":
          case "iso_8859-1":
          case "windows-1252":
          case "iso_8859-1:1987":
          case "cp1252":
          case "x-cp1252":
            return decoders.latin1;
          case "utf16le":
          case "utf-16le":
          case "ucs2":
          case "ucs-2":
            return decoders.utf16le;
          case "base64":
            return decoders.base64;
          default:
            if (lc === void 0) {
              lc = true;
              charset = charset.toLowerCase();
              continue;
            }
            return decoders.other.bind(charset);
        }
      }
    }
    __name(getDecoder, "getDecoder");
    var decoders = {
      utf8: /* @__PURE__ */ __name((data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.utf8Slice(0, data.length);
      }, "utf8"),
      latin1: /* @__PURE__ */ __name((data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          return data;
        }
        return data.latin1Slice(0, data.length);
      }, "latin1"),
      utf16le: /* @__PURE__ */ __name((data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.ucs2Slice(0, data.length);
      }, "utf16le"),
      base64: /* @__PURE__ */ __name((data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        return data.base64Slice(0, data.length);
      }, "base64"),
      other: /* @__PURE__ */ __name((data, sourceEncoding) => {
        if (data.length === 0) {
          return "";
        }
        if (typeof data === "string") {
          data = Buffer.from(data, sourceEncoding);
        }
        if (textDecoders.has(exports.toString())) {
          try {
            return textDecoders.get(exports).decode(data);
          } catch {
          }
        }
        return typeof data === "string" ? data : data.toString();
      }, "other")
    };
    function decodeText(text, sourceEncoding, destEncoding) {
      if (text) {
        return getDecoder(destEncoding)(text, sourceEncoding);
      }
      return text;
    }
    __name(decodeText, "decodeText");
    module.exports = decodeText;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/parseParams.js
var require_parseParams = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/parseParams.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var decodeText = require_decodeText();
    var RE_ENCODED = /%[a-fA-F0-9][a-fA-F0-9]/g;
    var EncodedLookup = {
      "%00": "\0",
      "%01": "",
      "%02": "",
      "%03": "",
      "%04": "",
      "%05": "",
      "%06": "",
      "%07": "\x07",
      "%08": "\b",
      "%09": "	",
      "%0a": "\n",
      "%0A": "\n",
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "",
      "%0E": "",
      "%0f": "",
      "%0F": "",
      "%10": "",
      "%11": "",
      "%12": "",
      "%13": "",
      "%14": "",
      "%15": "",
      "%16": "",
      "%17": "",
      "%18": "",
      "%19": "",
      "%1a": "",
      "%1A": "",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "",
      "%1C": "",
      "%1d": "",
      "%1D": "",
      "%1e": "",
      "%1E": "",
      "%1f": "",
      "%1F": "",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "\x7F",
      "%7F": "\x7F",
      "%80": "\x80",
      "%81": "\x81",
      "%82": "\x82",
      "%83": "\x83",
      "%84": "\x84",
      "%85": "\x85",
      "%86": "\x86",
      "%87": "\x87",
      "%88": "\x88",
      "%89": "\x89",
      "%8a": "\x8A",
      "%8A": "\x8A",
      "%8b": "\x8B",
      "%8B": "\x8B",
      "%8c": "\x8C",
      "%8C": "\x8C",
      "%8d": "\x8D",
      "%8D": "\x8D",
      "%8e": "\x8E",
      "%8E": "\x8E",
      "%8f": "\x8F",
      "%8F": "\x8F",
      "%90": "\x90",
      "%91": "\x91",
      "%92": "\x92",
      "%93": "\x93",
      "%94": "\x94",
      "%95": "\x95",
      "%96": "\x96",
      "%97": "\x97",
      "%98": "\x98",
      "%99": "\x99",
      "%9a": "\x9A",
      "%9A": "\x9A",
      "%9b": "\x9B",
      "%9B": "\x9B",
      "%9c": "\x9C",
      "%9C": "\x9C",
      "%9d": "\x9D",
      "%9D": "\x9D",
      "%9e": "\x9E",
      "%9E": "\x9E",
      "%9f": "\x9F",
      "%9F": "\x9F",
      "%a0": "\xA0",
      "%A0": "\xA0",
      "%a1": "\xA1",
      "%A1": "\xA1",
      "%a2": "\xA2",
      "%A2": "\xA2",
      "%a3": "\xA3",
      "%A3": "\xA3",
      "%a4": "\xA4",
      "%A4": "\xA4",
      "%a5": "\xA5",
      "%A5": "\xA5",
      "%a6": "\xA6",
      "%A6": "\xA6",
      "%a7": "\xA7",
      "%A7": "\xA7",
      "%a8": "\xA8",
      "%A8": "\xA8",
      "%a9": "\xA9",
      "%A9": "\xA9",
      "%aa": "\xAA",
      "%Aa": "\xAA",
      "%aA": "\xAA",
      "%AA": "\xAA",
      "%ab": "\xAB",
      "%Ab": "\xAB",
      "%aB": "\xAB",
      "%AB": "\xAB",
      "%ac": "\xAC",
      "%Ac": "\xAC",
      "%aC": "\xAC",
      "%AC": "\xAC",
      "%ad": "\xAD",
      "%Ad": "\xAD",
      "%aD": "\xAD",
      "%AD": "\xAD",
      "%ae": "\xAE",
      "%Ae": "\xAE",
      "%aE": "\xAE",
      "%AE": "\xAE",
      "%af": "\xAF",
      "%Af": "\xAF",
      "%aF": "\xAF",
      "%AF": "\xAF",
      "%b0": "\xB0",
      "%B0": "\xB0",
      "%b1": "\xB1",
      "%B1": "\xB1",
      "%b2": "\xB2",
      "%B2": "\xB2",
      "%b3": "\xB3",
      "%B3": "\xB3",
      "%b4": "\xB4",
      "%B4": "\xB4",
      "%b5": "\xB5",
      "%B5": "\xB5",
      "%b6": "\xB6",
      "%B6": "\xB6",
      "%b7": "\xB7",
      "%B7": "\xB7",
      "%b8": "\xB8",
      "%B8": "\xB8",
      "%b9": "\xB9",
      "%B9": "\xB9",
      "%ba": "\xBA",
      "%Ba": "\xBA",
      "%bA": "\xBA",
      "%BA": "\xBA",
      "%bb": "\xBB",
      "%Bb": "\xBB",
      "%bB": "\xBB",
      "%BB": "\xBB",
      "%bc": "\xBC",
      "%Bc": "\xBC",
      "%bC": "\xBC",
      "%BC": "\xBC",
      "%bd": "\xBD",
      "%Bd": "\xBD",
      "%bD": "\xBD",
      "%BD": "\xBD",
      "%be": "\xBE",
      "%Be": "\xBE",
      "%bE": "\xBE",
      "%BE": "\xBE",
      "%bf": "\xBF",
      "%Bf": "\xBF",
      "%bF": "\xBF",
      "%BF": "\xBF",
      "%c0": "\xC0",
      "%C0": "\xC0",
      "%c1": "\xC1",
      "%C1": "\xC1",
      "%c2": "\xC2",
      "%C2": "\xC2",
      "%c3": "\xC3",
      "%C3": "\xC3",
      "%c4": "\xC4",
      "%C4": "\xC4",
      "%c5": "\xC5",
      "%C5": "\xC5",
      "%c6": "\xC6",
      "%C6": "\xC6",
      "%c7": "\xC7",
      "%C7": "\xC7",
      "%c8": "\xC8",
      "%C8": "\xC8",
      "%c9": "\xC9",
      "%C9": "\xC9",
      "%ca": "\xCA",
      "%Ca": "\xCA",
      "%cA": "\xCA",
      "%CA": "\xCA",
      "%cb": "\xCB",
      "%Cb": "\xCB",
      "%cB": "\xCB",
      "%CB": "\xCB",
      "%cc": "\xCC",
      "%Cc": "\xCC",
      "%cC": "\xCC",
      "%CC": "\xCC",
      "%cd": "\xCD",
      "%Cd": "\xCD",
      "%cD": "\xCD",
      "%CD": "\xCD",
      "%ce": "\xCE",
      "%Ce": "\xCE",
      "%cE": "\xCE",
      "%CE": "\xCE",
      "%cf": "\xCF",
      "%Cf": "\xCF",
      "%cF": "\xCF",
      "%CF": "\xCF",
      "%d0": "\xD0",
      "%D0": "\xD0",
      "%d1": "\xD1",
      "%D1": "\xD1",
      "%d2": "\xD2",
      "%D2": "\xD2",
      "%d3": "\xD3",
      "%D3": "\xD3",
      "%d4": "\xD4",
      "%D4": "\xD4",
      "%d5": "\xD5",
      "%D5": "\xD5",
      "%d6": "\xD6",
      "%D6": "\xD6",
      "%d7": "\xD7",
      "%D7": "\xD7",
      "%d8": "\xD8",
      "%D8": "\xD8",
      "%d9": "\xD9",
      "%D9": "\xD9",
      "%da": "\xDA",
      "%Da": "\xDA",
      "%dA": "\xDA",
      "%DA": "\xDA",
      "%db": "\xDB",
      "%Db": "\xDB",
      "%dB": "\xDB",
      "%DB": "\xDB",
      "%dc": "\xDC",
      "%Dc": "\xDC",
      "%dC": "\xDC",
      "%DC": "\xDC",
      "%dd": "\xDD",
      "%Dd": "\xDD",
      "%dD": "\xDD",
      "%DD": "\xDD",
      "%de": "\xDE",
      "%De": "\xDE",
      "%dE": "\xDE",
      "%DE": "\xDE",
      "%df": "\xDF",
      "%Df": "\xDF",
      "%dF": "\xDF",
      "%DF": "\xDF",
      "%e0": "\xE0",
      "%E0": "\xE0",
      "%e1": "\xE1",
      "%E1": "\xE1",
      "%e2": "\xE2",
      "%E2": "\xE2",
      "%e3": "\xE3",
      "%E3": "\xE3",
      "%e4": "\xE4",
      "%E4": "\xE4",
      "%e5": "\xE5",
      "%E5": "\xE5",
      "%e6": "\xE6",
      "%E6": "\xE6",
      "%e7": "\xE7",
      "%E7": "\xE7",
      "%e8": "\xE8",
      "%E8": "\xE8",
      "%e9": "\xE9",
      "%E9": "\xE9",
      "%ea": "\xEA",
      "%Ea": "\xEA",
      "%eA": "\xEA",
      "%EA": "\xEA",
      "%eb": "\xEB",
      "%Eb": "\xEB",
      "%eB": "\xEB",
      "%EB": "\xEB",
      "%ec": "\xEC",
      "%Ec": "\xEC",
      "%eC": "\xEC",
      "%EC": "\xEC",
      "%ed": "\xED",
      "%Ed": "\xED",
      "%eD": "\xED",
      "%ED": "\xED",
      "%ee": "\xEE",
      "%Ee": "\xEE",
      "%eE": "\xEE",
      "%EE": "\xEE",
      "%ef": "\xEF",
      "%Ef": "\xEF",
      "%eF": "\xEF",
      "%EF": "\xEF",
      "%f0": "\xF0",
      "%F0": "\xF0",
      "%f1": "\xF1",
      "%F1": "\xF1",
      "%f2": "\xF2",
      "%F2": "\xF2",
      "%f3": "\xF3",
      "%F3": "\xF3",
      "%f4": "\xF4",
      "%F4": "\xF4",
      "%f5": "\xF5",
      "%F5": "\xF5",
      "%f6": "\xF6",
      "%F6": "\xF6",
      "%f7": "\xF7",
      "%F7": "\xF7",
      "%f8": "\xF8",
      "%F8": "\xF8",
      "%f9": "\xF9",
      "%F9": "\xF9",
      "%fa": "\xFA",
      "%Fa": "\xFA",
      "%fA": "\xFA",
      "%FA": "\xFA",
      "%fb": "\xFB",
      "%Fb": "\xFB",
      "%fB": "\xFB",
      "%FB": "\xFB",
      "%fc": "\xFC",
      "%Fc": "\xFC",
      "%fC": "\xFC",
      "%FC": "\xFC",
      "%fd": "\xFD",
      "%Fd": "\xFD",
      "%fD": "\xFD",
      "%FD": "\xFD",
      "%fe": "\xFE",
      "%Fe": "\xFE",
      "%fE": "\xFE",
      "%FE": "\xFE",
      "%ff": "\xFF",
      "%Ff": "\xFF",
      "%fF": "\xFF",
      "%FF": "\xFF"
    };
    function encodedReplacer(match) {
      return EncodedLookup[match];
    }
    __name(encodedReplacer, "encodedReplacer");
    var STATE_KEY = 0;
    var STATE_VALUE = 1;
    var STATE_CHARSET = 2;
    var STATE_LANG = 3;
    function parseParams(str) {
      const res = [];
      let state = STATE_KEY;
      let charset = "";
      let inquote = false;
      let escaping = false;
      let p2 = 0;
      let tmp = "";
      const len = str.length;
      for (var i = 0; i < len; ++i) {
        const char = str[i];
        if (char === "\\" && inquote) {
          if (escaping) {
            escaping = false;
          } else {
            escaping = true;
            continue;
          }
        } else if (char === '"') {
          if (!escaping) {
            if (inquote) {
              inquote = false;
              state = STATE_KEY;
            } else {
              inquote = true;
            }
            continue;
          } else {
            escaping = false;
          }
        } else {
          if (escaping && inquote) {
            tmp += "\\";
          }
          escaping = false;
          if ((state === STATE_CHARSET || state === STATE_LANG) && char === "'") {
            if (state === STATE_CHARSET) {
              state = STATE_LANG;
              charset = tmp.substring(1);
            } else {
              state = STATE_VALUE;
            }
            tmp = "";
            continue;
          } else if (state === STATE_KEY && (char === "*" || char === "=") && res.length) {
            state = char === "*" ? STATE_CHARSET : STATE_VALUE;
            res[p2] = [tmp, void 0];
            tmp = "";
            continue;
          } else if (!inquote && char === ";") {
            state = STATE_KEY;
            if (charset) {
              if (tmp.length) {
                tmp = decodeText(
                  tmp.replace(RE_ENCODED, encodedReplacer),
                  "binary",
                  charset
                );
              }
              charset = "";
            } else if (tmp.length) {
              tmp = decodeText(tmp, "binary", "utf8");
            }
            if (res[p2] === void 0) {
              res[p2] = tmp;
            } else {
              res[p2][1] = tmp;
            }
            tmp = "";
            ++p2;
            continue;
          } else if (!inquote && (char === " " || char === "	")) {
            continue;
          }
        }
        tmp += char;
      }
      if (charset && tmp.length) {
        tmp = decodeText(
          tmp.replace(RE_ENCODED, encodedReplacer),
          "binary",
          charset
        );
      } else if (tmp) {
        tmp = decodeText(tmp, "binary", "utf8");
      }
      if (res[p2] === void 0) {
        if (tmp) {
          res[p2] = tmp;
        }
      } else {
        res[p2][1] = tmp;
      }
      return res;
    }
    __name(parseParams, "parseParams");
    module.exports = parseParams;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/basename.js
var require_basename = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/basename.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = /* @__PURE__ */ __name(function basename(path) {
      if (typeof path !== "string") {
        return "";
      }
      for (var i = path.length - 1; i >= 0; --i) {
        switch (path.charCodeAt(i)) {
          case 47:
          // '/'
          case 92:
            path = path.slice(i + 1);
            return path === ".." || path === "." ? "" : path;
        }
      }
      return path === ".." || path === "." ? "" : path;
    }, "basename");
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/types/multipart.js
var require_multipart = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/types/multipart.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { Readable: Readable2 } = require_node_stream();
    var { inherits: inherits2 } = require_node_util();
    var Dicer = require_Dicer();
    var parseParams = require_parseParams();
    var decodeText = require_decodeText();
    var basename = require_basename();
    var getLimit = require_getLimit();
    var RE_BOUNDARY = /^boundary$/i;
    var RE_FIELD = /^form-data$/i;
    var RE_CHARSET = /^charset$/i;
    var RE_FILENAME = /^filename$/i;
    var RE_NAME = /^name$/i;
    Multipart.detect = /^multipart\/form-data/i;
    function Multipart(boy, cfg) {
      let i;
      let len;
      const self2 = this;
      let boundary;
      const limits = cfg.limits;
      const isPartAFile = cfg.isPartAFile || ((fieldName, contentType, fileName) => contentType === "application/octet-stream" || fileName !== void 0);
      const parsedConType = cfg.parsedConType || [];
      const defCharset = cfg.defCharset || "utf8";
      const preservePath = cfg.preservePath;
      const fileOpts = { highWaterMark: cfg.fileHwm };
      for (i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_BOUNDARY.test(parsedConType[i][0])) {
          boundary = parsedConType[i][1];
          break;
        }
      }
      function checkFinished() {
        if (nends === 0 && finished && !boy._done) {
          finished = false;
          self2.end();
        }
      }
      __name(checkFinished, "checkFinished");
      if (typeof boundary !== "string") {
        throw new Error("Multipart: Boundary not found");
      }
      const fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      const fileSizeLimit = getLimit(limits, "fileSize", Infinity);
      const filesLimit = getLimit(limits, "files", Infinity);
      const fieldsLimit = getLimit(limits, "fields", Infinity);
      const partsLimit = getLimit(limits, "parts", Infinity);
      const headerPairsLimit = getLimit(limits, "headerPairs", 2e3);
      const headerSizeLimit = getLimit(limits, "headerSize", 80 * 1024);
      let nfiles = 0;
      let nfields = 0;
      let nends = 0;
      let curFile;
      let curField;
      let finished = false;
      this._needDrain = false;
      this._pause = false;
      this._cb = void 0;
      this._nparts = 0;
      this._boy = boy;
      const parserCfg = {
        boundary,
        maxHeaderPairs: headerPairsLimit,
        maxHeaderSize: headerSizeLimit,
        partHwm: fileOpts.highWaterMark,
        highWaterMark: cfg.highWaterMark
      };
      this.parser = new Dicer(parserCfg);
      this.parser.on("drain", function() {
        self2._needDrain = false;
        if (self2._cb && !self2._pause) {
          const cb = self2._cb;
          self2._cb = void 0;
          cb();
        }
      }).on("part", /* @__PURE__ */ __name(function onPart(part) {
        if (++self2._nparts > partsLimit) {
          self2.parser.removeListener("part", onPart);
          self2.parser.on("part", skipPart);
          boy.hitPartsLimit = true;
          boy.emit("partsLimit");
          return skipPart(part);
        }
        if (curField) {
          const field = curField;
          field.emit("end");
          field.removeAllListeners("end");
        }
        part.on("header", function(header) {
          let contype;
          let fieldname;
          let parsed;
          let charset;
          let encoding;
          let filename;
          let nsize = 0;
          if (header["content-type"]) {
            parsed = parseParams(header["content-type"][0]);
            if (parsed[0]) {
              contype = parsed[0].toLowerCase();
              for (i = 0, len = parsed.length; i < len; ++i) {
                if (RE_CHARSET.test(parsed[i][0])) {
                  charset = parsed[i][1].toLowerCase();
                  break;
                }
              }
            }
          }
          if (contype === void 0) {
            contype = "text/plain";
          }
          if (charset === void 0) {
            charset = defCharset;
          }
          if (header["content-disposition"]) {
            parsed = parseParams(header["content-disposition"][0]);
            if (!RE_FIELD.test(parsed[0])) {
              return skipPart(part);
            }
            for (i = 0, len = parsed.length; i < len; ++i) {
              if (RE_NAME.test(parsed[i][0])) {
                fieldname = parsed[i][1];
              } else if (RE_FILENAME.test(parsed[i][0])) {
                filename = parsed[i][1];
                if (!preservePath) {
                  filename = basename(filename);
                }
              }
            }
          } else {
            return skipPart(part);
          }
          if (header["content-transfer-encoding"]) {
            encoding = header["content-transfer-encoding"][0].toLowerCase();
          } else {
            encoding = "7bit";
          }
          let onData, onEnd;
          if (isPartAFile(fieldname, contype, filename)) {
            if (nfiles === filesLimit) {
              if (!boy.hitFilesLimit) {
                boy.hitFilesLimit = true;
                boy.emit("filesLimit");
              }
              return skipPart(part);
            }
            ++nfiles;
            if (boy.listenerCount("file") === 0) {
              self2.parser._ignore();
              return;
            }
            ++nends;
            const file = new FileStream(fileOpts);
            curFile = file;
            file.on("end", function() {
              --nends;
              self2._pause = false;
              checkFinished();
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            });
            file._read = function(n) {
              if (!self2._pause) {
                return;
              }
              self2._pause = false;
              if (self2._cb && !self2._needDrain) {
                const cb = self2._cb;
                self2._cb = void 0;
                cb();
              }
            };
            boy.emit("file", fieldname, file, filename, encoding, contype);
            onData = /* @__PURE__ */ __name(function(data) {
              if ((nsize += data.length) > fileSizeLimit) {
                const extralen = fileSizeLimit - nsize + data.length;
                if (extralen > 0) {
                  file.push(data.slice(0, extralen));
                }
                file.truncated = true;
                file.bytesRead = fileSizeLimit;
                part.removeAllListeners("data");
                file.emit("limit");
                return;
              } else if (!file.push(data)) {
                self2._pause = true;
              }
              file.bytesRead = nsize;
            }, "onData");
            onEnd = /* @__PURE__ */ __name(function() {
              curFile = void 0;
              file.push(null);
            }, "onEnd");
          } else {
            if (nfields === fieldsLimit) {
              if (!boy.hitFieldsLimit) {
                boy.hitFieldsLimit = true;
                boy.emit("fieldsLimit");
              }
              return skipPart(part);
            }
            ++nfields;
            ++nends;
            let buffer = "";
            let truncated = false;
            curField = part;
            onData = /* @__PURE__ */ __name(function(data) {
              if ((nsize += data.length) > fieldSizeLimit) {
                const extralen = fieldSizeLimit - (nsize - data.length);
                buffer += data.toString("binary", 0, extralen);
                truncated = true;
                part.removeAllListeners("data");
              } else {
                buffer += data.toString("binary");
              }
            }, "onData");
            onEnd = /* @__PURE__ */ __name(function() {
              curField = void 0;
              if (buffer.length) {
                buffer = decodeText(buffer, "binary", charset);
              }
              boy.emit("field", fieldname, buffer, false, truncated, encoding, contype);
              --nends;
              checkFinished();
            }, "onEnd");
          }
          part._readableState.sync = false;
          part.on("data", onData);
          part.on("end", onEnd);
        }).on("error", function(err) {
          if (curFile) {
            curFile.emit("error", err);
          }
        });
      }, "onPart")).on("error", function(err) {
        boy.emit("error", err);
      }).on("finish", function() {
        finished = true;
        checkFinished();
      });
    }
    __name(Multipart, "Multipart");
    Multipart.prototype.write = function(chunk, cb) {
      const r = this.parser.write(chunk);
      if (r && !this._pause) {
        cb();
      } else {
        this._needDrain = !r;
        this._cb = cb;
      }
    };
    Multipart.prototype.end = function() {
      const self2 = this;
      if (self2.parser.writable) {
        self2.parser.end();
      } else if (!self2._boy._done) {
        process.nextTick(function() {
          self2._boy._done = true;
          self2._boy.emit("finish");
        });
      }
    };
    function skipPart(part) {
      part.resume();
    }
    __name(skipPart, "skipPart");
    function FileStream(opts) {
      Readable2.call(this, opts);
      this.bytesRead = 0;
      this.truncated = false;
    }
    __name(FileStream, "FileStream");
    inherits2(FileStream, Readable2);
    FileStream.prototype._read = function(n) {
    };
    module.exports = Multipart;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/Decoder.js
var require_Decoder = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/utils/Decoder.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var RE_PLUS = /\+/g;
    var HEX = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0
    ];
    function Decoder() {
      this.buffer = void 0;
    }
    __name(Decoder, "Decoder");
    Decoder.prototype.write = function(str) {
      str = str.replace(RE_PLUS, " ");
      let res = "";
      let i = 0;
      let p2 = 0;
      const len = str.length;
      for (; i < len; ++i) {
        if (this.buffer !== void 0) {
          if (!HEX[str.charCodeAt(i)]) {
            res += "%" + this.buffer;
            this.buffer = void 0;
            --i;
          } else {
            this.buffer += str[i];
            ++p2;
            if (this.buffer.length === 2) {
              res += String.fromCharCode(parseInt(this.buffer, 16));
              this.buffer = void 0;
            }
          }
        } else if (str[i] === "%") {
          if (i > p2) {
            res += str.substring(p2, i);
            p2 = i;
          }
          this.buffer = "";
          ++p2;
        }
      }
      if (p2 < len && this.buffer === void 0) {
        res += str.substring(p2);
      }
      return res;
    };
    Decoder.prototype.reset = function() {
      this.buffer = void 0;
    };
    module.exports = Decoder;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/types/urlencoded.js
var require_urlencoded = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/types/urlencoded.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Decoder = require_Decoder();
    var decodeText = require_decodeText();
    var getLimit = require_getLimit();
    var RE_CHARSET = /^charset$/i;
    UrlEncoded.detect = /^application\/x-www-form-urlencoded/i;
    function UrlEncoded(boy, cfg) {
      const limits = cfg.limits;
      const parsedConType = cfg.parsedConType;
      this.boy = boy;
      this.fieldSizeLimit = getLimit(limits, "fieldSize", 1 * 1024 * 1024);
      this.fieldNameSizeLimit = getLimit(limits, "fieldNameSize", 100);
      this.fieldsLimit = getLimit(limits, "fields", Infinity);
      let charset;
      for (var i = 0, len = parsedConType.length; i < len; ++i) {
        if (Array.isArray(parsedConType[i]) && RE_CHARSET.test(parsedConType[i][0])) {
          charset = parsedConType[i][1].toLowerCase();
          break;
        }
      }
      if (charset === void 0) {
        charset = cfg.defCharset || "utf8";
      }
      this.decoder = new Decoder();
      this.charset = charset;
      this._fields = 0;
      this._state = "key";
      this._checkingBytes = true;
      this._bytesKey = 0;
      this._bytesVal = 0;
      this._key = "";
      this._val = "";
      this._keyTrunc = false;
      this._valTrunc = false;
      this._hitLimit = false;
    }
    __name(UrlEncoded, "UrlEncoded");
    UrlEncoded.prototype.write = function(data, cb) {
      if (this._fields === this.fieldsLimit) {
        if (!this.boy.hitFieldsLimit) {
          this.boy.hitFieldsLimit = true;
          this.boy.emit("fieldsLimit");
        }
        return cb();
      }
      let idxeq;
      let idxamp;
      let i;
      let p2 = 0;
      const len = data.length;
      while (p2 < len) {
        if (this._state === "key") {
          idxeq = idxamp = void 0;
          for (i = p2; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p2;
            }
            if (data[i] === 61) {
              idxeq = i;
              break;
            } else if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesKey === this.fieldNameSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesKey;
            }
          }
          if (idxeq !== void 0) {
            if (idxeq > p2) {
              this._key += this.decoder.write(data.toString("binary", p2, idxeq));
            }
            this._state = "val";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._val = "";
            this._bytesVal = 0;
            this._valTrunc = false;
            this.decoder.reset();
            p2 = idxeq + 1;
          } else if (idxamp !== void 0) {
            ++this._fields;
            let key;
            const keyTrunc = this._keyTrunc;
            if (idxamp > p2) {
              key = this._key += this.decoder.write(data.toString("binary", p2, idxamp));
            } else {
              key = this._key;
            }
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            if (key.length) {
              this.boy.emit(
                "field",
                decodeText(key, "binary", this.charset),
                "",
                keyTrunc,
                false
              );
            }
            p2 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p2) {
              this._key += this.decoder.write(data.toString("binary", p2, i));
            }
            p2 = i;
            if ((this._bytesKey = this._key.length) === this.fieldNameSizeLimit) {
              this._checkingBytes = false;
              this._keyTrunc = true;
            }
          } else {
            if (p2 < len) {
              this._key += this.decoder.write(data.toString("binary", p2));
            }
            p2 = len;
          }
        } else {
          idxamp = void 0;
          for (i = p2; i < len; ++i) {
            if (!this._checkingBytes) {
              ++p2;
            }
            if (data[i] === 38) {
              idxamp = i;
              break;
            }
            if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
              this._hitLimit = true;
              break;
            } else if (this._checkingBytes) {
              ++this._bytesVal;
            }
          }
          if (idxamp !== void 0) {
            ++this._fields;
            if (idxamp > p2) {
              this._val += this.decoder.write(data.toString("binary", p2, idxamp));
            }
            this.boy.emit(
              "field",
              decodeText(this._key, "binary", this.charset),
              decodeText(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc
            );
            this._state = "key";
            this._hitLimit = false;
            this._checkingBytes = true;
            this._key = "";
            this._bytesKey = 0;
            this._keyTrunc = false;
            this.decoder.reset();
            p2 = idxamp + 1;
            if (this._fields === this.fieldsLimit) {
              return cb();
            }
          } else if (this._hitLimit) {
            if (i > p2) {
              this._val += this.decoder.write(data.toString("binary", p2, i));
            }
            p2 = i;
            if (this._val === "" && this.fieldSizeLimit === 0 || (this._bytesVal = this._val.length) === this.fieldSizeLimit) {
              this._checkingBytes = false;
              this._valTrunc = true;
            }
          } else {
            if (p2 < len) {
              this._val += this.decoder.write(data.toString("binary", p2));
            }
            p2 = len;
          }
        }
      }
      cb();
    };
    UrlEncoded.prototype.end = function() {
      if (this.boy._done) {
        return;
      }
      if (this._state === "key" && this._key.length > 0) {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          "",
          this._keyTrunc,
          false
        );
      } else if (this._state === "val") {
        this.boy.emit(
          "field",
          decodeText(this._key, "binary", this.charset),
          decodeText(this._val, "binary", this.charset),
          this._keyTrunc,
          this._valTrunc
        );
      }
      this.boy._done = true;
      this.boy.emit("finish");
    };
    module.exports = UrlEncoded;
  }
});

// node_modules/firebase-admin/node_modules/@fastify/busboy/lib/main.js
var require_main = __commonJS({
  "node_modules/firebase-admin/node_modules/@fastify/busboy/lib/main.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var WritableStream = require_node_stream().Writable;
    var { inherits: inherits2 } = require_node_util();
    var Dicer = require_Dicer();
    var MultipartParser = require_multipart();
    var UrlencodedParser = require_urlencoded();
    var parseParams = require_parseParams();
    function Busboy(opts) {
      if (!(this instanceof Busboy)) {
        return new Busboy(opts);
      }
      if (typeof opts !== "object") {
        throw new TypeError("Busboy expected an options-Object.");
      }
      if (typeof opts.headers !== "object") {
        throw new TypeError("Busboy expected an options-Object with headers-attribute.");
      }
      if (typeof opts.headers["content-type"] !== "string") {
        throw new TypeError("Missing Content-Type-header.");
      }
      const {
        headers,
        ...streamOptions
      } = opts;
      this.opts = {
        autoDestroy: false,
        ...streamOptions
      };
      WritableStream.call(this, this.opts);
      this._done = false;
      this._parser = this.getParserByHeaders(headers);
      this._finished = false;
    }
    __name(Busboy, "Busboy");
    inherits2(Busboy, WritableStream);
    Busboy.prototype.emit = function(ev) {
      if (ev === "finish") {
        if (!this._done) {
          this._parser?.end();
          return;
        } else if (this._finished) {
          return;
        }
        this._finished = true;
      }
      WritableStream.prototype.emit.apply(this, arguments);
    };
    Busboy.prototype.getParserByHeaders = function(headers) {
      const parsed = parseParams(headers["content-type"]);
      const cfg = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: parsed,
        preservePath: this.opts.preservePath
      };
      if (MultipartParser.detect.test(parsed[0])) {
        return new MultipartParser(this, cfg);
      }
      if (UrlencodedParser.detect.test(parsed[0])) {
        return new UrlencodedParser(this, cfg);
      }
      throw new Error("Unsupported Content-Type.");
    };
    Busboy.prototype._write = function(chunk, encoding, cb) {
      this._parser.write(chunk, cb);
    };
    module.exports = Busboy;
    module.exports.default = Busboy;
    module.exports.Busboy = Busboy;
    module.exports.Dicer = Dicer;
  }
});

// node-built-in-modules:zlib
import libDefault11 from "zlib";
var require_zlib = __commonJS({
  "node-built-in-modules:zlib"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = libDefault11;
  }
});

// node_modules/firebase-admin/lib/utils/api-request.js
var require_api_request = __commonJS({
  "node_modules/firebase-admin/lib/utils/api-request.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Http2SessionHandler = exports.ExponentialBackoffPoller = exports.ApiSettings = exports.AuthorizedHttp2Client = exports.AuthorizedHttpClient = exports.Http2Client = exports.HttpClient = exports.RequestClient = exports.RequestResponseError = void 0;
    exports.defaultRetryConfig = defaultRetryConfig;
    exports.parseHttpResponse = parseHttpResponse;
    var error_1 = require_error();
    var validator = require_validator();
    var http = require_http();
    var https = require_https();
    var http2 = require_http2();
    var url = require_url();
    var events_1 = require_events();
    var credential_internal_1 = require_credential_internal();
    var index_1 = require_utils();
    var DefaultRequestResponse = class {
      static {
        __name(this, "DefaultRequestResponse");
      }
      /**
       * Constructs a new `RequestResponse` from the given `LowLevelResponse`.
       */
      constructor(resp) {
        this.status = resp.status;
        this.headers = resp.headers;
        this.text = resp.data;
        try {
          if (!resp.data) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "HTTP response missing data.");
          }
          this.parsedData = JSON.parse(resp.data);
        } catch (err) {
          this.parsedData = void 0;
          this.parseError = err;
        }
        this.request = `${resp.config.method} ${resp.config.url}`;
      }
      get data() {
        if (this.isJson()) {
          return this.parsedData;
        }
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, `Error while parsing response data: "${this.parseError.toString()}". Raw server response: "${this.text}". Status code: "${this.status}". Outgoing request: "${this.request}."`);
      }
      isJson() {
        return typeof this.parsedData !== "undefined";
      }
    };
    var MultipartRequestResponse = class {
      static {
        __name(this, "MultipartRequestResponse");
      }
      constructor(resp) {
        this.status = resp.status;
        this.headers = resp.headers;
        this.multipart = resp.multipart;
      }
      get text() {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as text");
      }
      get data() {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.UNABLE_TO_PARSE_RESPONSE, "Unable to parse multipart payload as JSON");
      }
      isJson() {
        return false;
      }
    };
    var RequestResponseError = class _RequestResponseError extends Error {
      static {
        __name(this, "RequestResponseError");
      }
      constructor(response) {
        super(`Server responded with status ${response.status}.`);
        this.response = response;
        Object.setPrototypeOf(this, _RequestResponseError.prototype);
      }
    };
    exports.RequestResponseError = RequestResponseError;
    function defaultRetryConfig() {
      return {
        maxRetries: 4,
        statusCodes: [503],
        ioErrorCodes: ["ECONNRESET", "ETIMEDOUT"],
        backOffFactor: 0.5,
        maxDelayInMillis: 60 * 1e3
      };
    }
    __name(defaultRetryConfig, "defaultRetryConfig");
    function validateRetryConfig(retry) {
      if (!validator.isNumber(retry.maxRetries) || retry.maxRetries < 0) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "maxRetries must be a non-negative integer");
      }
      if (typeof retry.backOffFactor !== "undefined") {
        if (!validator.isNumber(retry.backOffFactor) || retry.backOffFactor < 0) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "backOffFactor must be a non-negative number");
        }
      }
      if (!validator.isNumber(retry.maxDelayInMillis) || retry.maxDelayInMillis < 0) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "maxDelayInMillis must be a non-negative integer");
      }
      if (typeof retry.statusCodes !== "undefined" && !validator.isArray(retry.statusCodes)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "statusCodes must be an array");
      }
      if (typeof retry.ioErrorCodes !== "undefined" && !validator.isArray(retry.ioErrorCodes)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INVALID_ARGUMENT, "ioErrorCodes must be an array");
      }
    }
    __name(validateRetryConfig, "validateRetryConfig");
    var RequestClient = class {
      static {
        __name(this, "RequestClient");
      }
      constructor(retry = defaultRetryConfig()) {
        if (retry) {
          this.retry = retry;
          validateRetryConfig(this.retry);
        }
      }
      createRequestResponse(resp) {
        if (resp.multipart) {
          return new MultipartRequestResponse(resp);
        }
        return new DefaultRequestResponse(resp);
      }
      waitForRetry(delayMillis) {
        if (delayMillis > 0) {
          return new Promise((resolve) => {
            setTimeout(resolve, delayMillis);
          });
        }
        return Promise.resolve();
      }
      /**
       * Checks if a failed request is eligible for a retry, and if so returns the duration to wait before initiating
       * the retry.
       *
       * @param retryAttempts - Number of retries completed up to now.
       * @param err - The last encountered error.
       * @returns A 2-tuple where the 1st element is the duration to wait before another retry, and the
       *     2nd element is a boolean indicating whether the request is eligible for a retry or not.
       */
      getRetryDelayMillis(retryAttempts, err) {
        if (!this.isRetryEligible(retryAttempts, err)) {
          return [0, false];
        }
        const response = err.response;
        if (response && response.headers["retry-after"]) {
          const delayMillis = this.parseRetryAfterIntoMillis(response.headers["retry-after"]);
          if (delayMillis > 0) {
            return [delayMillis, true];
          }
        }
        return [this.backOffDelayMillis(retryAttempts), true];
      }
      isRetryEligible(retryAttempts, err) {
        if (!this.retry) {
          return false;
        }
        if (retryAttempts >= this.retry.maxRetries) {
          return false;
        }
        if (err.response) {
          const statusCodes = this.retry.statusCodes || [];
          return statusCodes.indexOf(err.response.status) !== -1;
        }
        if (err.code) {
          const retryCodes = this.retry.ioErrorCodes || [];
          return retryCodes.indexOf(err.code) !== -1;
        }
        return false;
      }
      /**???
       * Parses the Retry-After header as a milliseconds value. Return value is negative if the Retry-After header
       * contains an expired timestamp or otherwise malformed.
       */
      parseRetryAfterIntoMillis(retryAfter) {
        const delaySeconds = parseInt(retryAfter, 10);
        if (!isNaN(delaySeconds)) {
          return delaySeconds * 1e3;
        }
        const date = new Date(retryAfter);
        if (!isNaN(date.getTime())) {
          return date.getTime() - Date.now();
        }
        return -1;
      }
      backOffDelayMillis(retryAttempts) {
        if (retryAttempts === 0) {
          return 0;
        }
        if (!this.retry) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Expected this.retry to exist.");
        }
        const backOffFactor = this.retry.backOffFactor || 0;
        const delayInSeconds = 2 ** retryAttempts * backOffFactor;
        return Math.min(delayInSeconds * 1e3, this.retry.maxDelayInMillis);
      }
    };
    exports.RequestClient = RequestClient;
    var HttpClient = class extends RequestClient {
      static {
        __name(this, "HttpClient");
      }
      constructor(retry) {
        super(retry);
      }
      /**
       * Sends an HTTP request to a remote server. If the server responds with a successful response (2xx), the returned
       * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
       * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
       * If a request fails due to a low-level network error, the client transparently retries the request once before
       * rejecting the promise.
       *
       * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
       * content-type header will also be automatically set in this case. For all other payload types, the content-type
       * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
       * and pass as a string or a Buffer along with the appropriate content-type header.
       *
       * @param config - HTTP request to be sent.
       * @returns A promise that resolves with the response details.
       */
      send(config2) {
        return this.sendWithRetry(config2);
      }
      /**
       * Sends an HTTP request. In the event of an error, retries the HTTP request according to the
       * `RetryConfig` set on the `HttpClient`.
       *
       * @param config - HTTP request to be sent.
       * @param retryAttempts - Number of retries performed up to now.
       * @returns A promise that resolves with the response details.
       */
      sendWithRetry(config2, retryAttempts = 0) {
        return AsyncHttpCall.invoke(config2).then((resp) => {
          return this.createRequestResponse(resp);
        }).catch((err) => {
          const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
          if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
            return this.waitForRetry(delayMillis).then(() => {
              return this.sendWithRetry(config2, retryAttempts + 1);
            });
          }
          if (err.response) {
            throw new RequestResponseError(this.createRequestResponse(err.response));
          }
          if (err.code === "ETIMEDOUT") {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
          }
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
        });
      }
    };
    exports.HttpClient = HttpClient;
    var Http2Client = class extends RequestClient {
      static {
        __name(this, "Http2Client");
      }
      constructor(retry = defaultRetryConfig()) {
        super(retry);
      }
      /**
       * Sends an HTTP/2 request to a remote server. If the server responds with a successful response (2xx), the returned
       * promise resolves with an `RequestResponse`. If the server responds with an error (3xx, 4xx, 5xx), the promise
       * rejects with an `RequestResponseError`. In case of all other errors, the promise rejects with a `FirebaseAppError`.
       * If a request fails due to a low-level network error, the client transparently retries the request once before
       * rejecting the promise.
       *
       * If the request data is specified as an object, it will be serialized into a JSON string. The application/json
       * content-type header will also be automatically set in this case. For all other payload types, the content-type
       * header should be explicitly set by the caller. To send a JSON leaf value (e.g. "foo", 5), parse it into JSON,
       * and pass as a string or a Buffer along with the appropriate content-type header.
       *
       * @param config - HTTP/2 request to be sent.
       * @returns A promise that resolves with the response details.
       */
      send(config2) {
        return this.sendWithRetry(config2);
      }
      /**
       * Sends an HTTP/2 request. In the event of an error, retries the HTTP/2 request according to the
       * `RetryConfig` set on the `Http2Client`.
       *
       * @param config - HTTP/2 request to be sent.
       * @param retryAttempts - Number of retries performed up to now.
       * @returns A promise that resolves with the response details.
       */
      sendWithRetry(config2, retryAttempts = 0) {
        return AsyncHttp2Call.invoke(config2).then((resp) => {
          return this.createRequestResponse(resp);
        }).catch((err) => {
          const [delayMillis, canRetry] = this.getRetryDelayMillis(retryAttempts, err);
          if (canRetry && this.retry && delayMillis <= this.retry.maxDelayInMillis) {
            return this.waitForRetry(delayMillis).then(() => {
              return this.sendWithRetry(config2, retryAttempts + 1);
            });
          }
          if (err.response) {
            throw new RequestResponseError(this.createRequestResponse(err.response));
          }
          if (err.code === "ETIMEDOUT") {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_TIMEOUT, `Error while making request: ${err.message}.`);
          }
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making request: ${err.message}. Error code: ${err.code}`);
        });
      }
    };
    exports.Http2Client = Http2Client;
    function parseHttpResponse(response, config2) {
      const responseText = validator.isBuffer(response) ? response.toString("utf-8") : response;
      const endOfHeaderPos = responseText.indexOf("\r\n\r\n");
      const headerLines = responseText.substring(0, endOfHeaderPos).split("\r\n");
      const statusLine = headerLines[0];
      const status = statusLine.trim().split(/\s/)[1];
      const headers = {};
      headerLines.slice(1).forEach((line) => {
        const colonPos = line.indexOf(":");
        const name = line.substring(0, colonPos).trim().toLowerCase();
        const value = line.substring(colonPos + 1).trim();
        headers[name] = value;
      });
      let data = responseText.substring(endOfHeaderPos + 4);
      if (data.endsWith("\n")) {
        data = data.slice(0, -1);
      }
      if (data.endsWith("\r")) {
        data = data.slice(0, -1);
      }
      const lowLevelResponse = {
        status: parseInt(status, 10),
        headers,
        data,
        config: config2,
        request: null
      };
      if (!validator.isNumber(lowLevelResponse.status)) {
        throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Malformed HTTP status line.");
      }
      return new DefaultRequestResponse(lowLevelResponse);
    }
    __name(parseHttpResponse, "parseHttpResponse");
    var AsyncRequestCall = class {
      static {
        __name(this, "AsyncRequestCall");
      }
      constructor(configImpl) {
        this.configImpl = configImpl;
      }
      /**
       * Extracts multipart boundary from the HTTP header. The content-type header of a multipart
       * response has the form 'multipart/subtype; boundary=string'.
       *
       * If the content-type header does not exist, or does not start with
       * 'multipart/', then null will be returned.
       */
      getMultipartBoundary(headers) {
        const contentType = headers["content-type"];
        if (!contentType || !contentType.startsWith("multipart/")) {
          return null;
        }
        const segments = contentType.split(";");
        const emptyObject = {};
        const headerParams = segments.slice(1).map((segment) => segment.trim().split("=")).reduce((curr, params) => {
          if (params.length === 2) {
            const keyValuePair = {};
            keyValuePair[params[0]] = params[1];
            return Object.assign(curr, keyValuePair);
          }
          return curr;
        }, emptyObject);
        return headerParams.boundary;
      }
      handleMultipartResponse(response, respStream, boundary) {
        const busboy = require_main();
        const multipartParser = new busboy.Dicer({ boundary });
        const responseBuffer = [];
        multipartParser.on("part", (part) => {
          const tempBuffers = [];
          part.on("data", (partData) => {
            tempBuffers.push(partData);
          });
          part.on("end", () => {
            responseBuffer.push(Buffer.concat(tempBuffers));
          });
        });
        multipartParser.on("finish", () => {
          response.data = void 0;
          response.multipart = responseBuffer;
          this.finalizeResponse(response);
        });
        respStream.pipe(multipartParser);
      }
      handleRegularResponse(response, respStream) {
        const responseBuffer = [];
        respStream.on("data", (chunk) => {
          responseBuffer.push(chunk);
        });
        respStream.on("error", (err) => {
          const req = response.request;
          if (req && req.destroyed) {
            return;
          }
          this.enhanceAndReject(err, null, req);
        });
        respStream.on("end", () => {
          response.data = Buffer.concat(responseBuffer).toString();
          this.finalizeResponse(response);
        });
      }
      /**
       * Finalizes the current request call in-flight by either resolving or rejecting the associated
       * promise. In the event of an error, adds additional useful information to the returned error.
       */
      finalizeResponse(response) {
        if (response.status >= 200 && response.status < 300) {
          this.resolve(response);
        } else {
          this.rejectWithError("Request failed with status code " + response.status, null, response.request, response);
        }
      }
      /**
       * Creates a new error from the given message, and enhances it with other information available.
       * Then the promise associated with this request call is rejected with the resulting error.
       */
      rejectWithError(message2, code, request3, response) {
        const error3 = new Error(message2);
        this.enhanceAndReject(error3, code, request3, response);
      }
      enhanceAndReject(error3, code, request3, response) {
        this.reject(this.enhanceError(error3, code, request3, response));
      }
      /**
       * Enhances the given error by adding more information to it. Specifically, the request config,
       * the underlying request and response will be attached to the error.
       */
      enhanceError(error3, code, request3, response) {
        error3.config = this.configImpl;
        if (code) {
          error3.code = code;
        }
        error3.request = request3;
        error3.response = response;
        return error3;
      }
    };
    var AsyncHttpCall = class _AsyncHttpCall extends AsyncRequestCall {
      static {
        __name(this, "AsyncHttpCall");
      }
      /**
       * Sends an HTTP request based on the provided configuration.
       */
      static invoke(config2) {
        return new _AsyncHttpCall(config2).promise;
      }
      constructor(config2) {
        const httpConfigImpl = new HttpRequestConfigImpl(config2);
        super(httpConfigImpl);
        try {
          this.httpConfigImpl = httpConfigImpl;
          this.options = this.httpConfigImpl.buildRequestOptions();
          this.entity = this.httpConfigImpl.buildEntity(this.options.headers);
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.execute();
          });
        } catch (err) {
          this.promise = Promise.reject(this.enhanceError(err, null));
        }
      }
      execute() {
        const transport = this.options.protocol === "https:" ? https : http;
        const req = transport.request(this.options, (res) => {
          this.handleResponse(res, req);
        });
        req.on("error", (err) => {
          if (req.aborted) {
            return;
          }
          this.enhanceAndReject(err, null, req);
        });
        const timeout = this.httpConfigImpl.timeout;
        const timeoutCallback = /* @__PURE__ */ __name(() => {
          req.destroy();
          this.rejectWithError(`timeout of ${timeout}ms exceeded`, "ETIMEDOUT", req);
        }, "timeoutCallback");
        if (timeout) {
          req.setTimeout(timeout, timeoutCallback);
        }
        req.end(this.entity);
      }
      handleResponse(res, req) {
        if (req.aborted) {
          return;
        }
        if (!res.statusCode) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Expected a statusCode on the response from a ClientRequest");
        }
        const response = {
          status: res.statusCode,
          headers: res.headers,
          request: req,
          data: void 0,
          config: this.httpConfigImpl
        };
        const boundary = this.getMultipartBoundary(res.headers);
        const respStream = this.uncompressResponse(res);
        if (boundary) {
          this.handleMultipartResponse(response, respStream, boundary);
        } else {
          this.handleRegularResponse(response, respStream);
        }
      }
      uncompressResponse(res) {
        let respStream = res;
        const encodings = ["gzip", "compress", "deflate"];
        if (res.headers["content-encoding"] && encodings.indexOf(res.headers["content-encoding"]) !== -1) {
          const zlib = require_zlib();
          respStream = respStream.pipe(zlib.createUnzip());
          delete res.headers["content-encoding"];
        }
        return respStream;
      }
    };
    var AsyncHttp2Call = class _AsyncHttp2Call extends AsyncRequestCall {
      static {
        __name(this, "AsyncHttp2Call");
      }
      /**
       * Sends an HTTP2 request based on the provided configuration.
       */
      static invoke(config2) {
        return new _AsyncHttp2Call(config2).promise;
      }
      constructor(config2) {
        const http2ConfigImpl = new Http2RequestConfigImpl(config2);
        super(http2ConfigImpl);
        try {
          this.http2ConfigImpl = http2ConfigImpl;
          this.options = this.http2ConfigImpl.buildRequestOptions();
          this.entity = this.http2ConfigImpl.buildEntity(this.options.headers);
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.execute();
          });
        } catch (err) {
          this.promise = Promise.reject(this.enhanceError(err, null));
        }
      }
      execute() {
        const req = this.http2ConfigImpl.http2SessionHandler.session.request({
          ":method": this.options.method,
          ":scheme": this.options.protocol,
          ":path": this.options.path,
          ...this.options.headers
        });
        req.on("response", (headers) => {
          this.handleHttp2Response(headers, req);
        });
        req.on("error", (err) => {
          if (req.aborted) {
            return;
          }
          this.enhanceAndReject(err, null, req);
        });
        const timeout = this.http2ConfigImpl.timeout;
        const timeoutCallback = /* @__PURE__ */ __name(() => {
          req.destroy();
          this.rejectWithError(`timeout of ${timeout}ms exceeded`, "ETIMEDOUT", req);
        }, "timeoutCallback");
        if (timeout) {
          req.setTimeout(timeout, timeoutCallback);
        }
        req.end(this.entity);
      }
      handleHttp2Response(headers, stream) {
        if (stream.aborted) {
          return;
        }
        if (!headers[":status"]) {
          throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "Expected a statusCode on the response from a ClientRequest");
        }
        const response = {
          status: headers[":status"],
          headers,
          request: stream,
          data: void 0,
          config: this.http2ConfigImpl
        };
        const boundary = this.getMultipartBoundary(headers);
        const respStream = this.uncompressResponse(headers, stream);
        if (boundary) {
          this.handleMultipartResponse(response, respStream, boundary);
        } else {
          this.handleRegularResponse(response, respStream);
        }
      }
      uncompressResponse(headers, stream) {
        let respStream = stream;
        const encodings = ["gzip", "compress", "deflate"];
        if (headers["content-encoding"] && encodings.indexOf(headers["content-encoding"]) !== -1) {
          const zlib = require_zlib();
          respStream = respStream.pipe(zlib.createUnzip());
          delete headers["content-encoding"];
        }
        return respStream;
      }
    };
    var BaseRequestConfigImpl = class {
      static {
        __name(this, "BaseRequestConfigImpl");
      }
      constructor(config2) {
        this.config = config2;
        this.config = config2;
      }
      get method() {
        return this.config.method;
      }
      get url() {
        return this.config.url;
      }
      get headers() {
        return this.config.headers;
      }
      get data() {
        return this.config.data;
      }
      get timeout() {
        return this.config.timeout;
      }
      buildEntity(headers) {
        let data;
        if (!this.hasEntity() || !this.isEntityEnclosingRequest()) {
          return data;
        }
        if (validator.isBuffer(this.data)) {
          data = this.data;
        } else if (validator.isObject(this.data)) {
          data = Buffer.from(JSON.stringify(this.data), "utf-8");
          if (typeof headers["content-type"] === "undefined") {
            headers["content-type"] = "application/json;charset=utf-8";
          }
        } else if (validator.isString(this.data)) {
          data = Buffer.from(this.data, "utf-8");
        } else {
          throw new Error("Request data must be a string, a Buffer or a json serializable object");
        }
        headers["Content-Length"] = data.length.toString();
        return data;
      }
      buildUrl() {
        const fullUrl = this.urlWithProtocol();
        if (!this.hasEntity() || this.isEntityEnclosingRequest()) {
          return url.parse(fullUrl);
        }
        if (!validator.isObject(this.data)) {
          throw new Error(`${this.method} requests cannot have a body`);
        }
        const parsedUrl = new url.URL(fullUrl);
        const dataObj = this.data;
        for (const key in dataObj) {
          if (Object.prototype.hasOwnProperty.call(dataObj, key)) {
            parsedUrl.searchParams.append(key, dataObj[key]);
          }
        }
        return url.parse(parsedUrl.toString());
      }
      urlWithProtocol() {
        const fullUrl = this.url;
        if (fullUrl.startsWith("http://") || fullUrl.startsWith("https://")) {
          return fullUrl;
        }
        return `https://${fullUrl}`;
      }
      hasEntity() {
        return !!this.data;
      }
      isEntityEnclosingRequest() {
        return this.method !== "GET" && this.method !== "HEAD";
      }
    };
    var HttpRequestConfigImpl = class extends BaseRequestConfigImpl {
      static {
        __name(this, "HttpRequestConfigImpl");
      }
      constructor(httpConfig) {
        super(httpConfig);
        this.httpConfig = httpConfig;
      }
      get httpAgent() {
        return this.httpConfig.httpAgent;
      }
      buildRequestOptions() {
        const parsed = this.buildUrl();
        const protocol = parsed.protocol;
        let port = parsed.port;
        if (!port) {
          const isHttps = protocol === "https:";
          port = isHttps ? "443" : "80";
        }
        return {
          protocol,
          hostname: parsed.hostname,
          port,
          path: parsed.path,
          method: this.method,
          agent: this.httpAgent,
          headers: Object.assign({}, this.headers)
        };
      }
    };
    var Http2RequestConfigImpl = class extends BaseRequestConfigImpl {
      static {
        __name(this, "Http2RequestConfigImpl");
      }
      constructor(http2Config) {
        super(http2Config);
        this.http2Config = http2Config;
      }
      get http2SessionHandler() {
        return this.http2Config.http2SessionHandler;
      }
      buildRequestOptions() {
        const parsed = this.buildUrl();
        const protocol = parsed.protocol;
        return {
          protocol,
          path: parsed.path,
          method: this.method,
          headers: Object.assign({}, this.headers)
        };
      }
    };
    var AuthorizedHttpClient = class extends HttpClient {
      static {
        __name(this, "AuthorizedHttpClient");
      }
      constructor(app) {
        super();
        this.app = app;
      }
      send(request3) {
        return this.getToken().then((token) => {
          const requestCopy = Object.assign({}, request3);
          requestCopy.headers = Object.assign({}, request3.headers);
          const authHeader = "Authorization";
          requestCopy.headers[authHeader] = `Bearer ${token}`;
          let quotaProjectId;
          if (this.app.options.credential instanceof credential_internal_1.ApplicationDefaultCredential) {
            quotaProjectId = this.app.options.credential.getQuotaProjectId();
          }
          quotaProjectId = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || quotaProjectId;
          if (!requestCopy.headers["x-goog-user-project"] && validator.isNonEmptyString(quotaProjectId)) {
            requestCopy.headers["x-goog-user-project"] = quotaProjectId;
          }
          if (!requestCopy.httpAgent && this.app.options.httpAgent) {
            requestCopy.httpAgent = this.app.options.httpAgent;
          }
          requestCopy.headers["X-Goog-Api-Client"] = (0, index_1.getMetricsHeader)();
          return super.send(requestCopy);
        });
      }
      getToken() {
        return this.app.INTERNAL.getToken().then((accessTokenObj) => accessTokenObj.accessToken);
      }
    };
    exports.AuthorizedHttpClient = AuthorizedHttpClient;
    var AuthorizedHttp2Client = class extends Http2Client {
      static {
        __name(this, "AuthorizedHttp2Client");
      }
      constructor(app) {
        super();
        this.app = app;
      }
      send(request3) {
        return this.getToken().then((token) => {
          const requestCopy = Object.assign({}, request3);
          requestCopy.headers = Object.assign({}, request3.headers);
          const authHeader = "Authorization";
          requestCopy.headers[authHeader] = `Bearer ${token}`;
          let quotaProjectId;
          if (this.app.options.credential instanceof credential_internal_1.ApplicationDefaultCredential) {
            quotaProjectId = this.app.options.credential.getQuotaProjectId();
          }
          quotaProjectId = process.env.GOOGLE_CLOUD_QUOTA_PROJECT || quotaProjectId;
          if (!requestCopy.headers["x-goog-user-project"] && validator.isNonEmptyString(quotaProjectId)) {
            requestCopy.headers["x-goog-user-project"] = quotaProjectId;
          }
          requestCopy.headers["X-Goog-Api-Client"] = (0, index_1.getMetricsHeader)();
          return super.send(requestCopy);
        });
      }
      getToken() {
        return this.app.INTERNAL.getToken().then((accessTokenObj) => accessTokenObj.accessToken);
      }
    };
    exports.AuthorizedHttp2Client = AuthorizedHttp2Client;
    var ApiSettings = class {
      static {
        __name(this, "ApiSettings");
      }
      constructor(endpoint, httpMethod = "POST") {
        this.endpoint = endpoint;
        this.httpMethod = httpMethod;
        this.setRequestValidator(null).setResponseValidator(null);
      }
      /** @returns The backend API endpoint. */
      getEndpoint() {
        return this.endpoint;
      }
      /** @returns The request HTTP method. */
      getHttpMethod() {
        return this.httpMethod;
      }
      /**
       * @param requestValidator - The request validator.
       * @returns The current API settings instance.
       */
      setRequestValidator(requestValidator) {
        const nullFunction = /* @__PURE__ */ __name(() => void 0, "nullFunction");
        this.requestValidator = requestValidator || nullFunction;
        return this;
      }
      /** @returns The request validator. */
      getRequestValidator() {
        return this.requestValidator;
      }
      /**
       * @param responseValidator - The response validator.
       * @returns The current API settings instance.
       */
      setResponseValidator(responseValidator) {
        const nullFunction = /* @__PURE__ */ __name(() => void 0, "nullFunction");
        this.responseValidator = responseValidator || nullFunction;
        return this;
      }
      /** @returns The response validator. */
      getResponseValidator() {
        return this.responseValidator;
      }
    };
    exports.ApiSettings = ApiSettings;
    var ExponentialBackoffPoller = class extends events_1.EventEmitter {
      static {
        __name(this, "ExponentialBackoffPoller");
      }
      constructor(initialPollingDelayMillis = 1e3, maxPollingDelayMillis = 1e4, masterTimeoutMillis = 6e4) {
        super();
        this.initialPollingDelayMillis = initialPollingDelayMillis;
        this.maxPollingDelayMillis = maxPollingDelayMillis;
        this.masterTimeoutMillis = masterTimeoutMillis;
        this.numTries = 0;
        this.completed = false;
      }
      /**
       * Poll the provided callback with exponential backoff.
       *
       * @param callback - The callback to be called for each poll. If the
       *     callback resolves to a falsey value, polling will continue. Otherwise, the truthy
       *     resolution will be used to resolve the promise returned by this method.
       * @returns A Promise which resolves to the truthy value returned by the provided
       *     callback when polling is complete.
       */
      poll(callback) {
        if (this.pollCallback) {
          throw new Error("poll() can only be called once per instance of ExponentialBackoffPoller");
        }
        this.pollCallback = callback;
        this.on("poll", this.repoll);
        this.masterTimer = setTimeout(() => {
          if (this.completed) {
            return;
          }
          this.markCompleted();
          this.reject(new Error("ExponentialBackoffPoller deadline exceeded - Master timeout reached"));
        }, this.masterTimeoutMillis);
        return new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
          this.repoll();
        });
      }
      repoll() {
        this.pollCallback().then((result) => {
          if (this.completed) {
            return;
          }
          if (!result) {
            this.repollTimer = setTimeout(() => this.emit("poll"), this.getPollingDelayMillis());
            this.numTries++;
            return;
          }
          this.markCompleted();
          this.resolve(result);
        }).catch((err) => {
          if (this.completed) {
            return;
          }
          this.markCompleted();
          this.reject(err);
        });
      }
      getPollingDelayMillis() {
        const increasedPollingDelay = Math.pow(2, this.numTries) * this.initialPollingDelayMillis;
        return Math.min(increasedPollingDelay, this.maxPollingDelayMillis);
      }
      markCompleted() {
        this.completed = true;
        if (this.masterTimer) {
          clearTimeout(this.masterTimer);
        }
        if (this.repollTimer) {
          clearTimeout(this.repollTimer);
        }
      }
    };
    exports.ExponentialBackoffPoller = ExponentialBackoffPoller;
    var Http2SessionHandler = class {
      static {
        __name(this, "Http2SessionHandler");
      }
      constructor(url2) {
        this.http2Session = this.createSession(url2);
      }
      createSession(url2) {
        if (!this.http2Session || this.isClosed) {
          const opts = {
            // Set local max concurrent stream limit to respect backend limit
            peerMaxConcurrentStreams: 100,
            ALPNProtocols: ["h2"]
          };
          const http2Session = http2.connect(url2, opts);
          http2Session.on("goaway", (errorCode, _, opaqueData) => {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: GOAWAY - ${opaqueData.toString()}, Error code: ${errorCode}`);
          });
          http2Session.on("error", (error3) => {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.NETWORK_ERROR, `Error while making requests: ${error3}`);
          });
          return http2Session;
        }
        return this.http2Session;
      }
      get session() {
        return this.http2Session;
      }
      get isClosed() {
        return this.http2Session.closed;
      }
      close() {
        this.http2Session.close();
      }
    };
    exports.Http2SessionHandler = Http2SessionHandler;
  }
});

// node_modules/firebase-admin/lib/auth/user-import-builder.js
var require_user_import_builder = __commonJS({
  "node_modules/firebase-admin/lib/auth/user-import-builder.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserImportBuilder = void 0;
    exports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;
    var deep_copy_1 = require_deep_copy();
    var utils = require_utils();
    var validator = require_validator();
    var error_1 = require_error();
    function convertMultiFactorInfoToServerFormat(multiFactorInfo) {
      let enrolledAt;
      if (typeof multiFactorInfo.enrollmentTime !== "undefined") {
        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {
          enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();
        } else {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${multiFactorInfo.uid}" must be a valid UTC date string.`);
        }
      }
      if (isPhoneFactor(multiFactorInfo)) {
        const authFactorInfo = {
          mfaEnrollmentId: multiFactorInfo.uid,
          displayName: multiFactorInfo.displayName,
          // Required for all phone second factors.
          phoneInfo: multiFactorInfo.phoneNumber,
          enrolledAt
        };
        for (const objKey in authFactorInfo) {
          if (typeof authFactorInfo[objKey] === "undefined") {
            delete authFactorInfo[objKey];
          }
        }
        return authFactorInfo;
      } else {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor "${JSON.stringify(multiFactorInfo)}" provided.`);
      }
    }
    __name(convertMultiFactorInfoToServerFormat, "convertMultiFactorInfoToServerFormat");
    function isPhoneFactor(multiFactorInfo) {
      return multiFactorInfo.factorId === "phone";
    }
    __name(isPhoneFactor, "isPhoneFactor");
    function getNumberField(obj, key) {
      if (typeof obj[key] !== "undefined" && obj[key] !== null) {
        return parseInt(obj[key].toString(), 10);
      }
      return NaN;
    }
    __name(getNumberField, "getNumberField");
    function populateUploadAccountUser(user, userValidator) {
      const result = {
        localId: user.uid,
        email: user.email,
        emailVerified: user.emailVerified,
        displayName: user.displayName,
        disabled: user.disabled,
        photoUrl: user.photoURL,
        phoneNumber: user.phoneNumber,
        providerUserInfo: [],
        mfaInfo: [],
        tenantId: user.tenantId,
        customAttributes: user.customClaims && JSON.stringify(user.customClaims)
      };
      if (typeof user.passwordHash !== "undefined") {
        if (!validator.isBuffer(user.passwordHash)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
        }
        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);
      }
      if (typeof user.passwordSalt !== "undefined") {
        if (!validator.isBuffer(user.passwordSalt)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
        }
        result.salt = utils.toWebSafeBase64(user.passwordSalt);
      }
      if (validator.isNonNullObject(user.metadata)) {
        if (validator.isNonEmptyString(user.metadata.creationTime)) {
          result.createdAt = new Date(user.metadata.creationTime).getTime();
        }
        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {
          result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();
        }
      }
      if (validator.isArray(user.providerData)) {
        user.providerData.forEach((providerData) => {
          result.providerUserInfo.push({
            providerId: providerData.providerId,
            rawId: providerData.uid,
            email: providerData.email,
            displayName: providerData.displayName,
            photoUrl: providerData.photoURL
          });
        });
      }
      if (validator.isNonNullObject(user.multiFactor) && validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {
        user.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
          result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));
        });
      }
      let key;
      for (key in result) {
        if (typeof result[key] === "undefined") {
          delete result[key];
        }
      }
      if (result.providerUserInfo.length === 0) {
        delete result.providerUserInfo;
      }
      if (result.mfaInfo.length === 0) {
        delete result.mfaInfo;
      }
      if (typeof userValidator === "function") {
        userValidator(result);
      }
      return result;
    }
    __name(populateUploadAccountUser, "populateUploadAccountUser");
    var UserImportBuilder = class {
      static {
        __name(this, "UserImportBuilder");
      }
      /**
       * @param {UserImportRecord[]} users The list of user records to import.
       * @param {UserImportOptions=} options The import options which includes hashing
       *     algorithm details.
       * @param {ValidatorFunction=} userRequestValidator The user request validator function.
       * @constructor
       */
      constructor(users, options, userRequestValidator) {
        this.requiresHashOptions = false;
        this.validatedUsers = [];
        this.userImportResultErrors = [];
        this.indexMap = {};
        this.validatedUsers = this.populateUsers(users, userRequestValidator);
        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);
      }
      /**
       * Returns the corresponding constructed uploadAccount request.
       * @returns {UploadAccountRequest} The constructed uploadAccount request.
       */
      buildRequest() {
        const users = this.validatedUsers.map((user) => {
          return (0, deep_copy_1.deepCopy)(user);
        });
        return (0, deep_copy_1.deepExtend)({ users }, (0, deep_copy_1.deepCopy)(this.validatedOptions));
      }
      /**
       * Populates the UserImportResult using the client side detected errors and the server
       * side returned errors.
       * @returns {UserImportResult} The user import result based on the returned failed
       *     uploadAccount response.
       */
      buildResponse(failedUploads) {
        const importResult = {
          successCount: this.validatedUsers.length,
          failureCount: this.userImportResultErrors.length,
          errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors)
        };
        importResult.failureCount += failedUploads.length;
        importResult.successCount -= failedUploads.length;
        failedUploads.forEach((failedUpload) => {
          importResult.errors.push({
            // Map backend request index to original developer provided array index.
            index: this.indexMap[failedUpload.index],
            error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)
          });
        });
        importResult.errors.sort((a2, b2) => {
          return a2.index - b2.index;
        });
        return importResult;
      }
      /**
       * Validates and returns the hashing options of the uploadAccount request.
       * Throws an error whenever an invalid or missing options is detected.
       * @param {UserImportOptions} options The UserImportOptions.
       * @param {boolean} requiresHashOptions Whether to require hash options.
       * @returns {UploadAccountOptions} The populated UploadAccount options.
       */
      populateOptions(options, requiresHashOptions) {
        let populatedOptions;
        if (!requiresHashOptions) {
          return {};
        }
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UserImportOptions" are required when importing users with passwords.');
        }
        if (!validator.isNonNullObject(options.hash)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '"hash.algorithm" is missing from the provided "UserImportOptions".');
        }
        if (typeof options.hash.algorithm === "undefined" || !validator.isNonEmptyString(options.hash.algorithm)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '"hash.algorithm" must be a string matching the list of supported algorithms.');
        }
        let rounds;
        switch (options.hash.algorithm) {
          case "HMAC_SHA512":
          case "HMAC_SHA256":
          case "HMAC_SHA1":
          case "HMAC_MD5":
            if (!validator.isBuffer(options.hash.key)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, `A non-empty "hash.key" byte buffer must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              signerKey: utils.toWebSafeBase64(options.hash.key)
            };
            break;
          case "MD5":
          case "SHA1":
          case "SHA256":
          case "SHA512": {
            rounds = getNumberField(options.hash, "rounds");
            const minRounds = options.hash.algorithm === "MD5" ? 0 : 1;
            if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between ${minRounds} and 8192 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              rounds
            };
            break;
          }
          case "PBKDF_SHA1":
          case "PBKDF2_SHA256":
            rounds = getNumberField(options.hash, "rounds");
            if (isNaN(rounds) || rounds < 0 || rounds > 12e4) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 0 and 120000 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              rounds
            };
            break;
          case "SCRYPT": {
            if (!validator.isBuffer(options.hash.key)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, `A "hash.key" byte buffer must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            rounds = getNumberField(options.hash, "rounds");
            if (isNaN(rounds) || rounds <= 0 || rounds > 8) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 1 and 8 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const memoryCost = getNumberField(options.hash, "memoryCost");
            if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number between 1 and 14 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            if (typeof options.hash.saltSeparator !== "undefined" && !validator.isBuffer(options.hash.saltSeparator)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '"hash.saltSeparator" must be a byte buffer.');
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              signerKey: utils.toWebSafeBase64(options.hash.key),
              rounds,
              memoryCost,
              saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(""))
            };
            break;
          }
          case "BCRYPT":
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm
            };
            break;
          case "STANDARD_SCRYPT": {
            const cpuMemCost = getNumberField(options.hash, "memoryCost");
            if (isNaN(cpuMemCost)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const parallelization = getNumberField(options.hash, "parallelization");
            if (isNaN(parallelization)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, `A valid "hash.parallelization" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const blockSize = getNumberField(options.hash, "blockSize");
            if (isNaN(blockSize)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, `A valid "hash.blockSize" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const dkLen = getNumberField(options.hash, "derivedKeyLength");
            if (isNaN(dkLen)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, `A valid "hash.derivedKeyLength" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              cpuMemCost,
              parallelization,
              blockSize,
              dkLen
            };
            break;
          }
          default:
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider "${options.hash.algorithm}".`);
        }
        return populatedOptions;
      }
      /**
       * Validates and returns the users list of the uploadAccount request.
       * Whenever a user with an error is detected, the error is cached and will later be
       * merged into the user import result. This allows the processing of valid users without
       * failing early on the first error detected.
       * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser
       *     objects.
       * @param {ValidatorFunction=} userValidator The user validator function.
       * @returns {UploadAccountUser[]} The populated uploadAccount users.
       */
      populateUsers(users, userValidator) {
        const populatedUsers = [];
        users.forEach((user, index) => {
          try {
            const result = populateUploadAccountUser(user, userValidator);
            if (typeof result.passwordHash !== "undefined") {
              this.requiresHashOptions = true;
            }
            populatedUsers.push(result);
            this.indexMap[populatedUsers.length - 1] = index;
          } catch (error3) {
            this.userImportResultErrors.push({
              index,
              error: error3
            });
          }
        });
        return populatedUsers;
      }
    };
    exports.UserImportBuilder = UserImportBuilder;
  }
});

// node_modules/firebase-admin/lib/auth/action-code-settings-builder.js
var require_action_code_settings_builder = __commonJS({
  "node_modules/firebase-admin/lib/auth/action-code-settings-builder.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionCodeSettingsBuilder = void 0;
    var validator = require_validator();
    var error_1 = require_error();
    var ActionCodeSettingsBuilder = class {
      static {
        __name(this, "ActionCodeSettingsBuilder");
      }
      /**
       * ActionCodeSettingsBuilder constructor.
       *
       * @param {ActionCodeSettings} actionCodeSettings The ActionCodeSettings
       *     object used to initiliaze this server request builder.
       * @constructor
       */
      constructor(actionCodeSettings) {
        if (!validator.isNonNullObject(actionCodeSettings)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings" must be a non-null object.');
        }
        if (typeof actionCodeSettings.url === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_CONTINUE_URI);
        } else if (!validator.isURL(actionCodeSettings.url)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONTINUE_URI);
        }
        this.continueUrl = actionCodeSettings.url;
        if (typeof actionCodeSettings.handleCodeInApp !== "undefined" && !validator.isBoolean(actionCodeSettings.handleCodeInApp)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.handleCodeInApp" must be a boolean.');
        }
        this.canHandleCodeInApp = actionCodeSettings.handleCodeInApp || false;
        if (typeof actionCodeSettings.dynamicLinkDomain !== "undefined" && !validator.isNonEmptyString(actionCodeSettings.dynamicLinkDomain)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN);
        }
        this.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
        if (typeof actionCodeSettings.iOS !== "undefined") {
          if (!validator.isNonNullObject(actionCodeSettings.iOS)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS" must be a valid non-null object.');
          } else if (typeof actionCodeSettings.iOS.bundleId === "undefined") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_IOS_BUNDLE_ID);
          } else if (!validator.isNonEmptyString(actionCodeSettings.iOS.bundleId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS.bundleId" must be a valid non-empty string.');
          }
          this.ibi = actionCodeSettings.iOS.bundleId;
        }
        if (typeof actionCodeSettings.android !== "undefined") {
          if (!validator.isNonNullObject(actionCodeSettings.android)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android" must be a valid non-null object.');
          } else if (typeof actionCodeSettings.android.packageName === "undefined") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME);
          } else if (!validator.isNonEmptyString(actionCodeSettings.android.packageName)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.packageName" must be a valid non-empty string.');
          } else if (typeof actionCodeSettings.android.minimumVersion !== "undefined" && !validator.isNonEmptyString(actionCodeSettings.android.minimumVersion)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.minimumVersion" must be a valid non-empty string.');
          } else if (typeof actionCodeSettings.android.installApp !== "undefined" && !validator.isBoolean(actionCodeSettings.android.installApp)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.installApp" must be a valid boolean.');
          }
          this.apn = actionCodeSettings.android.packageName;
          this.amv = actionCodeSettings.android.minimumVersion;
          this.installApp = actionCodeSettings.android.installApp || false;
        }
      }
      /**
       * Returns the corresponding constructed server request corresponding to the
       * current ActionCodeSettings.
       *
       * @returns The constructed EmailActionCodeRequest request.
       */
      buildRequest() {
        const request3 = {
          continueUrl: this.continueUrl,
          canHandleCodeInApp: this.canHandleCodeInApp,
          dynamicLinkDomain: this.dynamicLinkDomain,
          androidPackageName: this.apn,
          androidMinimumVersion: this.amv,
          androidInstallApp: this.installApp,
          iOSBundleId: this.ibi
        };
        for (const key in request3) {
          if (Object.prototype.hasOwnProperty.call(request3, key)) {
            if (typeof request3[key] === "undefined" || request3[key] === null) {
              delete request3[key];
            }
          }
        }
        return request3;
      }
    };
    exports.ActionCodeSettingsBuilder = ActionCodeSettingsBuilder;
  }
});

// node_modules/firebase-admin/lib/auth/auth-config.js
var require_auth_config = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth-config.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmailPrivacyAuthConfig = exports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;
    exports.validateTestPhoneNumbers = validateTestPhoneNumbers;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    exports.MAXIMUM_TEST_PHONE_NUMBERS = 10;
    var AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {
      phone: "PHONE_SMS"
    };
    var AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce((res, key) => {
      res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;
      return res;
    }, {});
    var MultiFactorAuthConfig = class _MultiFactorAuthConfig {
      static {
        __name(this, "MultiFactorAuthConfig");
      }
      /**
       * Static method to convert a client side request to a MultiFactorAuthServerConfig.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        const request3 = {};
        _MultiFactorAuthConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "state")) {
          request3.state = options.state;
        }
        if (Object.prototype.hasOwnProperty.call(options, "factorIds")) {
          (options.factorIds || []).forEach((factorId) => {
            if (typeof request3.enabledProviders === "undefined") {
              request3.enabledProviders = [];
            }
            request3.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);
          });
          if (options.factorIds && options.factorIds.length === 0) {
            request3.enabledProviders = [];
          }
        }
        if (Object.prototype.hasOwnProperty.call(options, "providerConfigs")) {
          request3.providerConfigs = options.providerConfigs;
        }
        return request3;
      }
      /**
       * Validates the MultiFactorConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          state: true,
          factorIds: true,
          providerConfigs: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid MultiFactorConfig parameter.`);
          }
        }
        if (typeof options.state !== "undefined" && options.state !== "ENABLED" && options.state !== "DISABLED") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.state" must be either "ENABLED" or "DISABLED".');
        }
        if (typeof options.factorIds !== "undefined") {
          if (!validator.isArray(options.factorIds)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.factorIds" must be an array of valid "AuthFactorTypes".');
          }
          options.factorIds.forEach((factorId) => {
            if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${factorId}" is not a valid "AuthFactorType".`);
            }
          });
        }
        if (typeof options.providerConfigs !== "undefined") {
          if (!validator.isArray(options.providerConfigs)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs" must be an array of valid "MultiFactorProviderConfig."');
          }
          options.providerConfigs.forEach((multiFactorProviderConfig) => {
            if (typeof multiFactorProviderConfig === "undefined" || !validator.isObject(multiFactorProviderConfig)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${multiFactorProviderConfig}" is not a valid "MultiFactorProviderConfig" type.`);
            }
            const validProviderConfigKeys = {
              state: true,
              totpProviderConfig: true
            };
            for (const key in multiFactorProviderConfig) {
              if (!(key in validProviderConfigKeys)) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid ProviderConfig parameter.`);
              }
            }
            if (typeof multiFactorProviderConfig.state === "undefined" || multiFactorProviderConfig.state !== "ENABLED" && multiFactorProviderConfig.state !== "DISABLED") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.state" must be either "ENABLED" or "DISABLED".');
            }
            if (typeof multiFactorProviderConfig.totpProviderConfig === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.totpProviderConfig" must be defined.');
            }
            const validTotpProviderConfigKeys = {
              adjacentIntervals: true
            };
            for (const key in multiFactorProviderConfig.totpProviderConfig) {
              if (!(key in validTotpProviderConfigKeys)) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid TotpProviderConfig parameter.`);
              }
            }
            const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;
            if (typeof adjIntervals !== "undefined" && (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals" must be a valid number between 0 and 10 (both inclusive).');
            }
          });
        }
      }
      /**
       * The MultiFactorAuthConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     MultiFactorAuthConfig object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.state === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
        }
        this.state = response.state;
        this.factorIds = [];
        (response.enabledProviders || []).forEach((enabledProvider) => {
          if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== "undefined") {
            this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);
          }
        });
        this.providerConfigs = [];
        (response.providerConfigs || []).forEach((providerConfig) => {
          if (typeof providerConfig !== "undefined") {
            if (typeof providerConfig.state === "undefined" || typeof providerConfig.totpProviderConfig === "undefined" || typeof providerConfig.totpProviderConfig.adjacentIntervals !== "undefined" && typeof providerConfig.totpProviderConfig.adjacentIntervals !== "number") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
            }
            this.providerConfigs.push(providerConfig);
          }
        });
      }
      /** Converts MultiFactorConfig to JSON object
       * @returns The plain object representation of the multi-factor config instance. */
      toJSON() {
        return {
          state: this.state,
          factorIds: this.factorIds,
          providerConfigs: this.providerConfigs
        };
      }
    };
    exports.MultiFactorAuthConfig = MultiFactorAuthConfig;
    function validateTestPhoneNumbers(testPhoneNumbers) {
      if (!validator.isObject(testPhoneNumbers)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"testPhoneNumbers" must be a map of phone number / code pairs.');
      }
      if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);
      }
      for (const phoneNumber in testPhoneNumbers) {
        if (!validator.isPhoneNumber(phoneNumber)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${phoneNumber}" is not a valid E.164 standard compliant phone number.`);
        }
        if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${testPhoneNumbers[phoneNumber]}" is not a valid 6 digit code string.`);
        }
      }
    }
    __name(validateTestPhoneNumbers, "validateTestPhoneNumbers");
    var EmailSignInConfig = class _EmailSignInConfig {
      static {
        __name(this, "EmailSignInConfig");
      }
      /**
       * Static method to convert a client side request to a EmailSignInConfigServerRequest.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        const request3 = {};
        _EmailSignInConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "enabled")) {
          request3.allowPasswordSignup = options.enabled;
        }
        if (Object.prototype.hasOwnProperty.call(options, "passwordRequired")) {
          request3.enableEmailLinkSignin = !options.passwordRequired;
        }
        return request3;
      }
      /**
       * Validates the EmailSignInConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          enabled: true,
          passwordRequired: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid EmailSignInConfig parameter.`);
          }
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.enabled" must be a boolean.');
        }
        if (typeof options.passwordRequired !== "undefined" && !validator.isBoolean(options.passwordRequired)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.passwordRequired" must be a boolean.');
        }
      }
      /**
       * The EmailSignInConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     EmailSignInConfig object.
       * @constructor
       */
      constructor(response) {
        if (typeof response.allowPasswordSignup === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid email sign-in configuration response");
        }
        this.enabled = response.allowPasswordSignup;
        this.passwordRequired = !response.enableEmailLinkSignin;
      }
      /** @returns The plain object representation of the email sign-in config. */
      toJSON() {
        return {
          enabled: this.enabled,
          passwordRequired: this.passwordRequired
        };
      }
    };
    exports.EmailSignInConfig = EmailSignInConfig;
    var SAMLConfig = class _SAMLConfig {
      static {
        __name(this, "SAMLConfig");
      }
      /**
       * Converts a client side request to a SAMLConfigServerRequest which is the format
       * accepted by the backend server.
       * Throws an error if validation fails. If the request is not a SAMLConfig request,
       * returns null.
       *
       * @param options - The options object to convert to a server request.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       * @returns The resulting server request or null if not valid.
       */
      static buildServerRequest(options, ignoreMissingFields = false) {
        const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);
        if (!makeRequest) {
          return null;
        }
        const request3 = {};
        _SAMLConfig.validate(options, ignoreMissingFields);
        request3.enabled = options.enabled;
        request3.displayName = options.displayName;
        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {
          request3.idpConfig = {
            idpEntityId: options.idpEntityId,
            ssoUrl: options.ssoURL,
            signRequest: options.enableRequestSigning,
            idpCertificates: typeof options.x509Certificates === "undefined" ? void 0 : []
          };
          if (options.x509Certificates) {
            for (const cert2 of options.x509Certificates || []) {
              request3.idpConfig.idpCertificates.push({ x509Certificate: cert2 });
            }
          }
        }
        if (options.callbackURL || options.rpEntityId) {
          request3.spConfig = {
            spEntityId: options.rpEntityId,
            callbackUri: options.callbackURL
          };
        }
        return request3;
      }
      /**
       * Returns the provider ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name.
       * @returns The provider ID corresponding to the resource, null otherwise.
       */
      static getProviderIdFromResourceName(resourceName) {
        const matchProviderRes = resourceName.match(/\/inboundSamlConfigs\/(saml\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) {
          return null;
        }
        return matchProviderRes[1];
      }
      /**
       * @param providerId - The provider ID to check.
       * @returns Whether the provider ID corresponds to a SAML provider.
       */
      static isProviderId(providerId) {
        return validator.isNonEmptyString(providerId) && providerId.indexOf("saml.") === 0;
      }
      /**
       * Validates the SAMLConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       */
      static validate(options, ignoreMissingFields = false) {
        const validKeys = {
          enabled: true,
          displayName: true,
          providerId: true,
          idpEntityId: true,
          ssoURL: true,
          x509Certificates: true,
          rpEntityId: true,
          callbackURL: true,
          enableRequestSigning: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig" must be a valid non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SAML config parameter.`);
          }
        }
        if (validator.isNonEmptyString(options.providerId)) {
          if (options.providerId.indexOf("saml.") !== 0) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
          }
        } else if (!ignoreMissingFields) {
          throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
        }
        if (!(ignoreMissingFields && typeof options.idpEntityId === "undefined") && !validator.isNonEmptyString(options.idpEntityId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.idpEntityId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.ssoURL === "undefined") && !validator.isURL(options.ssoURL)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.ssoURL" must be a valid URL string.');
        }
        if (!(ignoreMissingFields && typeof options.rpEntityId === "undefined") && !validator.isNonEmptyString(options.rpEntityId)) {
          throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.rpEntityId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.callbackURL === "undefined") && !validator.isURL(options.callbackURL)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.callbackURL" must be a valid URL string.');
        }
        if (!(ignoreMissingFields && typeof options.x509Certificates === "undefined") && !validator.isArray(options.x509Certificates)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
        }
        (options.x509Certificates || []).forEach((cert2) => {
          if (!validator.isNonEmptyString(cert2)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
          }
        });
        if (typeof options.enableRequestSigning !== "undefined" && !validator.isBoolean(options.enableRequestSigning)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enableRequestSigning" must be a boolean.');
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enabled" must be a boolean.');
        }
        if (typeof options.displayName !== "undefined" && !validator.isString(options.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.displayName" must be a valid string.');
        }
      }
      /**
       * The SAMLConfig constructor.
       *
       * @param response - The server side response used to initialize the SAMLConfig object.
       * @constructor
       */
      constructor(response) {
        if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && _SAMLConfig.getProviderIdFromResourceName(response.name))) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        const providerId = _SAMLConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        this.providerId = providerId;
        this.rpEntityId = response.spConfig.spEntityId;
        this.callbackURL = response.spConfig.callbackUri;
        this.idpEntityId = response.idpConfig.idpEntityId;
        this.ssoURL = response.idpConfig.ssoUrl;
        this.enableRequestSigning = !!response.idpConfig.signRequest;
        const x509Certificates = [];
        for (const cert2 of response.idpConfig.idpCertificates || []) {
          if (cert2.x509Certificate) {
            x509Certificates.push(cert2.x509Certificate);
          }
        }
        this.x509Certificates = x509Certificates;
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
      }
      /** @returns The plain object representation of the SAMLConfig. */
      toJSON() {
        return {
          enabled: this.enabled,
          displayName: this.displayName,
          providerId: this.providerId,
          idpEntityId: this.idpEntityId,
          ssoURL: this.ssoURL,
          x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),
          rpEntityId: this.rpEntityId,
          callbackURL: this.callbackURL,
          enableRequestSigning: this.enableRequestSigning
        };
      }
    };
    exports.SAMLConfig = SAMLConfig;
    var OIDCConfig = class _OIDCConfig {
      static {
        __name(this, "OIDCConfig");
      }
      /**
       * Converts a client side request to a OIDCConfigServerRequest which is the format
       * accepted by the backend server.
       * Throws an error if validation fails. If the request is not a OIDCConfig request,
       * returns null.
       *
       * @param options - The options object to convert to a server request.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       * @returns The resulting server request or null if not valid.
       */
      static buildServerRequest(options, ignoreMissingFields = false) {
        const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);
        if (!makeRequest) {
          return null;
        }
        const request3 = {};
        _OIDCConfig.validate(options, ignoreMissingFields);
        request3.enabled = options.enabled;
        request3.displayName = options.displayName;
        request3.issuer = options.issuer;
        request3.clientId = options.clientId;
        if (typeof options.clientSecret !== "undefined") {
          request3.clientSecret = options.clientSecret;
        }
        if (typeof options.responseType !== "undefined") {
          request3.responseType = options.responseType;
        }
        return request3;
      }
      /**
       * Returns the provider ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name
       * @returns The provider ID corresponding to the resource, null otherwise.
       */
      static getProviderIdFromResourceName(resourceName) {
        const matchProviderRes = resourceName.match(/\/oauthIdpConfigs\/(oidc\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) {
          return null;
        }
        return matchProviderRes[1];
      }
      /**
       * @param providerId - The provider ID to check.
       * @returns Whether the provider ID corresponds to an OIDC provider.
       */
      static isProviderId(providerId) {
        return validator.isNonEmptyString(providerId) && providerId.indexOf("oidc.") === 0;
      }
      /**
       * Validates the OIDCConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       */
      static validate(options, ignoreMissingFields = false) {
        const validKeys = {
          enabled: true,
          displayName: true,
          providerId: true,
          clientId: true,
          issuer: true,
          clientSecret: true,
          responseType: true
        };
        const validResponseTypes = {
          idToken: true,
          code: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig" must be a valid non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OIDC config parameter.`);
          }
        }
        if (validator.isNonEmptyString(options.providerId)) {
          if (options.providerId.indexOf("oidc.") !== 0) {
            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
          }
        } else if (!ignoreMissingFields) {
          throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
        }
        if (!(ignoreMissingFields && typeof options.clientId === "undefined") && !validator.isNonEmptyString(options.clientId)) {
          throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '"OIDCAuthProviderConfig.clientId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.issuer === "undefined") && !validator.isURL(options.issuer)) {
          throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.issuer" must be a valid URL string.');
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.enabled" must be a boolean.');
        }
        if (typeof options.displayName !== "undefined" && !validator.isString(options.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.displayName" must be a valid string.');
        }
        if (typeof options.clientSecret !== "undefined" && !validator.isNonEmptyString(options.clientSecret)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.clientSecret" must be a valid string.');
        }
        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== "undefined") {
          Object.keys(options.responseType).forEach((key) => {
            if (!(key in validResponseTypes)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OAuthResponseType parameter.`);
            }
          });
          const idToken = options.responseType.idToken;
          if (typeof idToken !== "undefined" && !validator.isBoolean(idToken)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.idToken" must be a boolean.');
          }
          const code = options.responseType.code;
          if (typeof code !== "undefined") {
            if (!validator.isBoolean(code)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.code" must be a boolean.');
            }
            if (code && typeof options.clientSecret === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, "The OAuth configuration client secret is required to enable OIDC code flow.");
            }
          }
          const allKeys = Object.keys(options.responseType).length;
          const enabledCount = Object.values(options.responseType).filter(Boolean).length;
          if (allKeys > 1 && enabledCount !== 1) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, "Only exactly one OAuth responseType should be set to true.");
          }
        }
      }
      /**
       * The OIDCConfig constructor.
       *
       * @param response - The server side response used to initialize the OIDCConfig object.
       * @constructor
       */
      constructor(response) {
        if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && _OIDCConfig.getProviderIdFromResourceName(response.name))) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid OIDC configuration response");
        }
        const providerId = _OIDCConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        this.providerId = providerId;
        this.clientId = response.clientId;
        this.issuer = response.issuer;
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
        if (typeof response.clientSecret !== "undefined") {
          this.clientSecret = response.clientSecret;
        }
        if (typeof response.responseType !== "undefined") {
          this.responseType = response.responseType;
        }
      }
      /** @returns The plain object representation of the OIDCConfig. */
      toJSON() {
        return {
          enabled: this.enabled,
          displayName: this.displayName,
          providerId: this.providerId,
          issuer: this.issuer,
          clientId: this.clientId,
          clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),
          responseType: (0, deep_copy_1.deepCopy)(this.responseType)
        };
      }
    };
    exports.OIDCConfig = OIDCConfig;
    var SmsRegionsAuthConfig = class {
      static {
        __name(this, "SmsRegionsAuthConfig");
      }
      static validate(options) {
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig" must be a non-null object.');
        }
        const validKeys = {
          allowlistOnly: true,
          allowByDefault: true
        };
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig parameter.`);
          }
        }
        if (typeof options.allowByDefault !== "undefined" && typeof options.allowlistOnly !== "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both "allowByDefault" and "allowlistOnly" parameters.');
        }
        if (typeof options.allowByDefault !== "undefined") {
          const allowByDefaultValidKeys = {
            disallowedRegions: true
          };
          for (const key in options.allowByDefault) {
            if (!(key in allowByDefaultValidKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowByDefault parameter.`);
            }
          }
          if (typeof options.allowByDefault.disallowedRegions !== "undefined" && !validator.isArray(options.allowByDefault.disallowedRegions)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowByDefault.disallowedRegions" must be a valid string array.');
          }
        }
        if (typeof options.allowlistOnly !== "undefined") {
          const allowListOnlyValidKeys = {
            allowedRegions: true
          };
          for (const key in options.allowlistOnly) {
            if (!(key in allowListOnlyValidKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowlistOnly parameter.`);
            }
          }
          if (typeof options.allowlistOnly.allowedRegions !== "undefined" && !validator.isArray(options.allowlistOnly.allowedRegions)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowlistOnly.allowedRegions" must be a valid string array.');
          }
        }
      }
    };
    exports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;
    var RecaptchaAuthConfig = class _RecaptchaAuthConfig {
      static {
        __name(this, "RecaptchaAuthConfig");
      }
      /**
       * The RecaptchaAuthConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     RecaptchaAuthConfig object.
       * @constructor
       * @internal
       */
      constructor(response) {
        const filteredResponse = Object.fromEntries(Object.entries(response).filter(([, value]) => value !== void 0));
        if (filteredResponse.tollFraudManagedRules !== void 0) {
          this.smsTollFraudManagedRules = filteredResponse.tollFraudManagedRules;
          delete filteredResponse.tollFraudManagedRules;
        }
        Object.assign(this, filteredResponse);
      }
      /**
       * Builds a server request object from the client-side RecaptchaConfig.
       * Converts client-side fields to their server-side equivalents.
       *
       * @param options - The client-side RecaptchaConfig object.
       * @returns The server-side RecaptchaAuthServerConfig object.
       */
      static buildServerRequest(options) {
        _RecaptchaAuthConfig.validate(options);
        const request3 = {};
        if (typeof options.emailPasswordEnforcementState !== "undefined") {
          request3.emailPasswordEnforcementState = options.emailPasswordEnforcementState;
        }
        if (typeof options.phoneEnforcementState !== "undefined") {
          request3.phoneEnforcementState = options.phoneEnforcementState;
        }
        if (typeof options.managedRules !== "undefined") {
          request3.managedRules = options.managedRules;
        }
        if (typeof options.recaptchaKeys !== "undefined") {
          request3.recaptchaKeys = options.recaptchaKeys;
        }
        if (typeof options.useAccountDefender !== "undefined") {
          request3.useAccountDefender = options.useAccountDefender;
        }
        if (typeof options.useSmsBotScore !== "undefined") {
          request3.useSmsBotScore = options.useSmsBotScore;
        }
        if (typeof options.useSmsTollFraudProtection !== "undefined") {
          request3.useSmsTollFraudProtection = options.useSmsTollFraudProtection;
        }
        if (typeof options.smsTollFraudManagedRules !== "undefined") {
          request3.tollFraudManagedRules = options.smsTollFraudManagedRules;
        }
        return request3;
      }
      /**
       * Validates the RecaptchaConfig options object. Throws an error on failure.
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          emailPasswordEnforcementState: true,
          phoneEnforcementState: true,
          managedRules: true,
          recaptchaKeys: true,
          useAccountDefender: true,
          useSmsBotScore: true,
          useSmsTollFraudProtection: true,
          smsTollFraudManagedRules: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaConfig parameter.`);
          }
        }
        if (typeof options.emailPasswordEnforcementState !== "undefined") {
          if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.emailPasswordEnforcementState" must be a valid non-empty string.');
          }
          if (options.emailPasswordEnforcementState !== "OFF" && options.emailPasswordEnforcementState !== "AUDIT" && options.emailPasswordEnforcementState !== "ENFORCE") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.emailPasswordEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
          }
        }
        if (typeof options.phoneEnforcementState !== "undefined") {
          if (!validator.isNonEmptyString(options.phoneEnforcementState)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.phoneEnforcementState" must be a valid non-empty string.');
          }
          if (options.phoneEnforcementState !== "OFF" && options.phoneEnforcementState !== "AUDIT" && options.phoneEnforcementState !== "ENFORCE") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.phoneEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
          }
        }
        if (typeof options.managedRules !== "undefined") {
          if (!validator.isArray(options.managedRules)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.managedRules" must be an array of valid "RecaptchaManagedRule".');
          }
          options.managedRules.forEach((managedRule) => {
            _RecaptchaAuthConfig.validateManagedRule(managedRule);
          });
        }
        if (typeof options.useAccountDefender !== "undefined") {
          if (!validator.isBoolean(options.useAccountDefender)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useAccountDefender" must be a boolean value".');
          }
        }
        if (typeof options.useSmsBotScore !== "undefined") {
          if (!validator.isBoolean(options.useSmsBotScore)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsBotScore" must be a boolean value".');
          }
        }
        if (typeof options.useSmsTollFraudProtection !== "undefined") {
          if (!validator.isBoolean(options.useSmsTollFraudProtection)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useSmsTollFraudProtection" must be a boolean value".');
          }
        }
        if (typeof options.smsTollFraudManagedRules !== "undefined") {
          if (!validator.isArray(options.smsTollFraudManagedRules)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.smsTollFraudManagedRules" must be an array of valid "RecaptchaTollFraudManagedRule".');
          }
          options.smsTollFraudManagedRules.forEach((tollFraudManagedRule) => {
            _RecaptchaAuthConfig.validateTollFraudManagedRule(tollFraudManagedRule);
          });
        }
      }
      /**
       * Validate each element in ManagedRule array
       * @param options - The options object to validate.
       */
      static validateManagedRule(options) {
        const validKeys = {
          endScore: true,
          action: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaManagedRule parameter.`);
          }
        }
        if (typeof options.action !== "undefined" && options.action !== "BLOCK") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule.action" must be "BLOCK".');
        }
      }
      /**
       * Validate each element in TollFraudManagedRule array
       * @param options - The options object to validate.
       */
      static validateTollFraudManagedRule(options) {
        const validKeys = {
          startScore: true,
          action: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaTollFraudManagedRule parameter.`);
          }
        }
        if (typeof options.action !== "undefined" && options.action !== "BLOCK") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaTollFraudManagedRule.action" must be "BLOCK".');
        }
      }
    };
    exports.RecaptchaAuthConfig = RecaptchaAuthConfig;
    var PasswordPolicyAuthConfig = class _PasswordPolicyAuthConfig {
      static {
        __name(this, "PasswordPolicyAuthConfig");
      }
      /**
       * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        const request3 = {};
        _PasswordPolicyAuthConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "enforcementState")) {
          request3.passwordPolicyEnforcementState = options.enforcementState;
        }
        request3.forceUpgradeOnSignin = false;
        if (Object.prototype.hasOwnProperty.call(options, "forceUpgradeOnSignin")) {
          request3.forceUpgradeOnSignin = options.forceUpgradeOnSignin;
        }
        const constraintsRequest = {
          containsUppercaseCharacter: false,
          containsLowercaseCharacter: false,
          containsNonAlphanumericCharacter: false,
          containsNumericCharacter: false,
          minPasswordLength: 6,
          maxPasswordLength: 4096
        };
        request3.passwordPolicyVersions = [];
        if (Object.prototype.hasOwnProperty.call(options, "constraints")) {
          if (options) {
            if (options.constraints?.requireUppercase !== void 0) {
              constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;
            }
            if (options.constraints?.requireLowercase !== void 0) {
              constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;
            }
            if (options.constraints?.requireNonAlphanumeric !== void 0) {
              constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;
            }
            if (options.constraints?.requireNumeric !== void 0) {
              constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;
            }
            if (options.constraints?.minLength !== void 0) {
              constraintsRequest.minPasswordLength = options.constraints.minLength;
            }
            if (options.constraints?.maxLength !== void 0) {
              constraintsRequest.maxPasswordLength = options.constraints.maxLength;
            }
          }
        }
        request3.passwordPolicyVersions.push({ customStrengthOptions: constraintsRequest });
        return request3;
      }
      /**
       * Validates the PasswordPolicyConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @internal
       */
      static validate(options) {
        const validKeys = {
          enforcementState: true,
          forceUpgradeOnSignin: true,
          constraints: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig parameter.`);
          }
        }
        if (typeof options.enforcementState === "undefined" || !(options.enforcementState === "ENFORCE" || options.enforcementState === "OFF")) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.enforcementState" must be either "ENFORCE" or "OFF".');
        }
        if (typeof options.forceUpgradeOnSignin !== "undefined") {
          if (!validator.isBoolean(options.forceUpgradeOnSignin)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.forceUpgradeOnSignin" must be a boolean.');
          }
        }
        if (typeof options.constraints !== "undefined") {
          if (options.enforcementState === "ENFORCE" && !validator.isNonNullObject(options.constraints)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be a non-empty object.');
          }
          const validCharKeys = {
            requireUppercase: true,
            requireLowercase: true,
            requireNumeric: true,
            requireNonAlphanumeric: true,
            minLength: true,
            maxLength: true
          };
          for (const key in options.constraints) {
            if (!(key in validCharKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig.constraints parameter.`);
            }
          }
          if (typeof options.constraints.requireUppercase !== "undefined" && !validator.isBoolean(options.constraints.requireUppercase)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireUppercase" must be a boolean.');
          }
          if (typeof options.constraints.requireLowercase !== "undefined" && !validator.isBoolean(options.constraints.requireLowercase)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireLowercase" must be a boolean.');
          }
          if (typeof options.constraints.requireNonAlphanumeric !== "undefined" && !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNonAlphanumeric" must be a boolean.');
          }
          if (typeof options.constraints.requireNumeric !== "undefined" && !validator.isBoolean(options.constraints.requireNumeric)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNumeric" must be a boolean.');
          }
          if (typeof options.constraints.minLength === "undefined") {
            options.constraints.minLength = 6;
          } else if (!validator.isNumber(options.constraints.minLength)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be a number.');
          } else {
            if (!(options.constraints.minLength >= 6 && options.constraints.minLength <= 30)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be an integer between 6 and 30, inclusive.');
            }
          }
          if (typeof options.constraints.maxLength === "undefined") {
            options.constraints.maxLength = 4096;
          } else if (!validator.isNumber(options.constraints.maxLength)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be a number.');
          } else {
            if (!(options.constraints.maxLength >= options.constraints.minLength && options.constraints.maxLength <= 4096)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be greater than or equal to minLength and at max 4096.');
            }
          }
        } else {
          if (options.enforcementState === "ENFORCE") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be defined.');
          }
        }
      }
      /**
       * The PasswordPolicyAuthConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     PasswordPolicyAuthConfig object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.passwordPolicyEnforcementState === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid password policy configuration response");
        }
        this.enforcementState = response.passwordPolicyEnforcementState;
        let constraintsResponse = {};
        if (typeof response.passwordPolicyVersions !== "undefined") {
          (response.passwordPolicyVersions || []).forEach((policyVersion) => {
            constraintsResponse = {
              requireLowercase: policyVersion.customStrengthOptions?.containsLowercaseCharacter,
              requireUppercase: policyVersion.customStrengthOptions?.containsUppercaseCharacter,
              requireNonAlphanumeric: policyVersion.customStrengthOptions?.containsNonAlphanumericCharacter,
              requireNumeric: policyVersion.customStrengthOptions?.containsNumericCharacter,
              minLength: policyVersion.customStrengthOptions?.minPasswordLength,
              maxLength: policyVersion.customStrengthOptions?.maxPasswordLength
            };
          });
        }
        this.constraints = constraintsResponse;
        this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;
      }
    };
    exports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;
    var EmailPrivacyAuthConfig = class {
      static {
        __name(this, "EmailPrivacyAuthConfig");
      }
      static validate(options) {
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig" must be a non-null object.');
        }
        const validKeys = {
          enableImprovedEmailPrivacy: true
        };
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid "EmailPrivacyConfig" parameter.`);
          }
        }
        if (typeof options.enableImprovedEmailPrivacy !== "undefined" && !validator.isBoolean(options.enableImprovedEmailPrivacy)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig.enableImprovedEmailPrivacy" must be a valid boolean value.');
        }
      }
    };
    exports.EmailPrivacyAuthConfig = EmailPrivacyAuthConfig;
  }
});

// node_modules/firebase-admin/lib/auth/tenant.js
var require_tenant = __commonJS({
  "node_modules/firebase-admin/lib/auth/tenant.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tenant = void 0;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var auth_config_1 = require_auth_config();
    var Tenant2 = class _Tenant {
      static {
        __name(this, "Tenant");
      }
      /**
       * Builds the corresponding server request for a TenantOptions object.
       *
       * @param tenantOptions - The properties to convert to a server request.
       * @param createRequest - Whether this is a create request.
       * @returns The equivalent server request.
       *
       * @internal
       */
      static buildServerRequest(tenantOptions, createRequest) {
        _Tenant.validate(tenantOptions, createRequest);
        let request3 = {};
        if (typeof tenantOptions.emailSignInConfig !== "undefined") {
          request3 = auth_config_1.EmailSignInConfig.buildServerRequest(tenantOptions.emailSignInConfig);
        }
        if (typeof tenantOptions.displayName !== "undefined") {
          request3.displayName = tenantOptions.displayName;
        }
        if (typeof tenantOptions.anonymousSignInEnabled !== "undefined") {
          request3.enableAnonymousUser = tenantOptions.anonymousSignInEnabled;
        }
        if (typeof tenantOptions.multiFactorConfig !== "undefined") {
          request3.mfaConfig = auth_config_1.MultiFactorAuthConfig.buildServerRequest(tenantOptions.multiFactorConfig);
        }
        if (typeof tenantOptions.testPhoneNumbers !== "undefined") {
          request3.testPhoneNumbers = tenantOptions.testPhoneNumbers ?? {};
        }
        if (typeof tenantOptions.smsRegionConfig !== "undefined") {
          request3.smsRegionConfig = tenantOptions.smsRegionConfig;
        }
        if (typeof tenantOptions.recaptchaConfig !== "undefined") {
          request3.recaptchaConfig = auth_config_1.RecaptchaAuthConfig.buildServerRequest(tenantOptions.recaptchaConfig);
        }
        if (typeof tenantOptions.passwordPolicyConfig !== "undefined") {
          request3.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(tenantOptions.passwordPolicyConfig);
        }
        if (typeof tenantOptions.emailPrivacyConfig !== "undefined") {
          request3.emailPrivacyConfig = tenantOptions.emailPrivacyConfig;
        }
        return request3;
      }
      /**
       * Returns the tenant ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name
       * @returns The tenant ID corresponding to the resource, null otherwise.
       *
       * @internal
       */
      static getTenantIdFromResourceName(resourceName) {
        const matchTenantRes = resourceName.match(/\/tenants\/(.*)$/);
        if (!matchTenantRes || matchTenantRes.length < 2) {
          return null;
        }
        return matchTenantRes[1];
      }
      /**
       * Validates a tenant options object. Throws an error on failure.
       *
       * @param request - The tenant options object to validate.
       * @param createRequest - Whether this is a create request.
       */
      static validate(request3, createRequest) {
        const validKeys = {
          displayName: true,
          emailSignInConfig: true,
          anonymousSignInEnabled: true,
          multiFactorConfig: true,
          testPhoneNumbers: true,
          smsRegionConfig: true,
          recaptchaConfig: true,
          passwordPolicyConfig: true,
          emailPrivacyConfig: true
        };
        const label = createRequest ? "CreateTenantRequest" : "UpdateTenantRequest";
        if (!validator.isNonNullObject(request3)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}" must be a valid non-null object.`);
        }
        for (const key in request3) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid ${label} parameter.`);
          }
        }
        if (typeof request3.displayName !== "undefined" && !validator.isNonEmptyString(request3.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.displayName" must be a valid non-empty string.`);
        }
        if (typeof request3.emailSignInConfig !== "undefined") {
          auth_config_1.EmailSignInConfig.buildServerRequest(request3.emailSignInConfig);
        }
        if (typeof request3.testPhoneNumbers !== "undefined" && request3.testPhoneNumbers !== null) {
          (0, auth_config_1.validateTestPhoneNumbers)(request3.testPhoneNumbers);
        } else if (request3.testPhoneNumbers === null && createRequest) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.testPhoneNumbers" must be a non-null object.`);
        }
        if (typeof request3.multiFactorConfig !== "undefined") {
          auth_config_1.MultiFactorAuthConfig.buildServerRequest(request3.multiFactorConfig);
        }
        if (typeof request3.smsRegionConfig !== "undefined") {
          auth_config_1.SmsRegionsAuthConfig.validate(request3.smsRegionConfig);
        }
        if (typeof request3.recaptchaConfig !== "undefined") {
          auth_config_1.RecaptchaAuthConfig.buildServerRequest(request3.recaptchaConfig);
        }
        if (typeof request3.passwordPolicyConfig !== "undefined") {
          auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(request3.passwordPolicyConfig);
        }
        if (typeof request3.emailPrivacyConfig !== "undefined") {
          auth_config_1.EmailPrivacyAuthConfig.validate(request3.emailPrivacyConfig);
        }
      }
      /**
       * The Tenant object constructor.
       *
       * @param response - The server side response used to initialize the Tenant object.
       * @constructor
       * @internal
       */
      constructor(response) {
        const tenantId = _Tenant.getTenantIdFromResourceName(response.name);
        if (!tenantId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid tenant response");
        }
        this.tenantId = tenantId;
        this.displayName = response.displayName;
        try {
          this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig(response);
        } catch (e) {
          this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig({
            allowPasswordSignup: false
          });
        }
        this.anonymousSignInEnabled = !!response.enableAnonymousUser;
        if (typeof response.mfaConfig !== "undefined") {
          this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfaConfig);
        }
        if (typeof response.testPhoneNumbers !== "undefined") {
          this.testPhoneNumbers = (0, deep_copy_1.deepCopy)(response.testPhoneNumbers || {});
        }
        if (typeof response.smsRegionConfig !== "undefined") {
          this.smsRegionConfig = (0, deep_copy_1.deepCopy)(response.smsRegionConfig);
        }
        if (typeof response.recaptchaConfig !== "undefined") {
          this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
        }
        if (typeof response.passwordPolicyConfig !== "undefined") {
          this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
        }
        if (typeof response.emailPrivacyConfig !== "undefined") {
          this.emailPrivacyConfig = (0, deep_copy_1.deepCopy)(response.emailPrivacyConfig);
        }
      }
      /**
       * The email sign in provider configuration.
       */
      get emailSignInConfig() {
        return this.emailSignInConfig_;
      }
      /**
       * The multi-factor auth configuration on the current tenant.
       */
      get multiFactorConfig() {
        return this.multiFactorConfig_;
      }
      /**
       * The recaptcha config auth configuration of the current tenant.
       */
      get recaptchaConfig() {
        return this.recaptchaConfig_;
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        const json = {
          tenantId: this.tenantId,
          displayName: this.displayName,
          emailSignInConfig: this.emailSignInConfig_?.toJSON(),
          multiFactorConfig: this.multiFactorConfig_?.toJSON(),
          anonymousSignInEnabled: this.anonymousSignInEnabled,
          testPhoneNumbers: this.testPhoneNumbers,
          smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
          recaptchaConfig: (0, deep_copy_1.deepCopy)(this.recaptchaConfig),
          passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
          emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig)
        };
        if (typeof json.multiFactorConfig === "undefined") {
          delete json.multiFactorConfig;
        }
        if (typeof json.testPhoneNumbers === "undefined") {
          delete json.testPhoneNumbers;
        }
        if (typeof json.smsRegionConfig === "undefined") {
          delete json.smsRegionConfig;
        }
        if (typeof json.recaptchaConfig === "undefined") {
          delete json.recaptchaConfig;
        }
        if (typeof json.passwordPolicyConfig === "undefined") {
          delete json.passwordPolicyConfig;
        }
        if (typeof json.emailPrivacyConfig === "undefined") {
          delete json.emailPrivacyConfig;
        }
        return json;
      }
    };
    exports.Tenant = Tenant2;
  }
});

// node_modules/firebase-admin/lib/auth/identifier.js
var require_identifier = __commonJS({
  "node_modules/firebase-admin/lib/auth/identifier.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isUidIdentifier = isUidIdentifier;
    exports.isEmailIdentifier = isEmailIdentifier;
    exports.isPhoneIdentifier = isPhoneIdentifier;
    exports.isProviderIdentifier = isProviderIdentifier;
    function isUidIdentifier(id) {
      return id.uid !== void 0;
    }
    __name(isUidIdentifier, "isUidIdentifier");
    function isEmailIdentifier(id) {
      return id.email !== void 0;
    }
    __name(isEmailIdentifier, "isEmailIdentifier");
    function isPhoneIdentifier(id) {
      return id.phoneNumber !== void 0;
    }
    __name(isPhoneIdentifier, "isPhoneIdentifier");
    function isProviderIdentifier(id) {
      const pid2 = id;
      return pid2.providerId !== void 0 && pid2.providerUid !== void 0;
    }
    __name(isProviderIdentifier, "isProviderIdentifier");
  }
});

// node_modules/firebase-admin/lib/auth/project-config.js
var require_project_config = __commonJS({
  "node_modules/firebase-admin/lib/auth/project-config.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectConfig = void 0;
    var validator = require_validator();
    var error_1 = require_error();
    var auth_config_1 = require_auth_config();
    var deep_copy_1 = require_deep_copy();
    var ProjectConfig2 = class _ProjectConfig {
      static {
        __name(this, "ProjectConfig");
      }
      /**
       * The multi-factor auth configuration.
       */
      get multiFactorConfig() {
        return this.multiFactorConfig_;
      }
      /**
       * The reCAPTCHA configuration.
       */
      get recaptchaConfig() {
        return this.recaptchaConfig_;
      }
      /**
       * Validates a project config options object. Throws an error on failure.
       *
       * @param request - The project config options object to validate.
       */
      static validate(request3) {
        if (!validator.isNonNullObject(request3)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UpdateProjectConfigRequest" must be a valid non-null object.');
        }
        const validKeys = {
          smsRegionConfig: true,
          multiFactorConfig: true,
          recaptchaConfig: true,
          passwordPolicyConfig: true,
          emailPrivacyConfig: true
        };
        for (const key in request3) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid UpdateProjectConfigRequest parameter.`);
          }
        }
        if (typeof request3.smsRegionConfig !== "undefined") {
          auth_config_1.SmsRegionsAuthConfig.validate(request3.smsRegionConfig);
        }
        if (typeof request3.multiFactorConfig !== "undefined") {
          auth_config_1.MultiFactorAuthConfig.validate(request3.multiFactorConfig);
        }
        if (typeof request3.recaptchaConfig !== "undefined") {
          auth_config_1.RecaptchaAuthConfig.validate(request3.recaptchaConfig);
        }
        if (typeof request3.passwordPolicyConfig !== "undefined") {
          auth_config_1.PasswordPolicyAuthConfig.validate(request3.passwordPolicyConfig);
        }
        if (typeof request3.emailPrivacyConfig !== "undefined") {
          auth_config_1.EmailPrivacyAuthConfig.validate(request3.emailPrivacyConfig);
        }
      }
      /**
       * Build the corresponding server request for a UpdateProjectConfigRequest object.
       * @param configOptions - The properties to convert to a server request.
       * @returns  The equivalent server request.
       *
       * @internal
       */
      static buildServerRequest(configOptions) {
        _ProjectConfig.validate(configOptions);
        const request3 = {};
        if (typeof configOptions.smsRegionConfig !== "undefined") {
          request3.smsRegionConfig = configOptions.smsRegionConfig;
        }
        if (typeof configOptions.multiFactorConfig !== "undefined") {
          request3.mfa = auth_config_1.MultiFactorAuthConfig.buildServerRequest(configOptions.multiFactorConfig);
        }
        if (typeof configOptions.recaptchaConfig !== "undefined") {
          request3.recaptchaConfig = auth_config_1.RecaptchaAuthConfig.buildServerRequest(configOptions.recaptchaConfig);
        }
        if (typeof configOptions.passwordPolicyConfig !== "undefined") {
          request3.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(configOptions.passwordPolicyConfig);
        }
        if (typeof configOptions.emailPrivacyConfig !== "undefined") {
          request3.emailPrivacyConfig = configOptions.emailPrivacyConfig;
        }
        return request3;
      }
      /**
       * The Project Config object constructor.
       *
       * @param response - The server side response used to initialize the Project Config object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.smsRegionConfig !== "undefined") {
          this.smsRegionConfig = response.smsRegionConfig;
        }
        if (typeof response.mfa !== "undefined") {
          this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfa);
        }
        if (typeof response.recaptchaConfig !== "undefined") {
          this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
        }
        if (typeof response.passwordPolicyConfig !== "undefined") {
          this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
        }
        if (typeof response.emailPrivacyConfig !== "undefined") {
          this.emailPrivacyConfig = response.emailPrivacyConfig;
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        const json = {
          smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
          multiFactorConfig: (0, deep_copy_1.deepCopy)(this.multiFactorConfig),
          recaptchaConfig: (0, deep_copy_1.deepCopy)(this.recaptchaConfig),
          passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
          emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig)
        };
        if (typeof json.smsRegionConfig === "undefined") {
          delete json.smsRegionConfig;
        }
        if (typeof json.multiFactorConfig === "undefined") {
          delete json.multiFactorConfig;
        }
        if (typeof json.recaptchaConfig === "undefined") {
          delete json.recaptchaConfig;
        }
        if (typeof json.passwordPolicyConfig === "undefined") {
          delete json.passwordPolicyConfig;
        }
        if (typeof json.emailPrivacyConfig === "undefined") {
          delete json.emailPrivacyConfig;
        }
        return json;
      }
    };
    exports.ProjectConfig = ProjectConfig2;
  }
});

// node_modules/firebase-admin/lib/auth/auth-api-request.js
var require_auth_api_request = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth-api-request.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;
    exports.useEmulator = useEmulator;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var api_request_1 = require_api_request();
    var utils = require_utils();
    var user_import_builder_1 = require_user_import_builder();
    var action_code_settings_builder_1 = require_action_code_settings_builder();
    var tenant_1 = require_tenant();
    var identifier_1 = require_identifier();
    var auth_config_1 = require_auth_config();
    var project_config_1 = require_project_config();
    var FIREBASE_AUTH_HEADERS = {
      "X-Client-Version": `Node/Admin/${utils.getSdkVersion()}`
    };
    var FIREBASE_AUTH_TIMEOUT = 25e3;
    exports.RESERVED_CLAIMS = [
      "acr",
      "amr",
      "at_hash",
      "aud",
      "auth_time",
      "azp",
      "cnf",
      "c_hash",
      "exp",
      "iat",
      "iss",
      "jti",
      "nbf",
      "nonce",
      "sub",
      "firebase"
    ];
    exports.EMAIL_ACTION_REQUEST_TYPES = [
      "PASSWORD_RESET",
      "VERIFY_EMAIL",
      "EMAIL_SIGNIN",
      "VERIFY_AND_CHANGE_EMAIL"
    ];
    var MAX_CLAIMS_PAYLOAD_SIZE = 1e3;
    var MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1e3;
    var MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1e3;
    var MAX_GET_ACCOUNTS_BATCH_SIZE = 100;
    var MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1e3;
    var MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;
    var MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;
    var MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;
    var FIREBASE_AUTH_BASE_URL_FORMAT = "https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}";
    var FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = "http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}";
    var FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}");
    var FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}");
    var MAX_LIST_TENANT_PAGE_SIZE = 1e3;
    var WriteOperationType;
    (function(WriteOperationType2) {
      WriteOperationType2["Create"] = "create";
      WriteOperationType2["Update"] = "update";
      WriteOperationType2["Upload"] = "upload";
    })(WriteOperationType || (WriteOperationType = {}));
    var AuthResourceUrlBuilder = class {
      static {
        __name(this, "AuthResourceUrlBuilder");
      }
      /**
       * The resource URL builder constructor.
       *
       * @param projectId - The resource project ID.
       * @param version - The endpoint API version.
       * @constructor
       */
      constructor(app, version3 = "v1") {
        this.app = app;
        this.version = version3;
        if (useEmulator()) {
          this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {
            host: emulatorHost()
          });
        } else {
          this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;
        }
      }
      /**
       * Returns the resource URL corresponding to the provided parameters.
       *
       * @param api - The backend API name.
       * @param params - The optional additional parameters to substitute in the
       *     URL path.
       * @returns The corresponding resource URL.
       */
      getUrl(api, params) {
        return this.getProjectId().then((projectId) => {
          const baseParams = {
            version: this.version,
            projectId,
            api: api || ""
          };
          const baseUrl = utils.formatString(this.urlFormat, baseParams);
          return utils.formatString(baseUrl, params || {});
        });
      }
      getProjectId() {
        if (this.projectId) {
          return Promise.resolve(this.projectId);
        }
        return utils.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, "Failed to determine project ID for Auth. Initialize the SDK with service account credentials or set project ID as an app option. Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.");
          }
          this.projectId = projectId;
          return projectId;
        });
      }
    };
    var TenantAwareAuthResourceUrlBuilder = class extends AuthResourceUrlBuilder {
      static {
        __name(this, "TenantAwareAuthResourceUrlBuilder");
      }
      /**
       * The tenant aware resource URL builder constructor.
       *
       * @param projectId - The resource project ID.
       * @param version - The endpoint API version.
       * @param tenantId - The tenant ID.
       * @constructor
       */
      constructor(app, version3, tenantId) {
        super(app, version3);
        this.app = app;
        this.version = version3;
        this.tenantId = tenantId;
        if (useEmulator()) {
          this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {
            host: emulatorHost()
          });
        } else {
          this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;
        }
      }
      /**
       * Returns the resource URL corresponding to the provided parameters.
       *
       * @param api - The backend API name.
       * @param params - The optional additional parameters to substitute in the
       *     URL path.
       * @returns The corresponding resource URL.
       */
      getUrl(api, params) {
        return super.getUrl(api, params).then((url) => {
          return utils.formatString(url, { tenantId: this.tenantId });
        });
      }
    };
    var AuthHttpClient = class extends api_request_1.AuthorizedHttpClient {
      static {
        __name(this, "AuthHttpClient");
      }
      getToken() {
        if (useEmulator()) {
          return Promise.resolve("owner");
        }
        return super.getToken();
      }
    };
    function validateAuthFactorInfo(request3) {
      const validKeys = {
        mfaEnrollmentId: true,
        displayName: true,
        phoneInfo: true,
        enrolledAt: true
      };
      for (const key in request3) {
        if (!(key in validKeys)) {
          delete request3[key];
        }
      }
      const authFactorInfoIdentifier = request3.mfaEnrollmentId || request3.phoneInfo || JSON.stringify(request3);
      if (typeof request3.mfaEnrollmentId !== "undefined" && !validator.isNonEmptyString(request3.mfaEnrollmentId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor "uid" must be a valid non-empty string.');
      }
      if (typeof request3.displayName !== "undefined" && !validator.isString(request3.displayName)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor "displayName" for "${authFactorInfoIdentifier}" must be a valid string.`);
      }
      if (typeof request3.enrolledAt !== "undefined" && !validator.isISODateString(request3.enrolledAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${authFactorInfoIdentifier}" must be a valid UTC date string.`);
      }
      if (typeof request3.phoneInfo !== "undefined") {
        if (!validator.isPhoneNumber(request3.phoneInfo)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor "phoneNumber" for "${authFactorInfoIdentifier}" must be a non-empty E.164 standard compliant identifier string.`);
        }
      } else {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, "MFAInfo object provided is invalid.");
      }
    }
    __name(validateAuthFactorInfo, "validateAuthFactorInfo");
    function validateProviderUserInfo(request3) {
      const validKeys = {
        rawId: true,
        providerId: true,
        email: true,
        displayName: true,
        photoUrl: true
      };
      for (const key in request3) {
        if (!(key in validKeys)) {
          delete request3[key];
        }
      }
      if (!validator.isNonEmptyString(request3.providerId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
      }
      if (typeof request3.displayName !== "undefined" && typeof request3.displayName !== "string") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider "displayName" for "${request3.providerId}" must be a valid string.`);
      }
      if (!validator.isNonEmptyString(request3.rawId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, `The provider "uid" for "${request3.providerId}" must be a valid non-empty string.`);
      }
      if (typeof request3.email !== "undefined" && !validator.isEmail(request3.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, `The provider "email" for "${request3.providerId}" must be a valid email string.`);
      }
      if (typeof request3.photoUrl !== "undefined" && !validator.isURL(request3.photoUrl)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider "photoURL" for "${request3.providerId}" must be a valid URL string.`);
      }
    }
    __name(validateProviderUserInfo, "validateProviderUserInfo");
    function validateCreateEditRequest(request3, writeOperationType) {
      const uploadAccountRequest = writeOperationType === WriteOperationType.Upload;
      const validKeys = {
        displayName: true,
        localId: true,
        email: true,
        password: true,
        rawPassword: true,
        emailVerified: true,
        photoUrl: true,
        disabled: true,
        disableUser: true,
        deleteAttribute: true,
        deleteProvider: true,
        sanityCheck: true,
        phoneNumber: true,
        customAttributes: true,
        validSince: true,
        // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)
        linkProviderUserInfo: !uploadAccountRequest,
        // Pass tenantId only for uploadAccount requests.
        tenantId: uploadAccountRequest,
        passwordHash: uploadAccountRequest,
        salt: uploadAccountRequest,
        createdAt: uploadAccountRequest,
        lastLoginAt: uploadAccountRequest,
        providerUserInfo: uploadAccountRequest,
        mfaInfo: uploadAccountRequest,
        // Only for non-uploadAccount requests.
        mfa: !uploadAccountRequest
      };
      for (const key in request3) {
        if (!(key in validKeys)) {
          delete request3[key];
        }
      }
      if (typeof request3.tenantId !== "undefined" && !validator.isNonEmptyString(request3.tenantId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
      }
      if (typeof request3.displayName !== "undefined" && !validator.isString(request3.displayName)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);
      }
      if ((typeof request3.localId !== "undefined" || uploadAccountRequest) && !validator.isUid(request3.localId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
      }
      if (typeof request3.email !== "undefined" && !validator.isEmail(request3.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
      }
      if (typeof request3.phoneNumber !== "undefined" && !validator.isPhoneNumber(request3.phoneNumber)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
      }
      if (typeof request3.password !== "undefined" && !validator.isPassword(request3.password)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
      }
      if (typeof request3.rawPassword !== "undefined" && !validator.isPassword(request3.rawPassword)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
      }
      if (typeof request3.emailVerified !== "undefined" && typeof request3.emailVerified !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);
      }
      if (typeof request3.photoUrl !== "undefined" && !validator.isURL(request3.photoUrl)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);
      }
      if (typeof request3.disabled !== "undefined" && typeof request3.disabled !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
      }
      if (typeof request3.validSince !== "undefined" && !validator.isNumber(request3.validSince)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);
      }
      if (typeof request3.createdAt !== "undefined" && !validator.isNumber(request3.createdAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);
      }
      if (typeof request3.lastLoginAt !== "undefined" && !validator.isNumber(request3.lastLoginAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);
      }
      if (typeof request3.disableUser !== "undefined" && typeof request3.disableUser !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
      }
      if (typeof request3.customAttributes !== "undefined") {
        let developerClaims;
        try {
          developerClaims = JSON.parse(request3.customAttributes);
        } catch (error3) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error3.message);
        }
        const invalidClaims = [];
        exports.RESERVED_CLAIMS.forEach((blacklistedClaim) => {
          if (Object.prototype.hasOwnProperty.call(developerClaims, blacklistedClaim)) {
            invalidClaims.push(blacklistedClaim);
          }
        });
        if (invalidClaims.length > 0) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims.length > 1 ? `Developer claims "${invalidClaims.join('", "')}" are reserved and cannot be specified.` : `Developer claim "${invalidClaims[0]}" is reserved and cannot be specified.`);
        }
        if (request3.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${MAX_CLAIMS_PAYLOAD_SIZE} characters.`);
        }
      }
      if (typeof request3.passwordHash !== "undefined" && !validator.isString(request3.passwordHash)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
      }
      if (typeof request3.salt !== "undefined" && !validator.isString(request3.salt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
      }
      if (typeof request3.providerUserInfo !== "undefined" && !validator.isArray(request3.providerUserInfo)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);
      } else if (validator.isArray(request3.providerUserInfo)) {
        request3.providerUserInfo.forEach((providerUserInfoEntry) => {
          validateProviderUserInfo(providerUserInfoEntry);
        });
      }
      if (typeof request3.linkProviderUserInfo !== "undefined") {
        validateProviderUserInfo(request3.linkProviderUserInfo);
      }
      let enrollments = null;
      if (request3.mfaInfo) {
        enrollments = request3.mfaInfo;
      } else if (request3.mfa && request3.mfa.enrollments) {
        enrollments = request3.mfa.enrollments;
      }
      if (enrollments) {
        if (!validator.isArray(enrollments)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);
        }
        enrollments.forEach((authFactorInfoEntry) => {
          validateAuthFactorInfo(authFactorInfoEntry);
        });
      }
    }
    __name(validateCreateEditRequest, "validateCreateEditRequest");
    exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(":createSessionCookie", "POST").setRequestValidator((request3) => {
      if (!validator.isNonEmptyString(request3.idToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);
      }
      if (!validator.isNumber(request3.validDuration) || request3.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request3.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);
      }
    }).setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.sessionCookie)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);
      }
    });
    exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings("/accounts:batchCreate", "POST");
    exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings("/accounts:batchGet", "GET").setRequestValidator((request3) => {
      if (typeof request3.nextPageToken !== "undefined" && !validator.isNonEmptyString(request3.nextPageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request3.maxResults) || request3.maxResults <= 0 || request3.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE}.`);
      }
    });
    exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings("/accounts:lookup", "POST").setRequestValidator((request3) => {
      if (!request3.localId && !request3.email && !request3.phoneNumber && !request3.federatedUserId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    }).setResponseValidator((response) => {
      if (!response.users || !response.users.length) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
      }
    });
    exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings("/accounts:lookup", "POST").setRequestValidator((request3) => {
      if (!request3.localId && !request3.email && !request3.phoneNumber && !request3.federatedUserId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    });
    exports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings("/accounts:delete", "POST").setRequestValidator((request3) => {
      if (!request3.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    });
    exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings("/accounts:batchDelete", "POST").setRequestValidator((request3) => {
      if (!request3.localIds) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifiers");
      }
      if (typeof request3.force === "undefined" || request3.force !== true) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing force=true field");
      }
    }).setResponseValidator((response) => {
      const errors = response.errors || [];
      errors.forEach((batchDeleteErrorInfo) => {
        if (typeof batchDeleteErrorInfo.index === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field");
        }
        if (!batchDeleteErrorInfo.localId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field");
        }
      });
    });
    exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings("/accounts:update", "POST").setRequestValidator((request3) => {
      if (typeof request3.localId === "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
      if (typeof request3.tenantId !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "UpdateRequest" property.');
      }
      validateCreateEditRequest(request3, WriteOperationType.Update);
    }).setResponseValidator((response) => {
      if (!response.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
      }
    });
    exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings("/accounts", "POST").setRequestValidator((request3) => {
      if (typeof request3.customAttributes !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"customAttributes" cannot be set when creating a new user.');
      }
      if (typeof request3.validSince !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"validSince" cannot be set when creating a new user.');
      }
      if (typeof request3.tenantId !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "CreateRequest" property.');
      }
      validateCreateEditRequest(request3, WriteOperationType.Create);
    }).setResponseValidator((response) => {
      if (!response.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new user");
      }
    });
    var FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings("/accounts:sendOobCode", "POST").setRequestValidator((request3) => {
      if (!validator.isEmail(request3.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
      }
      if (typeof request3.newEmail !== "undefined" && !validator.isEmail(request3.newEmail)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_NEW_EMAIL);
      }
      if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request3.requestType) === -1) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${request3.requestType}" is not a supported email action request type.`);
      }
    }).setResponseValidator((response) => {
      if (!response.oobLink) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create the email action link");
      }
    });
    var GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get OIDC configuration");
      }
    });
    var DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}", "DELETE");
    var CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs?oauthIdpConfigId={providerId}", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC configuration");
      }
    });
    var UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC configuration");
      }
    });
    var LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings("/oauthIdpConfigs", "GET").setRequestValidator((request3) => {
      if (typeof request3.pageToken !== "undefined" && !validator.isNonEmptyString(request3.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request3.pageSize) || request3.pageSize <= 0 || request3.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
      }
    });
    var GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get SAML configuration");
      }
    });
    var DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}", "DELETE");
    var CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs?inboundSamlConfigId={providerId}", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML configuration");
      }
    });
    var UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML configuration");
      }
    });
    var LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings("/inboundSamlConfigs", "GET").setRequestValidator((request3) => {
      if (typeof request3.pageToken !== "undefined" && !validator.isNonEmptyString(request3.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request3.pageSize) || request3.pageSize <= 0 || request3.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
      }
    });
    var AbstractAuthRequestHandler = class _AbstractAuthRequestHandler {
      static {
        __name(this, "AbstractAuthRequestHandler");
      }
      /**
       * @param response - The response to check for errors.
       * @returns The error code if present; null otherwise.
       */
      static getErrorCode(response) {
        return validator.isNonNullObject(response) && response.error && response.error.message || null;
      }
      static addUidToRequest(id, request3) {
        if (!validator.isUid(id.uid)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
        }
        request3.localId ? request3.localId.push(id.uid) : request3.localId = [id.uid];
        return request3;
      }
      static addEmailToRequest(id, request3) {
        if (!validator.isEmail(id.email)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
        }
        request3.email ? request3.email.push(id.email) : request3.email = [id.email];
        return request3;
      }
      static addPhoneToRequest(id, request3) {
        if (!validator.isPhoneNumber(id.phoneNumber)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
        }
        request3.phoneNumber ? request3.phoneNumber.push(id.phoneNumber) : request3.phoneNumber = [id.phoneNumber];
        return request3;
      }
      static addProviderToRequest(id, request3) {
        if (!validator.isNonEmptyString(id.providerId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
        }
        if (!validator.isNonEmptyString(id.providerUid)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);
        }
        const federatedUserId = {
          providerId: id.providerId,
          rawId: id.providerUid
        };
        request3.federatedUserId ? request3.federatedUserId.push(federatedUserId) : request3.federatedUserId = [federatedUserId];
        return request3;
      }
      /**
       * @param app - The app used to fetch access tokens to sign API requests.
       * @constructor
       */
      constructor(app) {
        this.app = app;
        if (typeof app !== "object" || app === null || !("options" in app)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "First argument passed to admin.auth() must be a valid Firebase app instance.");
        }
        this.httpClient = new AuthHttpClient(app);
      }
      /**
       * Creates a new Firebase session cookie with the specified duration that can be used for
       * session management (set as a server side session cookie with custom cookie policy).
       * The session cookie JWT will have the same payload claims as the provided ID token.
       *
       * @param idToken - The Firebase ID token to exchange for a session cookie.
       * @param expiresIn - The session cookie duration in milliseconds.
       *
       * @returns A promise that resolves on success with the created session cookie.
       */
      createSessionCookie(idToken, expiresIn) {
        const request3 = {
          idToken,
          // Convert to seconds.
          validDuration: Math.floor(expiresIn / 1e3)
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request3).then((response) => response.sessionCookie);
      }
      /**
       * Looks up a user by uid.
       *
       * @param uid - The uid of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByUid(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request3 = {
          localId: [uid]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request3);
      }
      /**
       * Looks up a user by email.
       *
       * @param email - The email of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByEmail(email) {
        if (!validator.isEmail(email)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));
        }
        const request3 = {
          email: [email]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request3);
      }
      /**
       * Looks up a user by phone number.
       *
       * @param phoneNumber - The phone number of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByPhoneNumber(phoneNumber) {
        if (!validator.isPhoneNumber(phoneNumber)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));
        }
        const request3 = {
          phoneNumber: [phoneNumber]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request3);
      }
      getAccountInfoByFederatedUid(providerId, rawId) {
        if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
        }
        const request3 = {
          federatedUserId: [{
            providerId,
            rawId
          }]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request3);
      }
      /**
       * Looks up multiple users by their identifiers (uid, email, etc).
       *
       * @param identifiers - The identifiers indicating the users
       *     to be looked up. Must have <= 100 entries.
       * @param A - promise that resolves with the set of successfully
       *     looked up users. Possibly empty if no users were looked up.
       */
      getAccountInfoByIdentifiers(identifiers) {
        if (identifiers.length === 0) {
          return Promise.resolve({ users: [] });
        } else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`identifiers` parameter must have <= " + MAX_GET_ACCOUNTS_BATCH_SIZE + " entries.");
        }
        let request3 = {};
        for (const id of identifiers) {
          if ((0, identifier_1.isUidIdentifier)(id)) {
            request3 = _AbstractAuthRequestHandler.addUidToRequest(id, request3);
          } else if ((0, identifier_1.isEmailIdentifier)(id)) {
            request3 = _AbstractAuthRequestHandler.addEmailToRequest(id, request3);
          } else if ((0, identifier_1.isPhoneIdentifier)(id)) {
            request3 = _AbstractAuthRequestHandler.addPhoneToRequest(id, request3);
          } else if ((0, identifier_1.isProviderIdentifier)(id)) {
            request3 = _AbstractAuthRequestHandler.addProviderToRequest(id, request3);
          } else {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Unrecognized identifier: " + id);
          }
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request3);
      }
      /**
       * Exports the users (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns users starting
       *     without any offset. Users are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     users and the next page token if available. For the last page, an empty list of users
       *     and no page token are returned.
       */
      downloadAccount(maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE, pageToken) {
        const request3 = {
          maxResults,
          nextPageToken: pageToken
        };
        if (typeof request3.nextPageToken === "undefined") {
          delete request3.nextPageToken;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request3).then((response) => {
          if (!response.users) {
            response.users = [];
          }
          return response;
        });
      }
      /**
       * Imports the list of users provided to Firebase Auth. This is useful when
       * migrating from an external authentication system without having to use the Firebase CLI SDK.
       * At most, 1000 users are allowed to be imported one at a time.
       * When importing a list of password users, UserImportOptions are required to be specified.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided
       *     include password credentials.
       * @returns A promise that resolves when the operation completes
       *     with the result of the import. This includes the number of successful imports, the number
       *     of failed uploads and their corresponding errors.
       */
      uploadAccount(users, options) {
        const userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, (userRequest) => {
          validateCreateEditRequest(userRequest, WriteOperationType.Upload);
        });
        const request3 = userImportBuilder.buildRequest();
        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${MAX_UPLOAD_ACCOUNT_BATCH_SIZE} users can be imported at once.`);
        }
        if (!request3.users || request3.users.length === 0) {
          return Promise.resolve(userImportBuilder.buildResponse([]));
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request3).then((response) => {
          const failedUploads = response.error || [];
          return userImportBuilder.buildResponse(failedUploads);
        });
      }
      /**
       * Deletes an account identified by a uid.
       *
       * @param uid - The uid of the user to delete.
       * @returns A promise that resolves when the user is deleted.
       */
      deleteAccount(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request3 = {
          localId: uid
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request3);
      }
      deleteAccounts(uids, force) {
        if (uids.length === 0) {
          return Promise.resolve({});
        } else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`uids` parameter must have <= " + MAX_DELETE_ACCOUNTS_BATCH_SIZE + " entries.");
        }
        const request3 = {
          localIds: [],
          force
        };
        uids.forEach((uid) => {
          if (!validator.isUid(uid)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
          }
          request3.localIds.push(uid);
        });
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request3);
      }
      /**
       * Sets additional developer claims on an existing user identified by provided UID.
       *
       * @param uid - The user to edit.
       * @param customUserClaims - The developer claims to set.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was edited.
       */
      setCustomUserClaims(uid, customUserClaims) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        } else if (!validator.isObject(customUserClaims)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "CustomUserClaims argument must be an object or null."));
        }
        if (customUserClaims === null) {
          customUserClaims = {};
        }
        const request3 = {
          localId: uid,
          customAttributes: JSON.stringify(customUserClaims)
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request3).then((response) => {
          return response.localId;
        });
      }
      /**
       * Edits an existing user.
       *
       * @param uid - The user to edit.
       * @param properties - The properties to set on the user.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was edited.
       */
      updateExistingAccount(uid, properties) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        } else if (!validator.isNonNullObject(properties)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
        } else if (validator.isNonNullObject(properties.providerToLink)) {
          if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.providerId of properties argument must be a non-empty string.");
          }
          if (!validator.isNonEmptyString(properties.providerToLink.uid)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.uid of properties argument must be a non-empty string.");
          }
        } else if (typeof properties.providersToUnlink !== "undefined") {
          if (!validator.isArray(properties.providersToUnlink)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
          }
          properties.providersToUnlink.forEach((providerId) => {
            if (!validator.isNonEmptyString(providerId)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
            }
          });
        }
        const request3 = (0, deep_copy_1.deepCopy)(properties);
        request3.localId = uid;
        const deletableParams = {
          displayName: "DISPLAY_NAME",
          photoURL: "PHOTO_URL"
        };
        request3.deleteAttribute = [];
        for (const key in deletableParams) {
          if (request3[key] === null) {
            request3.deleteAttribute.push(deletableParams[key]);
            delete request3[key];
          }
        }
        if (request3.deleteAttribute.length === 0) {
          delete request3.deleteAttribute;
        }
        if (request3.phoneNumber === null) {
          request3.deleteProvider ? request3.deleteProvider.push("phone") : request3.deleteProvider = ["phone"];
          delete request3.phoneNumber;
        }
        if (typeof request3.providerToLink !== "undefined") {
          request3.linkProviderUserInfo = (0, deep_copy_1.deepCopy)(request3.providerToLink);
          delete request3.providerToLink;
          request3.linkProviderUserInfo.rawId = request3.linkProviderUserInfo.uid;
          delete request3.linkProviderUserInfo.uid;
        }
        if (typeof request3.providersToUnlink !== "undefined") {
          if (!validator.isArray(request3.deleteProvider)) {
            request3.deleteProvider = [];
          }
          request3.deleteProvider = request3.deleteProvider.concat(request3.providersToUnlink);
          delete request3.providersToUnlink;
        }
        if (typeof request3.photoURL !== "undefined") {
          request3.photoUrl = request3.photoURL;
          delete request3.photoURL;
        }
        if (typeof request3.disabled !== "undefined") {
          request3.disableUser = request3.disabled;
          delete request3.disabled;
        }
        if (validator.isNonNullObject(request3.multiFactor)) {
          if (request3.multiFactor.enrolledFactors === null) {
            request3.mfa = {};
          } else if (validator.isArray(request3.multiFactor.enrolledFactors)) {
            request3.mfa = {
              enrollments: []
            };
            try {
              request3.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
                request3.mfa.enrollments.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
              });
            } catch (e) {
              return Promise.reject(e);
            }
            if (request3.mfa.enrollments.length === 0) {
              delete request3.mfa.enrollments;
            }
          }
          delete request3.multiFactor;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request3).then((response) => {
          return response.localId;
        });
      }
      /**
       * Revokes all refresh tokens for the specified user identified by the uid provided.
       * In addition to revoking all refresh tokens for a user, all ID tokens issued
       * before revocation will also be revoked on the Auth backend. Any request with an
       * ID token generated before revocation will be rejected with a token expired error.
       * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in
       * the same second as the revocation will still be valid. If there is a chance that a token
       * was minted in the last second, delay for 1 second before revoking.
       *
       * @param uid - The user whose tokens are to be revoked.
       * @returns A promise that resolves when the operation completes
       *     successfully with the user id of the corresponding user.
       */
      revokeRefreshTokens(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request3 = {
          localId: uid,
          // validSince is in UTC seconds.
          validSince: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3)
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request3).then((response) => {
          return response.localId;
        });
      }
      /**
       * Create a new user with the properties supplied.
       *
       * @param properties - The properties to set on the user.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was created.
       */
      createNewAccount(properties) {
        if (!validator.isNonNullObject(properties)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
        }
        const request3 = (0, deep_copy_1.deepCopy)(properties);
        if (typeof request3.photoURL !== "undefined") {
          request3.photoUrl = request3.photoURL;
          delete request3.photoURL;
        }
        if (typeof request3.uid !== "undefined") {
          request3.localId = request3.uid;
          delete request3.uid;
        }
        if (validator.isNonNullObject(request3.multiFactor)) {
          if (validator.isNonEmptyArray(request3.multiFactor.enrolledFactors)) {
            const mfaInfo = [];
            try {
              request3.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
                if ("enrollmentTime" in multiFactorInfo) {
                  throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"enrollmentTime" is not supported when adding second factors via "createUser()"');
                } else if ("uid" in multiFactorInfo) {
                  throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"uid" is not supported when adding second factors via "createUser()"');
                }
                mfaInfo.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
              });
            } catch (e) {
              return Promise.reject(e);
            }
            request3.mfaInfo = mfaInfo;
          }
          delete request3.multiFactor;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request3).then((response) => {
          return response.localId;
        });
      }
      /**
       * Generates the out of band email action link for the email specified using the action code settings provided.
       * Returns a promise that resolves with the generated link.
       *
       * @param requestType - The request type. This could be either used for password reset,
       *     email verification, email link sign-in.
       * @param email - The email of the user the link is being sent to.
       * @param actionCodeSettings - The optional action code setings which defines whether
       *     the link is to be handled by a mobile app and the additional state information to be passed in the
       *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'
       * @param newEmail - The email address the account is being updated to.
       *     Required only for VERIFY_AND_CHANGE_EMAIL requests.
       * @returns A promise that resolves with the email action link.
       */
      getEmailActionLink(requestType, email, actionCodeSettings, newEmail) {
        let request3 = {
          requestType,
          email,
          returnOobLink: true,
          ...typeof newEmail !== "undefined" && { newEmail }
        };
        if (typeof actionCodeSettings === "undefined" && requestType === "EMAIL_SIGNIN") {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'"));
        }
        if (typeof actionCodeSettings !== "undefined" || requestType === "EMAIL_SIGNIN") {
          try {
            const builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);
            request3 = (0, deep_copy_1.deepExtend)(request3, builder.buildRequest());
          } catch (e) {
            return Promise.reject(e);
          }
        }
        if (requestType === "VERIFY_AND_CHANGE_EMAIL" && typeof newEmail === "undefined") {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'"));
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request3).then((response) => {
          return response.oobLink;
        });
      }
      /**
       * Looks up an OIDC provider configuration by provider ID.
       *
       * @param providerId - The provider identifier of the configuration to lookup.
       * @returns A promise that resolves with the provider configuration information.
       */
      getOAuthIdpConfig(providerId) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId });
      }
      /**
       * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 100 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns OIDC configurations
       *     without any offset. Configurations are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     OIDC configurations and the next page token if available. For the last page, an empty list of provider
       *     configuration and no page token are returned.
       */
      listOAuthIdpConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
        const request3 = {
          pageSize: maxResults
        };
        if (typeof pageToken !== "undefined") {
          request3.pageToken = pageToken;
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request3).then((response) => {
          if (!response.oauthIdpConfigs) {
            response.oauthIdpConfigs = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes an OIDC configuration identified by a providerId.
       *
       * @param providerId - The identifier of the OIDC configuration to delete.
       * @returns A promise that resolves when the OIDC provider is deleted.
       */
      deleteOAuthIdpConfig(providerId) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId }).then(() => {
        });
      }
      /**
       * Creates a new OIDC provider configuration with the properties provided.
       *
       * @param options - The properties to set on the new OIDC provider configuration to be created.
       * @returns A promise that resolves with the newly created OIDC
       *     configuration.
       */
      createOAuthIdpConfig(options) {
        let request3;
        try {
          request3 = auth_config_1.OIDCConfig.buildServerRequest(options) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const providerId = options.providerId;
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request3, { providerId }).then((response) => {
          if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration");
          }
          return response;
        });
      }
      /**
       * Updates an existing OIDC provider configuration with the properties provided.
       *
       * @param providerId - The provider identifier of the OIDC configuration to update.
       * @param options - The properties to update on the existing configuration.
       * @returns A promise that resolves with the modified provider
       *     configuration.
       */
      updateOAuthIdpConfig(providerId, options) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        let request3;
        try {
          request3 = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const updateMask = utils.generateUpdateMask(request3);
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request3, { providerId, updateMask: updateMask.join(",") }).then((response) => {
          if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration");
          }
          return response;
        });
      }
      /**
       * Looks up an SAML provider configuration by provider ID.
       *
       * @param providerId - The provider identifier of the configuration to lookup.
       * @returns A promise that resolves with the provider configuration information.
       */
      getInboundSamlConfig(providerId) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId });
      }
      /**
       * Lists the SAML configurations (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 100 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns SAML configurations starting
       *     without any offset. Configurations are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     SAML configurations and the next page token if available. For the last page, an empty list of provider
       *     configuration and no page token are returned.
       */
      listInboundSamlConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
        const request3 = {
          pageSize: maxResults
        };
        if (typeof pageToken !== "undefined") {
          request3.pageToken = pageToken;
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request3).then((response) => {
          if (!response.inboundSamlConfigs) {
            response.inboundSamlConfigs = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes a SAML configuration identified by a providerId.
       *
       * @param providerId - The identifier of the SAML configuration to delete.
       * @returns A promise that resolves when the SAML provider is deleted.
       */
      deleteInboundSamlConfig(providerId) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId }).then(() => {
        });
      }
      /**
       * Creates a new SAML provider configuration with the properties provided.
       *
       * @param options - The properties to set on the new SAML provider configuration to be created.
       * @returns A promise that resolves with the newly created SAML
       *     configuration.
       */
      createInboundSamlConfig(options) {
        let request3;
        try {
          request3 = auth_config_1.SAMLConfig.buildServerRequest(options) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const providerId = options.providerId;
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request3, { providerId }).then((response) => {
          if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration");
          }
          return response;
        });
      }
      /**
       * Updates an existing SAML provider configuration with the properties provided.
       *
       * @param providerId - The provider identifier of the SAML configuration to update.
       * @param options - The properties to update on the existing configuration.
       * @returns A promise that resolves with the modified provider
       *     configuration.
       */
      updateInboundSamlConfig(providerId, options) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        let request3;
        try {
          request3 = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const updateMask = utils.generateUpdateMask(request3);
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request3, { providerId, updateMask: updateMask.join(",") }).then((response) => {
          if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML provider configuration");
          }
          return response;
        });
      }
      /**
       * Invokes the request handler based on the API settings object passed.
       *
       * @param urlBuilder - The URL builder for Auth endpoints.
       * @param apiSettings - The API endpoint settings to apply to request and response.
       * @param requestData - The request data.
       * @param additionalResourceParams - Additional resource related params if needed.
       * @returns A promise that resolves with the response.
       */
      invokeRequestHandler(urlBuilder, apiSettings, requestData, additionalResourceParams) {
        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams).then((url) => {
          if (requestData) {
            const requestValidator = apiSettings.getRequestValidator();
            requestValidator(requestData);
          }
          const req = {
            method: apiSettings.getHttpMethod(),
            url,
            headers: FIREBASE_AUTH_HEADERS,
            data: requestData,
            timeout: FIREBASE_AUTH_TIMEOUT
          };
          return this.httpClient.send(req);
        }).then((response) => {
          const responseValidator = apiSettings.getResponseValidator();
          responseValidator(response.data);
          return response.data;
        }).catch((err) => {
          if (err instanceof api_request_1.RequestResponseError) {
            const error3 = err.response.data;
            const errorCode = _AbstractAuthRequestHandler.getErrorCode(error3);
            if (!errorCode) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + error3 + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
            }
            throw error_1.FirebaseAuthError.fromServerError(
              errorCode,
              /* message */
              void 0,
              error3
            );
          }
          throw err;
        });
      }
      /**
       * @returns The current Auth user management resource URL builder.
       */
      getAuthUrlBuilder() {
        if (!this.authUrlBuilder) {
          this.authUrlBuilder = this.newAuthUrlBuilder();
        }
        return this.authUrlBuilder;
      }
      /**
       * @returns The current project config resource URL builder.
       */
      getProjectConfigUrlBuilder() {
        if (!this.projectConfigUrlBuilder) {
          this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();
        }
        return this.projectConfigUrlBuilder;
      }
    };
    exports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;
    var GET_PROJECT_CONFIG = new api_request_1.ApiSettings("/config", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get project config");
      }
    });
    var UPDATE_PROJECT_CONFIG = new api_request_1.ApiSettings("/config?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update project config");
      }
    });
    var GET_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get tenant");
      }
    });
    var DELETE_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}", "DELETE");
    var UPDATE_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update tenant");
      }
    });
    var LIST_TENANTS = new api_request_1.ApiSettings("/tenants", "GET").setRequestValidator((request3) => {
      if (typeof request3.pageToken !== "undefined" && !validator.isNonEmptyString(request3.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request3.pageSize) || request3.pageSize <= 0 || request3.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive non-zero number that does not exceed the allowed ${MAX_LIST_TENANT_PAGE_SIZE}.`);
      }
    });
    var CREATE_TENANT = new api_request_1.ApiSettings("/tenants", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new tenant");
      }
    });
    var AuthRequestHandler = class extends AbstractAuthRequestHandler {
      static {
        __name(this, "AuthRequestHandler");
      }
      /**
       * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.
       *
       * @param app - The app used to fetch access tokens to sign API requests.
       * @constructor
       */
      constructor(app) {
        super(app);
        this.authResourceUrlBuilder = new AuthResourceUrlBuilder(app, "v2");
      }
      /**
       * @returns A new Auth user management resource URL builder instance.
       */
      newAuthUrlBuilder() {
        return new AuthResourceUrlBuilder(this.app, "v1");
      }
      /**
       * @returns A new project config resource URL builder instance.
       */
      newProjectConfigUrlBuilder() {
        return new AuthResourceUrlBuilder(this.app, "v2");
      }
      /**
       * Get the current project's config
       * @returns A promise that resolves with the project config information.
       */
      getProjectConfig() {
        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_PROJECT_CONFIG, {}, {}).then((response) => {
          return response;
        });
      }
      /**
       * Update the current project's config.
       * @returns A promise that resolves with the project config information.
       */
      updateProjectConfig(options) {
        try {
          const request3 = project_config_1.ProjectConfig.buildServerRequest(options);
          const updateMask = utils.generateUpdateMask(request3);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_PROJECT_CONFIG, request3, { updateMask: updateMask.join(",") }).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Looks up a tenant by tenant ID.
       *
       * @param tenantId - The tenant identifier of the tenant to lookup.
       * @returns A promise that resolves with the tenant information.
       */
      getTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_TENANT, {}, { tenantId }).then((response) => {
          return response;
        });
      }
      /**
       * Exports the tenants (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns tenants starting
       *     without any offset. Tenants are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     tenants and the next page token if available. For the last page, an empty list of tenants
       *     and no page token are returned.
       */
      listTenants(maxResults = MAX_LIST_TENANT_PAGE_SIZE, pageToken) {
        const request3 = {
          pageSize: maxResults,
          pageToken
        };
        if (typeof request3.pageToken === "undefined") {
          delete request3.pageToken;
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, LIST_TENANTS, request3).then((response) => {
          if (!response.tenants) {
            response.tenants = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes a tenant identified by a tenantId.
       *
       * @param tenantId - The identifier of the tenant to delete.
       * @returns A promise that resolves when the tenant is deleted.
       */
      deleteTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, DELETE_TENANT, void 0, { tenantId }).then(() => {
        });
      }
      /**
       * Creates a new tenant with the properties provided.
       *
       * @param tenantOptions - The properties to set on the new tenant to be created.
       * @returns A promise that resolves with the newly created tenant object.
       */
      createTenant(tenantOptions) {
        try {
          const request3 = tenant_1.Tenant.buildServerRequest(tenantOptions, true);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, CREATE_TENANT, request3).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Updates an existing tenant with the properties provided.
       *
       * @param tenantId - The tenant identifier of the tenant to update.
       * @param tenantOptions - The properties to update on the existing tenant.
       * @returns A promise that resolves with the modified tenant object.
       */
      updateTenant(tenantId, tenantOptions) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        try {
          const request3 = tenant_1.Tenant.buildServerRequest(tenantOptions, false);
          const updateMask = utils.generateUpdateMask(request3, ["testPhoneNumbers"]);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_TENANT, request3, { tenantId, updateMask: updateMask.join(",") }).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
    exports.AuthRequestHandler = AuthRequestHandler;
    var TenantAwareAuthRequestHandler = class extends AbstractAuthRequestHandler {
      static {
        __name(this, "TenantAwareAuthRequestHandler");
      }
      /**
       * The FirebaseTenantRequestHandler constructor used to initialize an instance using a
       * FirebaseApp and a tenant ID.
       *
       * @param app - The app used to fetch access tokens to sign API requests.
       * @param tenantId - The request handler's tenant ID.
       * @constructor
       */
      constructor(app, tenantId) {
        super(app);
        this.tenantId = tenantId;
      }
      /**
       * @returns A new Auth user management resource URL builder instance.
       */
      newAuthUrlBuilder() {
        return new TenantAwareAuthResourceUrlBuilder(this.app, "v1", this.tenantId);
      }
      /**
       * @returns A new project config resource URL builder instance.
       */
      newProjectConfigUrlBuilder() {
        return new TenantAwareAuthResourceUrlBuilder(this.app, "v2", this.tenantId);
      }
      /**
       * Imports the list of users provided to Firebase Auth. This is useful when
       * migrating from an external authentication system without having to use the Firebase CLI SDK.
       * At most, 1000 users are allowed to be imported one at a time.
       * When importing a list of password users, UserImportOptions are required to be specified.
       *
       * Overrides the superclass methods by adding an additional check to match tenant IDs of
       * imported user records if present.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided
       *     include password credentials.
       * @returns A promise that resolves when the operation completes
       *     with the result of the import. This includes the number of successful imports, the number
       *     of failed uploads and their corresponding errors.
       */
      uploadAccount(users, options) {
        users.forEach((user, index) => {
          if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index "${index}" has mismatching tenant ID "${user.tenantId}"`);
          }
        });
        return super.uploadAccount(users, options);
      }
    };
    exports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;
    function emulatorHost() {
      return process.env.FIREBASE_AUTH_EMULATOR_HOST;
    }
    __name(emulatorHost, "emulatorHost");
    function useEmulator() {
      return !!emulatorHost();
    }
    __name(useEmulator, "useEmulator");
  }
});

// node_modules/firebase-admin/lib/utils/crypto-signer.js
var require_crypto_signer = __commonJS({
  "node_modules/firebase-admin/lib/utils/crypto-signer.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.IAMSigner = exports.ServiceAccountSigner = void 0;
    exports.cryptoSignerFromApp = cryptoSignerFromApp;
    var credential_internal_1 = require_credential_internal();
    var api_request_1 = require_api_request();
    var validator = require_validator();
    var ALGORITHM_RS256 = "RS256";
    var ServiceAccountSigner = class {
      static {
        __name(this, "ServiceAccountSigner");
      }
      /**
       * Creates a new CryptoSigner instance from the given service account credential.
       *
       * @param credential - A service account credential.
       */
      constructor(credential) {
        this.credential = credential;
        this.algorithm = ALGORITHM_RS256;
        if (!credential) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
            message: "INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner."
          });
        }
      }
      /**
       * @inheritDoc
       */
      sign(buffer) {
        const crypto2 = require_crypto2();
        const sign3 = crypto2.createSign("RSA-SHA256");
        sign3.update(buffer);
        return Promise.resolve(sign3.sign(this.credential.privateKey));
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        return Promise.resolve(this.credential.clientEmail);
      }
    };
    exports.ServiceAccountSigner = ServiceAccountSigner;
    var IAMSigner = class {
      static {
        __name(this, "IAMSigner");
      }
      constructor(httpClient, serviceAccountId) {
        this.algorithm = ALGORITHM_RS256;
        if (!httpClient) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_ARGUMENT,
            message: "INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner."
          });
        }
        if (typeof serviceAccountId !== "undefined" && !validator.isNonEmptyString(serviceAccountId)) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_ARGUMENT,
            message: "INTERNAL ASSERT: Service account ID must be undefined or a non-empty string."
          });
        }
        this.httpClient = httpClient;
        this.serviceAccountId = serviceAccountId;
      }
      /**
       * @inheritDoc
       */
      sign(buffer) {
        return this.getAccountId().then((serviceAccount) => {
          const request3 = {
            method: "POST",
            url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,
            data: { payload: buffer.toString("base64") }
          };
          return this.httpClient.send(request3);
        }).then((response) => {
          return Buffer.from(response.data.signedBlob, "base64");
        }).catch((err) => {
          if (err instanceof api_request_1.RequestResponseError) {
            throw new CryptoSignerError({
              code: CryptoSignerErrorCode.SERVER_ERROR,
              message: err.message,
              cause: err
            });
          }
          throw err;
        });
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        if (validator.isNonEmptyString(this.serviceAccountId)) {
          return Promise.resolve(this.serviceAccountId);
        }
        const request3 = {
          method: "GET",
          url: "http://metadata/computeMetadata/v1/instance/service-accounts/default/email",
          headers: {
            "Metadata-Flavor": "Google"
          }
        };
        const client = new api_request_1.HttpClient();
        return client.send(request3).then((response) => {
          if (!response.text) {
            throw new CryptoSignerError({
              code: CryptoSignerErrorCode.INTERNAL_ERROR,
              message: "HTTP Response missing payload"
            });
          }
          this.serviceAccountId = response.text;
          return response.text;
        }).catch((err) => {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
            message: `Failed to determine service account. Make sure to initialize the SDK with a service account credential. Alternatively specify a service account with iam.serviceAccounts.signBlob permission. Original error: ${err}`
          });
        });
      }
    };
    exports.IAMSigner = IAMSigner;
    function cryptoSignerFromApp(app) {
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return new ServiceAccountSigner(credential);
      }
      return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);
    }
    __name(cryptoSignerFromApp, "cryptoSignerFromApp");
    var CryptoSignerError = class _CryptoSignerError extends Error {
      static {
        __name(this, "CryptoSignerError");
      }
      constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        this.__proto__ = _CryptoSignerError.prototype;
      }
      /** @returns The error code. */
      get code() {
        return this.errorInfo.code;
      }
      /** @returns The error message. */
      get message() {
        return this.errorInfo.message;
      }
      /** @returns The error data. */
      get cause() {
        return this.errorInfo.cause;
      }
    };
    exports.CryptoSignerError = CryptoSignerError;
    var CryptoSignerErrorCode = class {
      static {
        __name(this, "CryptoSignerErrorCode");
      }
    };
    exports.CryptoSignerErrorCode = CryptoSignerErrorCode;
    CryptoSignerErrorCode.INVALID_ARGUMENT = "invalid-argument";
    CryptoSignerErrorCode.INTERNAL_ERROR = "internal-error";
    CryptoSignerErrorCode.INVALID_CREDENTIAL = "invalid-credential";
    CryptoSignerErrorCode.SERVER_ERROR = "server-error";
  }
});

// node_modules/firebase-admin/lib/auth/token-generator.js
var require_token_generator = __commonJS({
  "node_modules/firebase-admin/lib/auth/token-generator.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseTokenGenerator = exports.EmulatedSigner = exports.BLACKLISTED_CLAIMS = void 0;
    exports.handleCryptoSignerError = handleCryptoSignerError;
    var error_1 = require_error();
    var crypto_signer_1 = require_crypto_signer();
    var validator = require_validator();
    var utils_1 = require_utils();
    var ALGORITHM_NONE = "none";
    var ONE_HOUR_IN_SECONDS = 60 * 60;
    exports.BLACKLISTED_CLAIMS = [
      "acr",
      "amr",
      "at_hash",
      "aud",
      "auth_time",
      "azp",
      "cnf",
      "c_hash",
      "exp",
      "iat",
      "iss",
      "jti",
      "nbf",
      "nonce"
    ];
    var FIREBASE_AUDIENCE = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit";
    var EmulatedSigner = class {
      static {
        __name(this, "EmulatedSigner");
      }
      constructor() {
        this.algorithm = ALGORITHM_NONE;
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      sign(buffer) {
        return Promise.resolve(Buffer.from(""));
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        return Promise.resolve("firebase-auth-emulator@example.com");
      }
    };
    exports.EmulatedSigner = EmulatedSigner;
    var FirebaseTokenGenerator = class {
      static {
        __name(this, "FirebaseTokenGenerator");
      }
      /**
       * @param tenantId - The tenant ID to use for the generated Firebase Auth
       *     Custom token. If absent, then no tenant ID claim will be set in the
       *     resulting JWT.
       */
      constructor(signer, tenantId) {
        this.tenantId = tenantId;
        if (!validator.isNonNullObject(signer)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, "INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.");
        }
        if (typeof this.tenantId !== "undefined" && !validator.isNonEmptyString(this.tenantId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`tenantId` argument must be a non-empty string.");
        }
        this.signer = signer;
      }
      /**
       * Creates a new Firebase Auth Custom token.
       *
       * @param uid - The user ID to use for the generated Firebase Auth Custom token.
       * @param developerClaims - Optional developer claims to include in the generated Firebase
       *     Auth Custom token.
       * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a
       *     service account key and containing the provided payload.
       */
      createCustomToken(uid, developerClaims) {
        let errorMessage;
        if (!validator.isNonEmptyString(uid)) {
          errorMessage = "`uid` argument must be a non-empty string uid.";
        } else if (uid.length > 128) {
          errorMessage = "`uid` argument must a uid with less than or equal to 128 characters.";
        } else if (!this.isDeveloperClaimsValid_(developerClaims)) {
          errorMessage = "`developerClaims` argument must be a valid, non-null object containing the developer claims.";
        }
        if (errorMessage) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
        const claims = {};
        if (typeof developerClaims !== "undefined") {
          for (const key in developerClaims) {
            if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {
              if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim "${key}" is reserved and cannot be specified.`);
              }
              claims[key] = developerClaims[key];
            }
          }
        }
        return this.signer.getAccountId().then((account) => {
          const header = {
            alg: this.signer.algorithm,
            typ: "JWT"
          };
          const iat = Math.floor(Date.now() / 1e3);
          const body = {
            aud: FIREBASE_AUDIENCE,
            iat,
            exp: iat + ONE_HOUR_IN_SECONDS,
            iss: account,
            sub: account,
            uid
          };
          if (this.tenantId) {
            body.tenant_id = this.tenantId;
          }
          if (Object.keys(claims).length > 0) {
            body.claims = claims;
          }
          const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;
          const signPromise = this.signer.sign(Buffer.from(token));
          return Promise.all([token, signPromise]);
        }).then(([token, signature]) => {
          return `${token}.${this.encodeSegment(signature)}`;
        }).catch((err) => {
          throw handleCryptoSignerError(err);
        });
      }
      encodeSegment(segment) {
        const buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));
        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, "");
      }
      /**
       * Returns whether or not the provided developer claims are valid.
       *
       * @param developerClaims - Optional developer claims to validate.
       * @returns True if the provided claims are valid; otherwise, false.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      isDeveloperClaimsValid_(developerClaims) {
        if (typeof developerClaims === "undefined") {
          return true;
        }
        return validator.isNonNullObject(developerClaims);
      }
    };
    exports.FirebaseTokenGenerator = FirebaseTokenGenerator;
    function handleCryptoSignerError(err) {
      if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
        return err;
      }
      if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
        const httpError = err.cause;
        const errorResponse = httpError.response.data;
        if (validator.isNonNullObject(errorResponse) && errorResponse.error) {
          const errorCode = errorResponse.error.status;
          const description = "Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens for more details on how to use and troubleshoot this feature.";
          const errorMsg = `${errorResponse.error.message}; ${description}`;
          return error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, errorResponse);
        }
        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + errorResponse + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
      }
      return new error_1.FirebaseAuthError(mapToAuthClientErrorCode(err.code), err.message);
    }
    __name(handleCryptoSignerError, "handleCryptoSignerError");
    function mapToAuthClientErrorCode(code) {
      switch (code) {
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:
          return error_1.AuthClientErrorCode.INVALID_CREDENTIAL;
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:
          return error_1.AuthClientErrorCode.INVALID_ARGUMENT;
        default:
          return error_1.AuthClientErrorCode.INTERNAL_ERROR;
      }
    }
    __name(mapToAuthClientErrorCode, "mapToAuthClientErrorCode");
  }
});

// node_modules/jws/lib/data-stream.js
var require_data_stream3 = __commonJS({
  "node_modules/jws/lib/data-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var Stream = require_stream();
    var util = require_util3();
    function DataStream(data) {
      this.buffer = null;
      this.writable = true;
      this.readable = true;
      if (!data) {
        this.buffer = Buffer2.alloc(0);
        return this;
      }
      if (typeof data.pipe === "function") {
        this.buffer = Buffer2.alloc(0);
        data.pipe(this);
        return this;
      }
      if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick(function() {
          this.emit("end", data);
          this.readable = false;
          this.emit("close");
        }.bind(this));
        return this;
      }
      throw new TypeError("Unexpected data type (" + typeof data + ")");
    }
    __name(DataStream, "DataStream");
    util.inherits(DataStream, Stream);
    DataStream.prototype.write = /* @__PURE__ */ __name(function write2(data) {
      this.buffer = Buffer2.concat([this.buffer, Buffer2.from(data)]);
      this.emit("data", data);
    }, "write");
    DataStream.prototype.end = /* @__PURE__ */ __name(function end(data) {
      if (data)
        this.write(data);
      this.emit("end", data);
      this.emit("close");
      this.writable = false;
      this.readable = false;
    }, "end");
    module.exports = DataStream;
  }
});

// node_modules/jwa/index.js
var require_jwa3 = __commonJS({
  "node_modules/jwa/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var bufferEqual = require_buffer_equal_constant_time();
    var Buffer2 = require_safe_buffer().Buffer;
    var crypto2 = require_crypto2();
    var formatEcdsa = require_ecdsa_sig_formatter();
    var util = require_util3();
    var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
    var MSG_INVALID_SECRET = "secret must be a string or buffer";
    var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
    var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
    var supportsKeyObjects = typeof crypto2.createPublicKey === "function";
    if (supportsKeyObjects) {
      MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
      MSG_INVALID_SECRET += "or a KeyObject";
    }
    function checkIsPublicKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
      }
    }
    __name(checkIsPublicKey, "checkIsPublicKey");
    function checkIsPrivateKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return;
      }
      if (typeof key === "object") {
        return;
      }
      throw typeError(MSG_INVALID_SIGNER_KEY);
    }
    __name(checkIsPrivateKey, "checkIsPrivateKey");
    function checkIsSecretKey(key) {
      if (Buffer2.isBuffer(key)) {
        return;
      }
      if (typeof key === "string") {
        return key;
      }
      if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
      }
      if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
      }
    }
    __name(checkIsSecretKey, "checkIsSecretKey");
    function fromBase64(base64) {
      return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(fromBase64, "fromBase64");
    function toBase64(base64url) {
      base64url = base64url.toString();
      var padding = 4 - base64url.length % 4;
      if (padding !== 4) {
        for (var i = 0; i < padding; ++i) {
          base64url += "=";
        }
      }
      return base64url.replace(/\-/g, "+").replace(/_/g, "/");
    }
    __name(toBase64, "toBase64");
    function typeError(template) {
      var args = [].slice.call(arguments, 1);
      var errMsg = util.format.bind(util, template).apply(null, args);
      return new TypeError(errMsg);
    }
    __name(typeError, "typeError");
    function bufferOrString(obj) {
      return Buffer2.isBuffer(obj) || typeof obj === "string";
    }
    __name(bufferOrString, "bufferOrString");
    function normalizeInput(thing) {
      if (!bufferOrString(thing))
        thing = JSON.stringify(thing);
      return thing;
    }
    __name(normalizeInput, "normalizeInput");
    function createHmacSigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto2.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createHmacSigner, "createHmacSigner");
    function createHmacVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer2.from(signature), Buffer2.from(computedSig));
      }, "verify");
    }
    __name(createHmacVerifier, "createHmacVerifier");
    function createKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createKeySigner, "createKeySigner");
    function createKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
      }, "verify");
    }
    __name(createKeyVerifier, "createKeyVerifier");
    function createPSSKeySigner(bits) {
      return /* @__PURE__ */ __name(function sign3(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto2.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
          key: privateKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
      }, "sign");
    }
    __name(createPSSKeySigner, "createPSSKeySigner");
    function createPSSKeyVerifier(bits) {
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto2.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
          key: publicKey,
          padding: crypto2.constants.RSA_PKCS1_PSS_PADDING,
          saltLength: crypto2.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
      }, "verify");
    }
    __name(createPSSKeyVerifier, "createPSSKeyVerifier");
    function createECDSASigner(bits) {
      var inner = createKeySigner(bits);
      return /* @__PURE__ */ __name(function sign3() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
      }, "sign");
    }
    __name(createECDSASigner, "createECDSASigner");
    function createECDSAVerifer(bits) {
      var inner = createKeyVerifier(bits);
      return /* @__PURE__ */ __name(function verify3(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
      }, "verify");
    }
    __name(createECDSAVerifer, "createECDSAVerifer");
    function createNoneSigner() {
      return /* @__PURE__ */ __name(function sign3() {
        return "";
      }, "sign");
    }
    __name(createNoneSigner, "createNoneSigner");
    function createNoneVerifier() {
      return /* @__PURE__ */ __name(function verify3(thing, signature) {
        return signature === "";
      }, "verify");
    }
    __name(createNoneVerifier, "createNoneVerifier");
    module.exports = /* @__PURE__ */ __name(function jwa(algorithm) {
      var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
      };
      var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
      };
      var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
      if (!match)
        throw typeError(MSG_INVALID_ALGORITHM, algorithm);
      var algo = (match[1] || match[3]).toLowerCase();
      var bits = match[2];
      return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
      };
    }, "jwa");
  }
});

// node_modules/jws/lib/tostring.js
var require_tostring3 = __commonJS({
  "node_modules/jws/lib/tostring.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_buffer().Buffer;
    module.exports = /* @__PURE__ */ __name(function toString(obj) {
      if (typeof obj === "string")
        return obj;
      if (typeof obj === "number" || Buffer2.isBuffer(obj))
        return obj.toString();
      return JSON.stringify(obj);
    }, "toString");
  }
});

// node_modules/jws/lib/sign-stream.js
var require_sign_stream3 = __commonJS({
  "node_modules/jws/lib/sign-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream3();
    var jwa = require_jwa3();
    var Stream = require_stream();
    var toString = require_tostring3();
    var util = require_util3();
    function base64url(string, encoding) {
      return Buffer2.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }
    __name(base64url, "base64url");
    function jwsSecuredInput(header, payload, encoding) {
      encoding = encoding || "utf8";
      var encodedHeader = base64url(toString(header), "binary");
      var encodedPayload = base64url(toString(payload), encoding);
      return util.format("%s.%s", encodedHeader, encodedPayload);
    }
    __name(jwsSecuredInput, "jwsSecuredInput");
    function jwsSign(opts) {
      var header = opts.header;
      var payload = opts.payload;
      var secretOrKey = opts.secret || opts.privateKey;
      var encoding = opts.encoding;
      var algo = jwa(header.alg);
      var securedInput = jwsSecuredInput(header, payload, encoding);
      var signature = algo.sign(securedInput, secretOrKey);
      return util.format("%s.%s", securedInput, signature);
    }
    __name(jwsSign, "jwsSign");
    function SignStream(opts) {
      var secret = opts.secret || opts.privateKey || opts.key;
      var secretStream = new DataStream(secret);
      this.readable = true;
      this.header = opts.header;
      this.encoding = opts.encoding;
      this.secret = this.privateKey = this.key = secretStream;
      this.payload = new DataStream(opts.payload);
      this.secret.once("close", function() {
        if (!this.payload.writable && this.readable)
          this.sign();
      }.bind(this));
      this.payload.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.sign();
      }.bind(this));
    }
    __name(SignStream, "SignStream");
    util.inherits(SignStream, Stream);
    SignStream.prototype.sign = /* @__PURE__ */ __name(function sign3() {
      try {
        var signature = jwsSign({
          header: this.header,
          payload: this.payload.buffer,
          secret: this.secret.buffer,
          encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "sign");
    SignStream.sign = jwsSign;
    module.exports = SignStream;
  }
});

// node_modules/jws/lib/verify-stream.js
var require_verify_stream3 = __commonJS({
  "node_modules/jws/lib/verify-stream.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Buffer2 = require_safe_buffer().Buffer;
    var DataStream = require_data_stream3();
    var jwa = require_jwa3();
    var Stream = require_stream();
    var toString = require_tostring3();
    var util = require_util3();
    var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
    function isObject3(thing) {
      return Object.prototype.toString.call(thing) === "[object Object]";
    }
    __name(isObject3, "isObject");
    function safeJsonParse(thing) {
      if (isObject3(thing))
        return thing;
      try {
        return JSON.parse(thing);
      } catch (e) {
        return void 0;
      }
    }
    __name(safeJsonParse, "safeJsonParse");
    function headerFromJWS(jwsSig) {
      var encodedHeader = jwsSig.split(".", 1)[0];
      return safeJsonParse(Buffer2.from(encodedHeader, "base64").toString("binary"));
    }
    __name(headerFromJWS, "headerFromJWS");
    function securedInputFromJWS(jwsSig) {
      return jwsSig.split(".", 2).join(".");
    }
    __name(securedInputFromJWS, "securedInputFromJWS");
    function signatureFromJWS(jwsSig) {
      return jwsSig.split(".")[2];
    }
    __name(signatureFromJWS, "signatureFromJWS");
    function payloadFromJWS(jwsSig, encoding) {
      encoding = encoding || "utf8";
      var payload = jwsSig.split(".")[1];
      return Buffer2.from(payload, "base64").toString(encoding);
    }
    __name(payloadFromJWS, "payloadFromJWS");
    function isValidJws(string) {
      return JWS_REGEX.test(string) && !!headerFromJWS(string);
    }
    __name(isValidJws, "isValidJws");
    function jwsVerify(jwsSig, algorithm, secretOrKey) {
      if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
      }
      jwsSig = toString(jwsSig);
      var signature = signatureFromJWS(jwsSig);
      var securedInput = securedInputFromJWS(jwsSig);
      var algo = jwa(algorithm);
      return algo.verify(securedInput, signature, secretOrKey);
    }
    __name(jwsVerify, "jwsVerify");
    function jwsDecode(jwsSig, opts) {
      opts = opts || {};
      jwsSig = toString(jwsSig);
      if (!isValidJws(jwsSig))
        return null;
      var header = headerFromJWS(jwsSig);
      if (!header)
        return null;
      var payload = payloadFromJWS(jwsSig);
      if (header.typ === "JWT" || opts.json)
        payload = JSON.parse(payload, opts.encoding);
      return {
        header,
        payload,
        signature: signatureFromJWS(jwsSig)
      };
    }
    __name(jwsDecode, "jwsDecode");
    function VerifyStream(opts) {
      opts = opts || {};
      var secretOrKey = opts.secret || opts.publicKey || opts.key;
      var secretStream = new DataStream(secretOrKey);
      this.readable = true;
      this.algorithm = opts.algorithm;
      this.encoding = opts.encoding;
      this.secret = this.publicKey = this.key = secretStream;
      this.signature = new DataStream(opts.signature);
      this.secret.once("close", function() {
        if (!this.signature.writable && this.readable)
          this.verify();
      }.bind(this));
      this.signature.once("close", function() {
        if (!this.secret.writable && this.readable)
          this.verify();
      }.bind(this));
    }
    __name(VerifyStream, "VerifyStream");
    util.inherits(VerifyStream, Stream);
    VerifyStream.prototype.verify = /* @__PURE__ */ __name(function verify3() {
      try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
      } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
      }
    }, "verify");
    VerifyStream.decode = jwsDecode;
    VerifyStream.isValid = isValidJws;
    VerifyStream.verify = jwsVerify;
    module.exports = VerifyStream;
  }
});

// node_modules/jws/index.js
var require_jws3 = __commonJS({
  "node_modules/jws/index.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SignStream = require_sign_stream3();
    var VerifyStream = require_verify_stream3();
    var ALGORITHMS = [
      "HS256",
      "HS384",
      "HS512",
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES384",
      "ES512"
    ];
    exports.ALGORITHMS = ALGORITHMS;
    exports.sign = SignStream.sign;
    exports.verify = VerifyStream.verify;
    exports.decode = VerifyStream.decode;
    exports.isValid = VerifyStream.isValid;
    exports.createSign = /* @__PURE__ */ __name(function createSign2(opts) {
      return new SignStream(opts);
    }, "createSign");
    exports.createVerify = /* @__PURE__ */ __name(function createVerify2(opts) {
      return new VerifyStream(opts);
    }, "createVerify");
  }
});

// node_modules/jsonwebtoken/decode.js
var require_decode = __commonJS({
  "node_modules/jsonwebtoken/decode.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var jws = require_jws3();
    module.exports = function(jwt, options) {
      options = options || {};
      var decoded = jws.decode(jwt, options);
      if (!decoded) {
        return null;
      }
      var payload = decoded.payload;
      if (typeof payload === "string") {
        try {
          var obj = JSON.parse(payload);
          if (obj !== null && typeof obj === "object") {
            payload = obj;
          }
        } catch (e) {
        }
      }
      if (options.complete === true) {
        return {
          header: decoded.header,
          payload,
          signature: decoded.signature
        };
      }
      return payload;
    };
  }
});

// node_modules/jsonwebtoken/lib/JsonWebTokenError.js
var require_JsonWebTokenError = __commonJS({
  "node_modules/jsonwebtoken/lib/JsonWebTokenError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = /* @__PURE__ */ __name(function(message2, error3) {
      Error.call(this, message2);
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = "JsonWebTokenError";
      this.message = message2;
      if (error3) this.inner = error3;
    }, "JsonWebTokenError");
    JsonWebTokenError.prototype = Object.create(Error.prototype);
    JsonWebTokenError.prototype.constructor = JsonWebTokenError;
    module.exports = JsonWebTokenError;
  }
});

// node_modules/jsonwebtoken/lib/NotBeforeError.js
var require_NotBeforeError = __commonJS({
  "node_modules/jsonwebtoken/lib/NotBeforeError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = /* @__PURE__ */ __name(function(message2, date) {
      JsonWebTokenError.call(this, message2);
      this.name = "NotBeforeError";
      this.date = date;
    }, "NotBeforeError");
    NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
    NotBeforeError.prototype.constructor = NotBeforeError;
    module.exports = NotBeforeError;
  }
});

// node_modules/jsonwebtoken/lib/TokenExpiredError.js
var require_TokenExpiredError = __commonJS({
  "node_modules/jsonwebtoken/lib/TokenExpiredError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var TokenExpiredError = /* @__PURE__ */ __name(function(message2, expiredAt) {
      JsonWebTokenError.call(this, message2);
      this.name = "TokenExpiredError";
      this.expiredAt = expiredAt;
    }, "TokenExpiredError");
    TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
    TokenExpiredError.prototype.constructor = TokenExpiredError;
    module.exports = TokenExpiredError;
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var s = 1e3;
    var m2 = s * 60;
    var h = m2 * 60;
    var d2 = h * 24;
    var w2 = d2 * 7;
    var y = d2 * 365.25;
    module.exports = function(val, options) {
      options = options || {};
      var type2 = typeof val;
      if (type2 === "string" && val.length > 0) {
        return parse2(val);
      } else if (type2 === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error(
        "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
      );
    };
    function parse2(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        str
      );
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type2 = (match[2] || "ms").toLowerCase();
      switch (type2) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w2;
        case "days":
        case "day":
        case "d":
          return n * d2;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m2;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse2, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return Math.round(ms / d2) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m2) {
        return Math.round(ms / m2) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d2) {
        return plural(ms, msAbs, d2, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m2) {
        return plural(ms, msAbs, m2, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/jsonwebtoken/lib/timespan.js
var require_timespan = __commonJS({
  "node_modules/jsonwebtoken/lib/timespan.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ms = require_ms();
    module.exports = function(time3, iat) {
      var timestamp = iat || Math.floor(Date.now() / 1e3);
      if (typeof time3 === "string") {
        var milliseconds = ms(time3);
        if (typeof milliseconds === "undefined") {
          return;
        }
        return Math.floor(timestamp + milliseconds / 1e3);
      } else if (typeof time3 === "number") {
        return timestamp + time3;
      } else {
        return;
      }
    };
  }
});

// node_modules/semver/internal/constants.js
var require_constants = __commonJS({
  "node_modules/semver/internal/constants.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SEMVER_SPEC_VERSION = "2.0.0";
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */
    9007199254740991;
    var MAX_SAFE_COMPONENT_LENGTH = 16;
    var MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
    var RELEASE_TYPES = [
      "major",
      "premajor",
      "minor",
      "preminor",
      "patch",
      "prepatch",
      "prerelease"
    ];
    module.exports = {
      MAX_LENGTH,
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_SAFE_INTEGER,
      RELEASE_TYPES,
      SEMVER_SPEC_VERSION,
      FLAG_INCLUDE_PRERELEASE: 1,
      FLAG_LOOSE: 2
    };
  }
});

// node_modules/semver/internal/debug.js
var require_debug2 = __commonJS({
  "node_modules/semver/internal/debug.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug5 = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args) => console.error("SEMVER", ...args) : () => {
    };
    module.exports = debug5;
  }
});

// node_modules/semver/internal/re.js
var require_re = __commonJS({
  "node_modules/semver/internal/re.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var {
      MAX_SAFE_COMPONENT_LENGTH,
      MAX_SAFE_BUILD_LENGTH,
      MAX_LENGTH
    } = require_constants();
    var debug5 = require_debug2();
    exports = module.exports = {};
    var re = exports.re = [];
    var safeRe = exports.safeRe = [];
    var src = exports.src = [];
    var t = exports.t = {};
    var R = 0;
    var LETTERDASHNUMBER = "[a-zA-Z0-9-]";
    var safeRegexReplacements = [
      ["\\s", 1],
      ["\\d", MAX_LENGTH],
      [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH]
    ];
    var makeSafeRegex = /* @__PURE__ */ __name((value) => {
      for (const [token, max] of safeRegexReplacements) {
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
      }
      return value;
    }, "makeSafeRegex");
    var createToken = /* @__PURE__ */ __name((name, value, isGlobal) => {
      const safe = makeSafeRegex(value);
      const index = R++;
      debug5(name, index, value);
      t[name] = index;
      src[index] = value;
      re[index] = new RegExp(value, isGlobal ? "g" : void 0);
      safeRe[index] = new RegExp(safe, isGlobal ? "g" : void 0);
    }, "createToken");
    createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
    createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
    createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
    createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})\\.(${src[t.NUMERICIDENTIFIER]})`);
    createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})\\.(${src[t.NUMERICIDENTIFIERLOOSE]})`);
    createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
    createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
    createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
    createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
    createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
    createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
    createToken("FULL", `^${src[t.FULLPLAIN]}$`);
    createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
    createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
    createToken("GTLT", "((?:<|>)?=?)");
    createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
    createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
    createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:\\.(${src[t.XRANGEIDENTIFIER]})(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?)?)?`);
    createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
    createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COERCEPLAIN", `${"(^|[^\\d])(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`);
    createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
    createToken("COERCEFULL", src[t.COERCEPLAIN] + `(?:${src[t.PRERELEASE]})?(?:${src[t.BUILD]})?(?:$|[^\\d])`);
    createToken("COERCERTL", src[t.COERCE], true);
    createToken("COERCERTLFULL", src[t.COERCEFULL], true);
    createToken("LONETILDE", "(?:~>?)");
    createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
    exports.tildeTrimReplace = "$1~";
    createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
    createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("LONECARET", "(?:\\^)");
    createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
    exports.caretTrimReplace = "$1^";
    createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
    createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
    createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
    createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
    createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
    exports.comparatorTrimReplace = "$1$2$3";
    createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})\\s+-\\s+(${src[t.XRANGEPLAIN]})\\s*$`);
    createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})\\s+-\\s+(${src[t.XRANGEPLAINLOOSE]})\\s*$`);
    createToken("STAR", "(<|>)?=?\\s*\\*");
    createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
    createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
  }
});

// node_modules/semver/internal/parse-options.js
var require_parse_options = __commonJS({
  "node_modules/semver/internal/parse-options.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var looseOption = Object.freeze({ loose: true });
    var emptyOpts = Object.freeze({});
    var parseOptions = /* @__PURE__ */ __name((options) => {
      if (!options) {
        return emptyOpts;
      }
      if (typeof options !== "object") {
        return looseOption;
      }
      return options;
    }, "parseOptions");
    module.exports = parseOptions;
  }
});

// node_modules/semver/internal/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/semver/internal/identifiers.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numeric = /^[0-9]+$/;
    var compareIdentifiers = /* @__PURE__ */ __name((a2, b2) => {
      const anum = numeric.test(a2);
      const bnum = numeric.test(b2);
      if (anum && bnum) {
        a2 = +a2;
        b2 = +b2;
      }
      return a2 === b2 ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a2 < b2 ? -1 : 1;
    }, "compareIdentifiers");
    var rcompareIdentifiers = /* @__PURE__ */ __name((a2, b2) => compareIdentifiers(b2, a2), "rcompareIdentifiers");
    module.exports = {
      compareIdentifiers,
      rcompareIdentifiers
    };
  }
});

// node_modules/semver/classes/semver.js
var require_semver = __commonJS({
  "node_modules/semver/classes/semver.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var debug5 = require_debug2();
    var { MAX_LENGTH, MAX_SAFE_INTEGER } = require_constants();
    var { safeRe: re, t } = require_re();
    var parseOptions = require_parse_options();
    var { compareIdentifiers } = require_identifiers();
    var SemVer = class _SemVer {
      static {
        __name(this, "SemVer");
      }
      constructor(version3, options) {
        options = parseOptions(options);
        if (version3 instanceof _SemVer) {
          if (version3.loose === !!options.loose && version3.includePrerelease === !!options.includePrerelease) {
            return version3;
          } else {
            version3 = version3.version;
          }
        } else if (typeof version3 !== "string") {
          throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version3}".`);
        }
        if (version3.length > MAX_LENGTH) {
          throw new TypeError(
            `version is longer than ${MAX_LENGTH} characters`
          );
        }
        debug5("SemVer", version3, options);
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        const m2 = version3.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m2) {
          throw new TypeError(`Invalid Version: ${version3}`);
        }
        this.raw = version3;
        this.major = +m2[1];
        this.minor = +m2[2];
        this.patch = +m2[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
          throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
          throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
          throw new TypeError("Invalid patch version");
        }
        if (!m2[4]) {
          this.prerelease = [];
        } else {
          this.prerelease = m2[4].split(".").map((id) => {
            if (/^[0-9]+$/.test(id)) {
              const num = +id;
              if (num >= 0 && num < MAX_SAFE_INTEGER) {
                return num;
              }
            }
            return id;
          });
        }
        this.build = m2[5] ? m2[5].split(".") : [];
        this.format();
      }
      format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
          this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
      }
      toString() {
        return this.version;
      }
      compare(other) {
        debug5("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof _SemVer)) {
          if (typeof other === "string" && other === this.version) {
            return 0;
          }
          other = new _SemVer(other, this.options);
        }
        if (other.version === this.version) {
          return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
      }
      compareMain(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
      }
      comparePre(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        if (this.prerelease.length && !other.prerelease.length) {
          return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
          return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
          return 0;
        }
        let i = 0;
        do {
          const a2 = this.prerelease[i];
          const b2 = other.prerelease[i];
          debug5("prerelease compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      compareBuild(other) {
        if (!(other instanceof _SemVer)) {
          other = new _SemVer(other, this.options);
        }
        let i = 0;
        do {
          const a2 = this.build[i];
          const b2 = other.build[i];
          debug5("build compare", i, a2, b2);
          if (a2 === void 0 && b2 === void 0) {
            return 0;
          } else if (b2 === void 0) {
            return 1;
          } else if (a2 === void 0) {
            return -1;
          } else if (a2 === b2) {
            continue;
          } else {
            return compareIdentifiers(a2, b2);
          }
        } while (++i);
      }
      // preminor will bump the version up to the next minor release, and immediately
      // down to pre-release. premajor and prepatch work the same way.
      inc(release3, identifier, identifierBase) {
        switch (release3) {
          case "premajor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor = 0;
            this.major++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "preminor":
            this.prerelease.length = 0;
            this.patch = 0;
            this.minor++;
            this.inc("pre", identifier, identifierBase);
            break;
          case "prepatch":
            this.prerelease.length = 0;
            this.inc("patch", identifier, identifierBase);
            this.inc("pre", identifier, identifierBase);
            break;
          // If the input is a non-prerelease version, this acts the same as
          // prepatch.
          case "prerelease":
            if (this.prerelease.length === 0) {
              this.inc("patch", identifier, identifierBase);
            }
            this.inc("pre", identifier, identifierBase);
            break;
          case "major":
            if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
              this.major++;
            }
            this.minor = 0;
            this.patch = 0;
            this.prerelease = [];
            break;
          case "minor":
            if (this.patch !== 0 || this.prerelease.length === 0) {
              this.minor++;
            }
            this.patch = 0;
            this.prerelease = [];
            break;
          case "patch":
            if (this.prerelease.length === 0) {
              this.patch++;
            }
            this.prerelease = [];
            break;
          // This probably shouldn't be used publicly.
          // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
          case "pre": {
            const base = Number(identifierBase) ? 1 : 0;
            if (!identifier && identifierBase === false) {
              throw new Error("invalid increment argument: identifier is empty");
            }
            if (this.prerelease.length === 0) {
              this.prerelease = [base];
            } else {
              let i = this.prerelease.length;
              while (--i >= 0) {
                if (typeof this.prerelease[i] === "number") {
                  this.prerelease[i]++;
                  i = -2;
                }
              }
              if (i === -1) {
                if (identifier === this.prerelease.join(".") && identifierBase === false) {
                  throw new Error("invalid increment argument: identifier already exists");
                }
                this.prerelease.push(base);
              }
            }
            if (identifier) {
              let prerelease = [identifier, base];
              if (identifierBase === false) {
                prerelease = [identifier];
              }
              if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                if (isNaN(this.prerelease[1])) {
                  this.prerelease = prerelease;
                }
              } else {
                this.prerelease = prerelease;
              }
            }
            break;
          }
          default:
            throw new Error(`invalid increment argument: ${release3}`);
        }
        this.raw = this.format();
        if (this.build.length) {
          this.raw += `+${this.build.join(".")}`;
        }
        return this;
      }
    };
    module.exports = SemVer;
  }
});

// node_modules/semver/functions/parse.js
var require_parse3 = __commonJS({
  "node_modules/semver/functions/parse.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse2 = /* @__PURE__ */ __name((version3, options, throwErrors = false) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      try {
        return new SemVer(version3, options);
      } catch (er) {
        if (!throwErrors) {
          return null;
        }
        throw er;
      }
    }, "parse");
    module.exports = parse2;
  }
});

// node_modules/semver/functions/valid.js
var require_valid = __commonJS({
  "node_modules/semver/functions/valid.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse2 = require_parse3();
    var valid = /* @__PURE__ */ __name((version3, options) => {
      const v2 = parse2(version3, options);
      return v2 ? v2.version : null;
    }, "valid");
    module.exports = valid;
  }
});

// node_modules/semver/functions/clean.js
var require_clean = __commonJS({
  "node_modules/semver/functions/clean.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse2 = require_parse3();
    var clean = /* @__PURE__ */ __name((version3, options) => {
      const s = parse2(version3.trim().replace(/^[=v]+/, ""), options);
      return s ? s.version : null;
    }, "clean");
    module.exports = clean;
  }
});

// node_modules/semver/functions/inc.js
var require_inc = __commonJS({
  "node_modules/semver/functions/inc.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var inc = /* @__PURE__ */ __name((version3, release3, options, identifier, identifierBase) => {
      if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = void 0;
      }
      try {
        return new SemVer(
          version3 instanceof SemVer ? version3.version : version3,
          options
        ).inc(release3, identifier, identifierBase).version;
      } catch (er) {
        return null;
      }
    }, "inc");
    module.exports = inc;
  }
});

// node_modules/semver/functions/diff.js
var require_diff = __commonJS({
  "node_modules/semver/functions/diff.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse2 = require_parse3();
    var diff = /* @__PURE__ */ __name((version1, version22) => {
      const v1 = parse2(version1, null, true);
      const v2 = parse2(version22, null, true);
      const comparison = v1.compare(v2);
      if (comparison === 0) {
        return null;
      }
      const v1Higher = comparison > 0;
      const highVersion = v1Higher ? v1 : v2;
      const lowVersion = v1Higher ? v2 : v1;
      const highHasPre = !!highVersion.prerelease.length;
      const lowHasPre = !!lowVersion.prerelease.length;
      if (lowHasPre && !highHasPre) {
        if (!lowVersion.patch && !lowVersion.minor) {
          return "major";
        }
        if (highVersion.patch) {
          return "patch";
        }
        if (highVersion.minor) {
          return "minor";
        }
        return "major";
      }
      const prefix = highHasPre ? "pre" : "";
      if (v1.major !== v2.major) {
        return prefix + "major";
      }
      if (v1.minor !== v2.minor) {
        return prefix + "minor";
      }
      if (v1.patch !== v2.patch) {
        return prefix + "patch";
      }
      return "prerelease";
    }, "diff");
    module.exports = diff;
  }
});

// node_modules/semver/functions/major.js
var require_major = __commonJS({
  "node_modules/semver/functions/major.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var major = /* @__PURE__ */ __name((a2, loose) => new SemVer(a2, loose).major, "major");
    module.exports = major;
  }
});

// node_modules/semver/functions/minor.js
var require_minor = __commonJS({
  "node_modules/semver/functions/minor.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var minor = /* @__PURE__ */ __name((a2, loose) => new SemVer(a2, loose).minor, "minor");
    module.exports = minor;
  }
});

// node_modules/semver/functions/patch.js
var require_patch = __commonJS({
  "node_modules/semver/functions/patch.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var patch = /* @__PURE__ */ __name((a2, loose) => new SemVer(a2, loose).patch, "patch");
    module.exports = patch;
  }
});

// node_modules/semver/functions/prerelease.js
var require_prerelease = __commonJS({
  "node_modules/semver/functions/prerelease.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var parse2 = require_parse3();
    var prerelease = /* @__PURE__ */ __name((version3, options) => {
      const parsed = parse2(version3, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }, "prerelease");
    module.exports = prerelease;
  }
});

// node_modules/semver/functions/compare.js
var require_compare = __commonJS({
  "node_modules/semver/functions/compare.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compare = /* @__PURE__ */ __name((a2, b2, loose) => new SemVer(a2, loose).compare(new SemVer(b2, loose)), "compare");
    module.exports = compare;
  }
});

// node_modules/semver/functions/rcompare.js
var require_rcompare = __commonJS({
  "node_modules/semver/functions/rcompare.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var rcompare = /* @__PURE__ */ __name((a2, b2, loose) => compare(b2, a2, loose), "rcompare");
    module.exports = rcompare;
  }
});

// node_modules/semver/functions/compare-loose.js
var require_compare_loose = __commonJS({
  "node_modules/semver/functions/compare-loose.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var compareLoose = /* @__PURE__ */ __name((a2, b2) => compare(a2, b2, true), "compareLoose");
    module.exports = compareLoose;
  }
});

// node_modules/semver/functions/compare-build.js
var require_compare_build = __commonJS({
  "node_modules/semver/functions/compare-build.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var compareBuild = /* @__PURE__ */ __name((a2, b2, loose) => {
      const versionA = new SemVer(a2, loose);
      const versionB = new SemVer(b2, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }, "compareBuild");
    module.exports = compareBuild;
  }
});

// node_modules/semver/functions/sort.js
var require_sort = __commonJS({
  "node_modules/semver/functions/sort.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var sort = /* @__PURE__ */ __name((list, loose) => list.sort((a2, b2) => compareBuild(a2, b2, loose)), "sort");
    module.exports = sort;
  }
});

// node_modules/semver/functions/rsort.js
var require_rsort = __commonJS({
  "node_modules/semver/functions/rsort.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compareBuild = require_compare_build();
    var rsort = /* @__PURE__ */ __name((list, loose) => list.sort((a2, b2) => compareBuild(b2, a2, loose)), "rsort");
    module.exports = rsort;
  }
});

// node_modules/semver/functions/gt.js
var require_gt = __commonJS({
  "node_modules/semver/functions/gt.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gt3 = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) > 0, "gt");
    module.exports = gt3;
  }
});

// node_modules/semver/functions/lt.js
var require_lt = __commonJS({
  "node_modules/semver/functions/lt.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lt = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) < 0, "lt");
    module.exports = lt;
  }
});

// node_modules/semver/functions/eq.js
var require_eq = __commonJS({
  "node_modules/semver/functions/eq.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var eq = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) === 0, "eq");
    module.exports = eq;
  }
});

// node_modules/semver/functions/neq.js
var require_neq = __commonJS({
  "node_modules/semver/functions/neq.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var neq = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) !== 0, "neq");
    module.exports = neq;
  }
});

// node_modules/semver/functions/gte.js
var require_gte = __commonJS({
  "node_modules/semver/functions/gte.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var gte = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) >= 0, "gte");
    module.exports = gte;
  }
});

// node_modules/semver/functions/lte.js
var require_lte = __commonJS({
  "node_modules/semver/functions/lte.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var compare = require_compare();
    var lte = /* @__PURE__ */ __name((a2, b2, loose) => compare(a2, b2, loose) <= 0, "lte");
    module.exports = lte;
  }
});

// node_modules/semver/functions/cmp.js
var require_cmp = __commonJS({
  "node_modules/semver/functions/cmp.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var eq = require_eq();
    var neq = require_neq();
    var gt3 = require_gt();
    var gte = require_gte();
    var lt = require_lt();
    var lte = require_lte();
    var cmp = /* @__PURE__ */ __name((a2, op, b2, loose) => {
      switch (op) {
        case "===":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 === b2;
        case "!==":
          if (typeof a2 === "object") {
            a2 = a2.version;
          }
          if (typeof b2 === "object") {
            b2 = b2.version;
          }
          return a2 !== b2;
        case "":
        case "=":
        case "==":
          return eq(a2, b2, loose);
        case "!=":
          return neq(a2, b2, loose);
        case ">":
          return gt3(a2, b2, loose);
        case ">=":
          return gte(a2, b2, loose);
        case "<":
          return lt(a2, b2, loose);
        case "<=":
          return lte(a2, b2, loose);
        default:
          throw new TypeError(`Invalid operator: ${op}`);
      }
    }, "cmp");
    module.exports = cmp;
  }
});

// node_modules/semver/functions/coerce.js
var require_coerce = __commonJS({
  "node_modules/semver/functions/coerce.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var parse2 = require_parse3();
    var { safeRe: re, t } = require_re();
    var coerce = /* @__PURE__ */ __name((version3, options) => {
      if (version3 instanceof SemVer) {
        return version3;
      }
      if (typeof version3 === "number") {
        version3 = String(version3);
      }
      if (typeof version3 !== "string") {
        return null;
      }
      options = options || {};
      let match = null;
      if (!options.rtl) {
        match = version3.match(options.includePrerelease ? re[t.COERCEFULL] : re[t.COERCE]);
      } else {
        const coerceRtlRegex = options.includePrerelease ? re[t.COERCERTLFULL] : re[t.COERCERTL];
        let next;
        while ((next = coerceRtlRegex.exec(version3)) && (!match || match.index + match[0].length !== version3.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }
          coerceRtlRegex.lastIndex = next.index + next[1].length + next[2].length;
        }
        coerceRtlRegex.lastIndex = -1;
      }
      if (match === null) {
        return null;
      }
      const major = match[2];
      const minor = match[3] || "0";
      const patch = match[4] || "0";
      const prerelease = options.includePrerelease && match[5] ? `-${match[5]}` : "";
      const build = options.includePrerelease && match[6] ? `+${match[6]}` : "";
      return parse2(`${major}.${minor}.${patch}${prerelease}${build}`, options);
    }, "coerce");
    module.exports = coerce;
  }
});

// node_modules/semver/internal/lrucache.js
var require_lrucache = __commonJS({
  "node_modules/semver/internal/lrucache.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor() {
        this.max = 1e3;
        this.map = /* @__PURE__ */ new Map();
      }
      get(key) {
        const value = this.map.get(key);
        if (value === void 0) {
          return void 0;
        } else {
          this.map.delete(key);
          this.map.set(key, value);
          return value;
        }
      }
      delete(key) {
        return this.map.delete(key);
      }
      set(key, value) {
        const deleted = this.delete(key);
        if (!deleted && value !== void 0) {
          if (this.map.size >= this.max) {
            const firstKey = this.map.keys().next().value;
            this.delete(firstKey);
          }
          this.map.set(key, value);
        }
        return this;
      }
    };
    module.exports = LRUCache;
  }
});

// node_modules/semver/classes/range.js
var require_range = __commonJS({
  "node_modules/semver/classes/range.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = class _Range {
      static {
        __name(this, "Range");
      }
      constructor(range, options) {
        options = parseOptions(options);
        if (range instanceof _Range) {
          if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
            return range;
          } else {
            return new _Range(range.raw, options);
          }
        }
        if (range instanceof Comparator) {
          this.raw = range.value;
          this.set = [[range]];
          this.format();
          return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        this.raw = range.trim().split(/\s+/).join(" ");
        this.set = this.raw.split("||").map((r) => this.parseRange(r.trim())).filter((c) => c.length);
        if (!this.set.length) {
          throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        if (this.set.length > 1) {
          const first = this.set[0];
          this.set = this.set.filter((c) => !isNullSet(c[0]));
          if (this.set.length === 0) {
            this.set = [first];
          } else if (this.set.length > 1) {
            for (const c of this.set) {
              if (c.length === 1 && isAny(c[0])) {
                this.set = [c];
                break;
              }
            }
          }
        }
        this.format();
      }
      format() {
        this.range = this.set.map((comps) => comps.join(" ").trim()).join("||").trim();
        return this.range;
      }
      toString() {
        return this.range;
      }
      parseRange(range) {
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
          return cached;
        }
        const loose = this.options.loose;
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug5("hyphen replace", range);
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug5("comparator trim", range);
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug5("tilde trim", range);
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug5("caret trim", range);
        let rangeList = range.split(" ").map((comp) => parseComparator(comp, this.options)).join(" ").split(/\s+/).map((comp) => replaceGTE0(comp, this.options));
        if (loose) {
          rangeList = rangeList.filter((comp) => {
            debug5("loose invalid filter", comp, this.options);
            return !!comp.match(re[t.COMPARATORLOOSE]);
          });
        }
        debug5("range list", rangeList);
        const rangeMap = /* @__PURE__ */ new Map();
        const comparators = rangeList.map((comp) => new Comparator(comp, this.options));
        for (const comp of comparators) {
          if (isNullSet(comp)) {
            return [comp];
          }
          rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
          rangeMap.delete("");
        }
        const result = [...rangeMap.values()];
        cache.set(memoKey, result);
        return result;
      }
      intersects(range, options) {
        if (!(range instanceof _Range)) {
          throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators) => {
          return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators) => {
            return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator) => {
              return rangeComparators.every((rangeComparator) => {
                return thisComparator.intersects(rangeComparator, options);
              });
            });
          });
        });
      }
      // if ANY of the sets match ALL of its comparators, then pass
      test(version3) {
        if (!version3) {
          return false;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        for (let i = 0; i < this.set.length; i++) {
          if (testSet(this.set[i], version3, this.options)) {
            return true;
          }
        }
        return false;
      }
    };
    module.exports = Range;
    var LRU = require_lrucache();
    var cache = new LRU();
    var parseOptions = require_parse_options();
    var Comparator = require_comparator();
    var debug5 = require_debug2();
    var SemVer = require_semver();
    var {
      safeRe: re,
      t,
      comparatorTrimReplace,
      tildeTrimReplace,
      caretTrimReplace
    } = require_re();
    var { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = require_constants();
    var isNullSet = /* @__PURE__ */ __name((c) => c.value === "<0.0.0-0", "isNullSet");
    var isAny = /* @__PURE__ */ __name((c) => c.value === "", "isAny");
    var isSatisfiable = /* @__PURE__ */ __name((comparators, options) => {
      let result = true;
      const remainingComparators = comparators.slice();
      let testComparator = remainingComparators.pop();
      while (result && remainingComparators.length) {
        result = remainingComparators.every((otherComparator) => {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }
      return result;
    }, "isSatisfiable");
    var parseComparator = /* @__PURE__ */ __name((comp, options) => {
      debug5("comp", comp, options);
      comp = replaceCarets(comp, options);
      debug5("caret", comp);
      comp = replaceTildes(comp, options);
      debug5("tildes", comp);
      comp = replaceXRanges(comp, options);
      debug5("xrange", comp);
      comp = replaceStars(comp, options);
      debug5("stars", comp);
      return comp;
    }, "parseComparator");
    var isX = /* @__PURE__ */ __name((id) => !id || id.toLowerCase() === "x" || id === "*", "isX");
    var replaceTildes = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceTilde(c, options)).join(" ");
    }, "replaceTildes");
    var replaceTilde = /* @__PURE__ */ __name((comp, options) => {
      const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, (_, M, m2, p2, pr2) => {
        debug5("tilde", comp, _, M, m2, p2, pr2);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p2)) {
          ret = `>=${M}.${m2}.0 <${M}.${+m2 + 1}.0-0`;
        } else if (pr2) {
          debug5("replaceTilde pr", pr2);
          ret = `>=${M}.${m2}.${p2}-${pr2} <${M}.${+m2 + 1}.0-0`;
        } else {
          ret = `>=${M}.${m2}.${p2} <${M}.${+m2 + 1}.0-0`;
        }
        debug5("tilde return", ret);
        return ret;
      });
    }, "replaceTilde");
    var replaceCarets = /* @__PURE__ */ __name((comp, options) => {
      return comp.trim().split(/\s+/).map((c) => replaceCaret(c, options)).join(" ");
    }, "replaceCarets");
    var replaceCaret = /* @__PURE__ */ __name((comp, options) => {
      debug5("caret", comp, options);
      const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      const z2 = options.includePrerelease ? "-0" : "";
      return comp.replace(r, (_, M, m2, p2, pr2) => {
        debug5("caret", comp, _, M, m2, p2, pr2);
        let ret;
        if (isX(M)) {
          ret = "";
        } else if (isX(m2)) {
          ret = `>=${M}.0.0${z2} <${+M + 1}.0.0-0`;
        } else if (isX(p2)) {
          if (M === "0") {
            ret = `>=${M}.${m2}.0${z2} <${M}.${+m2 + 1}.0-0`;
          } else {
            ret = `>=${M}.${m2}.0${z2} <${+M + 1}.0.0-0`;
          }
        } else if (pr2) {
          debug5("replaceCaret pr", pr2);
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p2}-${pr2} <${M}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p2}-${pr2} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p2}-${pr2} <${+M + 1}.0.0-0`;
          }
        } else {
          debug5("no pr");
          if (M === "0") {
            if (m2 === "0") {
              ret = `>=${M}.${m2}.${p2}${z2} <${M}.${m2}.${+p2 + 1}-0`;
            } else {
              ret = `>=${M}.${m2}.${p2}${z2} <${M}.${+m2 + 1}.0-0`;
            }
          } else {
            ret = `>=${M}.${m2}.${p2} <${+M + 1}.0.0-0`;
          }
        }
        debug5("caret return", ret);
        return ret;
      });
    }, "replaceCaret");
    var replaceXRanges = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceXRanges", comp, options);
      return comp.split(/\s+/).map((c) => replaceXRange(c, options)).join(" ");
    }, "replaceXRanges");
    var replaceXRange = /* @__PURE__ */ __name((comp, options) => {
      comp = comp.trim();
      const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, (ret, gtlt, M, m2, p2, pr2) => {
        debug5("xRange", comp, ret, gtlt, M, m2, p2, pr2);
        const xM = isX(M);
        const xm = xM || isX(m2);
        const xp = xm || isX(p2);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
          gtlt = "";
        }
        pr2 = options.includePrerelease ? "-0" : "";
        if (xM) {
          if (gtlt === ">" || gtlt === "<") {
            ret = "<0.0.0-0";
          } else {
            ret = "*";
          }
        } else if (gtlt && anyX) {
          if (xm) {
            m2 = 0;
          }
          p2 = 0;
          if (gtlt === ">") {
            gtlt = ">=";
            if (xm) {
              M = +M + 1;
              m2 = 0;
              p2 = 0;
            } else {
              m2 = +m2 + 1;
              p2 = 0;
            }
          } else if (gtlt === "<=") {
            gtlt = "<";
            if (xm) {
              M = +M + 1;
            } else {
              m2 = +m2 + 1;
            }
          }
          if (gtlt === "<") {
            pr2 = "-0";
          }
          ret = `${gtlt + M}.${m2}.${p2}${pr2}`;
        } else if (xm) {
          ret = `>=${M}.0.0${pr2} <${+M + 1}.0.0-0`;
        } else if (xp) {
          ret = `>=${M}.${m2}.0${pr2} <${M}.${+m2 + 1}.0-0`;
        }
        debug5("xRange return", ret);
        return ret;
      });
    }, "replaceXRange");
    var replaceStars = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceStars", comp, options);
      return comp.trim().replace(re[t.STAR], "");
    }, "replaceStars");
    var replaceGTE0 = /* @__PURE__ */ __name((comp, options) => {
      debug5("replaceGTE0", comp, options);
      return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
    }, "replaceGTE0");
    var hyphenReplace = /* @__PURE__ */ __name((incPr) => ($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr) => {
      if (isX(fM)) {
        from = "";
      } else if (isX(fm)) {
        from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
      } else if (isX(fp)) {
        from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
      } else if (fpr) {
        from = `>=${from}`;
      } else {
        from = `>=${from}${incPr ? "-0" : ""}`;
      }
      if (isX(tM)) {
        to = "";
      } else if (isX(tm)) {
        to = `<${+tM + 1}.0.0-0`;
      } else if (isX(tp)) {
        to = `<${tM}.${+tm + 1}.0-0`;
      } else if (tpr) {
        to = `<=${tM}.${tm}.${tp}-${tpr}`;
      } else if (incPr) {
        to = `<${tM}.${tm}.${+tp + 1}-0`;
      } else {
        to = `<=${to}`;
      }
      return `${from} ${to}`.trim();
    }, "hyphenReplace");
    var testSet = /* @__PURE__ */ __name((set, version3, options) => {
      for (let i = 0; i < set.length; i++) {
        if (!set[i].test(version3)) {
          return false;
        }
      }
      if (version3.prerelease.length && !options.includePrerelease) {
        for (let i = 0; i < set.length; i++) {
          debug5(set[i].semver);
          if (set[i].semver === Comparator.ANY) {
            continue;
          }
          if (set[i].semver.prerelease.length > 0) {
            const allowed = set[i].semver;
            if (allowed.major === version3.major && allowed.minor === version3.minor && allowed.patch === version3.patch) {
              return true;
            }
          }
        }
        return false;
      }
      return true;
    }, "testSet");
  }
});

// node_modules/semver/classes/comparator.js
var require_comparator = __commonJS({
  "node_modules/semver/classes/comparator.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ANY = Symbol("SemVer ANY");
    var Comparator = class _Comparator {
      static {
        __name(this, "Comparator");
      }
      static get ANY() {
        return ANY;
      }
      constructor(comp, options) {
        options = parseOptions(options);
        if (comp instanceof _Comparator) {
          if (comp.loose === !!options.loose) {
            return comp;
          } else {
            comp = comp.value;
          }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug5("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
          this.value = "";
        } else {
          this.value = this.operator + this.semver.version;
        }
        debug5("comp", this);
      }
      parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m2 = comp.match(r);
        if (!m2) {
          throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m2[1] !== void 0 ? m2[1] : "";
        if (this.operator === "=") {
          this.operator = "";
        }
        if (!m2[2]) {
          this.semver = ANY;
        } else {
          this.semver = new SemVer(m2[2], this.options.loose);
        }
      }
      toString() {
        return this.value;
      }
      test(version3) {
        debug5("Comparator.test", version3, this.options.loose);
        if (this.semver === ANY || version3 === ANY) {
          return true;
        }
        if (typeof version3 === "string") {
          try {
            version3 = new SemVer(version3, this.options);
          } catch (er) {
            return false;
          }
        }
        return cmp(version3, this.operator, this.semver, this.options);
      }
      intersects(comp, options) {
        if (!(comp instanceof _Comparator)) {
          throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
          if (this.value === "") {
            return true;
          }
          return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
          if (comp.value === "") {
            return true;
          }
          return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
          return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
          return false;
        }
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
          return true;
        }
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
          return true;
        }
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
          return true;
        }
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
          return true;
        }
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
          return true;
        }
        return false;
      }
    };
    module.exports = Comparator;
    var parseOptions = require_parse_options();
    var { safeRe: re, t } = require_re();
    var cmp = require_cmp();
    var debug5 = require_debug2();
    var SemVer = require_semver();
    var Range = require_range();
  }
});

// node_modules/semver/functions/satisfies.js
var require_satisfies = __commonJS({
  "node_modules/semver/functions/satisfies.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var satisfies = /* @__PURE__ */ __name((version3, range, options) => {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }
      return range.test(version3);
    }, "satisfies");
    module.exports = satisfies;
  }
});

// node_modules/semver/ranges/to-comparators.js
var require_to_comparators = __commonJS({
  "node_modules/semver/ranges/to-comparators.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var toComparators = /* @__PURE__ */ __name((range, options) => new Range(range, options).set.map((comp) => comp.map((c) => c.value).join(" ").trim().split(" ")), "toComparators");
    module.exports = toComparators;
  }
});

// node_modules/semver/ranges/max-satisfying.js
var require_max_satisfying = __commonJS({
  "node_modules/semver/ranges/max-satisfying.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var maxSatisfying = /* @__PURE__ */ __name((versions2, range, options) => {
      let max = null;
      let maxSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!max || maxSV.compare(v2) === -1) {
            max = v2;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }, "maxSatisfying");
    module.exports = maxSatisfying;
  }
});

// node_modules/semver/ranges/min-satisfying.js
var require_min_satisfying = __commonJS({
  "node_modules/semver/ranges/min-satisfying.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var minSatisfying = /* @__PURE__ */ __name((versions2, range, options) => {
      let min = null;
      let minSV = null;
      let rangeObj = null;
      try {
        rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }
      versions2.forEach((v2) => {
        if (rangeObj.test(v2)) {
          if (!min || minSV.compare(v2) === 1) {
            min = v2;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }, "minSatisfying");
    module.exports = minSatisfying;
  }
});

// node_modules/semver/ranges/min-version.js
var require_min_version = __commonJS({
  "node_modules/semver/ranges/min-version.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Range = require_range();
    var gt3 = require_gt();
    var minVersion = /* @__PURE__ */ __name((range, loose) => {
      range = new Range(range, loose);
      let minver = new SemVer("0.0.0");
      if (range.test(minver)) {
        return minver;
      }
      minver = new SemVer("0.0.0-0");
      if (range.test(minver)) {
        return minver;
      }
      minver = null;
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator) => {
          const compver = new SemVer(comparator.semver.version);
          switch (comparator.operator) {
            case ">":
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }
              compver.raw = compver.format();
            /* fallthrough */
            case "":
            case ">=":
              if (!setMin || gt3(compver, setMin)) {
                setMin = compver;
              }
              break;
            case "<":
            case "<=":
              break;
            /* istanbul ignore next */
            default:
              throw new Error(`Unexpected operation: ${comparator.operator}`);
          }
        });
        if (setMin && (!minver || gt3(minver, setMin))) {
          minver = setMin;
        }
      }
      if (minver && range.test(minver)) {
        return minver;
      }
      return null;
    }, "minVersion");
    module.exports = minVersion;
  }
});

// node_modules/semver/ranges/valid.js
var require_valid2 = __commonJS({
  "node_modules/semver/ranges/valid.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var validRange = /* @__PURE__ */ __name((range, options) => {
      try {
        return new Range(range, options).range || "*";
      } catch (er) {
        return null;
      }
    }, "validRange");
    module.exports = validRange;
  }
});

// node_modules/semver/ranges/outside.js
var require_outside = __commonJS({
  "node_modules/semver/ranges/outside.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var SemVer = require_semver();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var Range = require_range();
    var satisfies = require_satisfies();
    var gt3 = require_gt();
    var lt = require_lt();
    var lte = require_lte();
    var gte = require_gte();
    var outside = /* @__PURE__ */ __name((version3, range, hilo, options) => {
      version3 = new SemVer(version3, options);
      range = new Range(range, options);
      let gtfn, ltefn, ltfn, comp, ecomp;
      switch (hilo) {
        case ">":
          gtfn = gt3;
          ltefn = lte;
          ltfn = lt;
          comp = ">";
          ecomp = ">=";
          break;
        case "<":
          gtfn = lt;
          ltefn = gte;
          ltfn = gt3;
          comp = "<";
          ecomp = "<=";
          break;
        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      }
      if (satisfies(version3, range, options)) {
        return false;
      }
      for (let i = 0; i < range.set.length; ++i) {
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator) => {
          if (comparator.semver === ANY) {
            comparator = new Comparator(">=0.0.0");
          }
          high = high || comparator;
          low = low || comparator;
          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        });
        if (high.operator === comp || high.operator === ecomp) {
          return false;
        }
        if ((!low.operator || low.operator === comp) && ltefn(version3, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version3, low.semver)) {
          return false;
        }
      }
      return true;
    }, "outside");
    module.exports = outside;
  }
});

// node_modules/semver/ranges/gtr.js
var require_gtr = __commonJS({
  "node_modules/semver/ranges/gtr.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var gtr = /* @__PURE__ */ __name((version3, range, options) => outside(version3, range, ">", options), "gtr");
    module.exports = gtr;
  }
});

// node_modules/semver/ranges/ltr.js
var require_ltr = __commonJS({
  "node_modules/semver/ranges/ltr.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var outside = require_outside();
    var ltr = /* @__PURE__ */ __name((version3, range, options) => outside(version3, range, "<", options), "ltr");
    module.exports = ltr;
  }
});

// node_modules/semver/ranges/intersects.js
var require_intersects = __commonJS({
  "node_modules/semver/ranges/intersects.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var intersects = /* @__PURE__ */ __name((r1, r2, options) => {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2, options);
    }, "intersects");
    module.exports = intersects;
  }
});

// node_modules/semver/ranges/simplify.js
var require_simplify = __commonJS({
  "node_modules/semver/ranges/simplify.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var satisfies = require_satisfies();
    var compare = require_compare();
    module.exports = (versions2, range, options) => {
      const set = [];
      let first = null;
      let prev = null;
      const v2 = versions2.sort((a2, b2) => compare(a2, b2, options));
      for (const version3 of v2) {
        const included = satisfies(version3, range, options);
        if (included) {
          prev = version3;
          if (!first) {
            first = version3;
          }
        } else {
          if (prev) {
            set.push([first, prev]);
          }
          prev = null;
          first = null;
        }
      }
      if (first) {
        set.push([first, null]);
      }
      const ranges = [];
      for (const [min, max] of set) {
        if (min === max) {
          ranges.push(min);
        } else if (!max && min === v2[0]) {
          ranges.push("*");
        } else if (!max) {
          ranges.push(`>=${min}`);
        } else if (min === v2[0]) {
          ranges.push(`<=${max}`);
        } else {
          ranges.push(`${min} - ${max}`);
        }
      }
      const simplified = ranges.join(" || ");
      const original = typeof range.raw === "string" ? range.raw : String(range);
      return simplified.length < original.length ? simplified : range;
    };
  }
});

// node_modules/semver/ranges/subset.js
var require_subset = __commonJS({
  "node_modules/semver/ranges/subset.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Range = require_range();
    var Comparator = require_comparator();
    var { ANY } = Comparator;
    var satisfies = require_satisfies();
    var compare = require_compare();
    var subset = /* @__PURE__ */ __name((sub, dom, options = {}) => {
      if (sub === dom) {
        return true;
      }
      sub = new Range(sub, options);
      dom = new Range(dom, options);
      let sawNonNull = false;
      OUTER: for (const simpleSub of sub.set) {
        for (const simpleDom of dom.set) {
          const isSub = simpleSubset(simpleSub, simpleDom, options);
          sawNonNull = sawNonNull || isSub !== null;
          if (isSub) {
            continue OUTER;
          }
        }
        if (sawNonNull) {
          return false;
        }
      }
      return true;
    }, "subset");
    var minimumVersionWithPreRelease = [new Comparator(">=0.0.0-0")];
    var minimumVersion = [new Comparator(">=0.0.0")];
    var simpleSubset = /* @__PURE__ */ __name((sub, dom, options) => {
      if (sub === dom) {
        return true;
      }
      if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
          return true;
        } else if (options.includePrerelease) {
          sub = minimumVersionWithPreRelease;
        } else {
          sub = minimumVersion;
        }
      }
      if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
          return true;
        } else {
          dom = minimumVersion;
        }
      }
      const eqSet = /* @__PURE__ */ new Set();
      let gt3, lt;
      for (const c of sub) {
        if (c.operator === ">" || c.operator === ">=") {
          gt3 = higherGT(gt3, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
          lt = lowerLT(lt, c, options);
        } else {
          eqSet.add(c.semver);
        }
      }
      if (eqSet.size > 1) {
        return null;
      }
      let gtltComp;
      if (gt3 && lt) {
        gtltComp = compare(gt3.semver, lt.semver, options);
        if (gtltComp > 0) {
          return null;
        } else if (gtltComp === 0 && (gt3.operator !== ">=" || lt.operator !== "<=")) {
          return null;
        }
      }
      for (const eq of eqSet) {
        if (gt3 && !satisfies(eq, String(gt3), options)) {
          return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
          return null;
        }
        for (const c of dom) {
          if (!satisfies(eq, String(c), options)) {
            return false;
          }
        }
        return true;
      }
      let higher, lower;
      let hasDomLT, hasDomGT;
      let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
      let needDomGTPre = gt3 && !options.includePrerelease && gt3.semver.prerelease.length ? gt3.semver : false;
      if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
      }
      for (const c of dom) {
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt3) {
          if (needDomGTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
              needDomGTPre = false;
            }
          }
          if (c.operator === ">" || c.operator === ">=") {
            higher = higherGT(gt3, c, options);
            if (higher === c && higher !== gt3) {
              return false;
            }
          } else if (gt3.operator === ">=" && !satisfies(gt3.semver, String(c), options)) {
            return false;
          }
        }
        if (lt) {
          if (needDomLTPre) {
            if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
              needDomLTPre = false;
            }
          }
          if (c.operator === "<" || c.operator === "<=") {
            lower = lowerLT(lt, c, options);
            if (lower === c && lower !== lt) {
              return false;
            }
          } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
            return false;
          }
        }
        if (!c.operator && (lt || gt3) && gtltComp !== 0) {
          return false;
        }
      }
      if (gt3 && hasDomLT && !lt && gtltComp !== 0) {
        return false;
      }
      if (lt && hasDomGT && !gt3 && gtltComp !== 0) {
        return false;
      }
      if (needDomGTPre || needDomLTPre) {
        return false;
      }
      return true;
    }, "simpleSubset");
    var higherGT = /* @__PURE__ */ __name((a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp > 0 ? a2 : comp < 0 ? b2 : b2.operator === ">" && a2.operator === ">=" ? b2 : a2;
    }, "higherGT");
    var lowerLT = /* @__PURE__ */ __name((a2, b2, options) => {
      if (!a2) {
        return b2;
      }
      const comp = compare(a2.semver, b2.semver, options);
      return comp < 0 ? a2 : comp > 0 ? b2 : b2.operator === "<" && a2.operator === "<=" ? b2 : a2;
    }, "lowerLT");
    module.exports = subset;
  }
});

// node_modules/semver/index.js
var require_semver2 = __commonJS({
  "node_modules/semver/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var internalRe = require_re();
    var constants4 = require_constants();
    var SemVer = require_semver();
    var identifiers = require_identifiers();
    var parse2 = require_parse3();
    var valid = require_valid();
    var clean = require_clean();
    var inc = require_inc();
    var diff = require_diff();
    var major = require_major();
    var minor = require_minor();
    var patch = require_patch();
    var prerelease = require_prerelease();
    var compare = require_compare();
    var rcompare = require_rcompare();
    var compareLoose = require_compare_loose();
    var compareBuild = require_compare_build();
    var sort = require_sort();
    var rsort = require_rsort();
    var gt3 = require_gt();
    var lt = require_lt();
    var eq = require_eq();
    var neq = require_neq();
    var gte = require_gte();
    var lte = require_lte();
    var cmp = require_cmp();
    var coerce = require_coerce();
    var Comparator = require_comparator();
    var Range = require_range();
    var satisfies = require_satisfies();
    var toComparators = require_to_comparators();
    var maxSatisfying = require_max_satisfying();
    var minSatisfying = require_min_satisfying();
    var minVersion = require_min_version();
    var validRange = require_valid2();
    var outside = require_outside();
    var gtr = require_gtr();
    var ltr = require_ltr();
    var intersects = require_intersects();
    var simplifyRange = require_simplify();
    var subset = require_subset();
    module.exports = {
      parse: parse2,
      valid,
      clean,
      inc,
      diff,
      major,
      minor,
      patch,
      prerelease,
      compare,
      rcompare,
      compareLoose,
      compareBuild,
      sort,
      rsort,
      gt: gt3,
      lt,
      eq,
      neq,
      gte,
      lte,
      cmp,
      coerce,
      Comparator,
      Range,
      satisfies,
      toComparators,
      maxSatisfying,
      minSatisfying,
      minVersion,
      validRange,
      outside,
      gtr,
      ltr,
      intersects,
      simplifyRange,
      subset,
      SemVer,
      re: internalRe.re,
      src: internalRe.src,
      tokens: internalRe.t,
      SEMVER_SPEC_VERSION: constants4.SEMVER_SPEC_VERSION,
      RELEASE_TYPES: constants4.RELEASE_TYPES,
      compareIdentifiers: identifiers.compareIdentifiers,
      rcompareIdentifiers: identifiers.rcompareIdentifiers
    };
  }
});

// node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js
var require_asymmetricKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/asymmetricKeyDetailsSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=15.7.0");
  }
});

// node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js
var require_rsaPssKeyDetailsSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/rsaPssKeyDetailsSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, ">=16.9.0");
  }
});

// node_modules/jsonwebtoken/lib/validateAsymmetricKey.js
var require_validateAsymmetricKey = __commonJS({
  "node_modules/jsonwebtoken/lib/validateAsymmetricKey.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var ASYMMETRIC_KEY_DETAILS_SUPPORTED = require_asymmetricKeyDetailsSupported();
    var RSA_PSS_KEY_DETAILS_SUPPORTED = require_rsaPssKeyDetailsSupported();
    var allowedAlgorithmsForKeys = {
      "ec": ["ES256", "ES384", "ES512"],
      "rsa": ["RS256", "PS256", "RS384", "PS384", "RS512", "PS512"],
      "rsa-pss": ["PS256", "PS384", "PS512"]
    };
    var allowedCurves = {
      ES256: "prime256v1",
      ES384: "secp384r1",
      ES512: "secp521r1"
    };
    module.exports = function(algorithm, key) {
      if (!algorithm || !key) return;
      const keyType = key.asymmetricKeyType;
      if (!keyType) return;
      const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
      if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
      }
      if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
      }
      if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch (keyType) {
          case "ec":
            const keyCurve = key.asymmetricKeyDetails.namedCurve;
            const allowedCurve = allowedCurves[algorithm];
            if (keyCurve !== allowedCurve) {
              throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
            }
            break;
          case "rsa-pss":
            if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
              const length = parseInt(algorithm.slice(-3), 10);
              const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
              if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
              }
              if (saltLength !== void 0 && saltLength > length >> 3) {
                throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
              }
            }
            break;
        }
      }
    };
  }
});

// node_modules/jsonwebtoken/lib/psSupported.js
var require_psSupported = __commonJS({
  "node_modules/jsonwebtoken/lib/psSupported.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var semver = require_semver2();
    module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");
  }
});

// node_modules/jsonwebtoken/verify.js
var require_verify = __commonJS({
  "node_modules/jsonwebtoken/verify.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var JsonWebTokenError = require_JsonWebTokenError();
    var NotBeforeError = require_NotBeforeError();
    var TokenExpiredError = require_TokenExpiredError();
    var decode3 = require_decode();
    var timespan = require_timespan();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var PS_SUPPORTED = require_psSupported();
    var jws = require_jws3();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPublicKey: createPublicKey2 } = require_crypto2();
    var PUB_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var EC_KEY_ALGS = ["ES256", "ES384", "ES512"];
    var RSA_KEY_ALGS = ["RS256", "RS384", "RS512"];
    var HS_ALGS = ["HS256", "HS384", "HS512"];
    if (PS_SUPPORTED) {
      PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
      RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    }
    module.exports = function(jwtString, secretOrPublicKey, options, callback) {
      if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
      }
      if (!options) {
        options = {};
      }
      options = Object.assign({}, options);
      let done;
      if (callback) {
        done = callback;
      } else {
        done = /* @__PURE__ */ __name(function(err, data) {
          if (err) throw err;
          return data;
        }, "done");
      }
      if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
      }
      if (options.nonce !== void 0 && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
      }
      if (options.allowInvalidAsymmetricKeyTypes !== void 0 && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
      }
      const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1e3);
      if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
      }
      if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
      }
      const parts = jwtString.split(".");
      if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
      }
      let decodedToken;
      try {
        decodedToken = decode3(jwtString, { complete: true });
      } catch (err) {
        return done(err);
      }
      if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
      }
      const header = decodedToken.header;
      let getSecret;
      if (typeof secretOrPublicKey === "function") {
        if (!callback) {
          return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
      } else {
        getSecret = /* @__PURE__ */ __name(function(header2, secretCallback) {
          return secretCallback(null, secretOrPublicKey);
        }, "getSecret");
      }
      return getSecret(header, function(err, secretOrPublicKey2) {
        if (err) {
          return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey2) {
          return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey2) {
          return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
          return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey2 != null && !(secretOrPublicKey2 instanceof KeyObject2)) {
          try {
            secretOrPublicKey2 = createPublicKey2(secretOrPublicKey2);
          } catch (_) {
            try {
              secretOrPublicKey2 = createSecretKey2(typeof secretOrPublicKey2 === "string" ? Buffer.from(secretOrPublicKey2) : secretOrPublicKey2);
            } catch (_2) {
              return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
            }
          }
        }
        if (!options.algorithms) {
          if (secretOrPublicKey2.type === "secret") {
            options.algorithms = HS_ALGS;
          } else if (["rsa", "rsa-pss"].includes(secretOrPublicKey2.asymmetricKeyType)) {
            options.algorithms = RSA_KEY_ALGS;
          } else if (secretOrPublicKey2.asymmetricKeyType === "ec") {
            options.algorithms = EC_KEY_ALGS;
          } else {
            options.algorithms = PUB_KEY_ALGS;
          }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
          return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey2.type !== "secret") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey2.type !== "public") {
          return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
          try {
            validateAsymmetricKey(header.alg, secretOrPublicKey2);
          } catch (e) {
            return done(e);
          }
        }
        let valid;
        try {
          valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey2);
        } catch (e) {
          return done(e);
        }
        if (!valid) {
          return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
          if (typeof payload.nbf !== "number") {
            return done(new JsonWebTokenError("invalid nbf value"));
          }
          if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
            return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1e3)));
          }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
          if (typeof payload.exp !== "number") {
            return done(new JsonWebTokenError("invalid exp value"));
          }
          if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1e3)));
          }
        }
        if (options.audience) {
          const audiences = Array.isArray(options.audience) ? options.audience : [options.audience];
          const target = Array.isArray(payload.aud) ? payload.aud : [payload.aud];
          const match = target.some(function(targetAudience) {
            return audiences.some(function(audience) {
              return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
            });
          });
          if (!match) {
            return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
          }
        }
        if (options.issuer) {
          const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
          if (invalid_issuer) {
            return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
          }
        }
        if (options.subject) {
          if (payload.sub !== options.subject) {
            return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
          }
        }
        if (options.jwtid) {
          if (payload.jti !== options.jwtid) {
            return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
          }
        }
        if (options.nonce) {
          if (payload.nonce !== options.nonce) {
            return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
          }
        }
        if (options.maxAge) {
          if (typeof payload.iat !== "number") {
            return done(new JsonWebTokenError("iat required when maxAge is specified"));
          }
          const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
          if (typeof maxAgeTimestamp === "undefined") {
            return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
          }
          if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
            return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1e3)));
          }
        }
        if (options.complete === true) {
          const signature = decodedToken.signature;
          return done(null, {
            header,
            payload,
            signature
          });
        }
        return done(null, payload);
      });
    };
  }
});

// node_modules/lodash.includes/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.includes/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_SAFE_INTEGER = 9007199254740991;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var argsTag = "[object Arguments]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var freeParseInt = parseInt;
    function arrayMap(array, iteratee) {
      var index = -1, length = array ? array.length : 0, result = Array(length);
      while (++index < length) {
        result[index] = iteratee(array[index], index, array);
      }
      return result;
    }
    __name(arrayMap, "arrayMap");
    function baseFindIndex(array, predicate, fromIndex, fromRight) {
      var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
      while (fromRight ? index-- : ++index < length) {
        if (predicate(array[index], index, array)) {
          return index;
        }
      }
      return -1;
    }
    __name(baseFindIndex, "baseFindIndex");
    function baseIndexOf(array, value, fromIndex) {
      if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
      }
      var index = fromIndex - 1, length = array.length;
      while (++index < length) {
        if (array[index] === value) {
          return index;
        }
      }
      return -1;
    }
    __name(baseIndexOf, "baseIndexOf");
    function baseIsNaN(value) {
      return value !== value;
    }
    __name(baseIsNaN, "baseIsNaN");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function baseValues(object, props) {
      return arrayMap(props, function(key) {
        return object[key];
      });
    }
    __name(baseValues, "baseValues");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var objectProto = Object.prototype;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var nativeKeys = overArg(Object.keys, Object);
    var nativeMax = Math.max;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString2(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
    }
    __name(includes, "includes");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function values(object) {
      return object ? baseValues(object, keys(object)) : [];
    }
    __name(values, "values");
    module.exports = includes;
  }
});

// node_modules/lodash.isboolean/index.js
var require_lodash2 = __commonJS({
  "node_modules/lodash.isboolean/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var boolTag = "[object Boolean]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isBoolean2(value) {
      return value === true || value === false || isObjectLike2(value) && objectToString.call(value) == boolTag;
    }
    __name(isBoolean2, "isBoolean");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    module.exports = isBoolean2;
  }
});

// node_modules/lodash.isinteger/index.js
var require_lodash3 = __commonJS({
  "node_modules/lodash.isinteger/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isInteger(value) {
      return typeof value == "number" && value == toInteger(value);
    }
    __name(isInteger, "isInteger");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = isInteger;
  }
});

// node_modules/lodash.isnumber/index.js
var require_lodash4 = __commonJS({
  "node_modules/lodash.isnumber/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var numberTag = "[object Number]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isNumber2(value) {
      return typeof value == "number" || isObjectLike2(value) && objectToString.call(value) == numberTag;
    }
    __name(isNumber2, "isNumber");
    module.exports = isNumber2;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash5 = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isPlainObject(value) {
      if (!isObjectLike2(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    __name(isPlainObject, "isPlainObject");
    module.exports = isPlainObject;
  }
});

// node_modules/lodash.isstring/index.js
var require_lodash6 = __commonJS({
  "node_modules/lodash.isstring/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var stringTag = "[object String]";
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var isArray2 = Array.isArray;
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isString2(value) {
      return typeof value == "string" || !isArray2(value) && isObjectLike2(value) && objectToString.call(value) == stringTag;
    }
    __name(isString2, "isString");
    module.exports = isString2;
  }
});

// node_modules/lodash.once/index.js
var require_lodash7 = __commonJS({
  "node_modules/lodash.once/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var FUNC_ERROR_TEXT = "Expected a function";
    var INFINITY = 1 / 0;
    var MAX_INTEGER = 17976931348623157e292;
    var NAN = 0 / 0;
    var symbolTag = "[object Symbol]";
    var reTrim = /^\s+|\s+$/g;
    var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
    var reIsBinary = /^0b[01]+$/i;
    var reIsOctal = /^0o[0-7]+$/i;
    var freeParseInt = parseInt;
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    function before(n, func) {
      var result;
      if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = void 0;
        }
        return result;
      };
    }
    __name(before, "before");
    function once2(func) {
      return before(2, func);
    }
    __name(once2, "once");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function isSymbol2(value) {
      return typeof value == "symbol" || isObjectLike2(value) && objectToString.call(value) == symbolTag;
    }
    __name(isSymbol2, "isSymbol");
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign3 = value < 0 ? -1 : 1;
        return sign3 * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }
    __name(toFinite, "toFinite");
    function toInteger(value) {
      var result = toFinite(value), remainder = result % 1;
      return result === result ? remainder ? result - remainder : result : 0;
    }
    __name(toInteger, "toInteger");
    function toNumber(value) {
      if (typeof value == "number") {
        return value;
      }
      if (isSymbol2(value)) {
        return NAN;
      }
      if (isObject3(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject3(other) ? other + "" : other;
      }
      if (typeof value != "string") {
        return value === 0 ? value : +value;
      }
      value = value.replace(reTrim, "");
      var isBinary = reIsBinary.test(value);
      return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
    }
    __name(toNumber, "toNumber");
    module.exports = once2;
  }
});

// node_modules/jsonwebtoken/sign.js
var require_sign = __commonJS({
  "node_modules/jsonwebtoken/sign.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var timespan = require_timespan();
    var PS_SUPPORTED = require_psSupported();
    var validateAsymmetricKey = require_validateAsymmetricKey();
    var jws = require_jws3();
    var includes = require_lodash();
    var isBoolean2 = require_lodash2();
    var isInteger = require_lodash3();
    var isNumber2 = require_lodash4();
    var isPlainObject = require_lodash5();
    var isString2 = require_lodash6();
    var once2 = require_lodash7();
    var { KeyObject: KeyObject2, createSecretKey: createSecretKey2, createPrivateKey: createPrivateKey2 } = require_crypto2();
    var SUPPORTED_ALGS = ["RS256", "RS384", "RS512", "ES256", "ES384", "ES512", "HS256", "HS384", "HS512", "none"];
    if (PS_SUPPORTED) {
      SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
    }
    var sign_options_schema = {
      expiresIn: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"expiresIn" should be a number of seconds or string representing a timespan' },
      notBefore: { isValid: /* @__PURE__ */ __name(function(value) {
        return isInteger(value) || isString2(value) && value;
      }, "isValid"), message: '"notBefore" should be a number of seconds or string representing a timespan' },
      audience: { isValid: /* @__PURE__ */ __name(function(value) {
        return isString2(value) || Array.isArray(value);
      }, "isValid"), message: '"audience" must be a string or array' },
      algorithm: { isValid: includes.bind(null, SUPPORTED_ALGS), message: '"algorithm" must be a valid string enum value' },
      header: { isValid: isPlainObject, message: '"header" must be an object' },
      encoding: { isValid: isString2, message: '"encoding" must be a string' },
      issuer: { isValid: isString2, message: '"issuer" must be a string' },
      subject: { isValid: isString2, message: '"subject" must be a string' },
      jwtid: { isValid: isString2, message: '"jwtid" must be a string' },
      noTimestamp: { isValid: isBoolean2, message: '"noTimestamp" must be a boolean' },
      keyid: { isValid: isString2, message: '"keyid" must be a string' },
      mutatePayload: { isValid: isBoolean2, message: '"mutatePayload" must be a boolean' },
      allowInsecureKeySizes: { isValid: isBoolean2, message: '"allowInsecureKeySizes" must be a boolean' },
      allowInvalidAsymmetricKeyTypes: { isValid: isBoolean2, message: '"allowInvalidAsymmetricKeyTypes" must be a boolean' }
    };
    var registered_claims_schema = {
      iat: { isValid: isNumber2, message: '"iat" should be a number of seconds' },
      exp: { isValid: isNumber2, message: '"exp" should be a number of seconds' },
      nbf: { isValid: isNumber2, message: '"nbf" should be a number of seconds' }
    };
    function validate(schema, allowUnknown, object, parameterName) {
      if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
      }
      Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
          if (!allowUnknown) {
            throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
          }
          return;
        }
        if (!validator.isValid(object[key])) {
          throw new Error(validator.message);
        }
      });
    }
    __name(validate, "validate");
    function validateOptions(options) {
      return validate(sign_options_schema, false, options, "options");
    }
    __name(validateOptions, "validateOptions");
    function validatePayload(payload) {
      return validate(registered_claims_schema, true, payload, "payload");
    }
    __name(validatePayload, "validatePayload");
    var options_to_payload = {
      "audience": "aud",
      "issuer": "iss",
      "subject": "sub",
      "jwtid": "jti"
    };
    var options_for_objects = [
      "expiresIn",
      "notBefore",
      "noTimestamp",
      "audience",
      "issuer",
      "subject",
      "jwtid"
    ];
    module.exports = function(payload, secretOrPrivateKey, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else {
        options = options || {};
      }
      const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
      const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : void 0,
        kid: options.keyid
      }, options.header);
      function failure(err) {
        if (callback) {
          return callback(err);
        }
        throw err;
      }
      __name(failure, "failure");
      if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
      }
      if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject2)) {
        try {
          secretOrPrivateKey = createPrivateKey2(secretOrPrivateKey);
        } catch (_) {
          try {
            secretOrPrivateKey = createSecretKey2(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
          } catch (_2) {
            return failure(new Error("secretOrPrivateKey is not valid key material"));
          }
        }
      }
      if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
      } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
          return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== void 0 && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
          return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
      }
      if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
      } else if (isObjectPayload) {
        try {
          validatePayload(payload);
        } catch (error3) {
          return failure(error3);
        }
        if (!options.mutatePayload) {
          payload = Object.assign({}, payload);
        }
      } else {
        const invalid_options = options_for_objects.filter(function(opt) {
          return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
          return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
      }
      if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
      }
      if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
      }
      try {
        validateOptions(options);
      } catch (error3) {
        return failure(error3);
      }
      if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
          validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error3) {
          return failure(error3);
        }
      }
      const timestamp = payload.iat || Math.floor(Date.now() / 1e3);
      if (options.noTimestamp) {
        delete payload.iat;
      } else if (isObjectPayload) {
        payload.iat = timestamp;
      }
      if (typeof options.notBefore !== "undefined") {
        try {
          payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
          return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
          payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
          return failure(err);
        }
        if (typeof payload.exp === "undefined") {
          return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
      }
      Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
          if (typeof payload[claim] !== "undefined") {
            return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
          }
          payload[claim] = options[key];
        }
      });
      const encoding = options.encoding || "utf8";
      if (typeof callback === "function") {
        callback = callback && once2(callback);
        jws.createSign({
          header,
          privateKey: secretOrPrivateKey,
          payload,
          encoding
        }).once("error", callback).once("done", function(signature) {
          if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
          }
          callback(null, signature);
        });
      } else {
        let signature = jws.sign({ header, payload, secret: secretOrPrivateKey, encoding });
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
          throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
      }
    };
  }
});

// node_modules/jsonwebtoken/index.js
var require_jsonwebtoken = __commonJS({
  "node_modules/jsonwebtoken/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      decode: require_decode(),
      verify: require_verify(),
      sign: require_sign(),
      JsonWebTokenError: require_JsonWebTokenError(),
      NotBeforeError: require_NotBeforeError(),
      TokenExpiredError: require_TokenExpiredError()
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    webcrypto_default = crypto;
    isCryptoKey = /* @__PURE__ */ __name((key) => key instanceof CryptoKey, "isCryptoKey");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/digest.js
var digest, digest_default;
var init_digest = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/digest.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    digest = /* @__PURE__ */ __name(async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    }, "digest");
    digest_default = digest;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
function p2s(alg, p2sInput) {
  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf = new Uint8Array(4 + secret.length + value.length);
    buf.set(uint32be(iter + 1));
    buf.set(secret, 4);
    buf.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_digest();
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
    __name(concat, "concat");
    __name(p2s, "p2s");
    __name(writeUInt32BE, "writeUInt32BE");
    __name(uint64be, "uint64be");
    __name(uint32be, "uint32be");
    __name(lengthAndInput, "lengthAndInput");
    __name(concatKdf, "concatKdf");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode, decodeBase64, decode;
var init_base64url = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_buffer_utils();
    encodeBase64 = /* @__PURE__ */ __name((input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    }, "encodeBase64");
    encode = /* @__PURE__ */ __name((input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    }, "encode");
    decodeBase64 = /* @__PURE__ */ __name((encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }, "decodeBase64");
    decode = /* @__PURE__ */ __name((input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    }, "decode");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecompressionFailed: () => JWEDecompressionFailed,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEDecompressionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/util/errors.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    JOSEError = class extends Error {
      static {
        __name(this, "JOSEError");
      }
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        var _a;
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static {
        __name(this, "JWTClaimValidationFailed");
      }
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static {
        __name(this, "JWTExpired");
      }
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      static {
        __name(this, "JOSEAlgNotAllowed");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      static {
        __name(this, "JOSENotSupported");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      static {
        __name(this, "JWEDecryptionFailed");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEDecompressionFailed = class extends JOSEError {
      static {
        __name(this, "JWEDecompressionFailed");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECOMPRESSION_FAILED";
        this.message = "decompression operation failed";
      }
      static get code() {
        return "ERR_JWE_DECOMPRESSION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      static {
        __name(this, "JWEInvalid");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      static {
        __name(this, "JWSInvalid");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      static {
        __name(this, "JWTInvalid");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      static {
        __name(this, "JWKInvalid");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      static {
        __name(this, "JWKSInvalid");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      static {
        __name(this, "JWKSNoMatchingKey");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      static {
        __name(this, "JWKSMultipleMatchingKeys");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      static {
        __name(this, "JWKSTimeout");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      static {
        __name(this, "JWSSignatureVerificationFailed");
      }
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/random.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/iv.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_random();
    __name(bitLength, "bitLength");
    iv_default = /* @__PURE__ */ __name((alg) => random_default(new Uint8Array(bitLength(alg) >> 3)), "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength, check_iv_length_default;
var init_check_iv_length = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_iv();
    checkIvLength = /* @__PURE__ */ __name((enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    }, "checkIvLength");
    check_iv_length_default = checkIvLength;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/check_cek_length.js
var checkCekLength, check_cek_length_default;
var init_check_cek_length = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    checkCekLength = /* @__PURE__ */ __name((cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    }, "checkCekLength");
    check_cek_length_default = checkCekLength;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var timingSafeEqual2, timing_safe_equal_default;
var init_timing_safe_equal = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    timingSafeEqual2 = /* @__PURE__ */ __name((a2, b2) => {
      if (!(a2 instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b2 instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a2.length !== b2.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a2.length;
      let out = 0;
      let i = -1;
      while (++i < len) {
        out |= a2[i] ^ b2[i];
      }
      return out === 0;
    }, "timingSafeEqual");
    timing_safe_equal_default = timingSafeEqual2;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash2) {
  return parseInt(hash2.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/crypto_key.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(unusable, "unusable");
    __name(isAlgorithm, "isAlgorithm");
    __name(getHashLength, "getHashLength");
    __name(getNamedCurve, "getNamedCurve");
    __name(checkUsage, "checkUsage");
    __name(checkSigCryptoKey, "checkSigCryptoKey");
    __name(checkEncCryptoKey, "checkEncCryptoKey");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types4) {
  if (types4.length > 2) {
    const last = types4.pop();
    msg += `one of type ${types4.join(", ")}, or ${last}.`;
  } else if (types4.length === 2) {
    msg += `one of type ${types4[0]} or ${types4[1]}.`;
  } else {
    msg += `of type ${types4[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types4) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types4);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(message, "message");
    invalid_key_input_default = /* @__PURE__ */ __name((actual, ...types4) => {
      return message("Key must be ", actual, ...types4);
    }, "default");
    __name(withAlg, "withAlg");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types3;
var init_is_key_like = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    is_key_like_default = /* @__PURE__ */ __name((key) => {
      return isCryptoKey(key);
    }, "default");
    types3 = ["CryptoKey"];
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag, expectedTag);
  } catch (_a) {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch (_b) {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag)));
  } catch (_a) {
    throw new JWEDecryptionFailed();
  }
}
var decrypt, decrypt_default;
var init_decrypt = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    __name(cbcDecrypt, "cbcDecrypt");
    __name(gcmDecrypt, "gcmDecrypt");
    decrypt = /* @__PURE__ */ __name(async (enc, cek, ciphertext, iv, tag, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types3, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    }, "decrypt");
    decrypt_default = decrypt;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/zlib.js
var inflate, deflate;
var init_zlib = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/zlib.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    inflate = /* @__PURE__ */ __name(async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
    }, "inflate");
    deflate = /* @__PURE__ */ __name(async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
    }, "deflate");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    isDisjoint = /* @__PURE__ */ __name((...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    }, "isDisjoint");
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject2(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/is_object.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    __name(isObjectLike, "isObjectLike");
    __name(isObject2, "isObject");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/bogus.js
var bogusWebCrypto, bogus_default;
var init_bogus = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/bogus.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types3, "Uint8Array"));
}
var wrap, unwrap;
var init_aeskw = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    __name(checkKeySize, "checkKeySize");
    __name(getCryptoKey, "getCryptoKey");
    wrap = /* @__PURE__ */ __name(async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    }, "wrap");
    unwrap = /* @__PURE__ */ __name(async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    }, "unwrap");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/ecdhes.js
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types3));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types3));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types3));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types3));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    __name(deriveKey, "deriveKey");
    __name(generateEpk, "generateEpk");
    __name(ecdhAllowed, "ecdhAllowed");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_p2s.js
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    __name(checkP2s, "checkP2s");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types3, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt, decrypt2;
var init_pbes2kw = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    __name(getCryptoKey2, "getCryptoKey");
    __name(deriveKey2, "deriveKey");
    encrypt = /* @__PURE__ */ __name(async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode(p2s2) };
    }, "encrypt");
    decrypt2 = /* @__PURE__ */ __name(async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    }, "decrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/subtle_rsaes.js
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    __name(subtleRsaEs, "subtleRsaEs");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    check_key_length_default = /* @__PURE__ */ __name((alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    }, "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2, decrypt3;
var init_rsaes = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = /* @__PURE__ */ __name(async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types3));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    }, "encrypt");
    decrypt3 = /* @__PURE__ */ __name(async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types3));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    }, "decrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/cek.js
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/cek.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_random();
    __name(bitLength2, "bitLength");
    cek_default = /* @__PURE__ */ __name((alg) => random_default(new Uint8Array(bitLength2(alg) >> 3)), "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/format_pem.js
var format_pem_default;
var init_format_pem = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/format_pem.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    format_pem_default = /* @__PURE__ */ __name((b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    }, "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/asn1.js
function getElement(seq) {
  let result = [];
  let next = 0;
  while (next < seq.length) {
    let nextPart = parseElement(seq.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes) {
  let position = 0;
  let tag = bytes[0] & 31;
  position++;
  if (tag === 31) {
    tag = 0;
    while (bytes[position] >= 128) {
      tag = tag * 128 + bytes[position] - 128;
      position++;
    }
    tag = tag * 128 + bytes[position] - 128;
    position++;
  }
  let length = 0;
  if (bytes[position] < 128) {
    length = bytes[position];
    position++;
  } else if (length === 128) {
    length = 0;
    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
      if (length > bytes.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length++;
    }
    const byteLength2 = position + length + 2;
    return {
      byteLength: byteLength2,
      contents: bytes.subarray(position, position + length),
      raw: bytes.subarray(0, byteLength2)
    };
  } else {
    let numberOfDigits = bytes[position] & 127;
    position++;
    length = 0;
    for (let i = 0; i < numberOfDigits; i++) {
      length = length * 256 + bytes[position];
      position++;
    }
  }
  const byteLength = position + length;
  return {
    byteLength,
    contents: bytes.subarray(position, byteLength),
    raw: bytes.subarray(0, byteLength)
  };
}
function spkiFromX509(buf) {
  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
var genericExport, toSPKI, toPKCS8, findOid, getNamedCurve2, genericImport, fromPKCS8, fromSPKI, fromX509;
var init_asn1 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
    genericExport = /* @__PURE__ */ __name(async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types3));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    }, "genericExport");
    toSPKI = /* @__PURE__ */ __name((key) => {
      return genericExport("public", "spki", key);
    }, "toSPKI");
    toPKCS8 = /* @__PURE__ */ __name((key) => {
      return genericExport("private", "pkcs8", key);
    }, "toPKCS8");
    findOid = /* @__PURE__ */ __name((keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      let i = keyData.indexOf(oid[0], from);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    }, "findOid");
    getNamedCurve2 = /* @__PURE__ */ __name((keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    }, "getNamedCurve");
    genericImport = /* @__PURE__ */ __name(async (replace, keyFormat, pem, alg, options) => {
      var _a;
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
    }, "genericImport");
    fromPKCS8 = /* @__PURE__ */ __name((pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    }, "fromPKCS8");
    fromSPKI = /* @__PURE__ */ __name((pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    }, "fromSPKI");
    __name(getElement, "getElement");
    __name(parseElement, "parseElement");
    __name(spkiFromX509, "spkiFromX509");
    __name(getSPKI, "getSPKI");
    fromX509 = /* @__PURE__ */ __name((pem, alg, options) => {
      let spki;
      try {
        spki = getSPKI(pem);
      } catch (cause) {
        throw new TypeError("Failed to parse the X.509 certificate", { cause });
      }
      return fromSPKI(spki, alg, options);
    }, "fromX509");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    init_errors();
    init_base64url();
    __name(subtleMapping, "subtleMapping");
    parse = /* @__PURE__ */ __name(async (jwk) => {
      var _a, _b;
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
      ];
      if (algorithm.name === "PBKDF2") {
        return webcrypto_default.subtle.importKey("raw", decode(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    }, "parse");
    jwk_to_key_default = parse;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/key/import.js
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  return fromX509(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a;
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/key/import.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_is_object();
    __name(importSPKI, "importSPKI");
    __name(importX509, "importX509");
    __name(importPKCS8, "importPKCS8");
    __name(importJWK, "importJWK");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = /* @__PURE__ */ __name((alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types3, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types3.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    }, "symmetricTypeCheck");
    asymmetricTypeCheck = /* @__PURE__ */ __name((alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types3));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types3.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    }, "asymmetricTypeCheck");
    checkKeyType = /* @__PURE__ */ __name((alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    }, "checkKeyType");
    check_key_type_default = checkKeyType;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/encrypt.js
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag };
}
var encrypt3, encrypt_default;
var init_encrypt = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
    __name(cbcEncrypt, "cbcEncrypt");
    __name(gcmEncrypt, "gcmEncrypt");
    encrypt3 = /* @__PURE__ */ __name(async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types3, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    }, "encrypt");
    encrypt_default = encrypt3;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode(iv), tag: encode(tag) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
var init_aesgcmkw = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
    __name(wrap2, "wrap");
    __name(unwrap2, "unwrap");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject2(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode(joseHeader.apu);
        } catch (_a) {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode(joseHeader.apv);
        } catch (_b) {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode(joseHeader.p2s);
      } catch (_c) {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode(joseHeader.iv);
      } catch (_d) {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag;
      try {
        tag = decode(joseHeader.tag);
      } catch (_e) {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg, key, encryptedKey, iv, tag);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    __name(decryptKeyManagement, "decryptKeyManagement");
    decrypt_key_management_default = decryptKeyManagement;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    __name(validateCrit, "validateCrit");
    validate_crit_default = validateCrit;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    validateAlgorithms = /* @__PURE__ */ __name((option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    }, "validateAlgorithms");
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  var _a;
  if (!isObject2(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject2(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject2(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch (_b) {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    if (!parsedProt || !parsedProt.zip) {
      throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    if (joseHeader.zip !== "DEF") {
      throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode(jwe.encrypted_key);
    } catch (_c) {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  let iv;
  let tag;
  try {
    iv = decode(jwe.iv);
  } catch (_d) {
    throw new JWEInvalid("Failed to base64url decode the iv");
  }
  try {
    tag = decode(jwe.tag);
  } catch (_e) {
    throw new JWEInvalid("Failed to base64url decode the tag");
  }
  const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode(jwe.ciphertext);
  } catch (_f) {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  let plaintext = await decrypt_default(enc, cek, ciphertext, iv, tag, additionalData);
  if (joseHeader.zip === "DEF") {
    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  }
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode(jwe.aad);
    } catch (_g) {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_decrypt();
    init_zlib();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
    __name(flattenedDecrypt, "flattenedDecrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader || void 0,
    tag: tag || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_decrypt2();
    init_errors();
    init_buffer_utils();
    __name(compactDecrypt, "compactDecrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/general/decrypt.js
async function generalDecrypt(jwe, key, options) {
  if (!isObject2(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject2)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_decrypt2();
    init_errors();
    init_is_object();
    __name(generalDecrypt, "generalDecrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = /* @__PURE__ */ __name(async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types3, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    }, "keyToJWK");
    key_to_jwk_default = keyToJWK;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/key/export.js
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/key/export.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_asn1();
    init_asn1();
    init_key_to_jwk();
    __name(exportSPKI, "exportSPKI");
    __name(exportPKCS8, "exportPKCS8");
    __name(exportJWK, "exportJWK");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode(apu);
      if (apv)
        parameters.apv = encode(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    __name(encryptKeyManagement, "encryptKeyManagement");
    encrypt_key_management_default = encryptKeyManagement;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected, FlattenedEncrypt;
var init_encrypt2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_encrypt();
    init_zlib();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      static {
        __name(this, "FlattenedEncrypt");
      }
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        if (this._aad) {
          aadMember = encode(this._aad);
          additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
          ({ ciphertext, tag } = await encrypt_default(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: encode(ciphertext),
          iv: encode(this._iv),
          tag: encode(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/general/encrypt.js
var IndividualRecipient, GeneralEncrypt;
var init_encrypt3 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      static {
        __name(this, "IndividualRecipient");
      }
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      static {
        __name(this, "GeneralEncrypt");
      }
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = cek_default(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = encode(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash2 = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash: hash2, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash: hash2, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash: hash2, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash: hash2, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    __name(subtleDsa, "subtleDsa");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types3));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types3, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    __name(getCryptoKey3, "getCryptoKey");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/verify.js
var verify2, verify_default;
var init_verify = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/verify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify2 = /* @__PURE__ */ __name(async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch (_a) {
        return false;
      }
    }, "verify");
    verify_default = verify2;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject2(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject2(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
    __name(flattenedVerify, "flattenedVerify");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_verify2();
    init_errors();
    init_buffer_utils();
    __name(compactVerify, "compactVerify");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/general/verify.js
async function generalVerify(jws, key, options) {
  if (!isObject2(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject2)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_verify2();
    init_errors();
    init_is_object();
    __name(generalVerify, "generalVerify");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/epoch.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    epoch_default = /* @__PURE__ */ __name((date) => Math.floor(date.getTime() / 1e3), "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/secs.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    secs_default = /* @__PURE__ */ __name((str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    }, "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = /* @__PURE__ */ __name((value) => value.toLowerCase().replace(/^application\//, ""), "normalizeTyp");
    checkAudiencePresence = /* @__PURE__ */ __name((audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    }, "checkAudiencePresence");
    jwt_claims_set_default = /* @__PURE__ */ __name((protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch (_a) {
      }
      if (!isObject2(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      if (maxTokenAge !== void 0)
        requiredClaims.push("iat");
      if (audience !== void 0)
        requiredClaims.push("aud");
      if (subject !== void 0)
        requiredClaims.push("sub");
      if (issuer !== void 0)
        requiredClaims.push("iss");
      for (const claim of new Set(requiredClaims.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    }, "default");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/verify.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_verify3();
    init_jwt_claims_set();
    init_errors();
    __name(jwtVerify, "jwtVerify");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/decrypt.js
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
    __name(jwtDecrypt, "jwtDecrypt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/compact/encrypt.js
var CompactEncrypt;
var init_encrypt4 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_encrypt2();
    CompactEncrypt = class {
      static {
        __name(this, "CompactEncrypt");
      }
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/sign.js
var sign2, sign_default;
var init_sign = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/sign.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign2 = /* @__PURE__ */ __name(async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    }, "sign");
    sign_default = sign2;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      static {
        __name(this, "FlattenedSign");
      }
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sign2();
    CompactSign = class {
      static {
        __name(this, "CompactSign");
      }
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/general/sign.js
var IndividualSignature, GeneralSign;
var init_sign4 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sign2();
    init_errors();
    IndividualSignature = class {
      static {
        __name(this, "IndividualSignature");
      }
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      static {
        __name(this, "GeneralSign");
      }
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT;
var init_produce = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/produce.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      static {
        __name(this, "ProduceJWT");
      }
      constructor(payload) {
        if (!isObject2(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: input };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: input };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input };
        }
        return this;
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/sign.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      static {
        __name(this, "SignJWT");
      }
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/encrypt.js
var EncryptJWT;
var init_encrypt5 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      static {
        __name(this, "EncryptJWT");
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwk/thumbprint.js
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject2(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_digest();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
    check = /* @__PURE__ */ __name((value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    }, "check");
    __name(calculateJwkThumbprint, "calculateJwkThumbprint");
    __name(calculateJwkThumbprintUri, "calculateJwkThumbprintUri");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwk/embedded.js
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token === null || token === void 0 ? void 0 : token.header
  };
  if (!isObject2(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_import();
    init_is_object();
    init_errors();
    __name(EmbeddedJWK, "EmbeddedJWK");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject2(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwks/local.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_import();
    init_errors();
    init_is_object();
    __name(getKtyFromAlg, "getKtyFromAlg");
    __name(isJWKSLike, "isJWKSLike");
    __name(isJWKLike, "isJWKLike");
    __name(clone, "clone");
    LocalJWKSet = class {
      static {
        __name(this, "LocalJWKSet");
      }
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
          const error3 = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error3[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch (_a) {
                continue;
              }
            }
          };
          throw error3;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
    __name(importWithAlgCache, "importWithAlgCache");
    __name(createLocalJWKSet, "createLocalJWKSet");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_errors();
    fetchJwks = /* @__PURE__ */ __name(async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    }, "fetchJwks");
    fetch_jwks_default = fetchJwks;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && true || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var RemoteJWKSet;
var init_remote = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwks/remote.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_fetch_jwks();
    init_errors();
    init_local();
    __name(isCloudflareWorkers, "isCloudflareWorkers");
    RemoteJWKSet = class extends LocalJWKSet {
      static {
        __name(this, "RemoteJWKSet");
      }
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
          if (!isJWKSLike(json)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
          }
          this._jwks = { keys: json.keys };
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
    __name(createRemoteJWKSet, "createRemoteJWKSet");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/unsecured.js
var UnsecuredJWT;
var init_unsecured = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      static {
        __name(this, "UnsecuredJWT");
      }
      encode() {
        const header = encode(JSON.stringify({ alg: "none" }));
        const payload = encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder.decode(decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch (_a) {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2, decode2;
var init_base64url2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/util/base64url.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url();
    encode2 = encode;
    decode2 = decode;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject2(result)) {
      throw new Error();
    }
    return result;
  } catch (_a) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    __name(decodeProtectedHeader, "decodeProtectedHeader");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (_a) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject2(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
    __name(decodeJwt, "decodeJwt");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/generate.js
async function generateSecret(alg, options) {
  var _a;
  let length;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length = parseInt(alg.slice(-3), 10);
      algorithm = { name: "HMAC", hash: `SHA-${length}`, length };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-KW", length };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-GCM", length };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}
function getModulusLengthOption(options) {
  var _a;
  const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair2(alg, options) {
  var _a, _b, _c;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA":
      keyUsages = ["sign", "verify"];
      const crv = (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv2 = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
      switch (crv2) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv2 };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv2 };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages);
}
var init_generate = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/generate.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_webcrypto();
    init_errors();
    init_random();
    __name(generateSecret, "generateSecret");
    __name(getModulusLengthOption, "getModulusLengthOption");
    __name(generateKeyPair2, "generateKeyPair");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair3(alg, options) {
  return generateKeyPair2(alg, options);
}
var init_generate_key_pair = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_generate();
    __name(generateKeyPair3, "generateKeyPair");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/key/generate_secret.js
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_generate();
    __name(generateSecret2, "generateSecret");
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/runtime.js
var runtime_default;
var init_runtime = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/runtime/runtime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    runtime_default = "WebCryptoAPI";
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/util/runtime.js
var runtime_default2;
var init_runtime2 = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/util/runtime.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_runtime();
    runtime_default2 = runtime_default;
  }
});

// node_modules/jwks-rsa/node_modules/jose/dist/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  cryptoRuntime: () => runtime_default2,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair3,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser = __esm({
  "node_modules/jwks-rsa/node_modules/jose/dist/browser/index.js"() {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// node_modules/jwks-rsa/src/errors/JwksError.js
var require_JwksError = __commonJS({
  "node_modules/jwks-rsa/src/errors/JwksError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function JwksError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "JwksError";
      this.message = message2;
    }
    __name(JwksError, "JwksError");
    JwksError.prototype = Object.create(Error.prototype);
    JwksError.prototype.constructor = JwksError;
    module.exports = JwksError;
  }
});

// node_modules/jwks-rsa/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/jwks-rsa/src/utils.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var jose = (init_browser(), __toCommonJS(browser_exports));
    var JwksError = require_JwksError();
    function resolveAlg(jwk) {
      if (jwk.alg) {
        return jwk.alg;
      }
      if (jwk.kty === "RSA") {
        return "RS256";
      }
      if (jwk.kty === "EC") {
        switch (jwk.crv) {
          case "P-256":
            return "ES256";
          case "secp256k1":
            return "ES256K";
          case "P-384":
            return "ES384";
          case "P-521":
            return "ES512";
        }
      }
      if (jwk.kty === "OKP") {
        switch (jwk.crv) {
          case "Ed25519":
          case "Ed448":
            return "EdDSA";
        }
      }
      throw new JwksError("Unsupported JWK");
    }
    __name(resolveAlg, "resolveAlg");
    async function retrieveSigningKeys(jwks) {
      const results = [];
      jwks = jwks.filter(({ use }) => use === "sig" || use === void 0).filter(({ kty }) => kty === "RSA" || kty === "EC" || kty === "OKP");
      for (const jwk of jwks) {
        try {
          const key = await jose.importJWK(jwk, resolveAlg(jwk));
          if (key.type !== "public") {
            continue;
          }
          let getSpki;
          switch (key[Symbol.toStringTag]) {
            case "CryptoKey": {
              const spki = await jose.exportSPKI(key);
              getSpki = /* @__PURE__ */ __name(() => spki, "getSpki");
              break;
            }
            case "KeyObject":
            // Assume legacy Node.js version without the Symbol.toStringTag backported
            // Fall through
            default:
              getSpki = /* @__PURE__ */ __name(() => key.export({ format: "pem", type: "spki" }), "getSpki");
          }
          results.push({
            get publicKey() {
              return getSpki();
            },
            get rsaPublicKey() {
              return getSpki();
            },
            getPublicKey() {
              return getSpki();
            },
            ...typeof jwk.kid === "string" && jwk.kid ? { kid: jwk.kid } : void 0,
            ...typeof jwk.alg === "string" && jwk.alg ? { alg: jwk.alg } : void 0
          });
        } catch (err) {
          continue;
        }
      }
      return results;
    }
    __name(retrieveSigningKeys, "retrieveSigningKeys");
    module.exports = {
      retrieveSigningKeys
    };
  }
});

// node_modules/jwks-rsa/src/wrappers/request.js
var require_request = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/request.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var http = require_http();
    var https = require_https();
    var urlUtil = require_url();
    module.exports.default = (options) => {
      if (options.fetcher) {
        return options.fetcher(options.uri);
      }
      return new Promise((resolve, reject) => {
        const {
          hostname: hostname2,
          path,
          port,
          protocol
        } = urlUtil.parse(options.uri);
        const requestOptions = {
          hostname: hostname2,
          path,
          port,
          method: "GET",
          ...options.headers && { headers: { ...options.headers } },
          ...options.timeout && { timeout: options.timeout },
          ...options.agent && { agent: options.agent }
        };
        const httpRequestLib = protocol === "https:" ? https : http;
        const httpRequest = httpRequestLib.request(requestOptions, (res) => {
          let rawData = "";
          res.setEncoding("utf8");
          res.on("data", (chunk) => {
            rawData += chunk;
          });
          res.on("end", () => {
            if (res.statusCode < 200 || res.statusCode >= 300) {
              const errorMsg = res.body && (res.body.message || res.body) || res.statusMessage || `Http Error ${res.statusCode}`;
              reject({ errorMsg });
            } else {
              try {
                resolve(rawData && JSON.parse(rawData));
              } catch (error3) {
                reject(error3);
              }
            }
          });
        });
        httpRequest.on("timeout", () => httpRequest.destroy()).on("error", (e) => reject(e)).end();
      });
    };
  }
});

// node_modules/lru-memoizer/node_modules/yallist/iterator.js
var require_iterator = __commonJS({
  "node_modules/lru-memoizer/node_modules/yallist/iterator.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = function(Yallist) {
      Yallist.prototype[Symbol.iterator] = function* () {
        for (let walker = this.head; walker; walker = walker.next) {
          yield walker.value;
        }
      };
    };
  }
});

// node_modules/lru-memoizer/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/lru-memoizer/node_modules/yallist/yallist.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    __name(Yallist, "Yallist");
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
      return next;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
      if (start > this.length) {
        start = this.length - 1;
      }
      if (start < 0) {
        start = this.length + start;
      }
      for (var i = 0, walker = this.head; walker !== null && i < start; i++) {
        walker = walker.next;
      }
      var ret = [];
      for (var i = 0; walker && i < deleteCount; i++) {
        ret.push(walker.value);
        walker = this.removeNode(walker);
      }
      if (walker === null) {
        walker = this.tail;
      }
      if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
      }
      for (var i = 0; i < nodes.length; i++) {
        walker = insert(this, walker, nodes[i]);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p2 = walker.prev;
        walker.prev = walker.next;
        walker.next = p2;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function insert(self2, node, value) {
      var inserted = node === self2.head ? new Node(value, null, node, self2) : new Node(value, node, node.next, self2);
      if (inserted.next === null) {
        self2.tail = inserted;
      }
      if (inserted.prev === null) {
        self2.head = inserted;
      }
      self2.length++;
      return inserted;
    }
    __name(insert, "insert");
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    __name(push, "push");
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    __name(unshift, "unshift");
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
    __name(Node, "Node");
    try {
      require_iterator()(Yallist);
    } catch (er) {
    }
  }
});

// node_modules/lru-memoizer/node_modules/lru-cache/index.js
var require_lru_cache = __commonJS({
  "node_modules/lru-memoizer/node_modules/lru-cache/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var Yallist = require_yallist();
    var MAX = Symbol("max");
    var LENGTH = Symbol("length");
    var LENGTH_CALCULATOR = Symbol("lengthCalculator");
    var ALLOW_STALE = Symbol("allowStale");
    var MAX_AGE = Symbol("maxAge");
    var DISPOSE = Symbol("dispose");
    var NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
    var LRU_LIST = Symbol("lruList");
    var CACHE = Symbol("cache");
    var UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
    var naiveLength = /* @__PURE__ */ __name(() => 1, "naiveLength");
    var LRUCache = class {
      static {
        __name(this, "LRUCache");
      }
      constructor(options) {
        if (typeof options === "number")
          options = { max: options };
        if (!options)
          options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0))
          throw new TypeError("max must be a non-negative number");
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
      }
      // resize the cache when the max changes.
      set max(mL) {
        if (typeof mL !== "number" || mL < 0)
          throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
      }
      get max() {
        return this[MAX];
      }
      set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
      }
      get allowStale() {
        return this[ALLOW_STALE];
      }
      set maxAge(mA) {
        if (typeof mA !== "number")
          throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
      }
      get maxAge() {
        return this[MAX_AGE];
      }
      // resize the cache when the lengthCalculator changes.
      set lengthCalculator(lC) {
        if (typeof lC !== "function")
          lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
          this[LENGTH_CALCULATOR] = lC;
          this[LENGTH] = 0;
          this[LRU_LIST].forEach((hit) => {
            hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
            this[LENGTH] += hit.length;
          });
        }
        trim(this);
      }
      get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
      }
      get length() {
        return this[LENGTH];
      }
      get itemCount() {
        return this[LRU_LIST].length;
      }
      rforEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].tail; walker !== null; ) {
          const prev = walker.prev;
          forEachStep(this, fn, walker, thisp);
          walker = prev;
        }
      }
      forEach(fn, thisp) {
        thisp = thisp || this;
        for (let walker = this[LRU_LIST].head; walker !== null; ) {
          const next = walker.next;
          forEachStep(this, fn, walker, thisp);
          walker = next;
        }
      }
      keys() {
        return this[LRU_LIST].toArray().map((k) => k.key);
      }
      values() {
        return this[LRU_LIST].toArray().map((k) => k.value);
      }
      reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
          this[LRU_LIST].forEach((hit) => this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = /* @__PURE__ */ new Map();
        this[LRU_LIST] = new Yallist();
        this[LENGTH] = 0;
      }
      dump() {
        return this[LRU_LIST].map((hit) => isStale(this, hit) ? false : {
          k: hit.key,
          v: hit.value,
          e: hit.now + (hit.maxAge || 0)
        }).toArray().filter((h) => h);
      }
      dumpLru() {
        return this[LRU_LIST];
      }
      set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number")
          throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
          if (len > this[MAX]) {
            del(this, this[CACHE].get(key));
            return false;
          }
          const node = this[CACHE].get(key);
          const item = node.value;
          if (this[DISPOSE]) {
            if (!this[NO_DISPOSE_ON_SET])
              this[DISPOSE](key, item.value);
          }
          item.now = now;
          item.maxAge = maxAge;
          item.value = value;
          this[LENGTH] += len - item.length;
          item.length = len;
          this.get(key);
          trim(this);
          return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        if (hit.length > this[MAX]) {
          if (this[DISPOSE])
            this[DISPOSE](key, value);
          return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
      }
      has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
      }
      get(key) {
        return get3(this, key, true);
      }
      peek(key) {
        return get3(this, key, false);
      }
      pop() {
        const node = this[LRU_LIST].tail;
        if (!node)
          return null;
        del(this, node);
        return node.value;
      }
      del(key) {
        del(this, this[CACHE].get(key));
      }
      load(arr) {
        this.reset();
        const now = Date.now();
        for (let l = arr.length - 1; l >= 0; l--) {
          const hit = arr[l];
          const expiresAt = hit.e || 0;
          if (expiresAt === 0)
            this.set(hit.k, hit.v);
          else {
            const maxAge = expiresAt - now;
            if (maxAge > 0) {
              this.set(hit.k, hit.v, maxAge);
            }
          }
        }
      }
      prune() {
        this[CACHE].forEach((value, key) => get3(this, key, false));
      }
    };
    var get3 = /* @__PURE__ */ __name((self2, key, doUse) => {
      const node = self2[CACHE].get(key);
      if (node) {
        const hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!self2[ALLOW_STALE])
            return void 0;
        } else {
          if (doUse) {
            if (self2[UPDATE_AGE_ON_GET])
              node.value.now = Date.now();
            self2[LRU_LIST].unshiftNode(node);
          }
        }
        return hit.value;
      }
    }, "get");
    var isStale = /* @__PURE__ */ __name((self2, hit) => {
      if (!hit || !hit.maxAge && !self2[MAX_AGE])
        return false;
      const diff = Date.now() - hit.now;
      return hit.maxAge ? diff > hit.maxAge : self2[MAX_AGE] && diff > self2[MAX_AGE];
    }, "isStale");
    var trim = /* @__PURE__ */ __name((self2) => {
      if (self2[LENGTH] > self2[MAX]) {
        for (let walker = self2[LRU_LIST].tail; self2[LENGTH] > self2[MAX] && walker !== null; ) {
          const prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }, "trim");
    var del = /* @__PURE__ */ __name((self2, node) => {
      if (node) {
        const hit = node.value;
        if (self2[DISPOSE])
          self2[DISPOSE](hit.key, hit.value);
        self2[LENGTH] -= hit.length;
        self2[CACHE].delete(hit.key);
        self2[LRU_LIST].removeNode(node);
      }
    }, "del");
    var Entry = class {
      static {
        __name(this, "Entry");
      }
      constructor(key, value, length, now, maxAge) {
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
      }
    };
    var forEachStep = /* @__PURE__ */ __name((self2, fn, node, thisp) => {
      let hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!self2[ALLOW_STALE])
          hit = void 0;
      }
      if (hit)
        fn.call(thisp, hit.value, hit.key, self2);
    }, "forEachStep");
    module.exports = LRUCache;
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash8 = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    __name(addMapEntry, "addMapEntry");
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    __name(addSetEntry, "addSetEntry");
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    __name(arrayEach, "arrayEach");
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    __name(arrayPush, "arrayPush");
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    __name(baseTimes, "baseTimes");
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    __name(getValue, "getValue");
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    __name(isHostObject, "isHostObject");
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    __name(mapToArray, "mapToArray");
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    __name(overArg, "overArg");
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    __name(setToArray, "setToArray");
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView2 = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView2);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash2(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(Hash2, "Hash");
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    __name(hashClear, "hashClear");
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    __name(hashDelete, "hashDelete");
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    __name(hashGet, "hashGet");
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    __name(hashHas, "hashHas");
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    __name(hashSet, "hashSet");
    Hash2.prototype.clear = hashClear;
    Hash2.prototype["delete"] = hashDelete;
    Hash2.prototype.get = hashGet;
    Hash2.prototype.has = hashHas;
    Hash2.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(ListCache, "ListCache");
    function listCacheClear() {
      this.__data__ = [];
    }
    __name(listCacheClear, "listCacheClear");
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    __name(listCacheDelete, "listCacheDelete");
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    __name(listCacheGet, "listCacheGet");
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    __name(listCacheHas, "listCacheHas");
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    __name(listCacheSet, "listCacheSet");
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    __name(MapCache, "MapCache");
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash2(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash2()
      };
    }
    __name(mapCacheClear, "mapCacheClear");
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    __name(mapCacheDelete, "mapCacheDelete");
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    __name(mapCacheGet, "mapCacheGet");
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    __name(mapCacheHas, "mapCacheHas");
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    __name(mapCacheSet, "mapCacheSet");
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    __name(Stack, "Stack");
    function stackClear() {
      this.__data__ = new ListCache();
    }
    __name(stackClear, "stackClear");
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    __name(stackDelete, "stackDelete");
    function stackGet(key) {
      return this.__data__.get(key);
    }
    __name(stackGet, "stackGet");
    function stackHas(key) {
      return this.__data__.has(key);
    }
    __name(stackHas, "stackHas");
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    __name(stackSet, "stackSet");
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray2(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    __name(arrayLikeKeys, "arrayLikeKeys");
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    __name(assignValue, "assignValue");
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    __name(assocIndexOf, "assocIndexOf");
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    __name(baseAssign, "baseAssign");
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject3(value)) {
        return value;
      }
      var isArr = isArray2(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer2(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    __name(baseClone, "baseClone");
    function baseCreate(proto) {
      return isObject3(proto) ? objectCreate(proto) : {};
    }
    __name(baseCreate, "baseCreate");
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray2(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    __name(baseGetAllKeys, "baseGetAllKeys");
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    __name(baseGetTag, "baseGetTag");
    function baseIsNative(value) {
      if (!isObject3(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction2(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    __name(baseIsNative, "baseIsNative");
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    __name(baseKeys, "baseKeys");
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    __name(cloneBuffer, "cloneBuffer");
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    __name(cloneArrayBuffer, "cloneArrayBuffer");
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    __name(cloneDataView, "cloneDataView");
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    __name(cloneMap, "cloneMap");
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    __name(cloneRegExp, "cloneRegExp");
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    __name(cloneSet, "cloneSet");
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    __name(cloneSymbol, "cloneSymbol");
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    __name(cloneTypedArray, "cloneTypedArray");
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    __name(copyArray, "copyArray");
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    __name(copyObject, "copyObject");
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    __name(copySymbols, "copySymbols");
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    __name(getAllKeys, "getAllKeys");
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    __name(getMapData, "getMapData");
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    __name(getNative, "getNative");
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = /* @__PURE__ */ __name(function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      }, "getTag");
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    __name(initCloneArray, "initCloneArray");
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    __name(initCloneObject, "initCloneObject");
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    __name(initCloneByTag, "initCloneByTag");
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    __name(isIndex, "isIndex");
    function isKeyable(value) {
      var type2 = typeof value;
      return type2 == "string" || type2 == "number" || type2 == "symbol" || type2 == "boolean" ? value !== "__proto__" : value === null;
    }
    __name(isKeyable, "isKeyable");
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    __name(isMasked, "isMasked");
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    __name(isPrototype, "isPrototype");
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    __name(toSource, "toSource");
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    __name(cloneDeep, "cloneDeep");
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    __name(eq, "eq");
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    __name(isArguments, "isArguments");
    var isArray2 = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction2(value);
    }
    __name(isArrayLike, "isArrayLike");
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    __name(isArrayLikeObject, "isArrayLikeObject");
    var isBuffer2 = nativeIsBuffer || stubFalse;
    function isFunction2(value) {
      var tag = isObject3(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    __name(isFunction2, "isFunction");
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    __name(isLength, "isLength");
    function isObject3(value) {
      var type2 = typeof value;
      return !!value && (type2 == "object" || type2 == "function");
    }
    __name(isObject3, "isObject");
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    __name(isObjectLike2, "isObjectLike");
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    __name(keys, "keys");
    function stubArray() {
      return [];
    }
    __name(stubArray, "stubArray");
    function stubFalse() {
      return false;
    }
    __name(stubFalse, "stubFalse");
    module.exports = cloneDeep;
  }
});

// node_modules/lru-memoizer/lib/freeze.js
var require_freeze = __commonJS({
  "node_modules/lru-memoizer/lib/freeze.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepFreeze = void 0;
    function deepFreeze(o) {
      if (o) {
        Object.freeze(o);
        Object.getOwnPropertyNames(o).forEach(function(prop) {
          if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && o[prop].constructor !== Buffer && !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
          }
        });
      }
      return o;
    }
    __name(deepFreeze, "deepFreeze");
    exports.deepFreeze = deepFreeze;
  }
});

// node_modules/lru-memoizer/lib/sync.js
var require_sync = __commonJS({
  "node_modules/lru-memoizer/lib/sync.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __read = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
      } catch (error3) {
        e = { error: error3 };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"])) m2.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar2;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar2 = [], i = 0; i < arguments.length; i++) ar2 = ar2.concat(__read(arguments[i]));
      return ar2;
    };
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syncMemoizer = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var events_1 = require_events();
    var lodash_clonedeep_1 = __importDefault(require_lodash8());
    var freeze_1 = require_freeze();
    function syncMemoizer(options) {
      var cache = new lru_cache_1.default(options);
      var load = options.load;
      var hash2 = options.hash;
      var bypass = options.bypass;
      var itemMaxAge = options.itemMaxAge;
      var freeze = options.freeze;
      var clone2 = options.clone;
      var emitter = new events_1.EventEmitter();
      var defaultResult = Object.assign({
        del,
        reset: /* @__PURE__ */ __name(function() {
          return cache.reset();
        }, "reset"),
        keys: cache.keys.bind(cache),
        on: emitter.on.bind(emitter),
        once: emitter.once.bind(emitter)
      }, options);
      if (options.disable) {
        return Object.assign(load, defaultResult);
      }
      function del() {
        var key = hash2.apply(void 0, __spread(arguments));
        cache.del(key);
      }
      __name(del, "del");
      function emit2(event) {
        var parameters = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          parameters[_i2 - 1] = arguments[_i2];
        }
        emitter.emit.apply(emitter, __spread([event], parameters));
      }
      __name(emit2, "emit");
      function isPromise(result2) {
        return result2 && result2.then && typeof result2.then === "function";
      }
      __name(isPromise, "isPromise");
      function processResult(result2) {
        var res = result2;
        if (clone2) {
          if (isPromise(res)) {
            res = res.then(lodash_clonedeep_1.default);
          } else {
            res = lodash_clonedeep_1.default(res);
          }
        }
        if (freeze) {
          if (isPromise(res)) {
            res = res.then(freeze_1.deepFreeze);
          } else {
            freeze_1.deepFreeze(res);
          }
        }
        return res;
      }
      __name(processResult, "processResult");
      var result = /* @__PURE__ */ __name(function() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        if (bypass && bypass.apply(void 0, __spread(args))) {
          emit2.apply(void 0, __spread(["miss"], args));
          return load.apply(void 0, __spread(args));
        }
        var key = hash2.apply(void 0, __spread(args));
        var fromCache = cache.get(key);
        if (fromCache) {
          emit2.apply(void 0, __spread(["hit"], args));
          return processResult(fromCache);
        }
        emit2.apply(void 0, __spread(["miss"], args));
        var result2 = load.apply(void 0, __spread(args));
        if (itemMaxAge) {
          cache.set(key, result2, itemMaxAge.apply(void 0, __spread(args.concat([result2]))));
        } else {
          cache.set(key, result2);
        }
        return processResult(result2);
      }, "result");
      return Object.assign(result, defaultResult);
    }
    __name(syncMemoizer, "syncMemoizer");
    exports.syncMemoizer = syncMemoizer;
  }
});

// node_modules/lru-memoizer/lib/async.js
var require_async = __commonJS({
  "node_modules/lru-memoizer/lib/async.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var __read = exports && exports.__read || function(o, n) {
      var m2 = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m2) return o;
      var i = m2.call(o), r, ar2 = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar2.push(r.value);
      } catch (error3) {
        e = { error: error3 };
      } finally {
        try {
          if (r && !r.done && (m2 = i["return"])) m2.call(i);
        } finally {
          if (e) throw e.error;
        }
      }
      return ar2;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar2 = [], i = 0; i < arguments.length; i++) ar2 = ar2.concat(__read(arguments[i]));
      return ar2;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m2 = s && o[s], i = 0;
      if (m2) return m2.call(o);
      if (o && typeof o.length === "number") return {
        next: /* @__PURE__ */ __name(function() {
          if (o && i >= o.length) o = void 0;
          return { value: o && o[i++], done: !o };
        }, "next")
      };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports && exports.__importDefault || function(mod4) {
      return mod4 && mod4.__esModule ? mod4 : { "default": mod4 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncMemoizer = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var events_1 = require_events();
    var lodash_clonedeep_1 = __importDefault(require_lodash8());
    var freeze_1 = require_freeze();
    var sync_1 = require_sync();
    function asyncMemoizer(options) {
      var cache = new lru_cache_1.default(options);
      var load = options.load;
      var hash2 = options.hash;
      var bypass = options.bypass;
      var itemMaxAge = options.itemMaxAge;
      var freeze = options.freeze;
      var clone2 = options.clone;
      var queueMaxAge = options.queueMaxAge || 1e3;
      var loading = /* @__PURE__ */ new Map();
      var emitter = new events_1.EventEmitter();
      var memoizerMethods = Object.assign({
        del,
        reset: /* @__PURE__ */ __name(function() {
          return cache.reset();
        }, "reset"),
        keys: cache.keys.bind(cache),
        on: emitter.on.bind(emitter),
        once: emitter.once.bind(emitter)
      }, options);
      if (options.disable) {
        return Object.assign(load, memoizerMethods);
      }
      function del() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var key = hash2.apply(void 0, __spread(args));
        cache.del(key);
      }
      __name(del, "del");
      function add(key, parameters, result) {
        if (freeze) {
          result.forEach(freeze_1.deepFreeze);
        }
        if (itemMaxAge) {
          cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));
        } else {
          cache.set(key, result);
        }
      }
      __name(add, "add");
      function runCallbacks(callbacks, args) {
        var e_1, _a;
        try {
          for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
            var callback = callbacks_1_1.value;
            if (clone2) {
              setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));
            } else {
              setImmediate.apply(void 0, __spread([callback], args));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return)) _a.call(callbacks_1);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
      __name(runCallbacks, "runCallbacks");
      function emit2(event) {
        var parameters = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          parameters[_i2 - 1] = arguments[_i2];
        }
        emitter.emit.apply(emitter, __spread([event], parameters));
      }
      __name(emit2, "emit");
      function memoizedFunction() {
        var args = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args[_i2] = arguments[_i2];
        }
        var parameters = args.slice(0, -1);
        var callback = args.slice(-1).pop();
        var key;
        if (bypass && bypass.apply(void 0, __spread(parameters))) {
          emit2.apply(void 0, __spread(["miss"], parameters));
          return load.apply(void 0, __spread(args));
        }
        if (parameters.length === 0 && !hash2) {
          key = "_";
        } else {
          key = hash2.apply(void 0, __spread(parameters));
        }
        var fromCache = cache.get(key);
        if (fromCache) {
          emit2.apply(void 0, __spread(["hit"], parameters));
          return runCallbacks([callback], [null].concat(fromCache));
        }
        var pendingLoad = loading.get(key);
        if (pendingLoad && pendingLoad.expiresAt > Date.now()) {
          pendingLoad.queue.push(callback);
          emit2.apply(void 0, __spread(["queue"], parameters));
          return;
        }
        emit2.apply(void 0, __spread(["miss"], parameters));
        var started = Date.now();
        var queue = [callback];
        loading.set(key, {
          queue,
          expiresAt: started + queueMaxAge
        });
        var loadHandler = /* @__PURE__ */ __name(function() {
          var args2 = [];
          for (var _i3 = 0; _i3 < arguments.length; _i3++) {
            args2[_i3] = arguments[_i3];
          }
          var err = args2[0];
          if (!err) {
            add(key, parameters, args2.slice(1));
          }
          loading.delete(key);
          emit2.apply(void 0, __spread(["loaded", Date.now() - started], parameters));
          runCallbacks(queue, args2);
        }, "loadHandler");
        load.apply(void 0, __spread(parameters, [loadHandler]));
      }
      __name(memoizedFunction, "memoizedFunction");
      ;
      return Object.assign(memoizedFunction, memoizerMethods);
    }
    __name(asyncMemoizer, "asyncMemoizer");
    exports.asyncMemoizer = asyncMemoizer;
    asyncMemoizer.sync = sync_1.syncMemoizer;
  }
});

// node_modules/lru-memoizer/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/lru-memoizer/lib/index.js"(exports, module) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var async_1 = require_async();
    module.exports = async_1.asyncMemoizer;
  }
});

// node_modules/jwks-rsa/src/wrappers/cache.js
var require_cache = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/cache.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var logger = require_debug()("jwks");
    var memoizer = require_lib2();
    var { promisify: promisify2, callbackify: callbackify3 } = require_util3();
    function cacheWrapper(client, { cacheMaxEntries = 5, cacheMaxAge = 6e5 }) {
      logger(`Configured caching of signing keys. Max: ${cacheMaxEntries} / Age: ${cacheMaxAge}`);
      return promisify2(memoizer({
        hash: /* @__PURE__ */ __name((kid) => kid, "hash"),
        load: callbackify3(client.getSigningKey.bind(client)),
        maxAge: cacheMaxAge,
        max: cacheMaxEntries
      }));
    }
    __name(cacheWrapper, "cacheWrapper");
    module.exports.default = cacheWrapper;
  }
});

// node_modules/limiter/lib/tokenBucket.js
var require_tokenBucket = __commonJS({
  "node_modules/limiter/lib/tokenBucket.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TokenBucket = /* @__PURE__ */ __name(function(bucketSize, tokensPerInterval, interval, parentBucket) {
      this.bucketSize = bucketSize;
      this.tokensPerInterval = tokensPerInterval;
      if (typeof interval === "string") {
        switch (interval) {
          case "sec":
          case "second":
            this.interval = 1e3;
            break;
          case "min":
          case "minute":
            this.interval = 1e3 * 60;
            break;
          case "hr":
          case "hour":
            this.interval = 1e3 * 60 * 60;
            break;
          case "day":
            this.interval = 1e3 * 60 * 60 * 24;
            break;
          default:
            throw new Error("Invaid interval " + interval);
        }
      } else {
        this.interval = interval;
      }
      this.parentBucket = parentBucket;
      this.content = 0;
      this.lastDrip = +/* @__PURE__ */ new Date();
    }, "TokenBucket");
    TokenBucket.prototype = {
      bucketSize: 1,
      tokensPerInterval: 1,
      interval: 1e3,
      parentBucket: null,
      content: 0,
      lastDrip: 0,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * bucket (and any parent buckets) contains enough tokens this will happen
       * immediately. Otherwise, the removal and callback will happen when enough
       * tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: /* @__PURE__ */ __name(function(count3, callback) {
        var self2 = this;
        if (!this.bucketSize) {
          process.nextTick(callback.bind(null, null, count3, Number.POSITIVE_INFINITY));
          return true;
        }
        if (count3 > this.bucketSize) {
          process.nextTick(callback.bind(null, "Requested tokens " + count3 + " exceeds bucket size " + this.bucketSize, null));
          return false;
        }
        this.drip();
        if (count3 > this.content)
          return comeBackLater();
        if (this.parentBucket) {
          return this.parentBucket.removeTokens(count3, function(err, remainingTokens) {
            if (err) return callback(err, null);
            if (count3 > self2.content)
              return comeBackLater();
            self2.content -= count3;
            callback(null, Math.min(remainingTokens, self2.content));
          });
        } else {
          this.content -= count3;
          process.nextTick(callback.bind(null, null, this.content));
          return true;
        }
        function comeBackLater() {
          var waitInterval = Math.ceil(
            (count3 - self2.content) * (self2.interval / self2.tokensPerInterval)
          );
          setTimeout(function() {
            self2.removeTokens(count3, callback);
          }, waitInterval);
          return false;
        }
        __name(comeBackLater, "comeBackLater");
      }, "removeTokens"),
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens this will
       * return true, otherwise false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: /* @__PURE__ */ __name(function(count3) {
        if (!this.bucketSize)
          return true;
        if (count3 > this.bucketSize)
          return false;
        this.drip();
        if (count3 > this.content)
          return false;
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count3))
          return false;
        this.content -= count3;
        return true;
      }, "tryRemoveTokens"),
      /**
       * Add any new tokens to the bucket since the last drip.
       * @returns {Boolean} True if new tokens were added, otherwise false.
       */
      drip: /* @__PURE__ */ __name(function() {
        if (!this.tokensPerInterval) {
          this.content = this.bucketSize;
          return;
        }
        var now = +/* @__PURE__ */ new Date();
        var deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
      }, "drip")
    };
    module.exports = TokenBucket;
  }
});

// node_modules/limiter/lib/clock.js
var require_clock = __commonJS({
  "node_modules/limiter/lib/clock.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var getMilliseconds = /* @__PURE__ */ __name(function() {
      if (typeof process !== "undefined" && process.hrtime) {
        var hrtime4 = process.hrtime();
        var seconds = hrtime4[0];
        var nanoseconds = hrtime4[1];
        return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
      }
      return (/* @__PURE__ */ new Date()).getTime();
    }, "getMilliseconds");
    module.exports = getMilliseconds;
  }
});

// node_modules/limiter/lib/rateLimiter.js
var require_rateLimiter = __commonJS({
  "node_modules/limiter/lib/rateLimiter.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var TokenBucket = require_tokenBucket();
    var getMilliseconds = require_clock();
    var RateLimiter = /* @__PURE__ */ __name(function(tokensPerInterval, interval, fireImmediately) {
      this.tokenBucket = new TokenBucket(
        tokensPerInterval,
        tokensPerInterval,
        interval,
        null
      );
      this.tokenBucket.content = tokensPerInterval;
      this.curIntervalStart = getMilliseconds();
      this.tokensThisInterval = 0;
      this.fireImmediately = fireImmediately;
    }, "RateLimiter");
    RateLimiter.prototype = {
      tokenBucket: null,
      curIntervalStart: 0,
      tokensThisInterval: 0,
      fireImmediately: false,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * rate limiter contains enough tokens and we haven't spent too many tokens
       * in this interval already, this will happen immediately. Otherwise, the
       * removal and callback will happen when enough tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: /* @__PURE__ */ __name(function(count3, callback) {
        if (count3 > this.tokenBucket.bucketSize) {
          process.nextTick(callback.bind(
            null,
            "Requested tokens " + count3 + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
            null
          ));
          return false;
        }
        var self2 = this;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count3 > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
          if (this.fireImmediately) {
            process.nextTick(callback.bind(null, null, -1));
          } else {
            var waitInterval = Math.ceil(
              this.curIntervalStart + this.tokenBucket.interval - now
            );
            setTimeout(function() {
              self2.tokenBucket.removeTokens(count3, afterTokensRemoved);
            }, waitInterval);
          }
          return false;
        }
        return this.tokenBucket.removeTokens(count3, afterTokensRemoved);
        function afterTokensRemoved(err, tokensRemaining) {
          if (err) return callback(err, null);
          self2.tokensThisInterval += count3;
          callback(null, tokensRemaining);
        }
        __name(afterTokensRemoved, "afterTokensRemoved");
      }, "removeTokens"),
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens and we
       * haven't spent too many tokens in this interval already, this will return
       * true. Otherwise, false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: /* @__PURE__ */ __name(function(count3) {
        if (count3 > this.tokenBucket.bucketSize)
          return false;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count3 > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
          return false;
        var removed = this.tokenBucket.tryRemoveTokens(count3);
        if (removed) {
          this.tokensThisInterval += count3;
        }
        return removed;
      }, "tryRemoveTokens"),
      /**
       * Returns the number of tokens remaining in the TokenBucket.
       * @returns {Number} The number of tokens remaining.
       */
      getTokensRemaining: /* @__PURE__ */ __name(function() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
      }, "getTokensRemaining")
    };
    module.exports = RateLimiter;
  }
});

// node_modules/limiter/index.js
var require_limiter = __commonJS({
  "node_modules/limiter/index.js"(exports) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    exports.RateLimiter = require_rateLimiter();
    exports.TokenBucket = require_tokenBucket();
  }
});

// node_modules/jwks-rsa/src/errors/JwksRateLimitError.js
var require_JwksRateLimitError = __commonJS({
  "node_modules/jwks-rsa/src/errors/JwksRateLimitError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function JwksRateLimitError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "JwksRateLimitError";
      this.message = message2;
    }
    __name(JwksRateLimitError, "JwksRateLimitError");
    JwksRateLimitError.prototype = Object.create(Error.prototype);
    JwksRateLimitError.prototype.constructor = JwksRateLimitError;
    module.exports = JwksRateLimitError;
  }
});

// node_modules/jwks-rsa/src/wrappers/rateLimit.js
var require_rateLimit = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/rateLimit.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var logger = require_debug()("jwks");
    var { RateLimiter } = require_limiter();
    var JwksRateLimitError = require_JwksRateLimitError();
    function rateLimitWrapper(client, { jwksRequestsPerMinute = 10 }) {
      const getSigningKey = client.getSigningKey.bind(client);
      const limiter = new RateLimiter(jwksRequestsPerMinute, "minute", true);
      logger(`Configured rate limiting to JWKS endpoint at ${jwksRequestsPerMinute}/minute`);
      return async (kid) => await new Promise((resolve, reject) => {
        limiter.removeTokens(1, async (err, remaining) => {
          if (err) {
            reject(err);
          }
          logger("Requests to the JWKS endpoint available for the next minute:", remaining);
          if (remaining < 0) {
            logger("Too many requests to the JWKS endpoint");
            reject(new JwksRateLimitError("Too many requests to the JWKS endpoint"));
          } else {
            try {
              const key = await getSigningKey(kid);
              resolve(key);
            } catch (error3) {
              reject(error3);
            }
          }
        });
      });
    }
    __name(rateLimitWrapper, "rateLimitWrapper");
    module.exports.default = rateLimitWrapper;
  }
});

// node_modules/jwks-rsa/src/wrappers/interceptor.js
var require_interceptor2 = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/interceptor.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var retrieveSigningKeys = require_utils2().retrieveSigningKeys;
    function getKeysInterceptor(client, { getKeysInterceptor: getKeysInterceptor2 }) {
      const getSigningKey = client.getSigningKey.bind(client);
      return async (kid) => {
        const keys = await getKeysInterceptor2();
        let signingKeys;
        if (keys && keys.length) {
          signingKeys = await retrieveSigningKeys(keys);
        }
        if (signingKeys && signingKeys.length) {
          const key = signingKeys.find((k) => !kid || k.kid === kid);
          if (key) {
            return key;
          }
        }
        return getSigningKey(kid);
      };
    }
    __name(getKeysInterceptor, "getKeysInterceptor");
    module.exports.default = getKeysInterceptor;
  }
});

// node_modules/jwks-rsa/src/wrappers/callbackSupport.js
var require_callbackSupport = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/callbackSupport.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { callbackify: callbackify3 } = require_util3();
    var callbackSupport = /* @__PURE__ */ __name((client) => {
      const getSigningKey = client.getSigningKey.bind(client);
      return (kid, cb) => {
        if (cb) {
          const callbackFunc = callbackify3(getSigningKey);
          return callbackFunc(kid, cb);
        }
        return getSigningKey(kid);
      };
    }, "callbackSupport");
    module.exports.default = callbackSupport;
  }
});

// node_modules/jwks-rsa/src/wrappers/index.js
var require_wrappers = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      request: require_request().default,
      cacheSigningKey: require_cache().default,
      rateLimitSigningKey: require_rateLimit().default,
      getKeysInterceptor: require_interceptor2().default,
      callbackSupport: require_callbackSupport().default
    };
  }
});

// node_modules/jwks-rsa/src/errors/SigningKeyNotFoundError.js
var require_SigningKeyNotFoundError = __commonJS({
  "node_modules/jwks-rsa/src/errors/SigningKeyNotFoundError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function SigningKeyNotFoundError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "SigningKeyNotFoundError";
      this.message = message2;
    }
    __name(SigningKeyNotFoundError, "SigningKeyNotFoundError");
    SigningKeyNotFoundError.prototype = Object.create(Error.prototype);
    SigningKeyNotFoundError.prototype.constructor = SigningKeyNotFoundError;
    module.exports = SigningKeyNotFoundError;
  }
});

// node_modules/jwks-rsa/src/JwksClient.js
var require_JwksClient = __commonJS({
  "node_modules/jwks-rsa/src/JwksClient.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var logger = require_debug()("jwks");
    var { retrieveSigningKeys } = require_utils2();
    var { request: request3, cacheSigningKey, rateLimitSigningKey, getKeysInterceptor, callbackSupport } = require_wrappers();
    var JwksError = require_JwksError();
    var SigningKeyNotFoundError = require_SigningKeyNotFoundError();
    var JwksClient = class {
      static {
        __name(this, "JwksClient");
      }
      constructor(options) {
        this.options = {
          rateLimit: false,
          cache: true,
          timeout: 3e4,
          ...options
        };
        if (this.options.getKeysInterceptor) {
          this.getSigningKey = getKeysInterceptor(this, options);
        }
        if (this.options.rateLimit) {
          this.getSigningKey = rateLimitSigningKey(this, options);
        }
        if (this.options.cache) {
          this.getSigningKey = cacheSigningKey(this, options);
        }
        this.getSigningKey = callbackSupport(this, options);
      }
      async getKeys() {
        logger(`Fetching keys from '${this.options.jwksUri}'`);
        try {
          const res = await request3({
            uri: this.options.jwksUri,
            headers: this.options.requestHeaders,
            agent: this.options.requestAgent,
            timeout: this.options.timeout,
            fetcher: this.options.fetcher
          });
          logger("Keys:", res.keys);
          return res.keys;
        } catch (err) {
          const { errorMsg } = err;
          logger("Failure:", errorMsg || err);
          throw errorMsg ? new JwksError(errorMsg) : err;
        }
      }
      async getSigningKeys() {
        const keys = await this.getKeys();
        if (!keys || !keys.length) {
          throw new JwksError("The JWKS endpoint did not contain any keys");
        }
        const signingKeys = await retrieveSigningKeys(keys);
        if (!signingKeys.length) {
          throw new JwksError("The JWKS endpoint did not contain any signing keys");
        }
        logger("Signing Keys:", signingKeys);
        return signingKeys;
      }
      async getSigningKey(kid) {
        logger(`Fetching signing key for '${kid}'`);
        const keys = await this.getSigningKeys();
        const kidDefined = kid !== void 0 && kid !== null;
        if (!kidDefined && keys.length > 1) {
          logger("No KID specified and JWKS endpoint returned more than 1 key");
          throw new SigningKeyNotFoundError("No KID specified and JWKS endpoint returned more than 1 key");
        }
        const key = keys.find((k) => !kidDefined || k.kid === kid);
        if (key) {
          return key;
        } else {
          logger(`Unable to find a signing key that matches '${kid}'`);
          throw new SigningKeyNotFoundError(`Unable to find a signing key that matches '${kid}'`);
        }
      }
    };
    module.exports = {
      JwksClient
    };
  }
});

// node_modules/jwks-rsa/src/errors/ArgumentError.js
var require_ArgumentError = __commonJS({
  "node_modules/jwks-rsa/src/errors/ArgumentError.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    function ArgumentError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "ArgumentError";
      this.message = message2;
    }
    __name(ArgumentError, "ArgumentError");
    ArgumentError.prototype = Object.create(Error.prototype);
    ArgumentError.prototype.constructor = ArgumentError;
    module.exports = ArgumentError;
  }
});

// node_modules/jwks-rsa/src/errors/index.js
var require_errors = __commonJS({
  "node_modules/jwks-rsa/src/errors/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    module.exports = {
      ArgumentError: require_ArgumentError(),
      JwksError: require_JwksError(),
      JwksRateLimitError: require_JwksRateLimitError(),
      SigningKeyNotFoundError: require_SigningKeyNotFoundError()
    };
  }
});

// node_modules/jwks-rsa/src/integrations/config.js
var require_config = __commonJS({
  "node_modules/jwks-rsa/src/integrations/config.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var allowedSignatureAlg = [
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES256K",
      "ES384",
      "ES512",
      "EdDSA"
    ];
    module.exports = allowedSignatureAlg;
  }
});

// node_modules/jwks-rsa/src/integrations/hapi.js
var require_hapi = __commonJS({
  "node_modules/jwks-rsa/src/integrations/hapi.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = /* @__PURE__ */ __name((err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(err, null, null);
      }
      if (err) {
        return cb(err, null, null);
      }
    }, "handleSigningKeyError");
    module.exports.hapiJwt2KeyAsync = (options) => {
      const secretProvider = module.exports.hapiJwt2Key(options);
      return function(decoded) {
        return new Promise((resolve, reject) => {
          const cb = /* @__PURE__ */ __name((err, key) => {
            !key || err ? reject(err) : resolve({ key });
          }, "cb");
          secretProvider(decoded, cb);
        });
      };
    };
    module.exports.hapiJwt2Key = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing hapiJwt2Key");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      return /* @__PURE__ */ __name(function secretProvider(decoded, cb) {
        if (!decoded || !decoded.header) {
          return cb(new Error("Cannot find a signing certificate if there is no header"), null, null);
        }
        if (!supportedAlg.includes(decoded.header.alg)) {
          return cb(new Error("Unsupported algorithm " + decoded.header.alg + " supplied."), null, null);
        }
        client.getSigningKey(decoded.header.kid).then((key) => {
          return cb(null, key.publicKey || key.rsaPublicKey, key);
        }).catch((err) => {
          return onError(err, (newError) => cb(newError, null, null));
        });
      }, "secretProvider");
    };
  }
});

// node_modules/jwks-rsa/src/integrations/express.js
var require_express = __commonJS({
  "node_modules/jwks-rsa/src/integrations/express.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = /* @__PURE__ */ __name((err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(null);
      }
      if (err) {
        return cb(err);
      }
    }, "handleSigningKeyError");
    module.exports.expressJwtSecret = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing expressJwtSecret");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      const expressJwt7Provider = /* @__PURE__ */ __name(async (req, token) => {
        if (!token) {
          return;
        }
        const header = token.header;
        if (!header || !supportedAlg.includes(header.alg)) {
          return;
        }
        try {
          const key = await client.getSigningKey(header.kid);
          return key.publicKey || key.rsaPublicKey;
        } catch (err) {
          return new Promise((resolve, reject) => {
            onError(err, (newError) => {
              if (!newError) {
                return resolve();
              }
              reject(newError);
            });
          });
        }
      }, "expressJwt7Provider");
      return /* @__PURE__ */ __name(function secretProvider(req, header, payload, cb) {
        if (arguments.length === 4) {
          expressJwt7Provider(req, { header }).then((key) => {
            setImmediate(cb, null, key);
          }).catch((err) => {
            setImmediate(cb, err);
          });
          return;
        }
        return expressJwt7Provider(req, arguments[1]);
      }, "secretProvider");
    };
  }
});

// node_modules/jwks-rsa/src/integrations/koa.js
var require_koa = __commonJS({
  "node_modules/jwks-rsa/src/integrations/koa.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    module.exports.koaJwtSecret = function(options = {}) {
      if (!options.jwksUri) {
        throw new ArgumentError("No JWKS provided. Please provide a jwksUri");
      }
      const client = new JwksClient(options);
      return /* @__PURE__ */ __name(function secretProvider({ alg, kid } = {}) {
        return new Promise((resolve, reject) => {
          if (!supportedAlg.includes(alg)) {
            return reject(new Error("Missing / invalid token algorithm"));
          }
          client.getSigningKey(kid).then((key) => {
            resolve(key.publicKey || key.rsaPublicKey);
          }).catch((err) => {
            if (options.handleSigningKeyError) {
              return options.handleSigningKeyError(err).then(reject);
            }
            return reject(err);
          });
        });
      }, "secretProvider");
    };
  }
});

// node_modules/jwks-rsa/src/integrations/passport.js
var require_passport = __commonJS({
  "node_modules/jwks-rsa/src/integrations/passport.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var jose = (init_browser(), __toCommonJS(browser_exports));
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = /* @__PURE__ */ __name((err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(null);
      }
      if (err) {
        return cb(err);
      }
    }, "handleSigningKeyError");
    module.exports.passportJwtSecret = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing passportJwtSecret");
      }
      if (!options.jwksUri) {
        throw new ArgumentError("No JWKS provided. Please provide a jwksUri");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      return /* @__PURE__ */ __name(function secretProvider(req, rawJwtToken, cb) {
        let decoded;
        try {
          decoded = {
            payload: jose.decodeJwt(rawJwtToken),
            header: jose.decodeProtectedHeader(rawJwtToken)
          };
        } catch (err) {
          decoded = null;
        }
        if (!decoded || !supportedAlg.includes(decoded.header.alg)) {
          return cb(null, null);
        }
        client.getSigningKey(decoded.header.kid).then((key) => {
          cb(null, key.publicKey || key.rsaPublicKey);
        }).catch((err) => {
          onError(err, (newError) => cb(newError, null));
        });
      }, "secretProvider");
    };
  }
});

// node_modules/jwks-rsa/src/index.js
var require_src5 = __commonJS({
  "node_modules/jwks-rsa/src/index.js"(exports, module) {
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    var { JwksClient } = require_JwksClient();
    var errors = require_errors();
    var { hapiJwt2Key, hapiJwt2KeyAsync } = require_hapi();
    var { expressJwtSecret } = require_express();
    var { koaJwtSecret } = require_koa();
    var { passportJwtSecret } = require_passport();
    module.exports = (options) => {
      return new JwksClient(options);
    };
    module.exports.JwksClient = JwksClient;
    module.exports.ArgumentError = errors.ArgumentError;
    module.exports.JwksError = errors.JwksError;
    module.exports.JwksRateLimitError = errors.JwksRateLimitError;
    module.exports.SigningKeyNotFoundError = errors.SigningKeyNotFoundError;
    module.exports.expressJwtSecret = expressJwtSecret;
    module.exports.hapiJwt2Key = hapiJwt2Key;
    module.exports.hapiJwt2KeyAsync = hapiJwt2KeyAsync;
    module.exports.koaJwtSecret = koaJwtSecret;
    module.exports.passportJwtSecret = passportJwtSecret;
  }
});

// node_modules/firebase-admin/lib/utils/jwt.js
var require_jwt = __commonJS({
  "node_modules/firebase-admin/lib/utils/jwt.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwtErrorCode = exports.JwtError = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;
    exports.verifyJwtSignature = verifyJwtSignature;
    exports.decodeJwt = decodeJwt2;
    var validator = require_validator();
    var jwt = require_jsonwebtoken();
    var jwks = require_src5();
    var api_request_1 = require_api_request();
    exports.ALGORITHM_RS256 = "RS256";
    var JWT_CALLBACK_ERROR_PREFIX = "error in secret or public key callback: ";
    var NO_MATCHING_KID_ERROR_MESSAGE = "no-matching-kid-error";
    var NO_KID_IN_HEADER_ERROR_MESSAGE = "no-kid-in-header-error";
    var HOUR_IN_SECONDS = 3600;
    var JwksFetcher = class {
      static {
        __name(this, "JwksFetcher");
      }
      constructor(jwksUrl, httpAgent) {
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(jwksUrl)) {
          throw new Error("The provided JWKS URL is not a valid URL.");
        }
        this.client = jwks({
          jwksUri: jwksUrl,
          cache: false,
          // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.
          requestAgent: httpAgent
        });
      }
      fetchPublicKeys() {
        if (this.shouldRefresh()) {
          return this.refresh();
        }
        return Promise.resolve(this.publicKeys);
      }
      shouldRefresh() {
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
      }
      refresh() {
        return this.client.getSigningKeys().then((signingKeys) => {
          this.publicKeysExpireAt = 0;
          const newKeys = signingKeys.reduce((map, signingKey) => {
            map[signingKey.kid] = signingKey.getPublicKey();
            return map;
          }, {});
          this.publicKeysExpireAt = Date.now() + HOUR_IN_SECONDS * 6 * 1e3;
          this.publicKeys = newKeys;
          return newKeys;
        }).catch((err) => {
          throw new Error(`Error fetching Json Web Keys: ${err.message}`);
        });
      }
    };
    exports.JwksFetcher = JwksFetcher;
    var UrlKeyFetcher = class {
      static {
        __name(this, "UrlKeyFetcher");
      }
      constructor(clientCertUrl, httpAgent) {
        this.clientCertUrl = clientCertUrl;
        this.httpAgent = httpAgent;
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(clientCertUrl)) {
          throw new Error("The provided public client certificate URL is not a valid URL.");
        }
      }
      /**
       * Fetches the public keys for the Google certs.
       *
       * @returns A promise fulfilled with public keys for the Google certs.
       */
      fetchPublicKeys() {
        if (this.shouldRefresh()) {
          return this.refresh();
        }
        return Promise.resolve(this.publicKeys);
      }
      /**
       * Checks if the cached public keys need to be refreshed.
       *
       * @returns Whether the keys should be fetched from the client certs url or not.
       */
      shouldRefresh() {
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
      }
      refresh() {
        const client = new api_request_1.HttpClient();
        const request3 = {
          method: "GET",
          url: this.clientCertUrl,
          httpAgent: this.httpAgent
        };
        return client.send(request3).then((resp) => {
          if (!resp.isJson() || resp.data.error) {
            throw new api_request_1.RequestResponseError(resp);
          }
          this.publicKeysExpireAt = 0;
          if (Object.prototype.hasOwnProperty.call(resp.headers, "cache-control")) {
            const cacheControlHeader = resp.headers["cache-control"];
            const parts = cacheControlHeader.split(",");
            parts.forEach((part) => {
              const subParts = part.trim().split("=");
              if (subParts[0] === "max-age") {
                const maxAge = +subParts[1];
                this.publicKeysExpireAt = Date.now() + maxAge * 1e3;
              }
            });
          }
          this.publicKeys = resp.data;
          return resp.data;
        }).catch((err) => {
          if (err instanceof api_request_1.RequestResponseError) {
            let errorMessage = "Error fetching public keys for Google certs: ";
            const resp = err.response;
            if (resp.isJson() && resp.data.error) {
              errorMessage += `${resp.data.error}`;
              if (resp.data.error_description) {
                errorMessage += " (" + resp.data.error_description + ")";
              }
            } else {
              errorMessage += `${resp.text}`;
            }
            throw new Error(errorMessage);
          }
          throw err;
        });
      }
    };
    exports.UrlKeyFetcher = UrlKeyFetcher;
    var PublicKeySignatureVerifier = class _PublicKeySignatureVerifier {
      static {
        __name(this, "PublicKeySignatureVerifier");
      }
      constructor(keyFetcher) {
        this.keyFetcher = keyFetcher;
        if (!validator.isNonNullObject(keyFetcher)) {
          throw new Error("The provided key fetcher is not an object or null.");
        }
      }
      static withCertificateUrl(clientCertUrl, httpAgent) {
        return new _PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));
      }
      static withJwksUrl(jwksUrl, httpAgent) {
        return new _PublicKeySignatureVerifier(new JwksFetcher(jwksUrl, httpAgent));
      }
      verify(token) {
        if (!validator.isString(token)) {
          return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
        }
        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), { algorithms: [exports.ALGORITHM_RS256] }).catch((error3) => {
          if (error3.code === JwtErrorCode.NO_KID_IN_HEADER) {
            return this.verifyWithoutKid(token);
          }
          throw error3;
        });
      }
      verifyWithoutKid(token) {
        return this.keyFetcher.fetchPublicKeys().then((publicKeys) => this.verifyWithAllKeys(token, publicKeys));
      }
      verifyWithAllKeys(token, keys) {
        const promises = [];
        Object.values(keys).forEach((key) => {
          const result = verifyJwtSignature(token, key).then(() => true).catch((error3) => {
            if (error3.code === JwtErrorCode.TOKEN_EXPIRED) {
              throw error3;
            }
            return false;
          });
          promises.push(result);
        });
        return Promise.all(promises).then((result) => {
          if (result.every((r) => r === false)) {
            throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, "Invalid token signature.");
          }
        });
      }
    };
    exports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;
    var EmulatorSignatureVerifier = class {
      static {
        __name(this, "EmulatorSignatureVerifier");
      }
      verify(token) {
        return verifyJwtSignature(token, void 0, { algorithms: ["none"] });
      }
    };
    exports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;
    function getKeyCallback(fetcher) {
      return (header, callback) => {
        if (!header.kid) {
          callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));
        }
        const kid = header.kid || "";
        fetcher.fetchPublicKeys().then((publicKeys) => {
          if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {
            callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));
          } else {
            callback(null, publicKeys[kid]);
          }
        }).catch((error3) => {
          callback(error3);
        });
      };
    }
    __name(getKeyCallback, "getKeyCallback");
    function verifyJwtSignature(token, secretOrPublicKey, options) {
      if (!validator.isString(token)) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
      }
      return new Promise((resolve, reject) => {
        jwt.verify(token, secretOrPublicKey, options, (error3) => {
          if (!error3) {
            return resolve();
          }
          if (error3.name === "TokenExpiredError") {
            return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, "The provided token has expired. Get a fresh token from your client app and try again."));
          } else if (error3.name === "JsonWebTokenError") {
            if (error3.message && error3.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {
              const message2 = error3.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || "Error fetching public keys.";
              let code = JwtErrorCode.KEY_FETCH_ERROR;
              if (message2 === NO_MATCHING_KID_ERROR_MESSAGE) {
                code = JwtErrorCode.NO_MATCHING_KID;
              } else if (message2 === NO_KID_IN_HEADER_ERROR_MESSAGE) {
                code = JwtErrorCode.NO_KID_IN_HEADER;
              }
              return reject(new JwtError(code, message2));
            }
          }
          return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error3.message));
        });
      });
    }
    __name(verifyJwtSignature, "verifyJwtSignature");
    function decodeJwt2(jwtToken) {
      if (!validator.isString(jwtToken)) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
      }
      const fullDecodedToken = jwt.decode(jwtToken, {
        complete: true
      });
      if (!fullDecodedToken) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "Decoding token failed."));
      }
      const header = fullDecodedToken?.header;
      const payload = fullDecodedToken?.payload;
      return Promise.resolve({ header, payload });
    }
    __name(decodeJwt2, "decodeJwt");
    var JwtError = class _JwtError extends Error {
      static {
        __name(this, "JwtError");
      }
      constructor(code, message2) {
        super(message2);
        this.code = code;
        this.message = message2;
        this.__proto__ = _JwtError.prototype;
      }
    };
    exports.JwtError = JwtError;
    var JwtErrorCode;
    (function(JwtErrorCode2) {
      JwtErrorCode2["INVALID_ARGUMENT"] = "invalid-argument";
      JwtErrorCode2["INVALID_CREDENTIAL"] = "invalid-credential";
      JwtErrorCode2["TOKEN_EXPIRED"] = "token-expired";
      JwtErrorCode2["INVALID_SIGNATURE"] = "invalid-token";
      JwtErrorCode2["NO_MATCHING_KID"] = "no-matching-kid-error";
      JwtErrorCode2["NO_KID_IN_HEADER"] = "no-kid-error";
      JwtErrorCode2["KEY_FETCH_ERROR"] = "key-fetch-error";
    })(JwtErrorCode || (exports.JwtErrorCode = JwtErrorCode = {}));
  }
});

// node_modules/firebase-admin/lib/auth/token-verifier.js
var require_token_verifier = __commonJS({
  "node_modules/firebase-admin/lib/auth/token-verifier.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseTokenVerifier = exports.SESSION_COOKIE_INFO = exports.AUTH_BLOCKING_TOKEN_INFO = exports.ID_TOKEN_INFO = void 0;
    exports.createIdTokenVerifier = createIdTokenVerifier;
    exports.createAuthBlockingTokenVerifier = createAuthBlockingTokenVerifier;
    exports.createSessionCookieVerifier = createSessionCookieVerifier;
    var error_1 = require_error();
    var util = require_utils();
    var validator = require_validator();
    var jwt_1 = require_jwt();
    var FIREBASE_AUDIENCE = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit";
    var CLIENT_CERT_URL = "https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com";
    var SESSION_COOKIE_CERT_URL = "https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys";
    var EMULATOR_VERIFIER = new jwt_1.EmulatorSignatureVerifier();
    exports.ID_TOKEN_INFO = {
      url: "https://firebase.google.com/docs/auth/admin/verify-id-tokens",
      verifyApiName: "verifyIdToken()",
      jwtName: "Firebase ID token",
      shortName: "ID token",
      expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED
    };
    exports.AUTH_BLOCKING_TOKEN_INFO = {
      url: "https://cloud.google.com/identity-platform/docs/blocking-functions",
      verifyApiName: "_verifyAuthBlockingToken()",
      jwtName: "Firebase Auth Blocking token",
      shortName: "Auth Blocking token",
      expiredErrorCode: error_1.AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED
    };
    exports.SESSION_COOKIE_INFO = {
      url: "https://firebase.google.com/docs/auth/admin/manage-cookies",
      verifyApiName: "verifySessionCookie()",
      jwtName: "Firebase session cookie",
      shortName: "session cookie",
      expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED
    };
    var FirebaseTokenVerifier = class {
      static {
        __name(this, "FirebaseTokenVerifier");
      }
      constructor(clientCertUrl, issuer, tokenInfo, app) {
        this.issuer = issuer;
        this.tokenInfo = tokenInfo;
        this.app = app;
        if (!validator.isURL(clientCertUrl)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided public client certificate URL is an invalid URL.");
        } else if (!validator.isURL(issuer)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT issuer is an invalid URL.");
        } else if (!validator.isNonNullObject(tokenInfo)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT information is not an object or null.");
        } else if (!validator.isURL(tokenInfo.url)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT verification documentation URL is invalid.");
        } else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT verify API name must be a non-empty string.");
        } else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public full name must be a non-empty string.");
        } else if (!validator.isNonEmptyString(tokenInfo.shortName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public short name must be a non-empty string.");
        } else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !("code" in tokenInfo.expiredErrorCode)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT expiration error code must be a non-null ErrorInfo object.");
        }
        this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? "an" : "a";
        this.signatureVerifier = jwt_1.PublicKeySignatureVerifier.withCertificateUrl(clientCertUrl, app.options.httpAgent);
      }
      /**
       * Verifies the format and signature of a Firebase Auth JWT token.
       *
       * @param jwtToken - The Firebase Auth JWT token to verify.
       * @param isEmulator - Whether to accept Auth Emulator tokens.
       * @returns A promise fulfilled with the decoded claims of the Firebase Auth ID token.
       */
      verifyJWT(jwtToken, isEmulator = false) {
        if (!validator.isString(jwtToken)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
        }
        return this.ensureProjectId().then((projectId) => {
          return this.decodeAndVerify(jwtToken, projectId, isEmulator);
        }).then((decoded) => {
          const decodedIdToken = decoded.payload;
          decodedIdToken.uid = decodedIdToken.sub;
          return decodedIdToken;
        });
      }
      /** @alpha */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _verifyAuthBlockingToken(jwtToken, isEmulator, audience) {
        if (!validator.isString(jwtToken)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
        }
        return this.ensureProjectId().then((projectId) => {
          if (typeof audience === "undefined") {
            audience = `${projectId}.cloudfunctions.net/`;
          }
          return this.decodeAndVerify(jwtToken, projectId, isEmulator, audience);
        }).then((decoded) => {
          const decodedAuthBlockingToken = decoded.payload;
          decodedAuthBlockingToken.uid = decodedAuthBlockingToken.sub;
          return decodedAuthBlockingToken;
        });
      }
      ensureProjectId() {
        return util.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, `Must initialize app with a cert credential or set your Firebase project ID as the GOOGLE_CLOUD_PROJECT environment variable to call ${this.tokenInfo.verifyApiName}.`);
          }
          return Promise.resolve(projectId);
        });
      }
      decodeAndVerify(token, projectId, isEmulator, audience) {
        return this.safeDecode(token).then((decodedToken) => {
          this.verifyContent(decodedToken, projectId, isEmulator, audience);
          return this.verifySignature(token, isEmulator).then(() => decodedToken);
        });
      }
      safeDecode(jwtToken) {
        return (0, jwt_1.decodeJwt)(jwtToken).catch((err) => {
          if (err.code === jwt_1.JwtErrorCode.INVALID_ARGUMENT) {
            const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
            const errorMessage = `Decoding ${this.tokenInfo.jwtName} failed. Make sure you passed the entire string JWT which represents ${this.shortNameArticle} ${this.tokenInfo.shortName}.` + verifyJwtTokenDocsMessage;
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
          }
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, err.message);
        });
      }
      /**
       * Verifies the content of a Firebase Auth JWT.
       *
       * @param fullDecodedToken - The decoded JWT.
       * @param projectId - The Firebase Project Id.
       * @param isEmulator - Whether the token is an Emulator token.
       */
      verifyContent(fullDecodedToken, projectId, isEmulator, audience) {
        const header = fullDecodedToken && fullDecodedToken.header;
        const payload = fullDecodedToken && fullDecodedToken.payload;
        const projectIdMatchMessage = ` Make sure the ${this.tokenInfo.shortName} comes from the same Firebase project as the service account used to authenticate this SDK.`;
        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
        let errorMessage;
        if (!isEmulator && typeof header.kid === "undefined") {
          const isCustomToken = payload.aud === FIREBASE_AUDIENCE;
          const isLegacyCustomToken = header.alg === "HS256" && payload.v === 0 && "d" in payload && "uid" in payload.d;
          if (isCustomToken) {
            errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a custom token.`;
          } else if (isLegacyCustomToken) {
            errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a legacy custom token.`;
          } else {
            errorMessage = `${this.tokenInfo.jwtName} has no "kid" claim.`;
          }
          errorMessage += verifyJwtTokenDocsMessage;
        } else if (!isEmulator && header.alg !== jwt_1.ALGORITHM_RS256) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect algorithm. Expected "` + jwt_1.ALGORITHM_RS256 + '" but got "' + header.alg + '".' + verifyJwtTokenDocsMessage;
        } else if (typeof audience !== "undefined" && !payload.aud.includes(audience)) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + audience + '" but got "' + payload.aud + '".' + verifyJwtTokenDocsMessage;
        } else if (typeof audience === "undefined" && payload.aud !== projectId) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + projectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;
        } else if (payload.iss !== this.issuer + projectId) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "iss" (issuer) claim. Expected "${this.issuer}` + projectId + '" but got "' + payload.iss + '".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;
        } else if (!(payload.event_type !== void 0 && (payload.event_type === "beforeSendSms" || payload.event_type === "beforeSendEmail"))) {
          if (typeof payload.sub !== "string") {
            errorMessage = `${this.tokenInfo.jwtName} has no "sub" (subject) claim.` + verifyJwtTokenDocsMessage;
          } else if (payload.sub === "") {
            errorMessage = `${this.tokenInfo.jwtName} has an empty "sub" (subject) claim.` + verifyJwtTokenDocsMessage;
          } else if (payload.sub.length > 128) {
            errorMessage = `${this.tokenInfo.jwtName} has a "sub" (subject) claim longer than 128 characters.` + verifyJwtTokenDocsMessage;
          }
        }
        if (errorMessage) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
      }
      verifySignature(jwtToken, isEmulator) {
        const verifier = isEmulator ? EMULATOR_VERIFIER : this.signatureVerifier;
        return verifier.verify(jwtToken).catch((error3) => {
          throw this.mapJwtErrorToAuthError(error3);
        });
      }
      /**
       * Maps JwtError to FirebaseAuthError
       *
       * @param error - JwtError to be mapped.
       * @returns FirebaseAuthError or Error instance.
       */
      mapJwtErrorToAuthError(error3) {
        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
        if (error3.code === jwt_1.JwtErrorCode.TOKEN_EXPIRED) {
          const errorMessage = `${this.tokenInfo.jwtName} has expired. Get a fresh ${this.tokenInfo.shortName} from your client app and try again (auth/${this.tokenInfo.expiredErrorCode.code}).` + verifyJwtTokenDocsMessage;
          return new error_1.FirebaseAuthError(this.tokenInfo.expiredErrorCode, errorMessage);
        } else if (error3.code === jwt_1.JwtErrorCode.INVALID_SIGNATURE) {
          const errorMessage = `${this.tokenInfo.jwtName} has invalid signature.` + verifyJwtTokenDocsMessage;
          return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        } else if (error3.code === jwt_1.JwtErrorCode.NO_MATCHING_KID) {
          const errorMessage = `${this.tokenInfo.jwtName} has "kid" claim which does not correspond to a known public key. Most likely the ${this.tokenInfo.shortName} is expired, so get a fresh token from your client app and try again.`;
          return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error3.message);
      }
    };
    exports.FirebaseTokenVerifier = FirebaseTokenVerifier;
    function createIdTokenVerifier(app) {
      return new FirebaseTokenVerifier(CLIENT_CERT_URL, "https://securetoken.google.com/", exports.ID_TOKEN_INFO, app);
    }
    __name(createIdTokenVerifier, "createIdTokenVerifier");
    function createAuthBlockingTokenVerifier(app) {
      return new FirebaseTokenVerifier(CLIENT_CERT_URL, "https://securetoken.google.com/", exports.AUTH_BLOCKING_TOKEN_INFO, app);
    }
    __name(createAuthBlockingTokenVerifier, "createAuthBlockingTokenVerifier");
    function createSessionCookieVerifier(app) {
      return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, "https://session.firebase.google.com/", exports.SESSION_COOKIE_INFO, app);
    }
    __name(createSessionCookieVerifier, "createSessionCookieVerifier");
  }
});

// node_modules/firebase-admin/lib/auth/user-record.js
var require_user_record = __commonJS({
  "node_modules/firebase-admin/lib/auth/user-record.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.TotpMultiFactorInfo = exports.TotpInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;
    var deep_copy_1 = require_deep_copy();
    var validator_1 = require_validator();
    var utils = require_utils();
    var error_1 = require_error();
    var B64_REDACTED = Buffer.from("REDACTED").toString("base64");
    function parseDate(time3) {
      try {
        const date = new Date(parseInt(time3, 10));
        if (!isNaN(date.getTime())) {
          return date.toUTCString();
        }
      } catch (e) {
      }
      return null;
    }
    __name(parseDate, "parseDate");
    var MultiFactorId;
    (function(MultiFactorId2) {
      MultiFactorId2["Phone"] = "phone";
      MultiFactorId2["Totp"] = "totp";
    })(MultiFactorId || (MultiFactorId = {}));
    var MultiFactorInfo2 = class {
      static {
        __name(this, "MultiFactorInfo");
      }
      /**
       * Initializes the MultiFactorInfo associated subclass using the server side.
       * If no MultiFactorInfo is associated with the response, null is returned.
       *
       * @param response - The server side response.
       * @internal
       */
      static initMultiFactorInfo(response) {
        let multiFactorInfo = null;
        try {
          if (response.phoneInfo !== void 0) {
            multiFactorInfo = new PhoneMultiFactorInfo2(response);
          } else if (response.totpInfo !== void 0) {
            multiFactorInfo = new TotpMultiFactorInfo(response);
          } else {
          }
        } catch (e) {
        }
        return multiFactorInfo;
      }
      /**
       * Initializes the MultiFactorInfo object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        this.initFromServerResponse(response);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          uid: this.uid,
          displayName: this.displayName,
          factorId: this.factorId,
          enrollmentTime: this.enrollmentTime
        };
      }
      /**
       * Initializes the MultiFactorInfo object using the provided server response.
       *
       * @param response - The server side response.
       */
      initFromServerResponse(response) {
        const factorId = response && this.getFactorId(response);
        if (!factorId || !response || !response.mfaEnrollmentId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor info response");
        }
        utils.addReadonlyGetter(this, "uid", response.mfaEnrollmentId);
        utils.addReadonlyGetter(this, "factorId", factorId);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        if (response.enrolledAt) {
          utils.addReadonlyGetter(this, "enrollmentTime", new Date(response.enrolledAt).toUTCString());
        } else {
          utils.addReadonlyGetter(this, "enrollmentTime", null);
        }
      }
    };
    exports.MultiFactorInfo = MultiFactorInfo2;
    var PhoneMultiFactorInfo2 = class extends MultiFactorInfo2 {
      static {
        __name(this, "PhoneMultiFactorInfo");
      }
      /**
       * Initializes the PhoneMultiFactorInfo object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        super(response);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneInfo);
      }
      /**
       * {@inheritdoc MultiFactorInfo.toJSON}
       */
      toJSON() {
        return Object.assign(super.toJSON(), {
          phoneNumber: this.phoneNumber
        });
      }
      /**
       * Returns the factor ID based on the response provided.
       *
       * @param response - The server side response.
       * @returns The multi-factor ID associated with the provided response. If the response is
       *     not associated with any known multi-factor ID, null is returned.
       *
       * @internal
       */
      getFactorId(response) {
        return response && response.phoneInfo ? MultiFactorId.Phone : null;
      }
    };
    exports.PhoneMultiFactorInfo = PhoneMultiFactorInfo2;
    var TotpInfo = class {
      static {
        __name(this, "TotpInfo");
      }
    };
    exports.TotpInfo = TotpInfo;
    var TotpMultiFactorInfo = class extends MultiFactorInfo2 {
      static {
        __name(this, "TotpMultiFactorInfo");
      }
      /**
       * Initializes the `TotpMultiFactorInfo` object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        super(response);
        utils.addReadonlyGetter(this, "totpInfo", response.totpInfo);
      }
      /**
       * {@inheritdoc MultiFactorInfo.toJSON}
       */
      toJSON() {
        return Object.assign(super.toJSON(), {
          totpInfo: this.totpInfo
        });
      }
      /**
       * Returns the factor ID based on the response provided.
       *
       * @param response - The server side response.
       * @returns The multi-factor ID associated with the provided response. If the response is
       *     not associated with any known multi-factor ID, `null` is returned.
       *
       * @internal
       */
      getFactorId(response) {
        return response && response.totpInfo ? MultiFactorId.Totp : null;
      }
    };
    exports.TotpMultiFactorInfo = TotpMultiFactorInfo;
    var MultiFactorSettings2 = class {
      static {
        __name(this, "MultiFactorSettings");
      }
      /**
       * Initializes the `MultiFactor` object using the server side or JWT format response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        const parsedEnrolledFactors = [];
        if (!(0, validator_1.isNonNullObject)(response)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor response");
        } else if (response.mfaInfo) {
          response.mfaInfo.forEach((factorResponse) => {
            const multiFactorInfo = MultiFactorInfo2.initMultiFactorInfo(factorResponse);
            if (multiFactorInfo) {
              parsedEnrolledFactors.push(multiFactorInfo);
            }
          });
        }
        utils.addReadonlyGetter(this, "enrolledFactors", Object.freeze(parsedEnrolledFactors));
      }
      /**
       * Returns a JSON-serializable representation of this multi-factor object.
       *
       * @returns A JSON-serializable representation of this multi-factor object.
       */
      toJSON() {
        return {
          enrolledFactors: this.enrolledFactors.map((info3) => info3.toJSON())
        };
      }
    };
    exports.MultiFactorSettings = MultiFactorSettings2;
    var UserMetadata2 = class {
      static {
        __name(this, "UserMetadata");
      }
      /**
       * @param response - The server side response returned from the `getAccountInfo`
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        utils.addReadonlyGetter(this, "creationTime", parseDate(response.createdAt));
        utils.addReadonlyGetter(this, "lastSignInTime", parseDate(response.lastLoginAt));
        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;
        utils.addReadonlyGetter(this, "lastRefreshTime", lastRefreshAt);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          lastSignInTime: this.lastSignInTime,
          creationTime: this.creationTime,
          lastRefreshTime: this.lastRefreshTime
        };
      }
    };
    exports.UserMetadata = UserMetadata2;
    var UserInfo2 = class {
      static {
        __name(this, "UserInfo");
      }
      /**
       * @param response - The server side response returned from the `getAccountInfo`
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (!response.rawId || !response.providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user info response");
        }
        utils.addReadonlyGetter(this, "uid", response.rawId);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        utils.addReadonlyGetter(this, "email", response.email);
        utils.addReadonlyGetter(this, "photoURL", response.photoUrl);
        utils.addReadonlyGetter(this, "providerId", response.providerId);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneNumber);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          uid: this.uid,
          displayName: this.displayName,
          email: this.email,
          photoURL: this.photoURL,
          providerId: this.providerId,
          phoneNumber: this.phoneNumber
        };
      }
    };
    exports.UserInfo = UserInfo2;
    var UserRecord2 = class {
      static {
        __name(this, "UserRecord");
      }
      /**
       * @param response - The server side response returned from the getAccountInfo
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (!response.localId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user response");
        }
        utils.addReadonlyGetter(this, "uid", response.localId);
        utils.addReadonlyGetter(this, "email", response.email);
        utils.addReadonlyGetter(this, "emailVerified", !!response.emailVerified);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        utils.addReadonlyGetter(this, "photoURL", response.photoUrl);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneNumber);
        utils.addReadonlyGetter(this, "disabled", response.disabled || false);
        utils.addReadonlyGetter(this, "metadata", new UserMetadata2(response));
        const providerData = [];
        for (const entry of response.providerUserInfo || []) {
          providerData.push(new UserInfo2(entry));
        }
        utils.addReadonlyGetter(this, "providerData", providerData);
        if (response.passwordHash === B64_REDACTED) {
          utils.addReadonlyGetter(this, "passwordHash", void 0);
        } else {
          utils.addReadonlyGetter(this, "passwordHash", response.passwordHash);
        }
        utils.addReadonlyGetter(this, "passwordSalt", response.salt);
        if (response.customAttributes) {
          utils.addReadonlyGetter(this, "customClaims", JSON.parse(response.customAttributes));
        }
        let validAfterTime = null;
        if (typeof response.validSince !== "undefined") {
          validAfterTime = parseDate(parseInt(response.validSince, 10) * 1e3);
        }
        utils.addReadonlyGetter(this, "tokensValidAfterTime", validAfterTime || void 0);
        utils.addReadonlyGetter(this, "tenantId", response.tenantId);
        const multiFactor = new MultiFactorSettings2(response);
        if (multiFactor.enrolledFactors.length > 0) {
          utils.addReadonlyGetter(this, "multiFactor", multiFactor);
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        const json = {
          uid: this.uid,
          email: this.email,
          emailVerified: this.emailVerified,
          displayName: this.displayName,
          photoURL: this.photoURL,
          phoneNumber: this.phoneNumber,
          disabled: this.disabled,
          // Convert metadata to json.
          metadata: this.metadata.toJSON(),
          passwordHash: this.passwordHash,
          passwordSalt: this.passwordSalt,
          customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),
          tokensValidAfterTime: this.tokensValidAfterTime,
          tenantId: this.tenantId
        };
        if (this.multiFactor) {
          json.multiFactor = this.multiFactor.toJSON();
        }
        json.providerData = [];
        for (const entry of this.providerData) {
          json.providerData.push(entry.toJSON());
        }
        return json;
      }
    };
    exports.UserRecord = UserRecord2;
  }
});

// node_modules/firebase-admin/lib/auth/base-auth.js
var require_base_auth = __commonJS({
  "node_modules/firebase-admin/lib/auth/base-auth.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseAuth = void 0;
    exports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;
    var error_1 = require_error();
    var deep_copy_1 = require_deep_copy();
    var validator = require_validator();
    var auth_api_request_1 = require_auth_api_request();
    var token_generator_1 = require_token_generator();
    var token_verifier_1 = require_token_verifier();
    var auth_config_1 = require_auth_config();
    var user_record_1 = require_user_record();
    var identifier_1 = require_identifier();
    var crypto_signer_1 = require_crypto_signer();
    function createFirebaseTokenGenerator(app, tenantId) {
      try {
        const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);
        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);
      } catch (err) {
        throw (0, token_generator_1.handleCryptoSignerError)(err);
      }
    }
    __name(createFirebaseTokenGenerator, "createFirebaseTokenGenerator");
    var BaseAuth2 = class {
      static {
        __name(this, "BaseAuth");
      }
      /**
       * The BaseAuth class constructor.
       *
       * @param app - The FirebaseApp to associate with this Auth instance.
       * @param authRequestHandler - The RPC request handler for this instance.
       * @param tokenGenerator - Optional token generator. If not specified, a
       *     (non-tenant-aware) instance will be created. Use this paramter to
       *     specify a tenant-aware tokenGenerator.
       * @constructor
       * @internal
       */
      constructor(app, authRequestHandler, tokenGenerator) {
        this.authRequestHandler = authRequestHandler;
        if (tokenGenerator) {
          this.tokenGenerator = tokenGenerator;
        } else {
          this.tokenGenerator = createFirebaseTokenGenerator(app);
        }
        this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);
        this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);
        this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);
      }
      /**
       * Creates a new Firebase custom token (JWT) that can be sent back to a client
       * device to use to sign in with the client SDKs' `signInWithCustomToken()`
       * methods. (Tenant-aware instances will also embed the tenant ID in the
       * token.)
       *
       * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` to use as the custom token's subject.
       * @param developerClaims - Optional additional claims to include
       *   in the custom token's payload.
       *
       * @returns A promise fulfilled with a custom token for the
       *   provided `uid` and payload.
       */
      createCustomToken(uid, developerClaims) {
        return this.tokenGenerator.createCustomToken(uid, developerClaims);
      }
      /**
       * Verifies a Firebase ID token (JWT). If the token is valid, the promise is
       * fulfilled with the token's decoded claims; otherwise, the promise is
       * rejected.
       *
       * If `checkRevoked` is set to true, first verifies whether the corresponding
       * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,
       * verifies if the session corresponding to the ID token was revoked. If the
       * corresponding user's session was invalidated, an `auth/id-token-revoked`
       * error is thrown. If not specified the check is not applied.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}
       * for code samples and detailed documentation.
       *
       * @param idToken - The ID token to verify.
       * @param checkRevoked - Whether to check if the ID token was revoked.
       *   This requires an extra request to the Firebase Auth backend to check
       *   the `tokensValidAfterTime` time for the corresponding user.
       *   When not specified, this additional check is not applied.
       *
       * @returns A promise fulfilled with the
       *   token's decoded claims if the ID token is valid; otherwise, a rejected
       *   promise.
       */
      verifyIdToken(idToken, checkRevoked = false) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then((decodedIdToken) => {
          if (checkRevoked || isEmulator) {
            return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);
          }
          return decodedIdToken;
        });
      }
      /**
       * Gets the user data for the user corresponding to a given `uid`.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user whose data to fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided `uid`.
       */
      getUser(uid) {
        return this.authRequestHandler.getAccountInfoByUid(uid).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given email.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param email - The email corresponding to the user whose data to
       *   fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided email.
       */
      getUserByEmail(email) {
        return this.authRequestHandler.getAccountInfoByEmail(email).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given phone number. The
       * phone number has to conform to the E.164 specification.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param phoneNumber - The phone number corresponding to the user whose
       *   data to fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided phone number.
       */
      getUserByPhoneNumber(phoneNumber) {
        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given provider id.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param providerId - The provider ID, for example, "google.com" for the
       *   Google provider.
       * @param uid - The user identifier for the given provider.
       *
       * @returns A promise fulfilled with the user data corresponding to the
       *   given provider id.
       */
      getUserByProviderUid(providerId, uid) {
        if (providerId === "phone") {
          return this.getUserByPhoneNumber(uid);
        } else if (providerId === "email") {
          return this.getUserByEmail(uid);
        }
        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data corresponding to the specified identifiers.
       *
       * There are no ordering guarantees; in particular, the nth entry in the result list is not
       * guaranteed to correspond to the nth entry in the input parameters list.
       *
       * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,
       * this method throws a FirebaseAuthError.
       *
       * @param identifiers - The identifiers used to indicate which user records should be returned.
       *     Must not have more than 100 entries.
       * @returns A promise that resolves to the corresponding user records.
       * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100
       *     identifiers are specified.
       */
      getUsers(identifiers) {
        if (!validator.isArray(identifiers)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`identifiers` parameter must be an array");
        }
        return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then((response) => {
          const isUserFound = /* @__PURE__ */ __name((id, userRecords) => {
            return !!userRecords.find((userRecord) => {
              if ((0, identifier_1.isUidIdentifier)(id)) {
                return id.uid === userRecord.uid;
              } else if ((0, identifier_1.isEmailIdentifier)(id)) {
                return id.email === userRecord.email;
              } else if ((0, identifier_1.isPhoneIdentifier)(id)) {
                return id.phoneNumber === userRecord.phoneNumber;
              } else if ((0, identifier_1.isProviderIdentifier)(id)) {
                const matchingUserInfo = userRecord.providerData.find((userInfo2) => {
                  return id.providerId === userInfo2.providerId;
                });
                return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;
              } else {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Unhandled identifier type");
              }
            });
          }, "isUserFound");
          const users = response.users ? response.users.map((user) => new user_record_1.UserRecord(user)) : [];
          const notFound = identifiers.filter((id) => !isUserFound(id, users));
          return { users, notFound };
        });
      }
      /**
       * Retrieves a list of users (single batch only) with a size of `maxResults`
       * starting from the offset as specified by `pageToken`. This is used to
       * retrieve all the users of a specified project in batches.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}
       * for code samples and detailed documentation.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also
       *   the maximum allowed limit.
       * @param pageToken - The next page token. If not specified, returns
       *   users starting without any offset.
       * @returns A promise that resolves with
       *   the current batch of downloaded users and the next page token.
       */
      listUsers(maxResults, pageToken) {
        return this.authRequestHandler.downloadAccount(maxResults, pageToken).then((response) => {
          const users = [];
          response.users.forEach((userResponse) => {
            users.push(new user_record_1.UserRecord(userResponse));
          });
          const result = {
            users,
            pageToken: response.nextPageToken
          };
          if (typeof result.pageToken === "undefined") {
            delete result.pageToken;
          }
          return result;
        });
      }
      /**
       * Creates a new user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}
       * for code samples and detailed documentation.
       *
       * @param properties - The properties to set on the
       *   new user record to be created.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the newly created user.
       */
      createUser(properties) {
        return this.authRequestHandler.createNewAccount(properties).then((uid) => {
          return this.getUser(uid);
        }).catch((error3) => {
          if (error3.code === "auth/user-not-found") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Unable to create the user record provided.");
          }
          throw error3;
        });
      }
      /**
       * Deletes an existing user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user to delete.
       *
       * @returns An empty promise fulfilled once the user has been
       *   deleted.
       */
      deleteUser(uid) {
        return this.authRequestHandler.deleteAccount(uid).then(() => {
        });
      }
      /**
       * Deletes the users specified by the given uids.
       *
       * Deleting a non-existing user won't generate an error (i.e. this method
       * is idempotent.) Non-existing users are considered to be successfully
       * deleted, and are therefore counted in the
       * `DeleteUsersResult.successCount` value.
       *
       * Only a maximum of 1000 identifiers may be supplied. If more than 1000
       * identifiers are supplied, this method throws a FirebaseAuthError.
       *
       * This API is currently rate limited at the server to 1 QPS. If you exceed
       * this, you may get a quota exceeded error. Therefore, if you want to
       * delete more than 1000 users, you may need to add a delay to ensure you
       * don't go over this limit.
       *
       * @param uids - The `uids` corresponding to the users to delete.
       *
       * @returns A Promise that resolves to the total number of successful/failed
       *     deletions, as well as the array of errors that corresponds to the
       *     failed deletions.
       */
      deleteUsers(uids) {
        if (!validator.isArray(uids)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`uids` parameter must be an array");
        }
        return this.authRequestHandler.deleteAccounts(
          uids,
          /*force=*/
          true
        ).then((batchDeleteAccountsResponse) => {
          const result = {
            failureCount: 0,
            successCount: uids.length,
            errors: []
          };
          if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {
            return result;
          }
          result.failureCount = batchDeleteAccountsResponse.errors.length;
          result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;
          result.errors = batchDeleteAccountsResponse.errors.map((batchDeleteErrorInfo) => {
            if (batchDeleteErrorInfo.index === void 0) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Corrupt BatchDeleteAccountsResponse detected");
            }
            const errMsgToError = /* @__PURE__ */ __name((msg) => {
              const code = msg && msg.startsWith("NOT_DISABLED") ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;
              return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);
            }, "errMsgToError");
            return {
              index: batchDeleteErrorInfo.index,
              error: errMsgToError(batchDeleteErrorInfo.message)
            };
          });
          return result;
        });
      }
      /**
       * Updates an existing user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user to update.
       * @param properties - The properties to update on
       *   the provided user.
       *
       * @returns A promise fulfilled with the
       *   updated user data.
       */
      updateUser(uid, properties) {
        properties = (0, deep_copy_1.deepCopy)(properties);
        if (properties?.providerToLink) {
          if (properties.providerToLink.providerId === "email") {
            if (typeof properties.email !== "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To link to the email/password provider, only specify the UpdateRequest.email field.");
            }
            properties.email = properties.providerToLink.uid;
            delete properties.providerToLink;
          } else if (properties.providerToLink.providerId === "phone") {
            if (typeof properties.phoneNumber !== "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To link to a phone provider, only specify the UpdateRequest.phoneNumber field.");
            }
            properties.phoneNumber = properties.providerToLink.uid;
            delete properties.providerToLink;
          }
        }
        if (properties?.providersToUnlink) {
          if (properties.providersToUnlink.indexOf("phone") !== -1) {
            if (properties.phoneNumber === null) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.");
            }
          }
        }
        return this.authRequestHandler.updateExistingAccount(uid, properties).then((existingUid) => {
          return this.getUser(existingUid);
        });
      }
      /**
       * Sets additional developer claims on an existing user identified by the
       * provided `uid`, typically used to define user roles and levels of
       * access. These claims should propagate to all devices where the user is
       * already signed in (after token expiration or when token refresh is forced)
       * and the next time the user signs in. If a reserved OIDC claim name
       * is used (sub, iat, iss, etc), an error is thrown. They are set on the
       * authenticated user's ID token JWT.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |
       * Defining user roles and access levels}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` of the user to edit.
       * @param customUserClaims - The developer claims to set. If null is
       *   passed, existing custom claims are deleted. Passing a custom claims payload
       *   larger than 1000 bytes will throw an error. Custom claims are added to the
       *   user's ID token which is transmitted on every authenticated request.
       *   For profile non-access related user attributes, use database or other
       *   separate storage systems.
       * @returns A promise that resolves when the operation completes
       *   successfully.
       */
      setCustomUserClaims(uid, customUserClaims) {
        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(() => {
        });
      }
      /**
       * Revokes all refresh tokens for an existing user.
       *
       * This API will update the user's {@link UserRecord.tokensValidAfterTime} to
       * the current UTC. It is important that the server on which this is called has
       * its clock set correctly and synchronized.
       *
       * While this will revoke all sessions for a specified user and disable any
       * new ID tokens for existing sessions from getting minted, existing ID tokens
       * may remain active until their natural expiration (one hour). To verify that
       * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}
       * where `checkRevoked` is set to true.
       *
       * @param uid - The `uid` corresponding to the user whose refresh tokens
       *   are to be revoked.
       *
       * @returns An empty promise fulfilled once the user's refresh
       *   tokens have been revoked.
       */
      revokeRefreshTokens(uid) {
        return this.authRequestHandler.revokeRefreshTokens(uid).then(() => {
        });
      }
      /**
       * Imports the provided list of users into Firebase Auth.
       * A maximum of 1000 users are allowed to be imported one at a time.
       * When importing users with passwords,
       * {@link UserImportOptions} are required to be
       * specified.
       * This operation is optimized for bulk imports and will ignore checks on `uid`,
       * `email` and other identifier uniqueness which could result in duplications.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided include
       *   password credentials.
       * @returns A promise that resolves when
       *   the operation completes with the result of the import. This includes the
       *   number of successful imports, the number of failed imports and their
       *   corresponding errors.
      */
      importUsers(users, options) {
        return this.authRequestHandler.uploadAccount(users, options);
      }
      /**
       * Creates a new Firebase session cookie with the specified options. The created
       * JWT string can be set as a server-side session cookie with a custom cookie
       * policy, and be used for session management. The session cookie JWT will have
       * the same payload claims as the provided ID token.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}
       * for code samples and detailed documentation.
       *
       * @param idToken - The Firebase ID token to exchange for a session
       *   cookie.
       * @param sessionCookieOptions - The session
       *   cookie options which includes custom session duration.
       *
       * @returns A promise that resolves on success with the
       *   created session cookie.
       */
      createSessionCookie(idToken, sessionCookieOptions) {
        if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
        }
        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);
      }
      /**
       * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.
       * Rejects the promise if the cookie could not be verified.
       *
       * If `checkRevoked` is set to true, first verifies whether the corresponding
       * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,
       * verifies if the session corresponding to the session cookie was revoked.
       * If the corresponding user's session was invalidated, an
       * `auth/session-cookie-revoked` error is thrown. If not specified the check
       * is not performed.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |
       * Verify Session Cookies}
       * for code samples and detailed documentation
       *
       * @param sessionCookie - The session cookie to verify.
       * @param checkForRevocation -  Whether to check if the session cookie was
       *   revoked. This requires an extra request to the Firebase Auth backend to
       *   check the `tokensValidAfterTime` time for the corresponding user.
       *   When not specified, this additional check is not performed.
       *
       * @returns A promise fulfilled with the
       *   session cookie's decoded claims if the session cookie is valid; otherwise,
       *   a rejected promise.
       */
      verifySessionCookie(sessionCookie, checkRevoked = false) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then((decodedIdToken) => {
          if (checkRevoked || isEmulator) {
            return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);
          }
          return decodedIdToken;
        });
      }
      /**
       * Generates the out of band email action link to reset a user's password.
       * The link is generated for the user with the specified email address. The
       * optional  {@link ActionCodeSettings} object
       * defines whether the link is to be handled by a mobile app or browser and the
       * additional state information to be passed in the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generatePasswordResetLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email address of the user whose password is to be
       *   reset.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the password reset link. The default password
       *     reset landing page will use this to display a link to go back to the app
       *     if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generatePasswordResetLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("PASSWORD_RESET", email, actionCodeSettings);
      }
      /**
       * Generates the out of band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email account to verify.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateEmailVerificationLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("VERIFY_EMAIL", email, actionCodeSettings);
      }
      /**
       * Generates an out-of-band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @param email - The current email account.
       * @param newEmail - The email address the account is being updated to.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is authorized
       *     in the console, or an error will be thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("VERIFY_AND_CHANGE_EMAIL", email, actionCodeSettings, newEmail);
      }
      /**
       * Generates the out of band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email account to verify.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateSignInWithEmailLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("EMAIL_SIGNIN", email, actionCodeSettings);
      }
      /**
       * Returns the list of existing provider configurations matching the filter
       * provided. At most, 100 provider configs can be listed at a time.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param options - The provider config filter to apply.
       * @returns A promise that resolves with the list of provider configs meeting the
       *   filter requirements.
       */
      listProviderConfigs(options) {
        const processResponse = /* @__PURE__ */ __name((response, providerConfigs) => {
          const result = {
            providerConfigs
          };
          if (Object.prototype.hasOwnProperty.call(response, "nextPageToken")) {
            result.pageToken = response.nextPageToken;
          }
          return result;
        }, "processResponse");
        if (options && options.type === "oidc") {
          return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then((response) => {
            const providerConfigs = [];
            response.oauthIdpConfigs.forEach((configResponse) => {
              providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));
            });
            return processResponse(response, providerConfigs);
          });
        } else if (options && options.type === "saml") {
          return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then((response) => {
            const providerConfigs = [];
            response.inboundSamlConfigs.forEach((configResponse) => {
              providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));
            });
            return processResponse(response, providerConfigs);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"AuthProviderConfigFilter.type" must be either "saml" or "oidc"'));
      }
      /**
       * Looks up an Auth provider configuration by the provided ID.
       * Returns a promise that resolves with the provider configuration
       * corresponding to the provider ID specified. If the specified ID does not
       * exist, an `auth/configuration-not-found` error is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to return.
       * @returns A promise that resolves
       *     with the configuration corresponding to the provided ID.
       */
      getProviderConfig(providerId) {
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.getOAuthIdpConfig(providerId).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.getInboundSamlConfig(providerId).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Deletes the provider configuration corresponding to the provider ID passed.
       * If the specified ID does not exist, an `auth/configuration-not-found` error
       * is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to delete.
       * @returns A promise that resolves on completion.
       */
      deleteProviderConfig(providerId) {
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.deleteOAuthIdpConfig(providerId);
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.deleteInboundSamlConfig(providerId);
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Returns a promise that resolves with the updated `AuthProviderConfig`
       * corresponding to the provider ID specified.
       * If the specified ID does not exist, an `auth/configuration-not-found` error
       * is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to update.
       * @param updatedConfig - The updated configuration.
       * @returns A promise that resolves with the updated provider configuration.
       */
      updateProviderConfig(providerId, updatedConfig) {
        if (!validator.isNonNullObject(updatedConfig)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "UpdateAuthProviderRequest" configuration.'));
        }
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Returns a promise that resolves with the newly created `AuthProviderConfig`
       * when the new provider configuration is created.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param config - The provider configuration to create.
       * @returns A promise that resolves with the created provider configuration.
       */
      createProviderConfig(config2) {
        if (!validator.isNonNullObject(config2)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "AuthProviderConfig" configuration.'));
        }
        if (auth_config_1.OIDCConfig.isProviderId(config2.providerId)) {
          return this.authRequestHandler.createOAuthIdpConfig(config2).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(config2.providerId)) {
          return this.authRequestHandler.createInboundSamlConfig(config2).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /** @alpha */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _verifyAuthBlockingToken(token, audience) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience).then((decodedAuthBlockingToken) => {
          return decodedAuthBlockingToken;
        });
      }
      /**
       * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that
       * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked
       * or user disabled.
       *
       * @param decodedIdToken - The JWT's decoded claims.
       * @param revocationErrorInfo - The revocation error info to throw on revocation
       *     detection.
       * @returns A promise that will be fulfilled after a successful verification.
       */
      verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {
        return this.getUser(decodedIdToken.sub).then((user) => {
          if (user.disabled) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, "The user record is disabled.");
          }
          if (user.tokensValidAfterTime) {
            const authTimeUtc = decodedIdToken.auth_time * 1e3;
            const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();
            if (authTimeUtc < validSinceUtc) {
              throw new error_1.FirebaseAuthError(revocationErrorInfo);
            }
          }
          return decodedIdToken;
        });
      }
    };
    exports.BaseAuth = BaseAuth2;
  }
});

// node_modules/firebase-admin/lib/auth/tenant-manager.js
var require_tenant_manager = __commonJS({
  "node_modules/firebase-admin/lib/auth/tenant-manager.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TenantManager = exports.TenantAwareAuth = void 0;
    var validator = require_validator();
    var utils = require_utils();
    var error_1 = require_error();
    var base_auth_1 = require_base_auth();
    var tenant_1 = require_tenant();
    var auth_api_request_1 = require_auth_api_request();
    var TenantAwareAuth2 = class extends base_auth_1.BaseAuth {
      static {
        __name(this, "TenantAwareAuth");
      }
      /**
       * The TenantAwareAuth class constructor.
       *
       * @param app - The app that created this tenant.
       * @param tenantId - The corresponding tenant ID.
       * @constructor
       * @internal
       */
      constructor(app, tenantId) {
        super(app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), (0, base_auth_1.createFirebaseTokenGenerator)(app, tenantId));
        utils.addReadonlyGetter(this, "tenantId", tenantId);
      }
      /**
       * {@inheritdoc BaseAuth.verifyIdToken}
       */
      verifyIdToken(idToken, checkRevoked = false) {
        return super.verifyIdToken(idToken, checkRevoked).then((decodedClaims) => {
          if (decodedClaims.firebase.tenant !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
          }
          return decodedClaims;
        });
      }
      /**
       * {@inheritdoc BaseAuth.createSessionCookie}
       */
      createSessionCookie(idToken, sessionCookieOptions) {
        if (!validator.isNonEmptyString(idToken)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));
        }
        if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
        }
        return this.verifyIdToken(idToken).then(() => {
          return super.createSessionCookie(idToken, sessionCookieOptions);
        });
      }
      /**
       * {@inheritdoc BaseAuth.verifySessionCookie}
       */
      verifySessionCookie(sessionCookie, checkRevoked = false) {
        return super.verifySessionCookie(sessionCookie, checkRevoked).then((decodedClaims) => {
          if (decodedClaims.firebase.tenant !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
          }
          return decodedClaims;
        });
      }
    };
    exports.TenantAwareAuth = TenantAwareAuth2;
    var TenantManager2 = class {
      static {
        __name(this, "TenantManager");
      }
      /**
       * Initializes a TenantManager instance for a specified FirebaseApp.
       *
       * @param app - The app for this TenantManager instance.
       *
       * @constructor
       * @internal
       */
      constructor(app) {
        this.app = app;
        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
        this.tenantsMap = {};
      }
      /**
       * Returns a `TenantAwareAuth` instance bound to the given tenant ID.
       *
       * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.
       *
       * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.
       */
      authForTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
        }
        if (typeof this.tenantsMap[tenantId] === "undefined") {
          this.tenantsMap[tenantId] = new TenantAwareAuth2(this.app, tenantId);
        }
        return this.tenantsMap[tenantId];
      }
      /**
       * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.
       *
       * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.
       *
       * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.
       */
      getTenant(tenantId) {
        return this.authRequestHandler.getTenant(tenantId).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
      /**
       * Retrieves a list of tenants (single batch only) with a size of `maxResults`
       * starting from the offset as specified by `pageToken`. This is used to
       * retrieve all the tenants of a specified project in batches.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also
       *   the maximum allowed limit.
       * @param pageToken - The next page token. If not specified, returns
       *   tenants starting without any offset.
       *
       * @returns A promise that resolves with
       *   a batch of downloaded tenants and the next page token.
       */
      listTenants(maxResults, pageToken) {
        return this.authRequestHandler.listTenants(maxResults, pageToken).then((response) => {
          const tenants = [];
          response.tenants.forEach((tenantResponse) => {
            tenants.push(new tenant_1.Tenant(tenantResponse));
          });
          const result = {
            tenants,
            pageToken: response.nextPageToken
          };
          if (typeof result.pageToken === "undefined") {
            delete result.pageToken;
          }
          return result;
        });
      }
      /**
       * Deletes an existing tenant.
       *
       * @param tenantId - The `tenantId` corresponding to the tenant to delete.
       *
       * @returns An empty promise fulfilled once the tenant has been deleted.
       */
      deleteTenant(tenantId) {
        return this.authRequestHandler.deleteTenant(tenantId);
      }
      /**
       * Creates a new tenant.
       * When creating new tenants, tenants that use separate billing and quota will require their
       * own project and must be defined as `full_service`.
       *
       * @param tenantOptions - The properties to set on the new tenant configuration to be created.
       *
       * @returns A promise fulfilled with the tenant configuration corresponding to the newly
       *   created tenant.
       */
      createTenant(tenantOptions) {
        return this.authRequestHandler.createTenant(tenantOptions).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
      /**
       * Updates an existing tenant configuration.
       *
       * @param tenantId - The `tenantId` corresponding to the tenant to delete.
       * @param tenantOptions - The properties to update on the provided tenant.
       *
       * @returns A promise fulfilled with the update tenant data.
       */
      updateTenant(tenantId, tenantOptions) {
        return this.authRequestHandler.updateTenant(tenantId, tenantOptions).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
    };
    exports.TenantManager = TenantManager2;
  }
});

// node_modules/firebase-admin/lib/auth/project-config-manager.js
var require_project_config_manager = __commonJS({
  "node_modules/firebase-admin/lib/auth/project-config-manager.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectConfigManager = void 0;
    var project_config_1 = require_project_config();
    var auth_api_request_1 = require_auth_api_request();
    var ProjectConfigManager2 = class {
      static {
        __name(this, "ProjectConfigManager");
      }
      /**
       * Initializes a ProjectConfigManager instance for a specified FirebaseApp.
       *
       * @param app - The app for this ProjectConfigManager instance.
       *
       * @constructor
       * @internal
       */
      constructor(app) {
        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
      }
      /**
       * Get the project configuration.
       *
       * @returns A promise fulfilled with the project configuration.
       */
      getProjectConfig() {
        return this.authRequestHandler.getProjectConfig().then((response) => {
          return new project_config_1.ProjectConfig(response);
        });
      }
      /**
       * Updates an existing project configuration.
       *
       * @param projectConfigOptions - The properties to update on the project.
       *
       * @returns A promise fulfilled with the updated project config.
       */
      updateProjectConfig(projectConfigOptions) {
        return this.authRequestHandler.updateProjectConfig(projectConfigOptions).then((response) => {
          return new project_config_1.ProjectConfig(response);
        });
      }
    };
    exports.ProjectConfigManager = ProjectConfigManager2;
  }
});

// node_modules/firebase-admin/lib/auth/auth.js
var require_auth = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = void 0;
    var auth_api_request_1 = require_auth_api_request();
    var tenant_manager_1 = require_tenant_manager();
    var base_auth_1 = require_base_auth();
    var project_config_manager_1 = require_project_config_manager();
    var Auth2 = class extends base_auth_1.BaseAuth {
      static {
        __name(this, "Auth");
      }
      /**
       * @param app - The app for this Auth service.
       * @constructor
       * @internal
       */
      constructor(app) {
        super(app, new auth_api_request_1.AuthRequestHandler(app));
        this.app_ = app;
        this.tenantManager_ = new tenant_manager_1.TenantManager(app);
        this.projectConfigManager_ = new project_config_manager_1.ProjectConfigManager(app);
      }
      /**
       * Returns the app associated with this Auth instance.
       *
       * @returns The app associated with this Auth instance.
       */
      get app() {
        return this.app_;
      }
      /**
       * Returns the tenant manager instance associated with the current project.
       *
       * @returns The tenant manager instance associated with the current project.
       */
      tenantManager() {
        return this.tenantManager_;
      }
      /**
       * Returns the project config manager instance associated with the current project.
       *
       * @returns The project config manager instance associated with the current project.
       */
      projectConfigManager() {
        return this.projectConfigManager_;
      }
    };
    exports.Auth = Auth2;
  }
});

// node_modules/firebase-admin/lib/auth/index.js
var require_auth2 = __commonJS({
  "node_modules/firebase-admin/lib/auth/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AuthClientErrorCode = exports.FirebaseAuthError = exports.UserRecord = exports.UserMetadata = exports.UserInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorSettings = exports.MultiFactorInfo = exports.ProjectConfigManager = exports.ProjectConfig = exports.TenantManager = exports.TenantAwareAuth = exports.Tenant = exports.BaseAuth = exports.Auth = void 0;
    exports.getAuth = getAuth2;
    var index_1 = require_app();
    var auth_1 = require_auth();
    function getAuth2(app) {
      if (typeof app === "undefined") {
        app = (0, index_1.getApp)();
      }
      const firebaseApp = app;
      return firebaseApp.getOrInitService("auth", (app2) => new auth_1.Auth(app2));
    }
    __name(getAuth2, "getAuth");
    var auth_2 = require_auth();
    Object.defineProperty(exports, "Auth", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return auth_2.Auth;
    }, "get") });
    var base_auth_1 = require_base_auth();
    Object.defineProperty(exports, "BaseAuth", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return base_auth_1.BaseAuth;
    }, "get") });
    var tenant_1 = require_tenant();
    Object.defineProperty(exports, "Tenant", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return tenant_1.Tenant;
    }, "get") });
    var tenant_manager_1 = require_tenant_manager();
    Object.defineProperty(exports, "TenantAwareAuth", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return tenant_manager_1.TenantAwareAuth;
    }, "get") });
    Object.defineProperty(exports, "TenantManager", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return tenant_manager_1.TenantManager;
    }, "get") });
    var project_config_1 = require_project_config();
    Object.defineProperty(exports, "ProjectConfig", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return project_config_1.ProjectConfig;
    }, "get") });
    var project_config_manager_1 = require_project_config_manager();
    Object.defineProperty(exports, "ProjectConfigManager", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return project_config_manager_1.ProjectConfigManager;
    }, "get") });
    var user_record_1 = require_user_record();
    Object.defineProperty(exports, "MultiFactorInfo", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.MultiFactorInfo;
    }, "get") });
    Object.defineProperty(exports, "MultiFactorSettings", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.MultiFactorSettings;
    }, "get") });
    Object.defineProperty(exports, "PhoneMultiFactorInfo", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.PhoneMultiFactorInfo;
    }, "get") });
    Object.defineProperty(exports, "UserInfo", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.UserInfo;
    }, "get") });
    Object.defineProperty(exports, "UserMetadata", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.UserMetadata;
    }, "get") });
    Object.defineProperty(exports, "UserRecord", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return user_record_1.UserRecord;
    }, "get") });
    var error_1 = require_error();
    Object.defineProperty(exports, "FirebaseAuthError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return error_1.FirebaseAuthError;
    }, "get") });
    Object.defineProperty(exports, "AuthClientErrorCode", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return error_1.AuthClientErrorCode;
    }, "get") });
  }
});

// node_modules/firebase-admin/node_modules/@firebase/util/dist/index.cjs.js
var require_index_cjs = __commonJS({
  "node_modules/firebase-admin/node_modules/@firebase/util/dist/index.cjs.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var CONSTANTS = {
      /**
       * @define {boolean} Whether this is the client Node.js SDK.
       */
      NODE_CLIENT: false,
      /**
       * @define {boolean} Whether this is the Admin Node.js SDK.
       */
      NODE_ADMIN: false,
      /**
       * Firebase SDK Version
       */
      SDK_VERSION: "${JSCORE_VERSION}"
    };
    var assert3 = /* @__PURE__ */ __name(function(assertion, message2) {
      if (!assertion) {
        throw assertionError(message2);
      }
    }, "assert");
    var assertionError = /* @__PURE__ */ __name(function(message2) {
      return new Error("Firebase Database (" + CONSTANTS.SDK_VERSION + ") INTERNAL ASSERT FAILED: " + message2);
    }, "assertionError");
    var stringToByteArray$1 = /* @__PURE__ */ __name(function(str) {
      const out = [];
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if ((c & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
          c = 65536 + ((c & 1023) << 10) + (str.charCodeAt(++i) & 1023);
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    }, "stringToByteArray$1");
    var byteArrayToString = /* @__PURE__ */ __name(function(bytes) {
      const out = [];
      let pos = 0, c = 0;
      while (pos < bytes.length) {
        const c1 = bytes[pos++];
        if (c1 < 128) {
          out[c++] = String.fromCharCode(c1);
        } else if (c1 > 191 && c1 < 224) {
          const c2 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 31) << 6 | c2 & 63);
        } else if (c1 > 239 && c1 < 365) {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          const c4 = bytes[pos++];
          const u = ((c1 & 7) << 18 | (c2 & 63) << 12 | (c3 & 63) << 6 | c4 & 63) - 65536;
          out[c++] = String.fromCharCode(55296 + (u >> 10));
          out[c++] = String.fromCharCode(56320 + (u & 1023));
        } else {
          const c2 = bytes[pos++];
          const c3 = bytes[pos++];
          out[c++] = String.fromCharCode((c1 & 15) << 12 | (c2 & 63) << 6 | c3 & 63);
        }
      }
      return out.join("");
    }, "byteArrayToString");
    var base64 = {
      /**
       * Maps bytes to characters.
       */
      byteToCharMap_: null,
      /**
       * Maps characters to bytes.
       */
      charToByteMap_: null,
      /**
       * Maps bytes to websafe characters.
       * @private
       */
      byteToCharMapWebSafe_: null,
      /**
       * Maps websafe characters to bytes.
       * @private
       */
      charToByteMapWebSafe_: null,
      /**
       * Our default alphabet, shared between
       * ENCODED_VALS and ENCODED_VALS_WEBSAFE
       */
      ENCODED_VALS_BASE: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789",
      /**
       * Our default alphabet. Value 64 (=) is special; it means "nothing."
       */
      get ENCODED_VALS() {
        return this.ENCODED_VALS_BASE + "+/=";
      },
      /**
       * Our websafe alphabet.
       */
      get ENCODED_VALS_WEBSAFE() {
        return this.ENCODED_VALS_BASE + "-_.";
      },
      /**
       * Whether this browser supports the atob and btoa functions. This extension
       * started at Mozilla but is now implemented by many browsers. We use the
       * ASSUME_* variables to avoid pulling in the full useragent detection library
       * but still allowing the standard per-browser compilations.
       *
       */
      HAS_NATIVE_SUPPORT: typeof atob === "function",
      /**
       * Base64-encode an array of bytes.
       *
       * @param input An array of bytes (numbers with
       *     value in [0, 255]) to encode.
       * @param webSafe Boolean indicating we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeByteArray(input, webSafe) {
        if (!Array.isArray(input)) {
          throw Error("encodeByteArray takes an array as a parameter");
        }
        this.init_();
        const byteToCharMap = webSafe ? this.byteToCharMapWebSafe_ : this.byteToCharMap_;
        const output = [];
        for (let i = 0; i < input.length; i += 3) {
          const byte1 = input[i];
          const haveByte2 = i + 1 < input.length;
          const byte2 = haveByte2 ? input[i + 1] : 0;
          const haveByte3 = i + 2 < input.length;
          const byte3 = haveByte3 ? input[i + 2] : 0;
          const outByte1 = byte1 >> 2;
          const outByte2 = (byte1 & 3) << 4 | byte2 >> 4;
          let outByte3 = (byte2 & 15) << 2 | byte3 >> 6;
          let outByte4 = byte3 & 63;
          if (!haveByte3) {
            outByte4 = 64;
            if (!haveByte2) {
              outByte3 = 64;
            }
          }
          output.push(byteToCharMap[outByte1], byteToCharMap[outByte2], byteToCharMap[outByte3], byteToCharMap[outByte4]);
        }
        return output.join("");
      },
      /**
       * Base64-encode a string.
       *
       * @param input A string to encode.
       * @param webSafe If true, we should use the
       *     alternative alphabet.
       * @return The base64 encoded string.
       */
      encodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return btoa(input);
        }
        return this.encodeByteArray(stringToByteArray$1(input), webSafe);
      },
      /**
       * Base64-decode a string.
       *
       * @param input to decode.
       * @param webSafe True if we should use the
       *     alternative alphabet.
       * @return string representing the decoded value.
       */
      decodeString(input, webSafe) {
        if (this.HAS_NATIVE_SUPPORT && !webSafe) {
          return atob(input);
        }
        return byteArrayToString(this.decodeStringToByteArray(input, webSafe));
      },
      /**
       * Base64-decode a string.
       *
       * In base-64 decoding, groups of four characters are converted into three
       * bytes.  If the encoder did not apply padding, the input length may not
       * be a multiple of 4.
       *
       * In this case, the last group will have fewer than 4 characters, and
       * padding will be inferred.  If the group has one or two characters, it decodes
       * to one byte.  If the group has three characters, it decodes to two bytes.
       *
       * @param input Input to decode.
       * @param webSafe True if we should use the web-safe alphabet.
       * @return bytes representing the decoded value.
       */
      decodeStringToByteArray(input, webSafe) {
        this.init_();
        const charToByteMap = webSafe ? this.charToByteMapWebSafe_ : this.charToByteMap_;
        const output = [];
        for (let i = 0; i < input.length; ) {
          const byte1 = charToByteMap[input.charAt(i++)];
          const haveByte2 = i < input.length;
          const byte2 = haveByte2 ? charToByteMap[input.charAt(i)] : 0;
          ++i;
          const haveByte3 = i < input.length;
          const byte3 = haveByte3 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          const haveByte4 = i < input.length;
          const byte4 = haveByte4 ? charToByteMap[input.charAt(i)] : 64;
          ++i;
          if (byte1 == null || byte2 == null || byte3 == null || byte4 == null) {
            throw new DecodeBase64StringError();
          }
          const outByte1 = byte1 << 2 | byte2 >> 4;
          output.push(outByte1);
          if (byte3 !== 64) {
            const outByte2 = byte2 << 4 & 240 | byte3 >> 2;
            output.push(outByte2);
            if (byte4 !== 64) {
              const outByte3 = byte3 << 6 & 192 | byte4;
              output.push(outByte3);
            }
          }
        }
        return output;
      },
      /**
       * Lazy static initialization function. Called before
       * accessing any of the static map variables.
       * @private
       */
      init_() {
        if (!this.byteToCharMap_) {
          this.byteToCharMap_ = {};
          this.charToByteMap_ = {};
          this.byteToCharMapWebSafe_ = {};
          this.charToByteMapWebSafe_ = {};
          for (let i = 0; i < this.ENCODED_VALS.length; i++) {
            this.byteToCharMap_[i] = this.ENCODED_VALS.charAt(i);
            this.charToByteMap_[this.byteToCharMap_[i]] = i;
            this.byteToCharMapWebSafe_[i] = this.ENCODED_VALS_WEBSAFE.charAt(i);
            this.charToByteMapWebSafe_[this.byteToCharMapWebSafe_[i]] = i;
            if (i >= this.ENCODED_VALS_BASE.length) {
              this.charToByteMap_[this.ENCODED_VALS_WEBSAFE.charAt(i)] = i;
              this.charToByteMapWebSafe_[this.ENCODED_VALS.charAt(i)] = i;
            }
          }
        }
      }
    };
    var DecodeBase64StringError = class extends Error {
      static {
        __name(this, "DecodeBase64StringError");
      }
      constructor() {
        super(...arguments);
        this.name = "DecodeBase64StringError";
      }
    };
    var base64Encode = /* @__PURE__ */ __name(function(str) {
      const utf8Bytes = stringToByteArray$1(str);
      return base64.encodeByteArray(utf8Bytes, true);
    }, "base64Encode");
    var base64urlEncodeWithoutPadding = /* @__PURE__ */ __name(function(str) {
      return base64Encode(str).replace(/\./g, "");
    }, "base64urlEncodeWithoutPadding");
    var base64Decode = /* @__PURE__ */ __name(function(str) {
      try {
        return base64.decodeString(str, true);
      } catch (e) {
        console.error("base64Decode failed: ", e);
      }
      return null;
    }, "base64Decode");
    function deepCopy(value) {
      return deepExtend(void 0, value);
    }
    __name(deepCopy, "deepCopy");
    function deepExtend(target, source) {
      if (!(source instanceof Object)) {
        return source;
      }
      switch (source.constructor) {
        case Date:
          const dateValue = source;
          return new Date(dateValue.getTime());
        case Object:
          if (target === void 0) {
            target = {};
          }
          break;
        case Array:
          target = [];
          break;
        default:
          return source;
      }
      for (const prop in source) {
        if (!source.hasOwnProperty(prop) || !isValidKey(prop)) {
          continue;
        }
        target[prop] = deepExtend(target[prop], source[prop]);
      }
      return target;
    }
    __name(deepExtend, "deepExtend");
    function isValidKey(key) {
      return key !== "__proto__";
    }
    __name(isValidKey, "isValidKey");
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("Unable to locate global object.");
    }
    __name(getGlobal, "getGlobal");
    var getDefaultsFromGlobal = /* @__PURE__ */ __name(() => getGlobal().__FIREBASE_DEFAULTS__, "getDefaultsFromGlobal");
    var getDefaultsFromEnvVariable = /* @__PURE__ */ __name(() => {
      if (typeof process === "undefined" || typeof process.env === "undefined") {
        return;
      }
      const defaultsJsonString = process.env.__FIREBASE_DEFAULTS__;
      if (defaultsJsonString) {
        return JSON.parse(defaultsJsonString);
      }
    }, "getDefaultsFromEnvVariable");
    var getDefaultsFromCookie = /* @__PURE__ */ __name(() => {
      if (typeof document === "undefined") {
        return;
      }
      let match;
      try {
        match = document.cookie.match(/__FIREBASE_DEFAULTS__=([^;]+)/);
      } catch (e) {
        return;
      }
      const decoded = match && base64Decode(match[1]);
      return decoded && JSON.parse(decoded);
    }, "getDefaultsFromCookie");
    var getDefaults = /* @__PURE__ */ __name(() => {
      try {
        return getDefaultsFromGlobal() || getDefaultsFromEnvVariable() || getDefaultsFromCookie();
      } catch (e) {
        console.info(`Unable to get __FIREBASE_DEFAULTS__ due to: ${e}`);
        return;
      }
    }, "getDefaults");
    var getDefaultEmulatorHost = /* @__PURE__ */ __name((productName) => {
      var _a, _b;
      return (_b = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.emulatorHosts) === null || _b === void 0 ? void 0 : _b[productName];
    }, "getDefaultEmulatorHost");
    var getDefaultEmulatorHostnameAndPort = /* @__PURE__ */ __name((productName) => {
      const host = getDefaultEmulatorHost(productName);
      if (!host) {
        return void 0;
      }
      const separatorIndex = host.lastIndexOf(":");
      if (separatorIndex <= 0 || separatorIndex + 1 === host.length) {
        throw new Error(`Invalid host ${host} with no separate hostname and port!`);
      }
      const port = parseInt(host.substring(separatorIndex + 1), 10);
      if (host[0] === "[") {
        return [host.substring(1, separatorIndex - 1), port];
      } else {
        return [host.substring(0, separatorIndex), port];
      }
    }, "getDefaultEmulatorHostnameAndPort");
    var getDefaultAppConfig = /* @__PURE__ */ __name(() => {
      var _a;
      return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.config;
    }, "getDefaultAppConfig");
    var getExperimentalSetting = /* @__PURE__ */ __name((name) => {
      var _a;
      return (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a[`_${name}`];
    }, "getExperimentalSetting");
    var Deferred = class {
      static {
        __name(this, "Deferred");
      }
      constructor() {
        this.reject = () => {
        };
        this.resolve = () => {
        };
        this.promise = new Promise((resolve, reject) => {
          this.resolve = resolve;
          this.reject = reject;
        });
      }
      /**
       * Our API internals are not promisified and cannot because our callback APIs have subtle expectations around
       * invoking promises inline, which Promises are forbidden to do. This method accepts an optional node-style callback
       * and returns a node-style callback which will resolve or reject the Deferred's promise.
       */
      wrapCallback(callback) {
        return (error3, value) => {
          if (error3) {
            this.reject(error3);
          } else {
            this.resolve(value);
          }
          if (typeof callback === "function") {
            this.promise.catch(() => {
            });
            if (callback.length === 1) {
              callback(error3);
            } else {
              callback(error3, value);
            }
          }
        };
      }
    };
    function createMockUserToken(token, projectId) {
      if (token.uid) {
        throw new Error('The "uid" field is no longer supported by mockUserToken. Please use "sub" instead for Firebase Auth User ID.');
      }
      const header = {
        alg: "none",
        type: "JWT"
      };
      const project = projectId || "demo-project";
      const iat = token.iat || 0;
      const sub = token.sub || token.user_id;
      if (!sub) {
        throw new Error("mockUserToken must contain 'sub' or 'user_id' field!");
      }
      const payload = Object.assign({
        // Set all required fields to decent defaults
        iss: `https://securetoken.google.com/${project}`,
        aud: project,
        iat,
        exp: iat + 3600,
        auth_time: iat,
        sub,
        user_id: sub,
        firebase: {
          sign_in_provider: "custom",
          identities: {}
        }
      }, token);
      const signature = "";
      return [
        base64urlEncodeWithoutPadding(JSON.stringify(header)),
        base64urlEncodeWithoutPadding(JSON.stringify(payload)),
        signature
      ].join(".");
    }
    __name(createMockUserToken, "createMockUserToken");
    function getUA() {
      if (typeof navigator !== "undefined" && true) {
        return "Cloudflare-Workers";
      } else {
        return "";
      }
    }
    __name(getUA, "getUA");
    function isMobileCordova() {
      return typeof window !== "undefined" && // @ts-ignore Setting up an broadly applicable index signature for Window
      // just to deal with this case would probably be a bad idea.
      !!(window["cordova"] || window["phonegap"] || window["PhoneGap"]) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test(getUA());
    }
    __name(isMobileCordova, "isMobileCordova");
    function isNode() {
      var _a;
      const forceEnvironment = (_a = getDefaults()) === null || _a === void 0 ? void 0 : _a.forceEnvironment;
      if (forceEnvironment === "node") {
        return true;
      } else if (forceEnvironment === "browser") {
        return false;
      }
      try {
        return Object.prototype.toString.call(global.process) === "[object process]";
      } catch (e) {
        return false;
      }
    }
    __name(isNode, "isNode");
    function isBrowser() {
      return typeof window !== "undefined" || isWebWorker();
    }
    __name(isBrowser, "isBrowser");
    function isWebWorker() {
      return typeof WorkerGlobalScope !== "undefined" && typeof self !== "undefined" && self instanceof WorkerGlobalScope;
    }
    __name(isWebWorker, "isWebWorker");
    function isCloudflareWorker() {
      return typeof navigator !== "undefined" && true;
    }
    __name(isCloudflareWorker, "isCloudflareWorker");
    function isBrowserExtension() {
      const runtime = typeof chrome === "object" ? chrome.runtime : typeof browser === "object" ? browser.runtime : void 0;
      return typeof runtime === "object" && runtime.id !== void 0;
    }
    __name(isBrowserExtension, "isBrowserExtension");
    function isReactNative() {
      return typeof navigator === "object" && navigator["product"] === "ReactNative";
    }
    __name(isReactNative, "isReactNative");
    function isElectron() {
      return getUA().indexOf("Electron/") >= 0;
    }
    __name(isElectron, "isElectron");
    function isIE() {
      const ua = getUA();
      return ua.indexOf("MSIE ") >= 0 || ua.indexOf("Trident/") >= 0;
    }
    __name(isIE, "isIE");
    function isUWP() {
      return getUA().indexOf("MSAppHost/") >= 0;
    }
    __name(isUWP, "isUWP");
    function isNodeSdk() {
      return CONSTANTS.NODE_CLIENT === true || CONSTANTS.NODE_ADMIN === true;
    }
    __name(isNodeSdk, "isNodeSdk");
    function isSafari() {
      return !isNode() && true && "Cloudflare-Workers".includes("Safari") && !"Cloudflare-Workers".includes("Chrome");
    }
    __name(isSafari, "isSafari");
    function isIndexedDBAvailable() {
      try {
        return typeof indexedDB === "object";
      } catch (e) {
        return false;
      }
    }
    __name(isIndexedDBAvailable, "isIndexedDBAvailable");
    function validateIndexedDBOpenable() {
      return new Promise((resolve, reject) => {
        try {
          let preExist = true;
          const DB_CHECK_NAME = "validate-browser-context-for-indexeddb-analytics-module";
          const request3 = self.indexedDB.open(DB_CHECK_NAME);
          request3.onsuccess = () => {
            request3.result.close();
            if (!preExist) {
              self.indexedDB.deleteDatabase(DB_CHECK_NAME);
            }
            resolve(true);
          };
          request3.onupgradeneeded = () => {
            preExist = false;
          };
          request3.onerror = () => {
            var _a;
            reject(((_a = request3.error) === null || _a === void 0 ? void 0 : _a.message) || "");
          };
        } catch (error3) {
          reject(error3);
        }
      });
    }
    __name(validateIndexedDBOpenable, "validateIndexedDBOpenable");
    function areCookiesEnabled() {
      if (typeof navigator === "undefined" || !navigator.cookieEnabled) {
        return false;
      }
      return true;
    }
    __name(areCookiesEnabled, "areCookiesEnabled");
    var ERROR_NAME = "FirebaseError";
    var FirebaseError = class _FirebaseError extends Error {
      static {
        __name(this, "FirebaseError");
      }
      constructor(code, message2, customData) {
        super(message2);
        this.code = code;
        this.customData = customData;
        this.name = ERROR_NAME;
        Object.setPrototypeOf(this, _FirebaseError.prototype);
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, ErrorFactory.prototype.create);
        }
      }
    };
    var ErrorFactory = class {
      static {
        __name(this, "ErrorFactory");
      }
      constructor(service, serviceName, errors) {
        this.service = service;
        this.serviceName = serviceName;
        this.errors = errors;
      }
      create(code, ...data) {
        const customData = data[0] || {};
        const fullCode = `${this.service}/${code}`;
        const template = this.errors[code];
        const message2 = template ? replaceTemplate(template, customData) : "Error";
        const fullMessage = `${this.serviceName}: ${message2} (${fullCode}).`;
        const error3 = new FirebaseError(fullCode, fullMessage, customData);
        return error3;
      }
    };
    function replaceTemplate(template, data) {
      return template.replace(PATTERN, (_, key) => {
        const value = data[key];
        return value != null ? String(value) : `<${key}?>`;
      });
    }
    __name(replaceTemplate, "replaceTemplate");
    var PATTERN = /\{\$([^}]+)}/g;
    function jsonEval(str) {
      return JSON.parse(str);
    }
    __name(jsonEval, "jsonEval");
    function stringify(data) {
      return JSON.stringify(data);
    }
    __name(stringify, "stringify");
    var decode3 = /* @__PURE__ */ __name(function(token) {
      let header = {}, claims = {}, data = {}, signature = "";
      try {
        const parts = token.split(".");
        header = jsonEval(base64Decode(parts[0]) || "");
        claims = jsonEval(base64Decode(parts[1]) || "");
        signature = parts[2];
        data = claims["d"] || {};
        delete claims["d"];
      } catch (e) {
      }
      return {
        header,
        claims,
        data,
        signature
      };
    }, "decode");
    var isValidTimestamp = /* @__PURE__ */ __name(function(token) {
      const claims = decode3(token).claims;
      const now = Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3);
      let validSince = 0, validUntil = 0;
      if (typeof claims === "object") {
        if (claims.hasOwnProperty("nbf")) {
          validSince = claims["nbf"];
        } else if (claims.hasOwnProperty("iat")) {
          validSince = claims["iat"];
        }
        if (claims.hasOwnProperty("exp")) {
          validUntil = claims["exp"];
        } else {
          validUntil = validSince + 86400;
        }
      }
      return !!now && !!validSince && !!validUntil && now >= validSince && now <= validUntil;
    }, "isValidTimestamp");
    var issuedAtTime = /* @__PURE__ */ __name(function(token) {
      const claims = decode3(token).claims;
      if (typeof claims === "object" && claims.hasOwnProperty("iat")) {
        return claims["iat"];
      }
      return null;
    }, "issuedAtTime");
    var isValidFormat = /* @__PURE__ */ __name(function(token) {
      const decoded = decode3(token), claims = decoded.claims;
      return !!claims && typeof claims === "object" && claims.hasOwnProperty("iat");
    }, "isValidFormat");
    var isAdmin = /* @__PURE__ */ __name(function(token) {
      const claims = decode3(token).claims;
      return typeof claims === "object" && claims["admin"] === true;
    }, "isAdmin");
    function contains(obj, key) {
      return Object.prototype.hasOwnProperty.call(obj, key);
    }
    __name(contains, "contains");
    function safeGet(obj, key) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        return obj[key];
      } else {
        return void 0;
      }
    }
    __name(safeGet, "safeGet");
    function isEmpty(obj) {
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          return false;
        }
      }
      return true;
    }
    __name(isEmpty, "isEmpty");
    function map(obj, fn, contextObj) {
      const res = {};
      for (const key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
          res[key] = fn.call(contextObj, obj[key], key, obj);
        }
      }
      return res;
    }
    __name(map, "map");
    function deepEqual(a2, b2) {
      if (a2 === b2) {
        return true;
      }
      const aKeys = Object.keys(a2);
      const bKeys = Object.keys(b2);
      for (const k of aKeys) {
        if (!bKeys.includes(k)) {
          return false;
        }
        const aProp = a2[k];
        const bProp = b2[k];
        if (isObject3(aProp) && isObject3(bProp)) {
          if (!deepEqual(aProp, bProp)) {
            return false;
          }
        } else if (aProp !== bProp) {
          return false;
        }
      }
      for (const k of bKeys) {
        if (!aKeys.includes(k)) {
          return false;
        }
      }
      return true;
    }
    __name(deepEqual, "deepEqual");
    function isObject3(thing) {
      return thing !== null && typeof thing === "object";
    }
    __name(isObject3, "isObject");
    function promiseWithTimeout(promise, timeInMS = 2e3) {
      const deferredPromise = new Deferred();
      setTimeout(() => deferredPromise.reject("timeout!"), timeInMS);
      promise.then(deferredPromise.resolve, deferredPromise.reject);
      return deferredPromise.promise;
    }
    __name(promiseWithTimeout, "promiseWithTimeout");
    function querystring(querystringParams) {
      const params = [];
      for (const [key, value] of Object.entries(querystringParams)) {
        if (Array.isArray(value)) {
          value.forEach((arrayVal) => {
            params.push(encodeURIComponent(key) + "=" + encodeURIComponent(arrayVal));
          });
        } else {
          params.push(encodeURIComponent(key) + "=" + encodeURIComponent(value));
        }
      }
      return params.length ? "&" + params.join("&") : "";
    }
    __name(querystring, "querystring");
    function querystringDecode(querystring2) {
      const obj = {};
      const tokens = querystring2.replace(/^\?/, "").split("&");
      tokens.forEach((token) => {
        if (token) {
          const [key, value] = token.split("=");
          obj[decodeURIComponent(key)] = decodeURIComponent(value);
        }
      });
      return obj;
    }
    __name(querystringDecode, "querystringDecode");
    function extractQuerystring(url) {
      const queryStart = url.indexOf("?");
      if (!queryStart) {
        return "";
      }
      const fragmentStart = url.indexOf("#", queryStart);
      return url.substring(queryStart, fragmentStart > 0 ? fragmentStart : void 0);
    }
    __name(extractQuerystring, "extractQuerystring");
    var Sha1 = class {
      static {
        __name(this, "Sha1");
      }
      constructor() {
        this.chain_ = [];
        this.buf_ = [];
        this.W_ = [];
        this.pad_ = [];
        this.inbuf_ = 0;
        this.total_ = 0;
        this.blockSize = 512 / 8;
        this.pad_[0] = 128;
        for (let i = 1; i < this.blockSize; ++i) {
          this.pad_[i] = 0;
        }
        this.reset();
      }
      reset() {
        this.chain_[0] = 1732584193;
        this.chain_[1] = 4023233417;
        this.chain_[2] = 2562383102;
        this.chain_[3] = 271733878;
        this.chain_[4] = 3285377520;
        this.inbuf_ = 0;
        this.total_ = 0;
      }
      /**
       * Internal compress helper function.
       * @param buf Block to compress.
       * @param offset Offset of the block in the buffer.
       * @private
       */
      compress_(buf, offset) {
        if (!offset) {
          offset = 0;
        }
        const W = this.W_;
        if (typeof buf === "string") {
          for (let i = 0; i < 16; i++) {
            W[i] = buf.charCodeAt(offset) << 24 | buf.charCodeAt(offset + 1) << 16 | buf.charCodeAt(offset + 2) << 8 | buf.charCodeAt(offset + 3);
            offset += 4;
          }
        } else {
          for (let i = 0; i < 16; i++) {
            W[i] = buf[offset] << 24 | buf[offset + 1] << 16 | buf[offset + 2] << 8 | buf[offset + 3];
            offset += 4;
          }
        }
        for (let i = 16; i < 80; i++) {
          const t = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
          W[i] = (t << 1 | t >>> 31) & 4294967295;
        }
        let a2 = this.chain_[0];
        let b2 = this.chain_[1];
        let c = this.chain_[2];
        let d2 = this.chain_[3];
        let e = this.chain_[4];
        let f, k;
        for (let i = 0; i < 80; i++) {
          if (i < 40) {
            if (i < 20) {
              f = d2 ^ b2 & (c ^ d2);
              k = 1518500249;
            } else {
              f = b2 ^ c ^ d2;
              k = 1859775393;
            }
          } else {
            if (i < 60) {
              f = b2 & c | d2 & (b2 | c);
              k = 2400959708;
            } else {
              f = b2 ^ c ^ d2;
              k = 3395469782;
            }
          }
          const t = (a2 << 5 | a2 >>> 27) + f + e + k + W[i] & 4294967295;
          e = d2;
          d2 = c;
          c = (b2 << 30 | b2 >>> 2) & 4294967295;
          b2 = a2;
          a2 = t;
        }
        this.chain_[0] = this.chain_[0] + a2 & 4294967295;
        this.chain_[1] = this.chain_[1] + b2 & 4294967295;
        this.chain_[2] = this.chain_[2] + c & 4294967295;
        this.chain_[3] = this.chain_[3] + d2 & 4294967295;
        this.chain_[4] = this.chain_[4] + e & 4294967295;
      }
      update(bytes, length) {
        if (bytes == null) {
          return;
        }
        if (length === void 0) {
          length = bytes.length;
        }
        const lengthMinusBlock = length - this.blockSize;
        let n = 0;
        const buf = this.buf_;
        let inbuf = this.inbuf_;
        while (n < length) {
          if (inbuf === 0) {
            while (n <= lengthMinusBlock) {
              this.compress_(bytes, n);
              n += this.blockSize;
            }
          }
          if (typeof bytes === "string") {
            while (n < length) {
              buf[inbuf] = bytes.charCodeAt(n);
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          } else {
            while (n < length) {
              buf[inbuf] = bytes[n];
              ++inbuf;
              ++n;
              if (inbuf === this.blockSize) {
                this.compress_(buf);
                inbuf = 0;
                break;
              }
            }
          }
        }
        this.inbuf_ = inbuf;
        this.total_ += length;
      }
      /** @override */
      digest() {
        const digest2 = [];
        let totalBits = this.total_ * 8;
        if (this.inbuf_ < 56) {
          this.update(this.pad_, 56 - this.inbuf_);
        } else {
          this.update(this.pad_, this.blockSize - (this.inbuf_ - 56));
        }
        for (let i = this.blockSize - 1; i >= 56; i--) {
          this.buf_[i] = totalBits & 255;
          totalBits /= 256;
        }
        this.compress_(this.buf_);
        let n = 0;
        for (let i = 0; i < 5; i++) {
          for (let j = 24; j >= 0; j -= 8) {
            digest2[n] = this.chain_[i] >> j & 255;
            ++n;
          }
        }
        return digest2;
      }
    };
    function createSubscribe(executor, onNoObservers) {
      const proxy = new ObserverProxy(executor, onNoObservers);
      return proxy.subscribe.bind(proxy);
    }
    __name(createSubscribe, "createSubscribe");
    var ObserverProxy = class {
      static {
        __name(this, "ObserverProxy");
      }
      /**
       * @param executor Function which can make calls to a single Observer
       *     as a proxy.
       * @param onNoObservers Callback when count of Observers goes to zero.
       */
      constructor(executor, onNoObservers) {
        this.observers = [];
        this.unsubscribes = [];
        this.observerCount = 0;
        this.task = Promise.resolve();
        this.finalized = false;
        this.onNoObservers = onNoObservers;
        this.task.then(() => {
          executor(this);
        }).catch((e) => {
          this.error(e);
        });
      }
      next(value) {
        this.forEachObserver((observer) => {
          observer.next(value);
        });
      }
      error(error3) {
        this.forEachObserver((observer) => {
          observer.error(error3);
        });
        this.close(error3);
      }
      complete() {
        this.forEachObserver((observer) => {
          observer.complete();
        });
        this.close();
      }
      /**
       * Subscribe function that can be used to add an Observer to the fan-out list.
       *
       * - We require that no event is sent to a subscriber synchronously to their
       *   call to subscribe().
       */
      subscribe(nextOrObserver, error3, complete) {
        let observer;
        if (nextOrObserver === void 0 && error3 === void 0 && complete === void 0) {
          throw new Error("Missing Observer.");
        }
        if (implementsAnyMethods(nextOrObserver, [
          "next",
          "error",
          "complete"
        ])) {
          observer = nextOrObserver;
        } else {
          observer = {
            next: nextOrObserver,
            error: error3,
            complete
          };
        }
        if (observer.next === void 0) {
          observer.next = noop2;
        }
        if (observer.error === void 0) {
          observer.error = noop2;
        }
        if (observer.complete === void 0) {
          observer.complete = noop2;
        }
        const unsub = this.unsubscribeOne.bind(this, this.observers.length);
        if (this.finalized) {
          this.task.then(() => {
            try {
              if (this.finalError) {
                observer.error(this.finalError);
              } else {
                observer.complete();
              }
            } catch (e) {
            }
            return;
          });
        }
        this.observers.push(observer);
        return unsub;
      }
      // Unsubscribe is synchronous - we guarantee that no events are sent to
      // any unsubscribed Observer.
      unsubscribeOne(i) {
        if (this.observers === void 0 || this.observers[i] === void 0) {
          return;
        }
        delete this.observers[i];
        this.observerCount -= 1;
        if (this.observerCount === 0 && this.onNoObservers !== void 0) {
          this.onNoObservers(this);
        }
      }
      forEachObserver(fn) {
        if (this.finalized) {
          return;
        }
        for (let i = 0; i < this.observers.length; i++) {
          this.sendOne(i, fn);
        }
      }
      // Call the Observer via one of it's callback function. We are careful to
      // confirm that the observe has not been unsubscribed since this asynchronous
      // function had been queued.
      sendOne(i, fn) {
        this.task.then(() => {
          if (this.observers !== void 0 && this.observers[i] !== void 0) {
            try {
              fn(this.observers[i]);
            } catch (e) {
              if (typeof console !== "undefined" && console.error) {
                console.error(e);
              }
            }
          }
        });
      }
      close(err) {
        if (this.finalized) {
          return;
        }
        this.finalized = true;
        if (err !== void 0) {
          this.finalError = err;
        }
        this.task.then(() => {
          this.observers = void 0;
          this.onNoObservers = void 0;
        });
      }
    };
    function async(fn, onError) {
      return (...args) => {
        Promise.resolve(true).then(() => {
          fn(...args);
        }).catch((error3) => {
          if (onError) {
            onError(error3);
          }
        });
      };
    }
    __name(async, "async");
    function implementsAnyMethods(obj, methods) {
      if (typeof obj !== "object" || obj === null) {
        return false;
      }
      for (const method of methods) {
        if (method in obj && typeof obj[method] === "function") {
          return true;
        }
      }
      return false;
    }
    __name(implementsAnyMethods, "implementsAnyMethods");
    function noop2() {
    }
    __name(noop2, "noop");
    var validateArgCount = /* @__PURE__ */ __name(function(fnName, minCount, maxCount, argCount) {
      let argError;
      if (argCount < minCount) {
        argError = "at least " + minCount;
      } else if (argCount > maxCount) {
        argError = maxCount === 0 ? "none" : "no more than " + maxCount;
      }
      if (argError) {
        const error3 = fnName + " failed: Was called with " + argCount + (argCount === 1 ? " argument." : " arguments.") + " Expects " + argError + ".";
        throw new Error(error3);
      }
    }, "validateArgCount");
    function errorPrefix(fnName, argName) {
      return `${fnName} failed: ${argName} argument `;
    }
    __name(errorPrefix, "errorPrefix");
    function validateNamespace(fnName, namespace, optional) {
      if (optional && !namespace) {
        return;
      }
      if (typeof namespace !== "string") {
        throw new Error(errorPrefix(fnName, "namespace") + "must be a valid firebase namespace.");
      }
    }
    __name(validateNamespace, "validateNamespace");
    function validateCallback(fnName, argumentName, callback, optional) {
      if (optional && !callback) {
        return;
      }
      if (typeof callback !== "function") {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid function.");
      }
    }
    __name(validateCallback, "validateCallback");
    function validateContextObject(fnName, argumentName, context2, optional) {
      if (optional && !context2) {
        return;
      }
      if (typeof context2 !== "object" || context2 === null) {
        throw new Error(errorPrefix(fnName, argumentName) + "must be a valid context object.");
      }
    }
    __name(validateContextObject, "validateContextObject");
    var stringToByteArray = /* @__PURE__ */ __name(function(str) {
      const out = [];
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        let c = str.charCodeAt(i);
        if (c >= 55296 && c <= 56319) {
          const high = c - 55296;
          i++;
          assert3(i < str.length, "Surrogate pair missing trail surrogate.");
          const low = str.charCodeAt(i) - 56320;
          c = 65536 + (high << 10) + low;
        }
        if (c < 128) {
          out[p2++] = c;
        } else if (c < 2048) {
          out[p2++] = c >> 6 | 192;
          out[p2++] = c & 63 | 128;
        } else if (c < 65536) {
          out[p2++] = c >> 12 | 224;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        } else {
          out[p2++] = c >> 18 | 240;
          out[p2++] = c >> 12 & 63 | 128;
          out[p2++] = c >> 6 & 63 | 128;
          out[p2++] = c & 63 | 128;
        }
      }
      return out;
    }, "stringToByteArray");
    var stringLength = /* @__PURE__ */ __name(function(str) {
      let p2 = 0;
      for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 128) {
          p2++;
        } else if (c < 2048) {
          p2 += 2;
        } else if (c >= 55296 && c <= 56319) {
          p2 += 4;
          i++;
        } else {
          p2 += 3;
        }
      }
      return p2;
    }, "stringLength");
    var uuidv4 = /* @__PURE__ */ __name(function() {
      return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
        const r = Math.random() * 16 | 0, v2 = c === "x" ? r : r & 3 | 8;
        return v2.toString(16);
      });
    }, "uuidv4");
    var DEFAULT_INTERVAL_MILLIS = 1e3;
    var DEFAULT_BACKOFF_FACTOR = 2;
    var MAX_VALUE_MILLIS = 4 * 60 * 60 * 1e3;
    var RANDOM_FACTOR = 0.5;
    function calculateBackoffMillis(backoffCount, intervalMillis = DEFAULT_INTERVAL_MILLIS, backoffFactor = DEFAULT_BACKOFF_FACTOR) {
      const currBaseValue = intervalMillis * Math.pow(backoffFactor, backoffCount);
      const randomWait = Math.round(
        // A fraction of the backoff value to add/subtract.
        // Deviation: changes multiplication order to improve readability.
        RANDOM_FACTOR * currBaseValue * // A random float (rounded to int by Math.round above) in the range [-1, 1]. Determines
        // if we add or subtract.
        (Math.random() - 0.5) * 2
      );
      return Math.min(MAX_VALUE_MILLIS, currBaseValue + randomWait);
    }
    __name(calculateBackoffMillis, "calculateBackoffMillis");
    function ordinal(i) {
      if (!Number.isFinite(i)) {
        return `${i}`;
      }
      return i + indicator(i);
    }
    __name(ordinal, "ordinal");
    function indicator(i) {
      i = Math.abs(i);
      const cent = i % 100;
      if (cent >= 10 && cent <= 20) {
        return "th";
      }
      const dec = i % 10;
      if (dec === 1) {
        return "st";
      }
      if (dec === 2) {
        return "nd";
      }
      if (dec === 3) {
        return "rd";
      }
      return "th";
    }
    __name(indicator, "indicator");
    function getModularInstance(service) {
      if (service && service._delegate) {
        return service._delegate;
      } else {
        return service;
      }
    }
    __name(getModularInstance, "getModularInstance");
    exports.CONSTANTS = CONSTANTS;
    exports.DecodeBase64StringError = DecodeBase64StringError;
    exports.Deferred = Deferred;
    exports.ErrorFactory = ErrorFactory;
    exports.FirebaseError = FirebaseError;
    exports.MAX_VALUE_MILLIS = MAX_VALUE_MILLIS;
    exports.RANDOM_FACTOR = RANDOM_FACTOR;
    exports.Sha1 = Sha1;
    exports.areCookiesEnabled = areCookiesEnabled;
    exports.assert = assert3;
    exports.assertionError = assertionError;
    exports.async = async;
    exports.base64 = base64;
    exports.base64Decode = base64Decode;
    exports.base64Encode = base64Encode;
    exports.base64urlEncodeWithoutPadding = base64urlEncodeWithoutPadding;
    exports.calculateBackoffMillis = calculateBackoffMillis;
    exports.contains = contains;
    exports.createMockUserToken = createMockUserToken;
    exports.createSubscribe = createSubscribe;
    exports.decode = decode3;
    exports.deepCopy = deepCopy;
    exports.deepEqual = deepEqual;
    exports.deepExtend = deepExtend;
    exports.errorPrefix = errorPrefix;
    exports.extractQuerystring = extractQuerystring;
    exports.getDefaultAppConfig = getDefaultAppConfig;
    exports.getDefaultEmulatorHost = getDefaultEmulatorHost;
    exports.getDefaultEmulatorHostnameAndPort = getDefaultEmulatorHostnameAndPort;
    exports.getDefaults = getDefaults;
    exports.getExperimentalSetting = getExperimentalSetting;
    exports.getGlobal = getGlobal;
    exports.getModularInstance = getModularInstance;
    exports.getUA = getUA;
    exports.isAdmin = isAdmin;
    exports.isBrowser = isBrowser;
    exports.isBrowserExtension = isBrowserExtension;
    exports.isCloudflareWorker = isCloudflareWorker;
    exports.isElectron = isElectron;
    exports.isEmpty = isEmpty;
    exports.isIE = isIE;
    exports.isIndexedDBAvailable = isIndexedDBAvailable;
    exports.isMobileCordova = isMobileCordova;
    exports.isNode = isNode;
    exports.isNodeSdk = isNodeSdk;
    exports.isReactNative = isReactNative;
    exports.isSafari = isSafari;
    exports.isUWP = isUWP;
    exports.isValidFormat = isValidFormat;
    exports.isValidTimestamp = isValidTimestamp;
    exports.isWebWorker = isWebWorker;
    exports.issuedAtTime = issuedAtTime;
    exports.jsonEval = jsonEval;
    exports.map = map;
    exports.ordinal = ordinal;
    exports.promiseWithTimeout = promiseWithTimeout;
    exports.querystring = querystring;
    exports.querystringDecode = querystringDecode;
    exports.safeGet = safeGet;
    exports.stringLength = stringLength;
    exports.stringToByteArray = stringToByteArray;
    exports.stringify = stringify;
    exports.uuidv4 = uuidv4;
    exports.validateArgCount = validateArgCount;
    exports.validateCallback = validateCallback;
    exports.validateContextObject = validateContextObject;
    exports.validateIndexedDBOpenable = validateIndexedDBOpenable;
    exports.validateNamespace = validateNamespace;
  }
});

// node_modules/firebase-admin/node_modules/@firebase/logger/dist/index.cjs.js
var require_index_cjs2 = __commonJS({
  "node_modules/firebase-admin/node_modules/@firebase/logger/dist/index.cjs.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var instances = [];
    exports.LogLevel = void 0;
    (function(LogLevel) {
      LogLevel[LogLevel["DEBUG"] = 0] = "DEBUG";
      LogLevel[LogLevel["VERBOSE"] = 1] = "VERBOSE";
      LogLevel[LogLevel["INFO"] = 2] = "INFO";
      LogLevel[LogLevel["WARN"] = 3] = "WARN";
      LogLevel[LogLevel["ERROR"] = 4] = "ERROR";
      LogLevel[LogLevel["SILENT"] = 5] = "SILENT";
    })(exports.LogLevel || (exports.LogLevel = {}));
    var levelStringToEnum = {
      "debug": exports.LogLevel.DEBUG,
      "verbose": exports.LogLevel.VERBOSE,
      "info": exports.LogLevel.INFO,
      "warn": exports.LogLevel.WARN,
      "error": exports.LogLevel.ERROR,
      "silent": exports.LogLevel.SILENT
    };
    var defaultLogLevel = exports.LogLevel.INFO;
    var ConsoleMethod = {
      [exports.LogLevel.DEBUG]: "log",
      [exports.LogLevel.VERBOSE]: "log",
      [exports.LogLevel.INFO]: "info",
      [exports.LogLevel.WARN]: "warn",
      [exports.LogLevel.ERROR]: "error"
    };
    var defaultLogHandler = /* @__PURE__ */ __name((instance, logType, ...args) => {
      if (logType < instance.logLevel) {
        return;
      }
      const now = (/* @__PURE__ */ new Date()).toISOString();
      const method = ConsoleMethod[logType];
      if (method) {
        console[method](`[${now}]  ${instance.name}:`, ...args);
      } else {
        throw new Error(`Attempted to log a message with an invalid logType (value: ${logType})`);
      }
    }, "defaultLogHandler");
    var Logger = class {
      static {
        __name(this, "Logger");
      }
      /**
       * Gives you an instance of a Logger to capture messages according to
       * Firebase's logging scheme.
       *
       * @param name The name that the logs will be associated with
       */
      constructor(name) {
        this.name = name;
        this._logLevel = defaultLogLevel;
        this._logHandler = defaultLogHandler;
        this._userLogHandler = null;
        instances.push(this);
      }
      get logLevel() {
        return this._logLevel;
      }
      set logLevel(val) {
        if (!(val in exports.LogLevel)) {
          throw new TypeError(`Invalid value "${val}" assigned to \`logLevel\``);
        }
        this._logLevel = val;
      }
      // Workaround for setter/getter having to be the same type.
      setLogLevel(val) {
        this._logLevel = typeof val === "string" ? levelStringToEnum[val] : val;
      }
      get logHandler() {
        return this._logHandler;
      }
      set logHandler(val) {
        if (typeof val !== "function") {
          throw new TypeError("Value assigned to `logHandler` must be a function");
        }
        this._logHandler = val;
      }
      get userLogHandler() {
        return this._userLogHandler;
      }
      set userLogHandler(val) {
        this._userLogHandler = val;
      }
      /**
       * The functions below are all based on the `console` interface
       */
      debug(...args) {
        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.DEBUG, ...args);
        this._logHandler(this, exports.LogLevel.DEBUG, ...args);
      }
      log(...args) {
        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.VERBOSE, ...args);
        this._logHandler(this, exports.LogLevel.VERBOSE, ...args);
      }
      info(...args) {
        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.INFO, ...args);
        this._logHandler(this, exports.LogLevel.INFO, ...args);
      }
      warn(...args) {
        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.WARN, ...args);
        this._logHandler(this, exports.LogLevel.WARN, ...args);
      }
      error(...args) {
        this._userLogHandler && this._userLogHandler(this, exports.LogLevel.ERROR, ...args);
        this._logHandler(this, exports.LogLevel.ERROR, ...args);
      }
    };
    function setLogLevel(level) {
      instances.forEach((inst) => {
        inst.setLogLevel(level);
      });
    }
    __name(setLogLevel, "setLogLevel");
    function setUserLogHandler(logCallback, options) {
      for (const instance of instances) {
        let customLogLevel = null;
        if (options && options.level) {
          customLogLevel = levelStringToEnum[options.level];
        }
        if (logCallback === null) {
          instance.userLogHandler = null;
        } else {
          instance.userLogHandler = (instance2, level, ...args) => {
            const message2 = args.map((arg) => {
              if (arg == null) {
                return null;
              } else if (typeof arg === "string") {
                return arg;
              } else if (typeof arg === "number" || typeof arg === "boolean") {
                return arg.toString();
              } else if (arg instanceof Error) {
                return arg.message;
              } else {
                try {
                  return JSON.stringify(arg);
                } catch (ignored) {
                  return null;
                }
              }
            }).filter((arg) => arg).join(" ");
            if (level >= (customLogLevel !== null && customLogLevel !== void 0 ? customLogLevel : instance2.logLevel)) {
              logCallback({
                level: exports.LogLevel[level].toLowerCase(),
                message: message2,
                args,
                type: instance2.name
              });
            }
          };
        }
      }
    }
    __name(setUserLogHandler, "setUserLogHandler");
    exports.Logger = Logger;
    exports.setLogLevel = setLogLevel;
    exports.setUserLogHandler = setUserLogHandler;
  }
});

// node_modules/firebase-admin/node_modules/@firebase/component/dist/index.cjs.js
var require_index_cjs3 = __commonJS({
  "node_modules/firebase-admin/node_modules/@firebase/component/dist/index.cjs.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var util = require_index_cjs();
    var Component = class {
      static {
        __name(this, "Component");
      }
      /**
       *
       * @param name The public service name, e.g. app, auth, firestore, database
       * @param instanceFactory Service factory responsible for creating the public interface
       * @param type whether the service provided by the component is public or private
       */
      constructor(name, instanceFactory, type2) {
        this.name = name;
        this.instanceFactory = instanceFactory;
        this.type = type2;
        this.multipleInstances = false;
        this.serviceProps = {};
        this.instantiationMode = "LAZY";
        this.onInstanceCreated = null;
      }
      setInstantiationMode(mode) {
        this.instantiationMode = mode;
        return this;
      }
      setMultipleInstances(multipleInstances) {
        this.multipleInstances = multipleInstances;
        return this;
      }
      setServiceProps(props) {
        this.serviceProps = props;
        return this;
      }
      setInstanceCreatedCallback(callback) {
        this.onInstanceCreated = callback;
        return this;
      }
    };
    var DEFAULT_ENTRY_NAME = "[DEFAULT]";
    var Provider = class {
      static {
        __name(this, "Provider");
      }
      constructor(name, container) {
        this.name = name;
        this.container = container;
        this.component = null;
        this.instances = /* @__PURE__ */ new Map();
        this.instancesDeferred = /* @__PURE__ */ new Map();
        this.instancesOptions = /* @__PURE__ */ new Map();
        this.onInitCallbacks = /* @__PURE__ */ new Map();
      }
      /**
       * @param identifier A provider can provide multiple instances of a service
       * if this.component.multipleInstances is true.
       */
      get(identifier) {
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        if (!this.instancesDeferred.has(normalizedIdentifier)) {
          const deferred = new util.Deferred();
          this.instancesDeferred.set(normalizedIdentifier, deferred);
          if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
            try {
              const instance = this.getOrInitializeService({
                instanceIdentifier: normalizedIdentifier
              });
              if (instance) {
                deferred.resolve(instance);
              }
            } catch (e) {
            }
          }
        }
        return this.instancesDeferred.get(normalizedIdentifier).promise;
      }
      getImmediate(options) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(options === null || options === void 0 ? void 0 : options.identifier);
        const optional = (_a = options === null || options === void 0 ? void 0 : options.optional) !== null && _a !== void 0 ? _a : false;
        if (this.isInitialized(normalizedIdentifier) || this.shouldAutoInitialize()) {
          try {
            return this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
          } catch (e) {
            if (optional) {
              return null;
            } else {
              throw e;
            }
          }
        } else {
          if (optional) {
            return null;
          } else {
            throw Error(`Service ${this.name} is not available`);
          }
        }
      }
      getComponent() {
        return this.component;
      }
      setComponent(component) {
        if (component.name !== this.name) {
          throw Error(`Mismatching Component ${component.name} for Provider ${this.name}.`);
        }
        if (this.component) {
          throw Error(`Component for ${this.name} has already been provided`);
        }
        this.component = component;
        if (!this.shouldAutoInitialize()) {
          return;
        }
        if (isComponentEager(component)) {
          try {
            this.getOrInitializeService({ instanceIdentifier: DEFAULT_ENTRY_NAME });
          } catch (e) {
          }
        }
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          try {
            const instance = this.getOrInitializeService({
              instanceIdentifier: normalizedIdentifier
            });
            instanceDeferred.resolve(instance);
          } catch (e) {
          }
        }
      }
      clearInstance(identifier = DEFAULT_ENTRY_NAME) {
        this.instancesDeferred.delete(identifier);
        this.instancesOptions.delete(identifier);
        this.instances.delete(identifier);
      }
      // app.delete() will call this method on every provider to delete the services
      // TODO: should we mark the provider as deleted?
      async delete() {
        const services = Array.from(this.instances.values());
        await Promise.all([
          ...services.filter((service) => "INTERNAL" in service).map((service) => service.INTERNAL.delete()),
          ...services.filter((service) => "_delete" in service).map((service) => service._delete())
        ]);
      }
      isComponentSet() {
        return this.component != null;
      }
      isInitialized(identifier = DEFAULT_ENTRY_NAME) {
        return this.instances.has(identifier);
      }
      getOptions(identifier = DEFAULT_ENTRY_NAME) {
        return this.instancesOptions.get(identifier) || {};
      }
      initialize(opts = {}) {
        const { options = {} } = opts;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(opts.instanceIdentifier);
        if (this.isInitialized(normalizedIdentifier)) {
          throw Error(`${this.name}(${normalizedIdentifier}) has already been initialized`);
        }
        if (!this.isComponentSet()) {
          throw Error(`Component ${this.name} has not been registered yet`);
        }
        const instance = this.getOrInitializeService({
          instanceIdentifier: normalizedIdentifier,
          options
        });
        for (const [instanceIdentifier, instanceDeferred] of this.instancesDeferred.entries()) {
          const normalizedDeferredIdentifier = this.normalizeInstanceIdentifier(instanceIdentifier);
          if (normalizedIdentifier === normalizedDeferredIdentifier) {
            instanceDeferred.resolve(instance);
          }
        }
        return instance;
      }
      /**
       *
       * @param callback - a function that will be invoked  after the provider has been initialized by calling provider.initialize().
       * The function is invoked SYNCHRONOUSLY, so it should not execute any longrunning tasks in order to not block the program.
       *
       * @param identifier An optional instance identifier
       * @returns a function to unregister the callback
       */
      onInit(callback, identifier) {
        var _a;
        const normalizedIdentifier = this.normalizeInstanceIdentifier(identifier);
        const existingCallbacks = (_a = this.onInitCallbacks.get(normalizedIdentifier)) !== null && _a !== void 0 ? _a : /* @__PURE__ */ new Set();
        existingCallbacks.add(callback);
        this.onInitCallbacks.set(normalizedIdentifier, existingCallbacks);
        const existingInstance = this.instances.get(normalizedIdentifier);
        if (existingInstance) {
          callback(existingInstance, normalizedIdentifier);
        }
        return () => {
          existingCallbacks.delete(callback);
        };
      }
      /**
       * Invoke onInit callbacks synchronously
       * @param instance the service instance`
       */
      invokeOnInitCallbacks(instance, identifier) {
        const callbacks = this.onInitCallbacks.get(identifier);
        if (!callbacks) {
          return;
        }
        for (const callback of callbacks) {
          try {
            callback(instance, identifier);
          } catch (_a) {
          }
        }
      }
      getOrInitializeService({ instanceIdentifier, options = {} }) {
        let instance = this.instances.get(instanceIdentifier);
        if (!instance && this.component) {
          instance = this.component.instanceFactory(this.container, {
            instanceIdentifier: normalizeIdentifierForFactory(instanceIdentifier),
            options
          });
          this.instances.set(instanceIdentifier, instance);
          this.instancesOptions.set(instanceIdentifier, options);
          this.invokeOnInitCallbacks(instance, instanceIdentifier);
          if (this.component.onInstanceCreated) {
            try {
              this.component.onInstanceCreated(this.container, instanceIdentifier, instance);
            } catch (_a) {
            }
          }
        }
        return instance || null;
      }
      normalizeInstanceIdentifier(identifier = DEFAULT_ENTRY_NAME) {
        if (this.component) {
          return this.component.multipleInstances ? identifier : DEFAULT_ENTRY_NAME;
        } else {
          return identifier;
        }
      }
      shouldAutoInitialize() {
        return !!this.component && this.component.instantiationMode !== "EXPLICIT";
      }
    };
    function normalizeIdentifierForFactory(identifier) {
      return identifier === DEFAULT_ENTRY_NAME ? void 0 : identifier;
    }
    __name(normalizeIdentifierForFactory, "normalizeIdentifierForFactory");
    function isComponentEager(component) {
      return component.instantiationMode === "EAGER";
    }
    __name(isComponentEager, "isComponentEager");
    var ComponentContainer = class {
      static {
        __name(this, "ComponentContainer");
      }
      constructor(name) {
        this.name = name;
        this.providers = /* @__PURE__ */ new Map();
      }
      /**
       *
       * @param component Component being added
       * @param overwrite When a component with the same name has already been registered,
       * if overwrite is true: overwrite the existing component with the new component and create a new
       * provider with the new component. It can be useful in tests where you want to use different mocks
       * for different tests.
       * if overwrite is false: throw an exception
       */
      addComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          throw new Error(`Component ${component.name} has already been registered with ${this.name}`);
        }
        provider.setComponent(component);
      }
      addOrOverwriteComponent(component) {
        const provider = this.getProvider(component.name);
        if (provider.isComponentSet()) {
          this.providers.delete(component.name);
        }
        this.addComponent(component);
      }
      /**
       * getProvider provides a type safe interface where it can only be called with a field name
       * present in NameServiceMapping interface.
       *
       * Firebase SDKs providing services should extend NameServiceMapping interface to register
       * themselves.
       */
      getProvider(name) {
        if (this.providers.has(name)) {
          return this.providers.get(name);
        }
        const provider = new Provider(name, this);
        this.providers.set(name, provider);
        return provider;
      }
      getProviders() {
        return Array.from(this.providers.values());
      }
    };
    exports.Component = Component;
    exports.ComponentContainer = ComponentContainer;
    exports.Provider = Provider;
  }
});

// node_modules/firebase-admin/node_modules/@firebase/database-compat/dist/index.standalone.js
var require_index_standalone = __commonJS({
  "node_modules/firebase-admin/node_modules/@firebase/database-compat/dist/index.standalone.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    var require$$2 = require_util3();
    var require$$0 = require_buffer();
    var require$$1 = require_events();
    var require$$0$1 = require_stream();
    var require$$1$1 = require_crypto2();
    var require$$2$1 = require_url();
    var require$$0$2 = require_assert();
    var require$$1$2 = require_net();
    var require$$2$2 = require_tls();
    var require$$1$3 = require_index_cjs();
    var require$$2$3 = require_index_cjs2();
    var require$$3 = require_index_cjs3();
    function _interopDefaultLegacy(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    __name(_interopDefaultLegacy, "_interopDefaultLegacy");
    var require$$2__default = /* @__PURE__ */ _interopDefaultLegacy(require$$2);
    var require$$0__default = /* @__PURE__ */ _interopDefaultLegacy(require$$0);
    var require$$1__default = /* @__PURE__ */ _interopDefaultLegacy(require$$1);
    var require$$0__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$1);
    var require$$1__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$1);
    var require$$2__default$1 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$1);
    var require$$0__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$0$2);
    var require$$1__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$2);
    var require$$2__default$2 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$2);
    var require$$1__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$1$3);
    var require$$2__default$3 = /* @__PURE__ */ _interopDefaultLegacy(require$$2$3);
    var require$$3__default = /* @__PURE__ */ _interopDefaultLegacy(require$$3);
    var index_standalone = {};
    var safeBuffer = { exports: {} };
    (function(module2, exports2) {
      var buffer = require$$0__default["default"];
      var Buffer2 = buffer.Buffer;
      function copyProps(src, dst) {
        for (var key2 in src) {
          dst[key2] = src[key2];
        }
      }
      __name(copyProps, "copyProps");
      if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
        module2.exports = buffer;
      } else {
        copyProps(buffer, exports2);
        exports2.Buffer = SafeBuffer;
      }
      function SafeBuffer(arg, encodingOrOffset, length) {
        return Buffer2(arg, encodingOrOffset, length);
      }
      __name(SafeBuffer, "SafeBuffer");
      SafeBuffer.prototype = Object.create(Buffer2.prototype);
      copyProps(Buffer2, SafeBuffer);
      SafeBuffer.from = function(arg, encodingOrOffset, length) {
        if (typeof arg === "number") {
          throw new TypeError("Argument must not be a number");
        }
        return Buffer2(arg, encodingOrOffset, length);
      };
      SafeBuffer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        var buf = Buffer2(size);
        if (fill !== void 0) {
          if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
        } else {
          buf.fill(0);
        }
        return buf;
      };
      SafeBuffer.allocUnsafe = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return Buffer2(size);
      };
      SafeBuffer.allocUnsafeSlow = function(size) {
        if (typeof size !== "number") {
          throw new TypeError("Argument must be a number");
        }
        return buffer.SlowBuffer(size);
      };
    })(safeBuffer, safeBuffer.exports);
    var streams$1 = {};
    var Stream$3 = require$$0__default$1["default"].Stream;
    var util$c = require$$2__default["default"];
    var IO = /* @__PURE__ */ __name(function(driver2) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver2;
    }, "IO");
    util$c.inherits(IO, Stream$3);
    IO.prototype.pause = function() {
      this._paused = true;
      this._driver.messages._paused = true;
    };
    IO.prototype.resume = function() {
      this._paused = false;
      this.emit("drain");
      var messages = this._driver.messages;
      messages._paused = false;
      messages.emit("drain");
    };
    IO.prototype.write = function(chunk) {
      if (!this.writable) return false;
      this._driver.parse(chunk);
      return !this._paused;
    };
    IO.prototype.end = function(chunk) {
      if (!this.writable) return;
      if (chunk !== void 0) this.write(chunk);
      this.writable = false;
      var messages = this._driver.messages;
      if (messages.readable) {
        messages.readable = messages.writable = false;
        messages.emit("end");
      }
    };
    IO.prototype.destroy = function() {
      this.end();
    };
    var Messages = /* @__PURE__ */ __name(function(driver2) {
      this.readable = this.writable = true;
      this._paused = false;
      this._driver = driver2;
    }, "Messages");
    util$c.inherits(Messages, Stream$3);
    Messages.prototype.pause = function() {
      this._driver.io._paused = true;
    };
    Messages.prototype.resume = function() {
      this._driver.io._paused = false;
      this._driver.io.emit("drain");
    };
    Messages.prototype.write = function(message3) {
      if (!this.writable) return false;
      if (typeof message3 === "string") this._driver.text(message3);
      else this._driver.binary(message3);
      return !this._paused;
    };
    Messages.prototype.end = function(message3) {
      if (message3 !== void 0) this.write(message3);
    };
    Messages.prototype.destroy = function() {
    };
    streams$1.IO = IO;
    streams$1.Messages = Messages;
    var Headers$3 = /* @__PURE__ */ __name(function() {
      this.clear();
    }, "Headers$3");
    Headers$3.prototype.ALLOWED_DUPLICATES = ["set-cookie", "set-cookie2", "warning", "www-authenticate"];
    Headers$3.prototype.clear = function() {
      this._sent = {};
      this._lines = [];
    };
    Headers$3.prototype.set = function(name, value) {
      if (value === void 0) return;
      name = this._strip(name);
      value = this._strip(value);
      var key2 = name.toLowerCase();
      if (!this._sent.hasOwnProperty(key2) || this.ALLOWED_DUPLICATES.indexOf(key2) >= 0) {
        this._sent[key2] = true;
        this._lines.push(name + ": " + value + "\r\n");
      }
    };
    Headers$3.prototype.toString = function() {
      return this._lines.join("");
    };
    Headers$3.prototype._strip = function(string) {
      return string.toString().replace(/^ */, "").replace(/ *$/, "");
    };
    var headers = Headers$3;
    var Buffer$9 = safeBuffer.exports.Buffer;
    var StreamReader = /* @__PURE__ */ __name(function() {
      this._queue = [];
      this._queueSize = 0;
      this._offset = 0;
    }, "StreamReader");
    StreamReader.prototype.put = function(buffer) {
      if (!buffer || buffer.length === 0) return;
      if (!Buffer$9.isBuffer(buffer)) buffer = Buffer$9.from(buffer);
      this._queue.push(buffer);
      this._queueSize += buffer.length;
    };
    StreamReader.prototype.read = function(length) {
      if (length > this._queueSize) return null;
      if (length === 0) return Buffer$9.alloc(0);
      this._queueSize -= length;
      var queue = this._queue, remain = length, first = queue[0], buffers, buffer;
      if (first.length >= length) {
        if (first.length === length) {
          return queue.shift();
        } else {
          buffer = first.slice(0, length);
          queue[0] = first.slice(length);
          return buffer;
        }
      }
      for (var i = 0, n = queue.length; i < n; i++) {
        if (remain < queue[i].length) break;
        remain -= queue[i].length;
      }
      buffers = queue.splice(0, i);
      if (remain > 0 && queue.length > 0) {
        buffers.push(queue[0].slice(0, remain));
        queue[0] = queue[0].slice(remain);
      }
      return Buffer$9.concat(buffers, length);
    };
    StreamReader.prototype.eachByte = function(callback, context2) {
      var buffer, n, index;
      while (this._queue.length > 0) {
        buffer = this._queue[0];
        n = buffer.length;
        while (this._offset < n) {
          index = this._offset;
          this._offset += 1;
          callback.call(context2, buffer[index]);
        }
        this._offset = 0;
        this._queue.shift();
      }
    };
    var stream_reader = StreamReader;
    var Buffer$8 = safeBuffer.exports.Buffer;
    var Emitter = require$$1__default["default"].EventEmitter;
    var util$b = require$$2__default["default"];
    var streams = streams$1;
    var Headers$2 = headers;
    var Reader = stream_reader;
    var Base$7 = /* @__PURE__ */ __name(function(request3, url2, options) {
      Emitter.call(this);
      Base$7.validateOptions(options || {}, ["maxLength", "masking", "requireMasking", "protocols"]);
      this._request = request3;
      this._reader = new Reader();
      this._options = options || {};
      this._maxLength = this._options.maxLength || this.MAX_LENGTH;
      this._headers = new Headers$2();
      this.__queue = [];
      this.readyState = 0;
      this.url = url2;
      this.io = new streams.IO(this);
      this.messages = new streams.Messages(this);
      this._bindEventListeners();
    }, "Base$7");
    util$b.inherits(Base$7, Emitter);
    Base$7.isWebSocket = function(request3) {
      var connection = request3.headers.connection || "", upgrade = request3.headers.upgrade || "";
      return request3.method === "GET" && connection.toLowerCase().split(/ *, */).indexOf("upgrade") >= 0 && upgrade.toLowerCase() === "websocket";
    };
    Base$7.validateOptions = function(options, validKeys) {
      for (var key2 in options) {
        if (validKeys.indexOf(key2) < 0)
          throw new Error("Unrecognized option: " + key2);
      }
    };
    var instance$b = {
      // This is 64MB, small enough for an average VPS to handle without
      // crashing from process out of memory
      MAX_LENGTH: 67108863,
      STATES: ["connecting", "open", "closing", "closed"],
      _bindEventListeners: /* @__PURE__ */ __name(function() {
        var self2 = this;
        this.messages.on("error", function() {
        });
        this.on("message", function(event2) {
          var messages = self2.messages;
          if (messages.readable) messages.emit("data", event2.data);
        });
        this.on("error", function(error4) {
          var messages = self2.messages;
          if (messages.readable) messages.emit("error", error4);
        });
        this.on("close", function() {
          var messages = self2.messages;
          if (!messages.readable) return;
          messages.readable = messages.writable = false;
          messages.emit("end");
        });
      }, "_bindEventListeners"),
      getState: /* @__PURE__ */ __name(function() {
        return this.STATES[this.readyState] || null;
      }, "getState"),
      addExtension: /* @__PURE__ */ __name(function(extension) {
        return false;
      }, "addExtension"),
      setHeader: /* @__PURE__ */ __name(function(name, value) {
        if (this.readyState > 0) return false;
        this._headers.set(name, value);
        return true;
      }, "setHeader"),
      start: /* @__PURE__ */ __name(function() {
        if (this.readyState !== 0) return false;
        if (!Base$7.isWebSocket(this._request))
          return this._failHandshake(new Error("Not a WebSocket request"));
        var response;
        try {
          response = this._handshakeResponse();
        } catch (error4) {
          return this._failHandshake(error4);
        }
        this._write(response);
        if (this._stage !== -1) this._open();
        return true;
      }, "start"),
      _failHandshake: /* @__PURE__ */ __name(function(error4) {
        var headers2 = new Headers$2();
        headers2.set("Content-Type", "text/plain");
        headers2.set("Content-Length", Buffer$8.byteLength(error4.message, "utf8"));
        headers2 = ["HTTP/1.1 400 Bad Request", headers2.toString(), error4.message];
        this._write(Buffer$8.from(headers2.join("\r\n"), "utf8"));
        this._fail("protocol_error", error4.message);
        return false;
      }, "_failHandshake"),
      text: /* @__PURE__ */ __name(function(message3) {
        return this.frame(message3);
      }, "text"),
      binary: /* @__PURE__ */ __name(function(message3) {
        return false;
      }, "binary"),
      ping: /* @__PURE__ */ __name(function() {
        return false;
      }, "ping"),
      pong: /* @__PURE__ */ __name(function() {
        return false;
      }, "pong"),
      close: /* @__PURE__ */ __name(function(reason, code) {
        if (this.readyState !== 1) return false;
        this.readyState = 3;
        this.emit("close", new Base$7.CloseEvent(null, null));
        return true;
      }, "close"),
      _open: /* @__PURE__ */ __name(function() {
        this.readyState = 1;
        this.__queue.forEach(function(args) {
          this.frame.apply(this, args);
        }, this);
        this.__queue = [];
        this.emit("open", new Base$7.OpenEvent());
      }, "_open"),
      _queue: /* @__PURE__ */ __name(function(message3) {
        this.__queue.push(message3);
        return true;
      }, "_queue"),
      _write: /* @__PURE__ */ __name(function(chunk) {
        var io2 = this.io;
        if (io2.readable) io2.emit("data", chunk);
      }, "_write"),
      _fail: /* @__PURE__ */ __name(function(type2, message3) {
        this.readyState = 2;
        this.emit("error", new Error(message3));
        this.close();
      }, "_fail")
    };
    for (key$b in instance$b)
      Base$7.prototype[key$b] = instance$b[key$b];
    var key$b;
    Base$7.ConnectEvent = function() {
    };
    Base$7.OpenEvent = function() {
    };
    Base$7.CloseEvent = function(code, reason) {
      this.code = code;
      this.reason = reason;
    };
    Base$7.MessageEvent = function(data) {
      this.data = data;
    };
    Base$7.PingEvent = function(data) {
      this.data = data;
    };
    Base$7.PongEvent = function(data) {
      this.data = data;
    };
    var base = Base$7;
    var httpParser = {};
    var assert3 = require$$0__default$2["default"];
    httpParser.HTTPParser = HTTPParser;
    function HTTPParser(type2) {
      assert3.ok(type2 === HTTPParser.REQUEST || type2 === HTTPParser.RESPONSE || type2 === void 0);
      if (type2 === void 0) ;
      else {
        this.initialize(type2);
      }
    }
    __name(HTTPParser, "HTTPParser");
    HTTPParser.prototype.initialize = function(type2, async_resource) {
      assert3.ok(type2 === HTTPParser.REQUEST || type2 === HTTPParser.RESPONSE);
      this.type = type2;
      this.state = type2 + "_LINE";
      this.info = {
        headers: [],
        upgrade: false
      };
      this.trailers = [];
      this.line = "";
      this.isChunked = false;
      this.connection = "";
      this.headerSize = 0;
      this.body_bytes = null;
      this.isUserCall = false;
      this.hadError = false;
    };
    HTTPParser.encoding = "ascii";
    HTTPParser.maxHeaderSize = 80 * 1024;
    HTTPParser.REQUEST = "REQUEST";
    HTTPParser.RESPONSE = "RESPONSE";
    var kOnHeaders = HTTPParser.kOnHeaders = 1;
    var kOnHeadersComplete = HTTPParser.kOnHeadersComplete = 2;
    var kOnBody = HTTPParser.kOnBody = 3;
    var kOnMessageComplete = HTTPParser.kOnMessageComplete = 4;
    HTTPParser.prototype[kOnHeaders] = HTTPParser.prototype[kOnHeadersComplete] = HTTPParser.prototype[kOnBody] = HTTPParser.prototype[kOnMessageComplete] = function() {
    };
    var compatMode0_12 = true;
    Object.defineProperty(HTTPParser, "kOnExecute", {
      get: /* @__PURE__ */ __name(function() {
        compatMode0_12 = false;
        return 99;
      }, "get")
    });
    var methods = httpParser.methods = HTTPParser.methods = [
      "DELETE",
      "GET",
      "HEAD",
      "POST",
      "PUT",
      "CONNECT",
      "OPTIONS",
      "TRACE",
      "COPY",
      "LOCK",
      "MKCOL",
      "MOVE",
      "PROPFIND",
      "PROPPATCH",
      "SEARCH",
      "UNLOCK",
      "BIND",
      "REBIND",
      "UNBIND",
      "ACL",
      "REPORT",
      "MKACTIVITY",
      "CHECKOUT",
      "MERGE",
      "M-SEARCH",
      "NOTIFY",
      "SUBSCRIBE",
      "UNSUBSCRIBE",
      "PATCH",
      "PURGE",
      "MKCALENDAR",
      "LINK",
      "UNLINK"
    ];
    var method_connect = methods.indexOf("CONNECT");
    HTTPParser.prototype.reinitialize = HTTPParser;
    HTTPParser.prototype.close = HTTPParser.prototype.pause = HTTPParser.prototype.resume = HTTPParser.prototype.free = function() {
    };
    HTTPParser.prototype._compatMode0_11 = false;
    HTTPParser.prototype.getAsyncId = function() {
      return 0;
    };
    var headerState = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      HEADER: true
    };
    HTTPParser.prototype.execute = function(chunk, start, length) {
      if (!(this instanceof HTTPParser)) {
        throw new TypeError("not a HTTPParser");
      }
      start = start || 0;
      length = typeof length === "number" ? length : chunk.length;
      this.chunk = chunk;
      this.offset = start;
      var end = this.end = start + length;
      try {
        while (this.offset < end) {
          if (this[this.state]()) {
            break;
          }
        }
      } catch (err) {
        if (this.isUserCall) {
          throw err;
        }
        this.hadError = true;
        return err;
      }
      this.chunk = null;
      length = this.offset - start;
      if (headerState[this.state]) {
        this.headerSize += length;
        if (this.headerSize > HTTPParser.maxHeaderSize) {
          return new Error("max header size exceeded");
        }
      }
      return length;
    };
    var stateFinishAllowed = {
      REQUEST_LINE: true,
      RESPONSE_LINE: true,
      BODY_RAW: true
    };
    HTTPParser.prototype.finish = function() {
      if (this.hadError) {
        return;
      }
      if (!stateFinishAllowed[this.state]) {
        return new Error("invalid state for EOF");
      }
      if (this.state === "BODY_RAW") {
        this.userCall()(this[kOnMessageComplete]());
      }
    };
    HTTPParser.prototype.consume = HTTPParser.prototype.unconsume = HTTPParser.prototype.getCurrentBuffer = function() {
    };
    HTTPParser.prototype.userCall = function() {
      this.isUserCall = true;
      var self2 = this;
      return function(ret) {
        self2.isUserCall = false;
        return ret;
      };
    };
    HTTPParser.prototype.nextRequest = function() {
      this.userCall()(this[kOnMessageComplete]());
      this.reinitialize(this.type);
    };
    HTTPParser.prototype.consumeLine = function() {
      var end = this.end, chunk = this.chunk;
      for (var i = this.offset; i < end; i++) {
        if (chunk[i] === 10) {
          var line = this.line + chunk.toString(HTTPParser.encoding, this.offset, i);
          if (line.charAt(line.length - 1) === "\r") {
            line = line.substr(0, line.length - 1);
          }
          this.line = "";
          this.offset = i + 1;
          return line;
        }
      }
      this.line += chunk.toString(HTTPParser.encoding, this.offset, this.end);
      this.offset = this.end;
    };
    var headerExp = /^([^: \t]+):[ \t]*((?:.*[^ \t])|)/;
    var headerContinueExp = /^[ \t]+(.*[^ \t])/;
    HTTPParser.prototype.parseHeader = function(line, headers2) {
      if (line.indexOf("\r") !== -1) {
        throw parseErrorCode("HPE_LF_EXPECTED");
      }
      var match = headerExp.exec(line);
      var k = match && match[1];
      if (k) {
        headers2.push(k);
        headers2.push(match[2]);
      } else {
        var matchContinue = headerContinueExp.exec(line);
        if (matchContinue && headers2.length) {
          if (headers2[headers2.length - 1]) {
            headers2[headers2.length - 1] += " ";
          }
          headers2[headers2.length - 1] += matchContinue[1];
        }
      }
    };
    var requestExp = /^([A-Z-]+) ([^ ]+) HTTP\/(\d)\.(\d)$/;
    HTTPParser.prototype.REQUEST_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = requestExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.method = this._compatMode0_11 ? match[1] : methods.indexOf(match[1]);
      if (this.info.method === -1) {
        throw new Error("invalid request method");
      }
      this.info.url = match[2];
      this.info.versionMajor = +match[3];
      this.info.versionMinor = +match[4];
      this.body_bytes = 0;
      this.state = "HEADER";
    };
    var responseExp = /^HTTP\/(\d)\.(\d) (\d{3}) ?(.*)$/;
    HTTPParser.prototype.RESPONSE_LINE = function() {
      var line = this.consumeLine();
      if (!line) {
        return;
      }
      var match = responseExp.exec(line);
      if (match === null) {
        throw parseErrorCode("HPE_INVALID_CONSTANT");
      }
      this.info.versionMajor = +match[1];
      this.info.versionMinor = +match[2];
      var statusCode = this.info.statusCode = +match[3];
      this.info.statusMessage = match[4];
      if ((statusCode / 100 | 0) === 1 || statusCode === 204 || statusCode === 304) {
        this.body_bytes = 0;
      }
      this.state = "HEADER";
    };
    HTTPParser.prototype.shouldKeepAlive = function() {
      if (this.info.versionMajor > 0 && this.info.versionMinor > 0) {
        if (this.connection.indexOf("close") !== -1) {
          return false;
        }
      } else if (this.connection.indexOf("keep-alive") === -1) {
        return false;
      }
      if (this.body_bytes !== null || this.isChunked) {
        return true;
      }
      return false;
    };
    HTTPParser.prototype.HEADER = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      var info3 = this.info;
      if (line) {
        this.parseHeader(line, info3.headers);
      } else {
        var headers2 = info3.headers;
        var hasContentLength = false;
        var currentContentLengthValue;
        var hasUpgradeHeader = false;
        for (var i = 0; i < headers2.length; i += 2) {
          switch (headers2[i].toLowerCase()) {
            case "transfer-encoding":
              this.isChunked = headers2[i + 1].toLowerCase() === "chunked";
              break;
            case "content-length":
              currentContentLengthValue = +headers2[i + 1];
              if (hasContentLength) {
                if (currentContentLengthValue !== this.body_bytes) {
                  throw parseErrorCode("HPE_UNEXPECTED_CONTENT_LENGTH");
                }
              } else {
                hasContentLength = true;
                this.body_bytes = currentContentLengthValue;
              }
              break;
            case "connection":
              this.connection += headers2[i + 1].toLowerCase();
              break;
            case "upgrade":
              hasUpgradeHeader = true;
              break;
          }
        }
        if (this.isChunked && hasContentLength) {
          hasContentLength = false;
          this.body_bytes = null;
        }
        if (hasUpgradeHeader && this.connection.indexOf("upgrade") != -1) {
          info3.upgrade = this.type === HTTPParser.REQUEST || info3.statusCode === 101;
        } else {
          info3.upgrade = info3.method === method_connect;
        }
        if (this.isChunked && info3.upgrade) {
          this.isChunked = false;
        }
        info3.shouldKeepAlive = this.shouldKeepAlive();
        var skipBody;
        if (compatMode0_12) {
          skipBody = this.userCall()(this[kOnHeadersComplete](info3));
        } else {
          skipBody = this.userCall()(this[kOnHeadersComplete](
            info3.versionMajor,
            info3.versionMinor,
            info3.headers,
            info3.method,
            info3.url,
            info3.statusCode,
            info3.statusMessage,
            info3.upgrade,
            info3.shouldKeepAlive
          ));
        }
        if (skipBody === 2) {
          this.nextRequest();
          return true;
        } else if (this.isChunked && !skipBody) {
          this.state = "BODY_CHUNKHEAD";
        } else if (skipBody || this.body_bytes === 0) {
          this.nextRequest();
          return info3.upgrade;
        } else if (this.body_bytes === null) {
          this.state = "BODY_RAW";
        } else {
          this.state = "BODY_SIZED";
        }
      }
    };
    HTTPParser.prototype.BODY_CHUNKHEAD = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      this.body_bytes = parseInt(line, 16);
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKTRAILERS";
      } else {
        this.state = "BODY_CHUNK";
      }
    };
    HTTPParser.prototype.BODY_CHUNK = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.state = "BODY_CHUNKEMPTYLINE";
      }
    };
    HTTPParser.prototype.BODY_CHUNKEMPTYLINE = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      assert3.equal(line, "");
      this.state = "BODY_CHUNKHEAD";
    };
    HTTPParser.prototype.BODY_CHUNKTRAILERS = function() {
      var line = this.consumeLine();
      if (line === void 0) {
        return;
      }
      if (line) {
        this.parseHeader(line, this.trailers);
      } else {
        if (this.trailers.length) {
          this.userCall()(this[kOnHeaders](this.trailers, ""));
        }
        this.nextRequest();
      }
    };
    HTTPParser.prototype.BODY_RAW = function() {
      var length = this.end - this.offset;
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset = this.end;
    };
    HTTPParser.prototype.BODY_SIZED = function() {
      var length = Math.min(this.end - this.offset, this.body_bytes);
      this.userCall()(this[kOnBody](this.chunk, this.offset, length));
      this.offset += length;
      this.body_bytes -= length;
      if (!this.body_bytes) {
        this.nextRequest();
      }
    };
    ["Headers", "HeadersComplete", "Body", "MessageComplete"].forEach(function(name) {
      var k = HTTPParser["kOn" + name];
      Object.defineProperty(HTTPParser.prototype, "on" + name, {
        get: /* @__PURE__ */ __name(function() {
          return this[k];
        }, "get"),
        set: /* @__PURE__ */ __name(function(to) {
          this._compatMode0_11 = true;
          method_connect = "CONNECT";
          return this[k] = to;
        }, "set")
      });
    });
    function parseErrorCode(code) {
      var err = new Error("Parse Error");
      err.code = code;
      return err;
    }
    __name(parseErrorCode, "parseErrorCode");
    var NodeHTTPParser = httpParser.HTTPParser;
    var Buffer$7 = safeBuffer.exports.Buffer;
    var TYPES = {
      request: NodeHTTPParser.REQUEST || "request",
      response: NodeHTTPParser.RESPONSE || "response"
    };
    var HttpParser$3 = /* @__PURE__ */ __name(function(type2) {
      this._type = type2;
      this._parser = new NodeHTTPParser(TYPES[type2]);
      this._complete = false;
      this.headers = {};
      var current = null, self2 = this;
      this._parser.onHeaderField = function(b2, start, length) {
        current = b2.toString("utf8", start, start + length).toLowerCase();
      };
      this._parser.onHeaderValue = function(b2, start, length) {
        var value = b2.toString("utf8", start, start + length);
        if (self2.headers.hasOwnProperty(current))
          self2.headers[current] += ", " + value;
        else
          self2.headers[current] = value;
      };
      this._parser.onHeadersComplete = this._parser[NodeHTTPParser.kOnHeadersComplete] = function(majorVersion, minorVersion, headers2, method2, pathname, statusCode) {
        var info3 = arguments[0];
        if (typeof info3 === "object") {
          method2 = info3.method;
          pathname = info3.url;
          statusCode = info3.statusCode;
          headers2 = info3.headers;
        }
        self2.method = typeof method2 === "number" ? HttpParser$3.METHODS[method2] : method2;
        self2.statusCode = statusCode;
        self2.url = pathname;
        if (!headers2) return;
        for (var i = 0, n = headers2.length, key2, value; i < n; i += 2) {
          key2 = headers2[i].toLowerCase();
          value = headers2[i + 1];
          if (self2.headers.hasOwnProperty(key2))
            self2.headers[key2] += ", " + value;
          else
            self2.headers[key2] = value;
        }
        self2._complete = true;
      };
    }, "HttpParser$3");
    HttpParser$3.METHODS = {
      0: "DELETE",
      1: "GET",
      2: "HEAD",
      3: "POST",
      4: "PUT",
      5: "CONNECT",
      6: "OPTIONS",
      7: "TRACE",
      8: "COPY",
      9: "LOCK",
      10: "MKCOL",
      11: "MOVE",
      12: "PROPFIND",
      13: "PROPPATCH",
      14: "SEARCH",
      15: "UNLOCK",
      16: "BIND",
      17: "REBIND",
      18: "UNBIND",
      19: "ACL",
      20: "REPORT",
      21: "MKACTIVITY",
      22: "CHECKOUT",
      23: "MERGE",
      24: "M-SEARCH",
      25: "NOTIFY",
      26: "SUBSCRIBE",
      27: "UNSUBSCRIBE",
      28: "PATCH",
      29: "PURGE",
      30: "MKCALENDAR",
      31: "LINK",
      32: "UNLINK"
    };
    var VERSION = process.version ? process.version.match(/[0-9]+/g).map(function(n) {
      return parseInt(n, 10);
    }) : [];
    if (VERSION[0] === 0 && VERSION[1] === 12) {
      HttpParser$3.METHODS[16] = "REPORT";
      HttpParser$3.METHODS[17] = "MKACTIVITY";
      HttpParser$3.METHODS[18] = "CHECKOUT";
      HttpParser$3.METHODS[19] = "MERGE";
      HttpParser$3.METHODS[20] = "M-SEARCH";
      HttpParser$3.METHODS[21] = "NOTIFY";
      HttpParser$3.METHODS[22] = "SUBSCRIBE";
      HttpParser$3.METHODS[23] = "UNSUBSCRIBE";
      HttpParser$3.METHODS[24] = "PATCH";
      HttpParser$3.METHODS[25] = "PURGE";
    }
    HttpParser$3.prototype.isComplete = function() {
      return this._complete;
    };
    HttpParser$3.prototype.parse = function(chunk) {
      var consumed = this._parser.execute(chunk, 0, chunk.length);
      if (typeof consumed !== "number") {
        this.error = consumed;
        this._complete = true;
        return;
      }
      if (this._complete)
        this.body = consumed < chunk.length ? chunk.slice(consumed) : Buffer$7.alloc(0);
    };
    var http_parser = HttpParser$3;
    var TOKEN = /([!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z]+)/;
    var NOTOKEN = /([^!#\$%&'\*\+\-\.\^_`\|~0-9A-Za-z])/g;
    var QUOTED = /"((?:\\[\x00-\x7f]|[^\x00-\x08\x0a-\x1f\x7f"\\])*)"/;
    var PARAM = new RegExp(TOKEN.source + "(?:=(?:" + TOKEN.source + "|" + QUOTED.source + "))?");
    var EXT = new RegExp(TOKEN.source + "(?: *; *" + PARAM.source + ")*", "g");
    var EXT_LIST = new RegExp("^" + EXT.source + "(?: *, *" + EXT.source + ")*$");
    var NUMBER = /^-?(0|[1-9][0-9]*)(\.[0-9]+)?$/;
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    var Parser$1 = {
      parseHeader: /* @__PURE__ */ __name(function(header) {
        var offers = new Offers();
        if (header === "" || header === void 0) return offers;
        if (!EXT_LIST.test(header))
          throw new SyntaxError("Invalid Sec-WebSocket-Extensions header: " + header);
        var values = header.match(EXT);
        values.forEach(function(value) {
          var params = value.match(new RegExp(PARAM.source, "g")), name = params.shift(), offer = {};
          params.forEach(function(param) {
            var args = param.match(PARAM), key2 = args[1], data;
            if (args[2] !== void 0) {
              data = args[2];
            } else if (args[3] !== void 0) {
              data = args[3].replace(/\\/g, "");
            } else {
              data = true;
            }
            if (NUMBER.test(data)) data = parseFloat(data);
            if (hasOwnProperty.call(offer, key2)) {
              offer[key2] = [].concat(offer[key2]);
              offer[key2].push(data);
            } else {
              offer[key2] = data;
            }
          }, this);
          offers.push(name, offer);
        }, this);
        return offers;
      }, "parseHeader"),
      serializeParams: /* @__PURE__ */ __name(function(name, params) {
        var values = [];
        var print = /* @__PURE__ */ __name(function(key3, value) {
          if (value instanceof Array) {
            value.forEach(function(v2) {
              print(key3, v2);
            });
          } else if (value === true) {
            values.push(key3);
          } else if (typeof value === "number") {
            values.push(key3 + "=" + value);
          } else if (NOTOKEN.test(value)) {
            values.push(key3 + '="' + value.replace(/"/g, '\\"') + '"');
          } else {
            values.push(key3 + "=" + value);
          }
        }, "print");
        for (var key2 in params) print(key2, params[key2]);
        return [name].concat(values).join("; ");
      }, "serializeParams")
    };
    var Offers = /* @__PURE__ */ __name(function() {
      this._byName = {};
      this._inOrder = [];
    }, "Offers");
    Offers.prototype.push = function(name, params) {
      if (!hasOwnProperty.call(this._byName, name))
        this._byName[name] = [];
      this._byName[name].push(params);
      this._inOrder.push({ name, params });
    };
    Offers.prototype.eachOffer = function(callback, context2) {
      var list = this._inOrder;
      for (var i = 0, n = list.length; i < n; i++)
        callback.call(context2, list[i].name, list[i].params);
    };
    Offers.prototype.byName = function(name) {
      return this._byName[name] || [];
    };
    Offers.prototype.toArray = function() {
      return this._inOrder.slice();
    };
    var parser = Parser$1;
    var RingBuffer$2 = /* @__PURE__ */ __name(function(bufferSize) {
      this._bufferSize = bufferSize;
      this.clear();
    }, "RingBuffer$2");
    RingBuffer$2.prototype.clear = function() {
      this._buffer = new Array(this._bufferSize);
      this._ringOffset = 0;
      this._ringSize = this._bufferSize;
      this._head = 0;
      this._tail = 0;
      this.length = 0;
    };
    RingBuffer$2.prototype.push = function(value) {
      var expandBuffer = false, expandRing = false;
      if (this._ringSize < this._bufferSize) {
        expandBuffer = this._tail === 0;
      } else if (this._ringOffset === this._ringSize) {
        expandBuffer = true;
        expandRing = this._tail === 0;
      }
      if (expandBuffer) {
        this._tail = this._bufferSize;
        this._buffer = this._buffer.concat(new Array(this._bufferSize));
        this._bufferSize = this._buffer.length;
        if (expandRing)
          this._ringSize = this._bufferSize;
      }
      this._buffer[this._tail] = value;
      this.length += 1;
      if (this._tail < this._ringSize) this._ringOffset += 1;
      this._tail = (this._tail + 1) % this._bufferSize;
    };
    RingBuffer$2.prototype.peek = function() {
      if (this.length === 0) return void 0;
      return this._buffer[this._head];
    };
    RingBuffer$2.prototype.shift = function() {
      if (this.length === 0) return void 0;
      var value = this._buffer[this._head];
      this._buffer[this._head] = void 0;
      this.length -= 1;
      this._ringOffset -= 1;
      if (this._ringOffset === 0 && this.length > 0) {
        this._head = this._ringSize;
        this._ringOffset = this.length;
        this._ringSize = this._bufferSize;
      } else {
        this._head = (this._head + 1) % this._ringSize;
      }
      return value;
    };
    var ring_buffer = RingBuffer$2;
    var RingBuffer$1 = ring_buffer;
    var Functor$1 = /* @__PURE__ */ __name(function(session, method2) {
      this._session = session;
      this._method = method2;
      this._queue = new RingBuffer$1(Functor$1.QUEUE_SIZE);
      this._stopped = false;
      this.pending = 0;
    }, "Functor$1");
    Functor$1.QUEUE_SIZE = 8;
    Functor$1.prototype.call = function(error4, message3, callback, context2) {
      if (this._stopped) return;
      var record = { error: error4, message: message3, callback, context: context2, done: false }, called = false, self2 = this;
      this._queue.push(record);
      if (record.error) {
        record.done = true;
        this._stop();
        return this._flushQueue();
      }
      var handler = /* @__PURE__ */ __name(function(err, msg) {
        if (!(called ^ (called = true))) return;
        if (err) {
          self2._stop();
          record.error = err;
          record.message = null;
        } else {
          record.message = msg;
        }
        record.done = true;
        self2._flushQueue();
      }, "handler");
      try {
        this._session[this._method](message3, handler);
      } catch (err) {
        handler(err);
      }
    };
    Functor$1.prototype._stop = function() {
      this.pending = this._queue.length;
      this._stopped = true;
    };
    Functor$1.prototype._flushQueue = function() {
      var queue = this._queue, record;
      while (queue.length > 0 && queue.peek().done) {
        record = queue.shift();
        if (record.error) {
          this.pending = 0;
          queue.clear();
        } else {
          this.pending -= 1;
        }
        record.callback.call(record.context, record.error, record.message);
      }
    };
    var functor = Functor$1;
    var RingBuffer = ring_buffer;
    var Pledge$2 = /* @__PURE__ */ __name(function() {
      this._complete = false;
      this._callbacks = new RingBuffer(Pledge$2.QUEUE_SIZE);
    }, "Pledge$2");
    Pledge$2.QUEUE_SIZE = 4;
    Pledge$2.all = function(list) {
      var pledge2 = new Pledge$2(), pending = list.length, n = pending;
      if (pending === 0) pledge2.done();
      while (n--) list[n].then(function() {
        pending -= 1;
        if (pending === 0) pledge2.done();
      });
      return pledge2;
    };
    Pledge$2.prototype.then = function(callback) {
      if (this._complete) callback();
      else this._callbacks.push(callback);
    };
    Pledge$2.prototype.done = function() {
      this._complete = true;
      var callbacks = this._callbacks, callback;
      while (callback = callbacks.shift()) callback();
    };
    var pledge = Pledge$2;
    var Functor = functor;
    var Pledge$1 = pledge;
    var Cell$1 = /* @__PURE__ */ __name(function(tuple) {
      this._ext = tuple[0];
      this._session = tuple[1];
      this._functors = {
        incoming: new Functor(this._session, "processIncomingMessage"),
        outgoing: new Functor(this._session, "processOutgoingMessage")
      };
    }, "Cell$1");
    Cell$1.prototype.pending = function(direction) {
      var functor2 = this._functors[direction];
      if (!functor2._stopped) functor2.pending += 1;
    };
    Cell$1.prototype.incoming = function(error4, message3, callback, context2) {
      this._exec("incoming", error4, message3, callback, context2);
    };
    Cell$1.prototype.outgoing = function(error4, message3, callback, context2) {
      this._exec("outgoing", error4, message3, callback, context2);
    };
    Cell$1.prototype.close = function() {
      this._closed = this._closed || new Pledge$1();
      this._doClose();
      return this._closed;
    };
    Cell$1.prototype._exec = function(direction, error4, message3, callback, context2) {
      this._functors[direction].call(error4, message3, function(err, msg) {
        if (err) err.message = this._ext.name + ": " + err.message;
        callback.call(context2, err, msg);
        this._doClose();
      }, this);
    };
    Cell$1.prototype._doClose = function() {
      var fin = this._functors.incoming, fout = this._functors.outgoing;
      if (!this._closed || fin.pending + fout.pending !== 0) return;
      if (this._session) this._session.close();
      this._session = null;
      this._closed.done();
    };
    var cell = Cell$1;
    var Cell = cell;
    var Pledge = pledge;
    var Pipeline$1 = /* @__PURE__ */ __name(function(sessions) {
      this._cells = sessions.map(function(session) {
        return new Cell(session);
      });
      this._stopped = { incoming: false, outgoing: false };
    }, "Pipeline$1");
    Pipeline$1.prototype.processIncomingMessage = function(message3, callback, context2) {
      if (this._stopped.incoming) return;
      this._loop("incoming", this._cells.length - 1, -1, -1, message3, callback, context2);
    };
    Pipeline$1.prototype.processOutgoingMessage = function(message3, callback, context2) {
      if (this._stopped.outgoing) return;
      this._loop("outgoing", 0, this._cells.length, 1, message3, callback, context2);
    };
    Pipeline$1.prototype.close = function(callback, context2) {
      this._stopped = { incoming: true, outgoing: true };
      var closed = this._cells.map(function(a2) {
        return a2.close();
      });
      if (callback)
        Pledge.all(closed).then(function() {
          callback.call(context2);
        });
    };
    Pipeline$1.prototype._loop = function(direction, start, end, step, message3, callback, context2) {
      var cells = this._cells, n = cells.length, self2 = this;
      while (n--) cells[n].pending(direction);
      var pipe = /* @__PURE__ */ __name(function(index, error4, msg) {
        if (index === end) return callback.call(context2, error4, msg);
        cells[index][direction](error4, msg, function(err, m2) {
          if (err) self2._stopped[direction] = true;
          pipe(index + step, err, m2);
        });
      }, "pipe");
      pipe(start, null, message3);
    };
    var pipeline = Pipeline$1;
    var Parser = parser;
    var Pipeline = pipeline;
    var Extensions$1 = /* @__PURE__ */ __name(function() {
      this._rsv1 = this._rsv2 = this._rsv3 = null;
      this._byName = {};
      this._inOrder = [];
      this._sessions = [];
      this._index = {};
    }, "Extensions$1");
    Extensions$1.MESSAGE_OPCODES = [1, 2];
    var instance$a = {
      add: /* @__PURE__ */ __name(function(ext) {
        if (typeof ext.name !== "string") throw new TypeError("extension.name must be a string");
        if (ext.type !== "permessage") throw new TypeError('extension.type must be "permessage"');
        if (typeof ext.rsv1 !== "boolean") throw new TypeError("extension.rsv1 must be true or false");
        if (typeof ext.rsv2 !== "boolean") throw new TypeError("extension.rsv2 must be true or false");
        if (typeof ext.rsv3 !== "boolean") throw new TypeError("extension.rsv3 must be true or false");
        if (this._byName.hasOwnProperty(ext.name))
          throw new TypeError('An extension with name "' + ext.name + '" is already registered');
        this._byName[ext.name] = ext;
        this._inOrder.push(ext);
      }, "add"),
      generateOffer: /* @__PURE__ */ __name(function() {
        var sessions = [], offer = [], index = {};
        this._inOrder.forEach(function(ext) {
          var session = ext.createClientSession();
          if (!session) return;
          var record = [ext, session];
          sessions.push(record);
          index[ext.name] = record;
          var offers = session.generateOffer();
          offers = offers ? [].concat(offers) : [];
          offers.forEach(function(off3) {
            offer.push(Parser.serializeParams(ext.name, off3));
          }, this);
        }, this);
        this._sessions = sessions;
        this._index = index;
        return offer.length > 0 ? offer.join(", ") : null;
      }, "generateOffer"),
      activate: /* @__PURE__ */ __name(function(header) {
        var responses = Parser.parseHeader(header), sessions = [];
        responses.eachOffer(function(name, params) {
          var record = this._index[name];
          if (!record)
            throw new Error('Server sent an extension response for unknown extension "' + name + '"');
          var ext = record[0], session = record[1], reserved = this._reserved(ext);
          if (reserved)
            throw new Error("Server sent two extension responses that use the RSV" + reserved[0] + ' bit: "' + reserved[1] + '" and "' + ext.name + '"');
          if (session.activate(params) !== true)
            throw new Error("Server sent unacceptable extension parameters: " + Parser.serializeParams(name, params));
          this._reserve(ext);
          sessions.push(record);
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
      }, "activate"),
      generateResponse: /* @__PURE__ */ __name(function(header) {
        var sessions = [], response = [], offers = Parser.parseHeader(header);
        this._inOrder.forEach(function(ext) {
          var offer = offers.byName(ext.name);
          if (offer.length === 0 || this._reserved(ext)) return;
          var session = ext.createServerSession(offer);
          if (!session) return;
          this._reserve(ext);
          sessions.push([ext, session]);
          response.push(Parser.serializeParams(ext.name, session.generateResponse()));
        }, this);
        this._sessions = sessions;
        this._pipeline = new Pipeline(sessions);
        return response.length > 0 ? response.join(", ") : null;
      }, "generateResponse"),
      validFrameRsv: /* @__PURE__ */ __name(function(frame2) {
        var allowed = { rsv1: false, rsv2: false, rsv3: false }, ext;
        if (Extensions$1.MESSAGE_OPCODES.indexOf(frame2.opcode) >= 0) {
          for (var i = 0, n = this._sessions.length; i < n; i++) {
            ext = this._sessions[i][0];
            allowed.rsv1 = allowed.rsv1 || ext.rsv1;
            allowed.rsv2 = allowed.rsv2 || ext.rsv2;
            allowed.rsv3 = allowed.rsv3 || ext.rsv3;
          }
        }
        return (allowed.rsv1 || !frame2.rsv1) && (allowed.rsv2 || !frame2.rsv2) && (allowed.rsv3 || !frame2.rsv3);
      }, "validFrameRsv"),
      processIncomingMessage: /* @__PURE__ */ __name(function(message3, callback, context2) {
        this._pipeline.processIncomingMessage(message3, callback, context2);
      }, "processIncomingMessage"),
      processOutgoingMessage: /* @__PURE__ */ __name(function(message3, callback, context2) {
        this._pipeline.processOutgoingMessage(message3, callback, context2);
      }, "processOutgoingMessage"),
      close: /* @__PURE__ */ __name(function(callback, context2) {
        if (!this._pipeline) return callback.call(context2);
        this._pipeline.close(callback, context2);
      }, "close"),
      _reserve: /* @__PURE__ */ __name(function(ext) {
        this._rsv1 = this._rsv1 || ext.rsv1 && ext.name;
        this._rsv2 = this._rsv2 || ext.rsv2 && ext.name;
        this._rsv3 = this._rsv3 || ext.rsv3 && ext.name;
      }, "_reserve"),
      _reserved: /* @__PURE__ */ __name(function(ext) {
        if (this._rsv1 && ext.rsv1) return [1, this._rsv1];
        if (this._rsv2 && ext.rsv2) return [2, this._rsv2];
        if (this._rsv3 && ext.rsv3) return [3, this._rsv3];
        return false;
      }, "_reserved")
    };
    for (key$a in instance$a)
      Extensions$1.prototype[key$a] = instance$a[key$a];
    var key$a;
    var websocket_extensions = Extensions$1;
    var Frame$1 = /* @__PURE__ */ __name(function() {
    }, "Frame$1");
    var instance$9 = {
      final: false,
      rsv1: false,
      rsv2: false,
      rsv3: false,
      opcode: null,
      masked: false,
      maskingKey: null,
      lengthBytes: 1,
      length: 0,
      payload: null
    };
    for (key$9 in instance$9)
      Frame$1.prototype[key$9] = instance$9[key$9];
    var key$9;
    var frame = Frame$1;
    var Buffer$6 = safeBuffer.exports.Buffer;
    var Message$1 = /* @__PURE__ */ __name(function() {
      this.rsv1 = false;
      this.rsv2 = false;
      this.rsv3 = false;
      this.opcode = null;
      this.length = 0;
      this._chunks = [];
    }, "Message$1");
    var instance$8 = {
      read: /* @__PURE__ */ __name(function() {
        return this.data = this.data || Buffer$6.concat(this._chunks, this.length);
      }, "read"),
      pushFrame: /* @__PURE__ */ __name(function(frame2) {
        this.rsv1 = this.rsv1 || frame2.rsv1;
        this.rsv2 = this.rsv2 || frame2.rsv2;
        this.rsv3 = this.rsv3 || frame2.rsv3;
        if (this.opcode === null) this.opcode = frame2.opcode;
        this._chunks.push(frame2.payload);
        this.length += frame2.length;
      }, "pushFrame")
    };
    for (key$8 in instance$8)
      Message$1.prototype[key$8] = instance$8[key$8];
    var key$8;
    var message2 = Message$1;
    var Buffer$5 = safeBuffer.exports.Buffer;
    var crypto$2 = require$$1__default$1["default"];
    var util$a = require$$2__default["default"];
    var Extensions = websocket_extensions;
    var Base$6 = base;
    var Frame = frame;
    var Message = message2;
    var Hybi$2 = /* @__PURE__ */ __name(function(request3, url2, options) {
      Base$6.apply(this, arguments);
      this._extensions = new Extensions();
      this._stage = 0;
      this._masking = this._options.masking;
      this._protocols = this._options.protocols || [];
      this._requireMasking = this._options.requireMasking;
      this._pingCallbacks = {};
      if (typeof this._protocols === "string")
        this._protocols = this._protocols.split(/ *, */);
      if (!this._request) return;
      var protos = this._request.headers["sec-websocket-protocol"], supported = this._protocols;
      if (protos !== void 0) {
        if (typeof protos === "string") protos = protos.split(/ *, */);
        this.protocol = protos.filter(function(p2) {
          return supported.indexOf(p2) >= 0;
        })[0];
      }
      this.version = "hybi-" + Hybi$2.VERSION;
    }, "Hybi$2");
    util$a.inherits(Hybi$2, Base$6);
    Hybi$2.VERSION = "13";
    Hybi$2.mask = function(payload, mask, offset) {
      if (!mask || mask.length === 0) return payload;
      offset = offset || 0;
      for (var i = 0, n = payload.length - offset; i < n; i++) {
        payload[offset + i] = payload[offset + i] ^ mask[i % 4];
      }
      return payload;
    };
    Hybi$2.generateAccept = function(key2) {
      var sha12 = crypto$2.createHash("sha1");
      sha12.update(key2 + Hybi$2.GUID);
      return sha12.digest("base64");
    };
    Hybi$2.GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11";
    var instance$7 = {
      FIN: 128,
      MASK: 128,
      RSV1: 64,
      RSV2: 32,
      RSV3: 16,
      OPCODE: 15,
      LENGTH: 127,
      OPCODES: {
        continuation: 0,
        text: 1,
        binary: 2,
        close: 8,
        ping: 9,
        pong: 10
      },
      OPCODE_CODES: [0, 1, 2, 8, 9, 10],
      MESSAGE_OPCODES: [0, 1, 2],
      OPENING_OPCODES: [1, 2],
      ERRORS: {
        normal_closure: 1e3,
        going_away: 1001,
        protocol_error: 1002,
        unacceptable: 1003,
        encoding_error: 1007,
        policy_violation: 1008,
        too_large: 1009,
        extension_error: 1010,
        unexpected_condition: 1011
      },
      ERROR_CODES: [1e3, 1001, 1002, 1003, 1007, 1008, 1009, 1010, 1011],
      DEFAULT_ERROR_CODE: 1e3,
      MIN_RESERVED_ERROR: 3e3,
      MAX_RESERVED_ERROR: 4999,
      // http://www.w3.org/International/questions/qa-forms-utf-8.en.php
      UTF8_MATCH: /^([\x00-\x7F]|[\xC2-\xDF][\x80-\xBF]|\xE0[\xA0-\xBF][\x80-\xBF]|[\xE1-\xEC\xEE\xEF][\x80-\xBF]{2}|\xED[\x80-\x9F][\x80-\xBF]|\xF0[\x90-\xBF][\x80-\xBF]{2}|[\xF1-\xF3][\x80-\xBF]{3}|\xF4[\x80-\x8F][\x80-\xBF]{2})*$/,
      addExtension: /* @__PURE__ */ __name(function(extension) {
        this._extensions.add(extension);
        return true;
      }, "addExtension"),
      parse: /* @__PURE__ */ __name(function(chunk) {
        this._reader.put(chunk);
        var buffer = true;
        while (buffer) {
          switch (this._stage) {
            case 0:
              buffer = this._reader.read(1);
              if (buffer) this._parseOpcode(buffer[0]);
              break;
            case 1:
              buffer = this._reader.read(1);
              if (buffer) this._parseLength(buffer[0]);
              break;
            case 2:
              buffer = this._reader.read(this._frame.lengthBytes);
              if (buffer) this._parseExtendedLength(buffer);
              break;
            case 3:
              buffer = this._reader.read(4);
              if (buffer) {
                this._stage = 4;
                this._frame.maskingKey = buffer;
              }
              break;
            case 4:
              buffer = this._reader.read(this._frame.length);
              if (buffer) {
                this._stage = 0;
                this._emitFrame(buffer);
              }
              break;
            default:
              buffer = null;
          }
        }
      }, "parse"),
      text: /* @__PURE__ */ __name(function(message3) {
        if (this.readyState > 1) return false;
        return this.frame(message3, "text");
      }, "text"),
      binary: /* @__PURE__ */ __name(function(message3) {
        if (this.readyState > 1) return false;
        return this.frame(message3, "binary");
      }, "binary"),
      ping: /* @__PURE__ */ __name(function(message3, callback) {
        if (this.readyState > 1) return false;
        message3 = message3 || "";
        if (callback) this._pingCallbacks[message3] = callback;
        return this.frame(message3, "ping");
      }, "ping"),
      pong: /* @__PURE__ */ __name(function(message3) {
        if (this.readyState > 1) return false;
        message3 = message3 || "";
        return this.frame(message3, "pong");
      }, "pong"),
      close: /* @__PURE__ */ __name(function(reason, code) {
        reason = reason || "";
        code = code || this.ERRORS.normal_closure;
        if (this.readyState <= 0) {
          this.readyState = 3;
          this.emit("close", new Base$6.CloseEvent(code, reason));
          return true;
        } else if (this.readyState === 1) {
          this.readyState = 2;
          this._extensions.close(function() {
            this.frame(reason, "close", code);
          }, this);
          return true;
        } else {
          return false;
        }
      }, "close"),
      frame: /* @__PURE__ */ __name(function(buffer, type2, code) {
        if (this.readyState <= 0) return this._queue([buffer, type2, code]);
        if (this.readyState > 2) return false;
        if (buffer instanceof Array) buffer = Buffer$5.from(buffer);
        if (typeof buffer === "number") buffer = buffer.toString();
        var message3 = new Message(), isText = typeof buffer === "string", payload, copy;
        message3.rsv1 = message3.rsv2 = message3.rsv3 = false;
        message3.opcode = this.OPCODES[type2 || (isText ? "text" : "binary")];
        payload = isText ? Buffer$5.from(buffer, "utf8") : buffer;
        if (code) {
          copy = payload;
          payload = Buffer$5.allocUnsafe(2 + copy.length);
          payload.writeUInt16BE(code, 0);
          copy.copy(payload, 2);
        }
        message3.data = payload;
        var onMessageReady = /* @__PURE__ */ __name(function(message4) {
          var frame2 = new Frame();
          frame2.final = true;
          frame2.rsv1 = message4.rsv1;
          frame2.rsv2 = message4.rsv2;
          frame2.rsv3 = message4.rsv3;
          frame2.opcode = message4.opcode;
          frame2.masked = !!this._masking;
          frame2.length = message4.data.length;
          frame2.payload = message4.data;
          if (frame2.masked) frame2.maskingKey = crypto$2.randomBytes(4);
          this._sendFrame(frame2);
        }, "onMessageReady");
        if (this.MESSAGE_OPCODES.indexOf(message3.opcode) >= 0)
          this._extensions.processOutgoingMessage(message3, function(error4, message4) {
            if (error4) return this._fail("extension_error", error4.message);
            onMessageReady.call(this, message4);
          }, this);
        else
          onMessageReady.call(this, message3);
        return true;
      }, "frame"),
      _sendFrame: /* @__PURE__ */ __name(function(frame2) {
        var length = frame2.length, header = length <= 125 ? 2 : length <= 65535 ? 4 : 10, offset = header + (frame2.masked ? 4 : 0), buffer = Buffer$5.allocUnsafe(offset + length), masked = frame2.masked ? this.MASK : 0;
        buffer[0] = (frame2.final ? this.FIN : 0) | (frame2.rsv1 ? this.RSV1 : 0) | (frame2.rsv2 ? this.RSV2 : 0) | (frame2.rsv3 ? this.RSV3 : 0) | frame2.opcode;
        if (length <= 125) {
          buffer[1] = masked | length;
        } else if (length <= 65535) {
          buffer[1] = masked | 126;
          buffer.writeUInt16BE(length, 2);
        } else {
          buffer[1] = masked | 127;
          buffer.writeUInt32BE(Math.floor(length / 4294967296), 2);
          buffer.writeUInt32BE(length % 4294967296, 6);
        }
        frame2.payload.copy(buffer, offset);
        if (frame2.masked) {
          frame2.maskingKey.copy(buffer, header);
          Hybi$2.mask(buffer, frame2.maskingKey, offset);
        }
        this._write(buffer);
      }, "_sendFrame"),
      _handshakeResponse: /* @__PURE__ */ __name(function() {
        var secKey = this._request.headers["sec-websocket-key"], version3 = this._request.headers["sec-websocket-version"];
        if (version3 !== Hybi$2.VERSION)
          throw new Error("Unsupported WebSocket version: " + version3);
        if (typeof secKey !== "string")
          throw new Error("Missing handshake request header: Sec-WebSocket-Key");
        this._headers.set("Upgrade", "websocket");
        this._headers.set("Connection", "Upgrade");
        this._headers.set("Sec-WebSocket-Accept", Hybi$2.generateAccept(secKey));
        if (this.protocol) this._headers.set("Sec-WebSocket-Protocol", this.protocol);
        var extensions = this._extensions.generateResponse(this._request.headers["sec-websocket-extensions"]);
        if (extensions) this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start = "HTTP/1.1 101 Switching Protocols", headers2 = [start, this._headers.toString(), ""];
        return Buffer$5.from(headers2.join("\r\n"), "utf8");
      }, "_handshakeResponse"),
      _shutdown: /* @__PURE__ */ __name(function(code, reason, error4) {
        delete this._frame;
        delete this._message;
        this._stage = 5;
        var sendCloseFrame = this.readyState === 1;
        this.readyState = 2;
        this._extensions.close(function() {
          if (sendCloseFrame) this.frame(reason, "close", code);
          this.readyState = 3;
          if (error4) this.emit("error", new Error(reason));
          this.emit("close", new Base$6.CloseEvent(code, reason));
        }, this);
      }, "_shutdown"),
      _fail: /* @__PURE__ */ __name(function(type2, message3) {
        if (this.readyState > 1) return;
        this._shutdown(this.ERRORS[type2], message3, true);
      }, "_fail"),
      _parseOpcode: /* @__PURE__ */ __name(function(octet) {
        var rsvs = [this.RSV1, this.RSV2, this.RSV3].map(function(rsv) {
          return (octet & rsv) === rsv;
        });
        var frame2 = this._frame = new Frame();
        frame2.final = (octet & this.FIN) === this.FIN;
        frame2.rsv1 = rsvs[0];
        frame2.rsv2 = rsvs[1];
        frame2.rsv3 = rsvs[2];
        frame2.opcode = octet & this.OPCODE;
        this._stage = 1;
        if (!this._extensions.validFrameRsv(frame2))
          return this._fail(
            "protocol_error",
            "One or more reserved bits are on: reserved1 = " + (frame2.rsv1 ? 1 : 0) + ", reserved2 = " + (frame2.rsv2 ? 1 : 0) + ", reserved3 = " + (frame2.rsv3 ? 1 : 0)
          );
        if (this.OPCODE_CODES.indexOf(frame2.opcode) < 0)
          return this._fail("protocol_error", "Unrecognized frame opcode: " + frame2.opcode);
        if (this.MESSAGE_OPCODES.indexOf(frame2.opcode) < 0 && !frame2.final)
          return this._fail("protocol_error", "Received fragmented control frame: opcode = " + frame2.opcode);
        if (this._message && this.OPENING_OPCODES.indexOf(frame2.opcode) >= 0)
          return this._fail("protocol_error", "Received new data frame but previous continuous frame is unfinished");
      }, "_parseOpcode"),
      _parseLength: /* @__PURE__ */ __name(function(octet) {
        var frame2 = this._frame;
        frame2.masked = (octet & this.MASK) === this.MASK;
        frame2.length = octet & this.LENGTH;
        if (frame2.length >= 0 && frame2.length <= 125) {
          this._stage = frame2.masked ? 3 : 4;
          if (!this._checkFrameLength()) return;
        } else {
          this._stage = 2;
          frame2.lengthBytes = frame2.length === 126 ? 2 : 8;
        }
        if (this._requireMasking && !frame2.masked)
          return this._fail("unacceptable", "Received unmasked frame but masking is required");
      }, "_parseLength"),
      _parseExtendedLength: /* @__PURE__ */ __name(function(buffer) {
        var frame2 = this._frame;
        frame2.length = this._readUInt(buffer);
        this._stage = frame2.masked ? 3 : 4;
        if (this.MESSAGE_OPCODES.indexOf(frame2.opcode) < 0 && frame2.length > 125)
          return this._fail("protocol_error", "Received control frame having too long payload: " + frame2.length);
        if (!this._checkFrameLength()) return;
      }, "_parseExtendedLength"),
      _checkFrameLength: /* @__PURE__ */ __name(function() {
        var length = this._message ? this._message.length : 0;
        if (length + this._frame.length > this._maxLength) {
          this._fail("too_large", "WebSocket frame length too large");
          return false;
        } else {
          return true;
        }
      }, "_checkFrameLength"),
      _emitFrame: /* @__PURE__ */ __name(function(buffer) {
        var frame2 = this._frame, payload = frame2.payload = Hybi$2.mask(buffer, frame2.maskingKey), opcode = frame2.opcode, message3, code, reason, callbacks, callback;
        delete this._frame;
        if (opcode === this.OPCODES.continuation) {
          if (!this._message) return this._fail("protocol_error", "Received unexpected continuation frame");
          this._message.pushFrame(frame2);
        }
        if (opcode === this.OPCODES.text || opcode === this.OPCODES.binary) {
          this._message = new Message();
          this._message.pushFrame(frame2);
        }
        if (frame2.final && this.MESSAGE_OPCODES.indexOf(opcode) >= 0)
          return this._emitMessage(this._message);
        if (opcode === this.OPCODES.close) {
          code = payload.length >= 2 ? payload.readUInt16BE(0) : null;
          reason = payload.length > 2 ? this._encode(payload.slice(2)) : null;
          if (!(payload.length === 0) && !(code !== null && code >= this.MIN_RESERVED_ERROR && code <= this.MAX_RESERVED_ERROR) && this.ERROR_CODES.indexOf(code) < 0)
            code = this.ERRORS.protocol_error;
          if (payload.length > 125 || payload.length > 2 && !reason)
            code = this.ERRORS.protocol_error;
          this._shutdown(code || this.DEFAULT_ERROR_CODE, reason || "");
        }
        if (opcode === this.OPCODES.ping) {
          this.frame(payload, "pong");
          this.emit("ping", new Base$6.PingEvent(payload.toString()));
        }
        if (opcode === this.OPCODES.pong) {
          callbacks = this._pingCallbacks;
          message3 = this._encode(payload);
          callback = callbacks[message3];
          delete callbacks[message3];
          if (callback) callback();
          this.emit("pong", new Base$6.PongEvent(payload.toString()));
        }
      }, "_emitFrame"),
      _emitMessage: /* @__PURE__ */ __name(function(message3) {
        var message3 = this._message;
        message3.read();
        delete this._message;
        this._extensions.processIncomingMessage(message3, function(error4, message4) {
          if (error4) return this._fail("extension_error", error4.message);
          var payload = message4.data;
          if (message4.opcode === this.OPCODES.text) payload = this._encode(payload);
          if (payload === null)
            return this._fail("encoding_error", "Could not decode a text frame as UTF-8");
          else
            this.emit("message", new Base$6.MessageEvent(payload));
        }, this);
      }, "_emitMessage"),
      _encode: /* @__PURE__ */ __name(function(buffer) {
        try {
          var string = buffer.toString("binary", 0, buffer.length);
          if (!this.UTF8_MATCH.test(string)) return null;
        } catch (e) {
        }
        return buffer.toString("utf8", 0, buffer.length);
      }, "_encode"),
      _readUInt: /* @__PURE__ */ __name(function(buffer) {
        if (buffer.length === 2) return buffer.readUInt16BE(0);
        return buffer.readUInt32BE(0) * 4294967296 + buffer.readUInt32BE(4);
      }, "_readUInt")
    };
    for (key$7 in instance$7)
      Hybi$2.prototype[key$7] = instance$7[key$7];
    var key$7;
    var hybi = Hybi$2;
    var Buffer$4 = safeBuffer.exports.Buffer;
    var Stream$2 = require$$0__default$1["default"].Stream;
    var url$2 = require$$2__default$1["default"];
    var util$9 = require$$2__default["default"];
    var Base$5 = base;
    var Headers$1 = headers;
    var HttpParser$2 = http_parser;
    var PORTS = { "ws:": 80, "wss:": 443 };
    var Proxy$1 = /* @__PURE__ */ __name(function(client2, origin, options) {
      this._client = client2;
      this._http = new HttpParser$2("response");
      this._origin = typeof client2.url === "object" ? client2.url : url$2.parse(client2.url);
      this._url = typeof origin === "object" ? origin : url$2.parse(origin);
      this._options = options || {};
      this._state = 0;
      this.readable = this.writable = true;
      this._paused = false;
      this._headers = new Headers$1();
      this._headers.set("Host", this._origin.host);
      this._headers.set("Connection", "keep-alive");
      this._headers.set("Proxy-Connection", "keep-alive");
      var auth = this._url.auth && Buffer$4.from(this._url.auth, "utf8").toString("base64");
      if (auth) this._headers.set("Proxy-Authorization", "Basic " + auth);
    }, "Proxy$1");
    util$9.inherits(Proxy$1, Stream$2);
    var instance$6 = {
      setHeader: /* @__PURE__ */ __name(function(name, value) {
        if (this._state !== 0) return false;
        this._headers.set(name, value);
        return true;
      }, "setHeader"),
      start: /* @__PURE__ */ __name(function() {
        if (this._state !== 0) return false;
        this._state = 1;
        var origin = this._origin, port = origin.port || PORTS[origin.protocol], start = "CONNECT " + origin.hostname + ":" + port + " HTTP/1.1";
        var headers2 = [start, this._headers.toString(), ""];
        this.emit("data", Buffer$4.from(headers2.join("\r\n"), "utf8"));
        return true;
      }, "start"),
      pause: /* @__PURE__ */ __name(function() {
        this._paused = true;
      }, "pause"),
      resume: /* @__PURE__ */ __name(function() {
        this._paused = false;
        this.emit("drain");
      }, "resume"),
      write: /* @__PURE__ */ __name(function(chunk) {
        if (!this.writable) return false;
        this._http.parse(chunk);
        if (!this._http.isComplete()) return !this._paused;
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this.statusCode === 200) {
          this.emit("connect", new Base$5.ConnectEvent());
        } else {
          var message3 = "Can't establish a connection to the server at " + this._origin.href;
          this.emit("error", new Error(message3));
        }
        this.end();
        return !this._paused;
      }, "write"),
      end: /* @__PURE__ */ __name(function(chunk) {
        if (!this.writable) return;
        if (chunk !== void 0) this.write(chunk);
        this.readable = this.writable = false;
        this.emit("close");
        this.emit("end");
      }, "end"),
      destroy: /* @__PURE__ */ __name(function() {
        this.end();
      }, "destroy")
    };
    for (key$6 in instance$6)
      Proxy$1.prototype[key$6] = instance$6[key$6];
    var key$6;
    var proxy = Proxy$1;
    var Buffer$3 = safeBuffer.exports.Buffer;
    var crypto$1 = require$$1__default$1["default"];
    var url$1 = require$$2__default$1["default"];
    var util$8 = require$$2__default["default"];
    var HttpParser$1 = http_parser;
    var Base$4 = base;
    var Hybi$1 = hybi;
    var Proxy2 = proxy;
    var Client$2 = /* @__PURE__ */ __name(function(_url, options) {
      this.version = "hybi-" + Hybi$1.VERSION;
      Hybi$1.call(this, null, _url, options);
      this.readyState = -1;
      this._key = Client$2.generateKey();
      this._accept = Hybi$1.generateAccept(this._key);
      this._http = new HttpParser$1("response");
      var uri = url$1.parse(this.url), auth = uri.auth && Buffer$3.from(uri.auth, "utf8").toString("base64");
      if (this.VALID_PROTOCOLS.indexOf(uri.protocol) < 0)
        throw new Error(this.url + " is not a valid WebSocket URL");
      this._pathname = (uri.pathname || "/") + (uri.search || "");
      this._headers.set("Host", uri.host);
      this._headers.set("Upgrade", "websocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Key", this._key);
      this._headers.set("Sec-WebSocket-Version", Hybi$1.VERSION);
      if (this._protocols.length > 0)
        this._headers.set("Sec-WebSocket-Protocol", this._protocols.join(", "));
      if (auth)
        this._headers.set("Authorization", "Basic " + auth);
    }, "Client$2");
    util$8.inherits(Client$2, Hybi$1);
    Client$2.generateKey = function() {
      return crypto$1.randomBytes(16).toString("base64");
    };
    var instance$5 = {
      VALID_PROTOCOLS: ["ws:", "wss:"],
      proxy: /* @__PURE__ */ __name(function(origin, options) {
        return new Proxy2(this, origin, options);
      }, "proxy"),
      start: /* @__PURE__ */ __name(function() {
        if (this.readyState !== -1) return false;
        this._write(this._handshakeRequest());
        this.readyState = 0;
        return true;
      }, "start"),
      parse: /* @__PURE__ */ __name(function(chunk) {
        if (this.readyState === 3) return;
        if (this.readyState > 0) return Hybi$1.prototype.parse.call(this, chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete()) return;
        this._validateHandshake();
        if (this.readyState === 3) return;
        this._open();
        this.parse(this._http.body);
      }, "parse"),
      _handshakeRequest: /* @__PURE__ */ __name(function() {
        var extensions = this._extensions.generateOffer();
        if (extensions)
          this._headers.set("Sec-WebSocket-Extensions", extensions);
        var start = "GET " + this._pathname + " HTTP/1.1", headers2 = [start, this._headers.toString(), ""];
        return Buffer$3.from(headers2.join("\r\n"), "utf8");
      }, "_handshakeRequest"),
      _failHandshake: /* @__PURE__ */ __name(function(message3) {
        message3 = "Error during WebSocket handshake: " + message3;
        this.readyState = 3;
        this.emit("error", new Error(message3));
        this.emit("close", new Base$4.CloseEvent(this.ERRORS.protocol_error, message3));
      }, "_failHandshake"),
      _validateHandshake: /* @__PURE__ */ __name(function() {
        this.statusCode = this._http.statusCode;
        this.headers = this._http.headers;
        if (this._http.error)
          return this._failHandshake(this._http.error.message);
        if (this._http.statusCode !== 101)
          return this._failHandshake("Unexpected response code: " + this._http.statusCode);
        var headers2 = this._http.headers, upgrade = headers2["upgrade"] || "", connection = headers2["connection"] || "", accept = headers2["sec-websocket-accept"] || "", protocol = headers2["sec-websocket-protocol"] || "";
        if (upgrade === "")
          return this._failHandshake("'Upgrade' header is missing");
        if (upgrade.toLowerCase() !== "websocket")
          return this._failHandshake("'Upgrade' header value is not 'WebSocket'");
        if (connection === "")
          return this._failHandshake("'Connection' header is missing");
        if (connection.toLowerCase() !== "upgrade")
          return this._failHandshake("'Connection' header value is not 'Upgrade'");
        if (accept !== this._accept)
          return this._failHandshake("Sec-WebSocket-Accept mismatch");
        this.protocol = null;
        if (protocol !== "") {
          if (this._protocols.indexOf(protocol) < 0)
            return this._failHandshake("Sec-WebSocket-Protocol mismatch");
          else
            this.protocol = protocol;
        }
        try {
          this._extensions.activate(this.headers["sec-websocket-extensions"]);
        } catch (e) {
          return this._failHandshake(e.message);
        }
      }, "_validateHandshake")
    };
    for (key$5 in instance$5)
      Client$2.prototype[key$5] = instance$5[key$5];
    var key$5;
    var client$1 = Client$2;
    var Buffer$2 = safeBuffer.exports.Buffer;
    var Base$3 = base;
    var util$7 = require$$2__default["default"];
    var Draft75$2 = /* @__PURE__ */ __name(function(request3, url2, options) {
      Base$3.apply(this, arguments);
      this._stage = 0;
      this.version = "hixie-75";
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("WebSocket-Origin", this._request.headers.origin);
      this._headers.set("WebSocket-Location", this.url);
    }, "Draft75$2");
    util$7.inherits(Draft75$2, Base$3);
    var instance$4 = {
      close: /* @__PURE__ */ __name(function() {
        if (this.readyState === 3) return false;
        this.readyState = 3;
        this.emit("close", new Base$3.CloseEvent(null, null));
        return true;
      }, "close"),
      parse: /* @__PURE__ */ __name(function(chunk) {
        if (this.readyState > 1) return;
        this._reader.put(chunk);
        this._reader.eachByte(function(octet) {
          var message3;
          switch (this._stage) {
            case -1:
              this._body.push(octet);
              this._sendHandshakeBody();
              break;
            case 0:
              this._parseLeadingByte(octet);
              break;
            case 1:
              this._length = (octet & 127) + 128 * this._length;
              if (this._closing && this._length === 0) {
                return this.close();
              } else if ((octet & 128) !== 128) {
                if (this._length === 0) {
                  this._stage = 0;
                } else {
                  this._skipped = 0;
                  this._stage = 2;
                }
              }
              break;
            case 2:
              if (octet === 255) {
                this._stage = 0;
                message3 = Buffer$2.from(this._buffer).toString("utf8", 0, this._buffer.length);
                this.emit("message", new Base$3.MessageEvent(message3));
              } else {
                if (this._length) {
                  this._skipped += 1;
                  if (this._skipped === this._length)
                    this._stage = 0;
                } else {
                  this._buffer.push(octet);
                  if (this._buffer.length > this._maxLength) return this.close();
                }
              }
              break;
          }
        }, this);
      }, "parse"),
      frame: /* @__PURE__ */ __name(function(buffer) {
        if (this.readyState === 0) return this._queue([buffer]);
        if (this.readyState > 1) return false;
        if (typeof buffer !== "string") buffer = buffer.toString();
        var length = Buffer$2.byteLength(buffer), frame2 = Buffer$2.allocUnsafe(length + 2);
        frame2[0] = 0;
        frame2.write(buffer, 1);
        frame2[frame2.length - 1] = 255;
        this._write(frame2);
        return true;
      }, "frame"),
      _handshakeResponse: /* @__PURE__ */ __name(function() {
        var start = "HTTP/1.1 101 Web Socket Protocol Handshake", headers2 = [start, this._headers.toString(), ""];
        return Buffer$2.from(headers2.join("\r\n"), "utf8");
      }, "_handshakeResponse"),
      _parseLeadingByte: /* @__PURE__ */ __name(function(octet) {
        if ((octet & 128) === 128) {
          this._length = 0;
          this._stage = 1;
        } else {
          delete this._length;
          delete this._skipped;
          this._buffer = [];
          this._stage = 2;
        }
      }, "_parseLeadingByte")
    };
    for (key$4 in instance$4)
      Draft75$2.prototype[key$4] = instance$4[key$4];
    var key$4;
    var draft75 = Draft75$2;
    var Buffer$1 = safeBuffer.exports.Buffer;
    var Base$2 = base;
    var Draft75$1 = draft75;
    var crypto2 = require$$1__default$1["default"];
    var util$6 = require$$2__default["default"];
    var numberFromKey = /* @__PURE__ */ __name(function(key2) {
      return parseInt((key2.match(/[0-9]/g) || []).join(""), 10);
    }, "numberFromKey");
    var spacesInKey = /* @__PURE__ */ __name(function(key2) {
      return (key2.match(/ /g) || []).length;
    }, "spacesInKey");
    var Draft76$1 = /* @__PURE__ */ __name(function(request3, url2, options) {
      Draft75$1.apply(this, arguments);
      this._stage = -1;
      this._body = [];
      this.version = "hixie-76";
      this._headers.clear();
      this._headers.set("Upgrade", "WebSocket");
      this._headers.set("Connection", "Upgrade");
      this._headers.set("Sec-WebSocket-Origin", this._request.headers.origin);
      this._headers.set("Sec-WebSocket-Location", this.url);
    }, "Draft76$1");
    util$6.inherits(Draft76$1, Draft75$1);
    var instance$3 = {
      BODY_SIZE: 8,
      start: /* @__PURE__ */ __name(function() {
        if (!Draft75$1.prototype.start.call(this)) return false;
        this._started = true;
        this._sendHandshakeBody();
        return true;
      }, "start"),
      close: /* @__PURE__ */ __name(function() {
        if (this.readyState === 3) return false;
        if (this.readyState === 1) this._write(Buffer$1.from([255, 0]));
        this.readyState = 3;
        this.emit("close", new Base$2.CloseEvent(null, null));
        return true;
      }, "close"),
      _handshakeResponse: /* @__PURE__ */ __name(function() {
        var headers2 = this._request.headers, key1 = headers2["sec-websocket-key1"], key2 = headers2["sec-websocket-key2"];
        if (!key1) throw new Error("Missing required header: Sec-WebSocket-Key1");
        if (!key2) throw new Error("Missing required header: Sec-WebSocket-Key2");
        var number1 = numberFromKey(key1), spaces1 = spacesInKey(key1), number2 = numberFromKey(key2), spaces2 = spacesInKey(key2);
        if (number1 % spaces1 !== 0 || number2 % spaces2 !== 0)
          throw new Error("Client sent invalid Sec-WebSocket-Key headers");
        this._keyValues = [number1 / spaces1, number2 / spaces2];
        var start = "HTTP/1.1 101 WebSocket Protocol Handshake", headers2 = [start, this._headers.toString(), ""];
        return Buffer$1.from(headers2.join("\r\n"), "binary");
      }, "_handshakeResponse"),
      _handshakeSignature: /* @__PURE__ */ __name(function() {
        if (this._body.length < this.BODY_SIZE) return null;
        var md5 = crypto2.createHash("md5"), buffer = Buffer$1.allocUnsafe(8 + this.BODY_SIZE);
        buffer.writeUInt32BE(this._keyValues[0], 0);
        buffer.writeUInt32BE(this._keyValues[1], 4);
        Buffer$1.from(this._body).copy(buffer, 8, 0, this.BODY_SIZE);
        md5.update(buffer);
        return Buffer$1.from(md5.digest("binary"), "binary");
      }, "_handshakeSignature"),
      _sendHandshakeBody: /* @__PURE__ */ __name(function() {
        if (!this._started) return;
        var signature = this._handshakeSignature();
        if (!signature) return;
        this._write(signature);
        this._stage = 0;
        this._open();
        if (this._body.length > this.BODY_SIZE)
          this.parse(this._body.slice(this.BODY_SIZE));
      }, "_sendHandshakeBody"),
      _parseLeadingByte: /* @__PURE__ */ __name(function(octet) {
        if (octet !== 255)
          return Draft75$1.prototype._parseLeadingByte.call(this, octet);
        this._closing = true;
        this._length = 0;
        this._stage = 1;
      }, "_parseLeadingByte")
    };
    for (key$3 in instance$3)
      Draft76$1.prototype[key$3] = instance$3[key$3];
    var key$3;
    var draft76 = Draft76$1;
    var util$5 = require$$2__default["default"];
    var HttpParser = http_parser;
    var Base$1 = base;
    var Draft75 = draft75;
    var Draft76 = draft76;
    var Hybi = hybi;
    var Server$1 = /* @__PURE__ */ __name(function(options) {
      Base$1.call(this, null, null, options);
      this._http = new HttpParser("request");
    }, "Server$1");
    util$5.inherits(Server$1, Base$1);
    var instance$2 = {
      EVENTS: ["open", "message", "error", "close", "ping", "pong"],
      _bindEventListeners: /* @__PURE__ */ __name(function() {
        this.messages.on("error", function() {
        });
        this.on("error", function() {
        });
      }, "_bindEventListeners"),
      parse: /* @__PURE__ */ __name(function(chunk) {
        if (this._delegate) return this._delegate.parse(chunk);
        this._http.parse(chunk);
        if (!this._http.isComplete()) return;
        this.method = this._http.method;
        this.url = this._http.url;
        this.headers = this._http.headers;
        this.body = this._http.body;
        var self2 = this;
        this._delegate = Server$1.http(this, this._options);
        this._delegate.messages = this.messages;
        this._delegate.io = this.io;
        this._open();
        this.EVENTS.forEach(function(event2) {
          this._delegate.on(event2, function(e) {
            self2.emit(event2, e);
          });
        }, this);
        this.protocol = this._delegate.protocol;
        this.version = this._delegate.version;
        this.parse(this._http.body);
        this.emit("connect", new Base$1.ConnectEvent());
      }, "parse"),
      _open: /* @__PURE__ */ __name(function() {
        this.__queue.forEach(function(msg) {
          this._delegate[msg[0]].apply(this._delegate, msg[1]);
        }, this);
        this.__queue = [];
      }, "_open")
    };
    ["addExtension", "setHeader", "start", "frame", "text", "binary", "ping", "close"].forEach(function(method2) {
      instance$2[method2] = function() {
        if (this._delegate) {
          return this._delegate[method2].apply(this._delegate, arguments);
        } else {
          this.__queue.push([method2, arguments]);
          return true;
        }
      };
    });
    for (key$2 in instance$2)
      Server$1.prototype[key$2] = instance$2[key$2];
    var key$2;
    Server$1.isSecureRequest = function(request3) {
      if (request3.connection && request3.connection.authorized !== void 0) return true;
      if (request3.socket && request3.socket.secure) return true;
      var headers2 = request3.headers;
      if (!headers2) return false;
      if (headers2["https"] === "on") return true;
      if (headers2["x-forwarded-ssl"] === "on") return true;
      if (headers2["x-forwarded-scheme"] === "https") return true;
      if (headers2["x-forwarded-proto"] === "https") return true;
      return false;
    };
    Server$1.determineUrl = function(request3) {
      var scheme = this.isSecureRequest(request3) ? "wss:" : "ws:";
      return scheme + "//" + request3.headers.host + request3.url;
    };
    Server$1.http = function(request3, options) {
      options = options || {};
      if (options.requireMasking === void 0) options.requireMasking = true;
      var headers2 = request3.headers, version3 = headers2["sec-websocket-version"], key2 = headers2["sec-websocket-key"], key1 = headers2["sec-websocket-key1"], key22 = headers2["sec-websocket-key2"], url2 = this.determineUrl(request3);
      if (version3 || key2)
        return new Hybi(request3, url2, options);
      else if (key1 || key22)
        return new Draft76(request3, url2, options);
      else
        return new Draft75(request3, url2, options);
    };
    var server = Server$1;
    var Base = base;
    var Client$1 = client$1;
    var Server4 = server;
    var Driver = {
      client: /* @__PURE__ */ __name(function(url2, options) {
        options = options || {};
        if (options.masking === void 0) options.masking = true;
        return new Client$1(url2, options);
      }, "client"),
      server: /* @__PURE__ */ __name(function(options) {
        options = options || {};
        if (options.requireMasking === void 0) options.requireMasking = true;
        return new Server4(options);
      }, "server"),
      http: /* @__PURE__ */ __name(function() {
        return Server4.http.apply(Server4, arguments);
      }, "http"),
      isSecureRequest: /* @__PURE__ */ __name(function(request3) {
        return Server4.isSecureRequest(request3);
      }, "isSecureRequest"),
      isWebSocket: /* @__PURE__ */ __name(function(request3) {
        return Base.isWebSocket(request3);
      }, "isWebSocket"),
      validateOptions: /* @__PURE__ */ __name(function(options, validKeys) {
        Base.validateOptions(options, validKeys);
      }, "validateOptions")
    };
    var driver$4 = Driver;
    var Event$3 = /* @__PURE__ */ __name(function(eventType, options) {
      this.type = eventType;
      for (var key2 in options)
        this[key2] = options[key2];
    }, "Event$3");
    Event$3.prototype.initEvent = function(eventType, canBubble, cancelable) {
      this.type = eventType;
      this.bubbles = canBubble;
      this.cancelable = cancelable;
    };
    Event$3.prototype.stopPropagation = function() {
    };
    Event$3.prototype.preventDefault = function() {
    };
    Event$3.CAPTURING_PHASE = 1;
    Event$3.AT_TARGET = 2;
    Event$3.BUBBLING_PHASE = 3;
    var event = Event$3;
    var Event$2 = event;
    var EventTarget$2 = {
      onopen: null,
      onmessage: null,
      onerror: null,
      onclose: null,
      addEventListener: /* @__PURE__ */ __name(function(eventType, listener, useCapture) {
        this.on(eventType, listener);
      }, "addEventListener"),
      removeEventListener: /* @__PURE__ */ __name(function(eventType, listener, useCapture) {
        this.removeListener(eventType, listener);
      }, "removeEventListener"),
      dispatchEvent: /* @__PURE__ */ __name(function(event2) {
        event2.target = event2.currentTarget = this;
        event2.eventPhase = Event$2.AT_TARGET;
        if (this["on" + event2.type])
          this["on" + event2.type](event2);
        this.emit(event2.type, event2);
      }, "dispatchEvent")
    };
    var event_target = EventTarget$2;
    var Stream$1 = require$$0__default$1["default"].Stream;
    var util$4 = require$$2__default["default"];
    var driver$3 = driver$4;
    var EventTarget$1 = event_target;
    var Event$1 = event;
    var API$3 = /* @__PURE__ */ __name(function(options) {
      options = options || {};
      driver$3.validateOptions(options, ["headers", "extensions", "maxLength", "ping", "proxy", "tls", "ca"]);
      this.readable = this.writable = true;
      var headers2 = options.headers;
      if (headers2) {
        for (var name in headers2) this._driver.setHeader(name, headers2[name]);
      }
      var extensions = options.extensions;
      if (extensions) {
        [].concat(extensions).forEach(this._driver.addExtension, this._driver);
      }
      this._ping = options.ping;
      this._pingId = 0;
      this.readyState = API$3.CONNECTING;
      this.bufferedAmount = 0;
      this.protocol = "";
      this.url = this._driver.url;
      this.version = this._driver.version;
      var self2 = this;
      this._driver.on("open", function(e) {
        self2._open();
      });
      this._driver.on("message", function(e) {
        self2._receiveMessage(e.data);
      });
      this._driver.on("close", function(e) {
        self2._beginClose(e.reason, e.code);
      });
      this._driver.on("error", function(error4) {
        self2._emitError(error4.message);
      });
      this.on("error", function() {
      });
      this._driver.messages.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2._pingId += 1;
          self2.ping(self2._pingId.toString());
        }, this._ping * 1e3);
      this._configureStream();
      if (!this._proxy) {
        this._stream.pipe(this._driver.io);
        this._driver.io.pipe(this._stream);
      }
    }, "API$3");
    util$4.inherits(API$3, Stream$1);
    API$3.CONNECTING = 0;
    API$3.OPEN = 1;
    API$3.CLOSING = 2;
    API$3.CLOSED = 3;
    API$3.CLOSE_TIMEOUT = 3e4;
    var instance$1 = {
      write: /* @__PURE__ */ __name(function(data) {
        return this.send(data);
      }, "write"),
      end: /* @__PURE__ */ __name(function(data) {
        if (data !== void 0) this.send(data);
        this.close();
      }, "end"),
      pause: /* @__PURE__ */ __name(function() {
        return this._driver.messages.pause();
      }, "pause"),
      resume: /* @__PURE__ */ __name(function() {
        return this._driver.messages.resume();
      }, "resume"),
      send: /* @__PURE__ */ __name(function(data) {
        if (this.readyState > API$3.OPEN) return false;
        if (!(data instanceof Buffer)) data = String(data);
        return this._driver.messages.write(data);
      }, "send"),
      ping: /* @__PURE__ */ __name(function(message3, callback) {
        if (this.readyState > API$3.OPEN) return false;
        return this._driver.ping(message3, callback);
      }, "ping"),
      close: /* @__PURE__ */ __name(function(code, reason) {
        if (code === void 0) code = 1e3;
        if (reason === void 0) reason = "";
        if (code !== 1e3 && (code < 3e3 || code > 4999))
          throw new Error("Failed to execute 'close' on WebSocket: The code must be either 1000, or between 3000 and 4999. " + code + " is neither.");
        if (this.readyState < API$3.CLOSING) {
          var self2 = this;
          this._closeTimer = setTimeout(function() {
            self2._beginClose("", 1006);
          }, API$3.CLOSE_TIMEOUT);
        }
        if (this.readyState !== API$3.CLOSED) this.readyState = API$3.CLOSING;
        this._driver.close(reason, code);
      }, "close"),
      _configureStream: /* @__PURE__ */ __name(function() {
        var self2 = this;
        this._stream.setTimeout(0);
        this._stream.setNoDelay(true);
        ["close", "end"].forEach(function(event2) {
          this._stream.on(event2, function() {
            self2._finalizeClose();
          });
        }, this);
        this._stream.on("error", function(error4) {
          self2._emitError("Network error: " + self2.url + ": " + error4.message);
          self2._finalizeClose();
        });
      }, "_configureStream"),
      _open: /* @__PURE__ */ __name(function() {
        if (this.readyState !== API$3.CONNECTING) return;
        this.readyState = API$3.OPEN;
        this.protocol = this._driver.protocol || "";
        var event2 = new Event$1("open");
        event2.initEvent("open", false, false);
        this.dispatchEvent(event2);
      }, "_open"),
      _receiveMessage: /* @__PURE__ */ __name(function(data) {
        if (this.readyState > API$3.OPEN) return false;
        if (this.readable) this.emit("data", data);
        var event2 = new Event$1("message", { data });
        event2.initEvent("message", false, false);
        this.dispatchEvent(event2);
      }, "_receiveMessage"),
      _emitError: /* @__PURE__ */ __name(function(message3) {
        if (this.readyState >= API$3.CLOSING) return;
        var event2 = new Event$1("error", { message: message3 });
        event2.initEvent("error", false, false);
        this.dispatchEvent(event2);
      }, "_emitError"),
      _beginClose: /* @__PURE__ */ __name(function(reason, code) {
        if (this.readyState === API$3.CLOSED) return;
        this.readyState = API$3.CLOSING;
        this._closeParams = [reason, code];
        if (this._stream) {
          this._stream.destroy();
          if (!this._stream.readable) this._finalizeClose();
        }
      }, "_beginClose"),
      _finalizeClose: /* @__PURE__ */ __name(function() {
        if (this.readyState === API$3.CLOSED) return;
        this.readyState = API$3.CLOSED;
        if (this._closeTimer) clearTimeout(this._closeTimer);
        if (this._pingTimer) clearInterval(this._pingTimer);
        if (this._stream) this._stream.end();
        if (this.readable) this.emit("end");
        this.readable = this.writable = false;
        var reason = this._closeParams ? this._closeParams[0] : "", code = this._closeParams ? this._closeParams[1] : 1006;
        var event2 = new Event$1("close", { code, reason });
        event2.initEvent("close", false, false);
        this.dispatchEvent(event2);
      }, "_finalizeClose")
    };
    for (method$1 in instance$1) API$3.prototype[method$1] = instance$1[method$1];
    var method$1;
    for (key$1 in EventTarget$1) API$3.prototype[key$1] = EventTarget$1[key$1];
    var key$1;
    var api = API$3;
    var util$3 = require$$2__default["default"];
    var net = require$$1__default$2["default"];
    var tls = require$$2__default$2["default"];
    var url = require$$2__default$1["default"];
    var driver$2 = driver$4;
    var API$2 = api;
    var DEFAULT_PORTS = { "http:": 80, "https:": 443, "ws:": 80, "wss:": 443 };
    var SECURE_PROTOCOLS = ["https:", "wss:"];
    var Client = /* @__PURE__ */ __name(function(_url, protocols, options) {
      options = options || {};
      this.url = _url;
      this._driver = driver$2.client(this.url, { maxLength: options.maxLength, protocols });
      ["open", "error"].forEach(function(event2) {
        this._driver.on(event2, function() {
          self2.headers = self2._driver.headers;
          self2.statusCode = self2._driver.statusCode;
        });
      }, this);
      var proxy2 = options.proxy || {}, endpoint = url.parse(proxy2.origin || this.url), port = endpoint.port || DEFAULT_PORTS[endpoint.protocol], secure = SECURE_PROTOCOLS.indexOf(endpoint.protocol) >= 0, onConnect = /* @__PURE__ */ __name(function() {
        self2._onConnect();
      }, "onConnect"), netOptions = options.net || {}, originTLS = options.tls || {}, socketTLS = proxy2.origin ? proxy2.tls || {} : originTLS, self2 = this;
      netOptions.host = socketTLS.host = endpoint.hostname;
      netOptions.port = socketTLS.port = port;
      originTLS.ca = originTLS.ca || options.ca;
      socketTLS.servername = socketTLS.servername || endpoint.hostname;
      this._stream = secure ? tls.connect(socketTLS, onConnect) : net.connect(netOptions, onConnect);
      if (proxy2.origin) this._configureProxy(proxy2, originTLS);
      API$2.call(this, options);
    }, "Client");
    util$3.inherits(Client, API$2);
    Client.prototype._onConnect = function() {
      var worker = this._proxy || this._driver;
      worker.start();
    };
    Client.prototype._configureProxy = function(proxy2, originTLS) {
      var uri = url.parse(this.url), secure = SECURE_PROTOCOLS.indexOf(uri.protocol) >= 0, self2 = this, name;
      this._proxy = this._driver.proxy(proxy2.origin);
      if (proxy2.headers) {
        for (name in proxy2.headers) this._proxy.setHeader(name, proxy2.headers[name]);
      }
      this._proxy.pipe(this._stream, { end: false });
      this._stream.pipe(this._proxy);
      this._proxy.on("connect", function() {
        if (secure) {
          var options = { socket: self2._stream, servername: uri.hostname };
          for (name in originTLS) options[name] = originTLS[name];
          self2._stream = tls.connect(options);
          self2._configureStream();
        }
        self2._driver.io.pipe(self2._stream);
        self2._stream.pipe(self2._driver.io);
        self2._driver.start();
      });
      this._proxy.on("error", function(error4) {
        self2._driver.emit("error", error4);
      });
    };
    var client = Client;
    var Stream = require$$0__default$1["default"].Stream;
    var util$2 = require$$2__default["default"];
    var driver$1 = driver$4;
    var Headers2 = headers;
    var API$1 = api;
    var EventTarget = event_target;
    var Event = event;
    var EventSource = /* @__PURE__ */ __name(function(request3, response, options) {
      this.writable = true;
      options = options || {};
      this._stream = response.socket;
      this._ping = options.ping || this.DEFAULT_PING;
      this._retry = options.retry || this.DEFAULT_RETRY;
      var scheme = driver$1.isSecureRequest(request3) ? "https:" : "http:";
      this.url = scheme + "//" + request3.headers.host + request3.url;
      this.lastEventId = request3.headers["last-event-id"] || "";
      this.readyState = API$1.CONNECTING;
      var headers2 = new Headers2(), self2 = this;
      if (options.headers) {
        for (var key2 in options.headers) headers2.set(key2, options.headers[key2]);
      }
      if (!this._stream || !this._stream.writable) return;
      process.nextTick(function() {
        self2._open();
      });
      this._stream.setTimeout(0);
      this._stream.setNoDelay(true);
      var handshake = "HTTP/1.1 200 OK\r\nContent-Type: text/event-stream\r\nCache-Control: no-cache, no-store\r\nConnection: close\r\n" + headers2.toString() + "\r\nretry: " + Math.floor(this._retry * 1e3) + "\r\n\r\n";
      this._write(handshake);
      this._stream.on("drain", function() {
        self2.emit("drain");
      });
      if (this._ping)
        this._pingTimer = setInterval(function() {
          self2.ping();
        }, this._ping * 1e3);
      ["error", "end"].forEach(function(event2) {
        self2._stream.on(event2, function() {
          self2.close();
        });
      });
    }, "EventSource");
    util$2.inherits(EventSource, Stream);
    EventSource.isEventSource = function(request3) {
      if (request3.method !== "GET") return false;
      var accept = (request3.headers.accept || "").split(/\s*,\s*/);
      return accept.indexOf("text/event-stream") >= 0;
    };
    var instance = {
      DEFAULT_PING: 10,
      DEFAULT_RETRY: 5,
      _write: /* @__PURE__ */ __name(function(chunk) {
        if (!this.writable) return false;
        try {
          return this._stream.write(chunk, "utf8");
        } catch (e) {
          return false;
        }
      }, "_write"),
      _open: /* @__PURE__ */ __name(function() {
        if (this.readyState !== API$1.CONNECTING) return;
        this.readyState = API$1.OPEN;
        var event2 = new Event("open");
        event2.initEvent("open", false, false);
        this.dispatchEvent(event2);
      }, "_open"),
      write: /* @__PURE__ */ __name(function(message3) {
        return this.send(message3);
      }, "write"),
      end: /* @__PURE__ */ __name(function(message3) {
        if (message3 !== void 0) this.write(message3);
        this.close();
      }, "end"),
      send: /* @__PURE__ */ __name(function(message3, options) {
        if (this.readyState > API$1.OPEN) return false;
        message3 = String(message3).replace(/(\r\n|\r|\n)/g, "$1data: ");
        options = options || {};
        var frame2 = "";
        if (options.event) frame2 += "event: " + options.event + "\r\n";
        if (options.id) frame2 += "id: " + options.id + "\r\n";
        frame2 += "data: " + message3 + "\r\n\r\n";
        return this._write(frame2);
      }, "send"),
      ping: /* @__PURE__ */ __name(function() {
        return this._write(":\r\n\r\n");
      }, "ping"),
      close: /* @__PURE__ */ __name(function() {
        if (this.readyState > API$1.OPEN) return false;
        this.readyState = API$1.CLOSED;
        this.writable = false;
        if (this._pingTimer) clearInterval(this._pingTimer);
        if (this._stream) this._stream.end();
        var event2 = new Event("close");
        event2.initEvent("close", false, false);
        this.dispatchEvent(event2);
        return true;
      }, "close")
    };
    for (method in instance) EventSource.prototype[method] = instance[method];
    var method;
    for (key in EventTarget) EventSource.prototype[key] = EventTarget[key];
    var key;
    var eventsource = EventSource;
    var util$1 = require$$2__default["default"];
    var driver = driver$4;
    var API = api;
    var WebSocket$1 = /* @__PURE__ */ __name(function(request3, socket, body, protocols, options) {
      options = options || {};
      this._stream = socket;
      this._driver = driver.http(request3, { maxLength: options.maxLength, protocols });
      var self2 = this;
      if (!this._stream || !this._stream.writable) return;
      if (!this._stream.readable) return this._stream.end();
      var catchup = /* @__PURE__ */ __name(function() {
        self2._stream.removeListener("data", catchup);
      }, "catchup");
      this._stream.on("data", catchup);
      API.call(this, options);
      process.nextTick(function() {
        self2._driver.start();
        self2._driver.io.write(body);
      });
    }, "WebSocket$1");
    util$1.inherits(WebSocket$1, API);
    WebSocket$1.isWebSocket = function(request3) {
      return driver.isWebSocket(request3);
    };
    WebSocket$1.validateOptions = function(options, validKeys) {
      driver.validateOptions(options, validKeys);
    };
    WebSocket$1.WebSocket = WebSocket$1;
    WebSocket$1.Client = client;
    WebSocket$1.EventSource = eventsource;
    var websocket = WebSocket$1;
    Object.defineProperty(index_standalone, "__esModule", { value: true });
    var Websocket = websocket;
    var util = require$$1__default$3["default"];
    var logger$1 = require$$2__default$3["default"];
    var component = require$$3__default["default"];
    function _interopDefaultLegacy$1(e) {
      return e && typeof e === "object" && "default" in e ? e : { "default": e };
    }
    __name(_interopDefaultLegacy$1, "_interopDefaultLegacy$1");
    var Websocket__default = /* @__PURE__ */ _interopDefaultLegacy$1(Websocket);
    var PROTOCOL_VERSION = "5";
    var VERSION_PARAM = "v";
    var TRANSPORT_SESSION_PARAM = "s";
    var REFERER_PARAM = "r";
    var FORGE_REF = "f";
    var FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
    var LAST_SESSION_PARAM = "ls";
    var APPLICATION_ID_PARAM = "p";
    var APP_CHECK_TOKEN_PARAM = "ac";
    var WEBSOCKET = "websocket";
    var LONG_POLLING = "long_polling";
    var DOMStorageWrapper = class {
      static {
        __name(this, "DOMStorageWrapper");
      }
      /**
       * @param domStorage_ - The underlying storage object (e.g. localStorage or sessionStorage)
       */
      constructor(domStorage_) {
        this.domStorage_ = domStorage_;
        this.prefix_ = "firebase:";
      }
      /**
       * @param key - The key to save the value under
       * @param value - The value being stored, or null to remove the key.
       */
      set(key2, value) {
        if (value == null) {
          this.domStorage_.removeItem(this.prefixedName_(key2));
        } else {
          this.domStorage_.setItem(this.prefixedName_(key2), util.stringify(value));
        }
      }
      /**
       * @returns The value that was stored under this key, or null
       */
      get(key2) {
        const storedVal = this.domStorage_.getItem(this.prefixedName_(key2));
        if (storedVal == null) {
          return null;
        } else {
          return util.jsonEval(storedVal);
        }
      }
      remove(key2) {
        this.domStorage_.removeItem(this.prefixedName_(key2));
      }
      prefixedName_(name) {
        return this.prefix_ + name;
      }
      toString() {
        return this.domStorage_.toString();
      }
    };
    var MemoryStorage = class {
      static {
        __name(this, "MemoryStorage");
      }
      constructor() {
        this.cache_ = {};
        this.isInMemoryStorage = true;
      }
      set(key2, value) {
        if (value == null) {
          delete this.cache_[key2];
        } else {
          this.cache_[key2] = value;
        }
      }
      get(key2) {
        if (util.contains(this.cache_, key2)) {
          return this.cache_[key2];
        }
        return null;
      }
      remove(key2) {
        delete this.cache_[key2];
      }
    };
    var createStoragefor = /* @__PURE__ */ __name(function(domStorageName) {
      try {
        if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
          const domStorage = window[domStorageName];
          domStorage.setItem("firebase:sentinel", "cache");
          domStorage.removeItem("firebase:sentinel");
          return new DOMStorageWrapper(domStorage);
        }
      } catch (e) {
      }
      return new MemoryStorage();
    }, "createStoragefor");
    var PersistentStorage = createStoragefor("localStorage");
    var SessionStorage = createStoragefor("sessionStorage");
    var logClient$1 = new logger$1.Logger("@firebase/database");
    var LUIDGenerator = /* @__PURE__ */ function() {
      let id = 1;
      return function() {
        return id++;
      };
    }();
    var sha1 = /* @__PURE__ */ __name(function(str) {
      const utf8Bytes = util.stringToByteArray(str);
      const sha12 = new util.Sha1();
      sha12.update(utf8Bytes);
      const sha1Bytes = sha12.digest();
      return util.base64.encodeByteArray(sha1Bytes);
    }, "sha1");
    var buildLogMessage_ = /* @__PURE__ */ __name(function(...varArgs) {
      let message3 = "";
      for (let i = 0; i < varArgs.length; i++) {
        const arg = varArgs[i];
        if (Array.isArray(arg) || arg && typeof arg === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
        typeof arg.length === "number") {
          message3 += buildLogMessage_.apply(null, arg);
        } else if (typeof arg === "object") {
          message3 += util.stringify(arg);
        } else {
          message3 += arg;
        }
        message3 += " ";
      }
      return message3;
    }, "buildLogMessage_");
    var logger = null;
    var firstLog_ = true;
    var enableLogging$1 = /* @__PURE__ */ __name(function(logger_, persistent) {
      util.assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
      if (logger_ === true) {
        logClient$1.logLevel = logger$1.LogLevel.VERBOSE;
        logger = logClient$1.log.bind(logClient$1);
        if (persistent) {
          SessionStorage.set("logging_enabled", true);
        }
      } else if (typeof logger_ === "function") {
        logger = logger_;
      } else {
        logger = null;
        SessionStorage.remove("logging_enabled");
      }
    }, "enableLogging$1");
    var log4 = /* @__PURE__ */ __name(function(...varArgs) {
      if (firstLog_ === true) {
        firstLog_ = false;
        if (logger === null && SessionStorage.get("logging_enabled") === true) {
          enableLogging$1(true);
        }
      }
      if (logger) {
        const message3 = buildLogMessage_.apply(null, varArgs);
        logger(message3);
      }
    }, "log");
    var logWrapper = /* @__PURE__ */ __name(function(prefix) {
      return function(...varArgs) {
        log4(prefix, ...varArgs);
      };
    }, "logWrapper");
    var error3 = /* @__PURE__ */ __name(function(...varArgs) {
      const message3 = "FIREBASE INTERNAL ERROR: " + buildLogMessage_(...varArgs);
      logClient$1.error(message3);
    }, "error");
    var fatal = /* @__PURE__ */ __name(function(...varArgs) {
      const message3 = `FIREBASE FATAL ERROR: ${buildLogMessage_(...varArgs)}`;
      logClient$1.error(message3);
      throw new Error(message3);
    }, "fatal");
    var warn$1 = /* @__PURE__ */ __name(function(...varArgs) {
      const message3 = "FIREBASE WARNING: " + buildLogMessage_(...varArgs);
      logClient$1.warn(message3);
    }, "warn$1");
    var warnIfPageIsSecure = /* @__PURE__ */ __name(function() {
      if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
        warn$1("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
      }
    }, "warnIfPageIsSecure");
    var isInvalidJSONNumber = /* @__PURE__ */ __name(function(data) {
      return typeof data === "number" && (data !== data || // NaN
      data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
    }, "isInvalidJSONNumber");
    var executeWhenDOMReady = /* @__PURE__ */ __name(function(fn) {
      if (util.isNodeSdk() || document.readyState === "complete") {
        fn();
      } else {
        let called = false;
        const wrappedFn = /* @__PURE__ */ __name(function() {
          if (!document.body) {
            setTimeout(wrappedFn, Math.floor(10));
            return;
          }
          if (!called) {
            called = true;
            fn();
          }
        }, "wrappedFn");
        if (document.addEventListener) {
          document.addEventListener("DOMContentLoaded", wrappedFn, false);
          window.addEventListener("load", wrappedFn, false);
        } else if (document.attachEvent) {
          document.attachEvent("onreadystatechange", () => {
            if (document.readyState === "complete") {
              wrappedFn();
            }
          });
          window.attachEvent("onload", wrappedFn);
        }
      }
    }, "executeWhenDOMReady");
    var MIN_NAME = "[MIN_NAME]";
    var MAX_NAME = "[MAX_NAME]";
    var nameCompare = /* @__PURE__ */ __name(function(a2, b2) {
      if (a2 === b2) {
        return 0;
      } else if (a2 === MIN_NAME || b2 === MAX_NAME) {
        return -1;
      } else if (b2 === MIN_NAME || a2 === MAX_NAME) {
        return 1;
      } else {
        const aAsInt = tryParseInt(a2), bAsInt = tryParseInt(b2);
        if (aAsInt !== null) {
          if (bAsInt !== null) {
            return aAsInt - bAsInt === 0 ? a2.length - b2.length : aAsInt - bAsInt;
          } else {
            return -1;
          }
        } else if (bAsInt !== null) {
          return 1;
        } else {
          return a2 < b2 ? -1 : 1;
        }
      }
    }, "nameCompare");
    var stringCompare = /* @__PURE__ */ __name(function(a2, b2) {
      if (a2 === b2) {
        return 0;
      } else if (a2 < b2) {
        return -1;
      } else {
        return 1;
      }
    }, "stringCompare");
    var requireKey = /* @__PURE__ */ __name(function(key2, obj) {
      if (obj && key2 in obj) {
        return obj[key2];
      } else {
        throw new Error("Missing required key (" + key2 + ") in object: " + util.stringify(obj));
      }
    }, "requireKey");
    var ObjectToUniqueKey = /* @__PURE__ */ __name(function(obj) {
      if (typeof obj !== "object" || obj === null) {
        return util.stringify(obj);
      }
      const keys = [];
      for (const k in obj) {
        keys.push(k);
      }
      keys.sort();
      let key2 = "{";
      for (let i = 0; i < keys.length; i++) {
        if (i !== 0) {
          key2 += ",";
        }
        key2 += util.stringify(keys[i]);
        key2 += ":";
        key2 += ObjectToUniqueKey(obj[keys[i]]);
      }
      key2 += "}";
      return key2;
    }, "ObjectToUniqueKey");
    var splitStringBySize = /* @__PURE__ */ __name(function(str, segsize) {
      const len = str.length;
      if (len <= segsize) {
        return [str];
      }
      const dataSegs = [];
      for (let c = 0; c < len; c += segsize) {
        if (c + segsize > len) {
          dataSegs.push(str.substring(c, len));
        } else {
          dataSegs.push(str.substring(c, c + segsize));
        }
      }
      return dataSegs;
    }, "splitStringBySize");
    function each(obj, fn) {
      for (const key2 in obj) {
        if (obj.hasOwnProperty(key2)) {
          fn(key2, obj[key2]);
        }
      }
    }
    __name(each, "each");
    var doubleToIEEE754String = /* @__PURE__ */ __name(function(v2) {
      util.assert(!isInvalidJSONNumber(v2), "Invalid JSON number");
      const ebits = 11, fbits = 52;
      const bias = (1 << ebits - 1) - 1;
      let s, e, f, ln, i;
      if (v2 === 0) {
        e = 0;
        f = 0;
        s = 1 / v2 === -Infinity ? 1 : 0;
      } else {
        s = v2 < 0;
        v2 = Math.abs(v2);
        if (v2 >= Math.pow(2, 1 - bias)) {
          ln = Math.min(Math.floor(Math.log(v2) / Math.LN2), bias);
          e = ln + bias;
          f = Math.round(v2 * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
        } else {
          e = 0;
          f = Math.round(v2 / Math.pow(2, 1 - bias - fbits));
        }
      }
      const bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      const str = bits.join("");
      let hexByteString = "";
      for (i = 0; i < 64; i += 8) {
        let hexByte = parseInt(str.substr(i, 8), 2).toString(16);
        if (hexByte.length === 1) {
          hexByte = "0" + hexByte;
        }
        hexByteString = hexByteString + hexByte;
      }
      return hexByteString.toLowerCase();
    }, "doubleToIEEE754String");
    var isChromeExtensionContentScript = /* @__PURE__ */ __name(function() {
      return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
    }, "isChromeExtensionContentScript");
    var isWindowsStoreApp = /* @__PURE__ */ __name(function() {
      return typeof Windows === "object" && typeof Windows.UI === "object";
    }, "isWindowsStoreApp");
    function errorForServerCode(code, query2) {
      let reason = "Unknown Error";
      if (code === "too_big") {
        reason = "The data requested exceeds the maximum size that can be accessed with a single request.";
      } else if (code === "permission_denied") {
        reason = "Client doesn't have permission to access the desired data.";
      } else if (code === "unavailable") {
        reason = "The service is unavailable";
      }
      const error4 = new Error(code + " at " + query2._path.toString() + ": " + reason);
      error4.code = code.toUpperCase();
      return error4;
    }
    __name(errorForServerCode, "errorForServerCode");
    var INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
    var INTEGER_32_MIN = -2147483648;
    var INTEGER_32_MAX = 2147483647;
    var tryParseInt = /* @__PURE__ */ __name(function(str) {
      if (INTEGER_REGEXP_.test(str)) {
        const intVal = Number(str);
        if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
          return intVal;
        }
      }
      return null;
    }, "tryParseInt");
    var exceptionGuard = /* @__PURE__ */ __name(function(fn) {
      try {
        fn();
      } catch (e) {
        setTimeout(() => {
          const stack = e.stack || "";
          warn$1("Exception was thrown by user callback.", stack);
          throw e;
        }, Math.floor(0));
      }
    }, "exceptionGuard");
    var beingCrawled = /* @__PURE__ */ __name(function() {
      const userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
      return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
    }, "beingCrawled");
    var setTimeoutNonBlocking = /* @__PURE__ */ __name(function(fn, time3) {
      const timeout = setTimeout(fn, time3);
      if (typeof timeout === "number" && // @ts-ignore Is only defined in Deno environments.
      typeof Deno !== "undefined" && // @ts-ignore Deno and unrefTimer are only defined in Deno environments.
      Deno["unrefTimer"]) {
        Deno.unrefTimer(timeout);
      } else if (typeof timeout === "object" && timeout["unref"]) {
        timeout["unref"]();
      }
      return timeout;
    }, "setTimeoutNonBlocking");
    var RepoInfo = class {
      static {
        __name(this, "RepoInfo");
      }
      /**
       * @param host - Hostname portion of the url for the repo
       * @param secure - Whether or not this repo is accessed over ssl
       * @param namespace - The namespace represented by the repo
       * @param webSocketOnly - Whether to prefer websockets over all other transports (used by Nest).
       * @param nodeAdmin - Whether this instance uses Admin SDK credentials
       * @param persistenceKey - Override the default session persistence storage key
       */
      constructor(host, secure, namespace, webSocketOnly, nodeAdmin = false, persistenceKey = "", includeNamespaceInQueryParams = false, isUsingEmulator = false) {
        this.secure = secure;
        this.namespace = namespace;
        this.webSocketOnly = webSocketOnly;
        this.nodeAdmin = nodeAdmin;
        this.persistenceKey = persistenceKey;
        this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
        this.isUsingEmulator = isUsingEmulator;
        this._host = host.toLowerCase();
        this._domain = this._host.substr(this._host.indexOf(".") + 1);
        this.internalHost = PersistentStorage.get("host:" + host) || this._host;
      }
      isCacheableHost() {
        return this.internalHost.substr(0, 2) === "s-";
      }
      isCustomHost() {
        return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
      }
      get host() {
        return this._host;
      }
      set host(newHost) {
        if (newHost !== this.internalHost) {
          this.internalHost = newHost;
          if (this.isCacheableHost()) {
            PersistentStorage.set("host:" + this._host, this.internalHost);
          }
        }
      }
      toString() {
        let str = this.toURLString();
        if (this.persistenceKey) {
          str += "<" + this.persistenceKey + ">";
        }
        return str;
      }
      toURLString() {
        const protocol = this.secure ? "https://" : "http://";
        const query2 = this.includeNamespaceInQueryParams ? `?ns=${this.namespace}` : "";
        return `${protocol}${this.host}/${query2}`;
      }
    };
    function repoInfoNeedsQueryParam(repoInfo) {
      return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
    }
    __name(repoInfoNeedsQueryParam, "repoInfoNeedsQueryParam");
    function repoInfoConnectionURL(repoInfo, type2, params) {
      util.assert(typeof type2 === "string", "typeof type must == string");
      util.assert(typeof params === "object", "typeof params must == object");
      let connURL;
      if (type2 === WEBSOCKET) {
        connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
      } else if (type2 === LONG_POLLING) {
        connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
      } else {
        throw new Error("Unknown connection type: " + type2);
      }
      if (repoInfoNeedsQueryParam(repoInfo)) {
        params["ns"] = repoInfo.namespace;
      }
      const pairs = [];
      each(params, (key2, value) => {
        pairs.push(key2 + "=" + value);
      });
      return connURL + pairs.join("&");
    }
    __name(repoInfoConnectionURL, "repoInfoConnectionURL");
    var StatsCollection = class {
      static {
        __name(this, "StatsCollection");
      }
      constructor() {
        this.counters_ = {};
      }
      incrementCounter(name, amount = 1) {
        if (!util.contains(this.counters_, name)) {
          this.counters_[name] = 0;
        }
        this.counters_[name] += amount;
      }
      get() {
        return util.deepCopy(this.counters_);
      }
    };
    var collections = {};
    var reporters = {};
    function statsManagerGetCollection(repoInfo) {
      const hashString = repoInfo.toString();
      if (!collections[hashString]) {
        collections[hashString] = new StatsCollection();
      }
      return collections[hashString];
    }
    __name(statsManagerGetCollection, "statsManagerGetCollection");
    function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
      const hashString = repoInfo.toString();
      if (!reporters[hashString]) {
        reporters[hashString] = creatorFunction();
      }
      return reporters[hashString];
    }
    __name(statsManagerGetOrCreateReporter, "statsManagerGetOrCreateReporter");
    var SDK_VERSION2 = "";
    function setSDKVersion(version3) {
      SDK_VERSION2 = version3;
    }
    __name(setSDKVersion, "setSDKVersion");
    var WEBSOCKET_MAX_FRAME_SIZE = 16384;
    var WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
    var WebSocketImpl = null;
    if (typeof MozWebSocket !== "undefined") {
      WebSocketImpl = MozWebSocket;
    } else if (typeof WebSocket !== "undefined") {
      WebSocketImpl = WebSocket;
    }
    function setWebSocketImpl(impl) {
      WebSocketImpl = impl;
    }
    __name(setWebSocketImpl, "setWebSocketImpl");
    var WebSocketConnection = class _WebSocketConnection {
      static {
        __name(this, "WebSocketConnection");
      }
      /**
       * @param connId identifier for this transport
       * @param repoInfo The info for the websocket endpoint.
       * @param applicationId The Firebase App ID for this project.
       * @param appCheckToken The App Check Token for this client.
       * @param authToken The Auth Token for this client.
       * @param transportSessionId Optional transportSessionId if this is connecting
       * to an existing transport session
       * @param lastSessionId Optional lastSessionId if there was a previous
       * connection
       */
      constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.keepaliveTimer = null;
        this.frames = null;
        this.totalFrames = 0;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.log_ = logWrapper(this.connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.connURL = _WebSocketConnection.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId);
        this.nodeAdmin = repoInfo.nodeAdmin;
      }
      /**
       * @param repoInfo - The info for the websocket endpoint.
       * @param transportSessionId - Optional transportSessionId if this is connecting to an existing transport
       *                                         session
       * @param lastSessionId - Optional lastSessionId if there was a previous connection
       * @returns connection url
       */
      static connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken, applicationId) {
        const urlParams = {};
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (!util.isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
          urlParams[REFERER_PARAM] = FORGE_REF;
        }
        if (transportSessionId) {
          urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
        }
        if (lastSessionId) {
          urlParams[LAST_SESSION_PARAM] = lastSessionId;
        }
        if (appCheckToken) {
          urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
        }
        if (applicationId) {
          urlParams[APPLICATION_ID_PARAM] = applicationId;
        }
        return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
      }
      /**
       * @param onMessage - Callback when messages arrive
       * @param onDisconnect - Callback with connection lost.
       */
      open(onMessage, onDisconnect2) {
        this.onDisconnect = onDisconnect2;
        this.onMessage = onMessage;
        this.log_("Websocket connecting to " + this.connURL);
        this.everConnected_ = false;
        PersistentStorage.set("previous_websocket_failure", true);
        try {
          let options;
          if (util.isNodeSdk()) {
            const device = this.nodeAdmin ? "AdminNode" : "Node";
            options = {
              headers: {
                "User-Agent": `Firebase/${PROTOCOL_VERSION}/${SDK_VERSION2}/${process.platform}/${device}`,
                "X-Firebase-GMPID": this.applicationId || ""
              }
            };
            if (this.authToken) {
              options.headers["Authorization"] = `Bearer ${this.authToken}`;
            }
            if (this.appCheckToken) {
              options.headers["X-Firebase-AppCheck"] = this.appCheckToken;
            }
            const env2 = process["env"];
            const proxy2 = this.connURL.indexOf("wss://") === 0 ? env2["HTTPS_PROXY"] || env2["https_proxy"] : env2["HTTP_PROXY"] || env2["http_proxy"];
            if (proxy2) {
              options["proxy"] = { origin: proxy2 };
            }
          }
          this.mySock = new WebSocketImpl(this.connURL, [], options);
        } catch (e) {
          this.log_("Error instantiating WebSocket.");
          const error4 = e.message || e.data;
          if (error4) {
            this.log_(error4);
          }
          this.onClosed_();
          return;
        }
        this.mySock.onopen = () => {
          this.log_("Websocket connected.");
          this.everConnected_ = true;
        };
        this.mySock.onclose = () => {
          this.log_("Websocket connection was disconnected.");
          this.mySock = null;
          this.onClosed_();
        };
        this.mySock.onmessage = (m2) => {
          this.handleIncomingFrame(m2);
        };
        this.mySock.onerror = (e) => {
          this.log_("WebSocket error.  Closing connection.");
          const error4 = e.message || e.data;
          if (error4) {
            this.log_(error4);
          }
          this.onClosed_();
        };
      }
      /**
       * No-op for websockets, we don't need to do anything once the connection is confirmed as open
       */
      start() {
      }
      static forceDisallow() {
        _WebSocketConnection.forceDisallow_ = true;
      }
      static isAvailable() {
        let isOldAndroid = false;
        if (typeof navigator !== "undefined" && "Cloudflare-Workers") {
          const oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
          const oldAndroidMatch = "Cloudflare-Workers".match(oldAndroidRegex);
          if (oldAndroidMatch && oldAndroidMatch.length > 1) {
            if (parseFloat(oldAndroidMatch[1]) < 4.4) {
              isOldAndroid = true;
            }
          }
        }
        return !isOldAndroid && WebSocketImpl !== null && !_WebSocketConnection.forceDisallow_;
      }
      /**
       * Returns true if we previously failed to connect with this transport.
       */
      static previouslyFailed() {
        return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
      }
      markConnectionHealthy() {
        PersistentStorage.remove("previous_websocket_failure");
      }
      appendFrame_(data) {
        this.frames.push(data);
        if (this.frames.length === this.totalFrames) {
          const fullMess = this.frames.join("");
          this.frames = null;
          const jsonMess = util.jsonEval(fullMess);
          this.onMessage(jsonMess);
        }
      }
      /**
       * @param frameCount - The number of frames we are expecting from the server
       */
      handleNewFrameCount_(frameCount) {
        this.totalFrames = frameCount;
        this.frames = [];
      }
      /**
       * Attempts to parse a frame count out of some text. If it can't, assumes a value of 1
       * @returns Any remaining data to be process, or null if there is none
       */
      extractFrameCount_(data) {
        util.assert(this.frames === null, "We already have a frame buffer");
        if (data.length <= 6) {
          const frameCount = Number(data);
          if (!isNaN(frameCount)) {
            this.handleNewFrameCount_(frameCount);
            return null;
          }
        }
        this.handleNewFrameCount_(1);
        return data;
      }
      /**
       * Process a websocket frame that has arrived from the server.
       * @param mess - The frame data
       */
      handleIncomingFrame(mess) {
        if (this.mySock === null) {
          return;
        }
        const data = mess["data"];
        this.bytesReceived += data.length;
        this.stats_.incrementCounter("bytes_received", data.length);
        this.resetKeepAlive();
        if (this.frames !== null) {
          this.appendFrame_(data);
        } else {
          const remainingData = this.extractFrameCount_(data);
          if (remainingData !== null) {
            this.appendFrame_(remainingData);
          }
        }
      }
      /**
       * Send a message to the server
       * @param data - The JSON object to transmit
       */
      send(data) {
        this.resetKeepAlive();
        const dataStr = util.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        const dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
        if (dataSegs.length > 1) {
          this.sendString_(String(dataSegs.length));
        }
        for (let i = 0; i < dataSegs.length; i++) {
          this.sendString_(dataSegs[i]);
        }
      }
      shutdown_() {
        this.isClosed_ = true;
        if (this.keepaliveTimer) {
          clearInterval(this.keepaliveTimer);
          this.keepaliveTimer = null;
        }
        if (this.mySock) {
          this.mySock.close();
          this.mySock = null;
        }
      }
      onClosed_() {
        if (!this.isClosed_) {
          this.log_("WebSocket is closing itself");
          this.shutdown_();
          if (this.onDisconnect) {
            this.onDisconnect(this.everConnected_);
            this.onDisconnect = null;
          }
        }
      }
      /**
       * External-facing close handler.
       * Close the websocket and kill the connection.
       */
      close() {
        if (!this.isClosed_) {
          this.log_("WebSocket is being closed");
          this.shutdown_();
        }
      }
      /**
       * Kill the current keepalive timer and start a new one, to ensure that it always fires N seconds after
       * the last activity.
       */
      resetKeepAlive() {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = setInterval(() => {
          if (this.mySock) {
            this.sendString_("0");
          }
          this.resetKeepAlive();
        }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
      }
      /**
       * Send a string over the websocket.
       *
       * @param str - String to send.
       */
      sendString_(str) {
        try {
          this.mySock.send(str);
        } catch (e) {
          this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
          setTimeout(this.onClosed_.bind(this), 0);
        }
      }
    };
    WebSocketConnection.responsesRequiredToBeHealthy = 2;
    WebSocketConnection.healthyTimeout = 3e4;
    var AppCheckTokenProvider = class {
      static {
        __name(this, "AppCheckTokenProvider");
      }
      constructor(appName_, appCheckProvider) {
        this.appName_ = appName_;
        this.appCheckProvider = appCheckProvider;
        this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
        if (!this.appCheck) {
          appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then((appCheck) => this.appCheck = appCheck);
        }
      }
      getToken(forceRefresh) {
        if (!this.appCheck) {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              if (this.appCheck) {
                this.getToken(forceRefresh).then(resolve, reject);
              } else {
                resolve(null);
              }
            }, 0);
          });
        }
        return this.appCheck.getToken(forceRefresh);
      }
      addTokenChangeListener(listener) {
        var _a;
        (_a = this.appCheckProvider) === null || _a === void 0 ? void 0 : _a.get().then((appCheck) => appCheck.addTokenListener(listener));
      }
      notifyForInvalidToken() {
        warn$1(`Provided AppCheck credentials for the app named "${this.appName_}" are invalid. This usually indicates your app was not initialized correctly.`);
      }
    };
    var FirebaseAuthTokenProvider = class {
      static {
        __name(this, "FirebaseAuthTokenProvider");
      }
      constructor(appName_, firebaseOptions_, authProvider_) {
        this.appName_ = appName_;
        this.firebaseOptions_ = firebaseOptions_;
        this.authProvider_ = authProvider_;
        this.auth_ = null;
        this.auth_ = authProvider_.getImmediate({ optional: true });
        if (!this.auth_) {
          authProvider_.onInit((auth) => this.auth_ = auth);
        }
      }
      getToken(forceRefresh) {
        if (!this.auth_) {
          return new Promise((resolve, reject) => {
            setTimeout(() => {
              if (this.auth_) {
                this.getToken(forceRefresh).then(resolve, reject);
              } else {
                resolve(null);
              }
            }, 0);
          });
        }
        return this.auth_.getToken(forceRefresh).catch((error4) => {
          if (error4 && error4.code === "auth/token-not-initialized") {
            log4("Got auth/token-not-initialized error.  Treating as null token.");
            return null;
          } else {
            return Promise.reject(error4);
          }
        });
      }
      addTokenChangeListener(listener) {
        if (this.auth_) {
          this.auth_.addAuthTokenListener(listener);
        } else {
          this.authProvider_.get().then((auth) => auth.addAuthTokenListener(listener));
        }
      }
      removeTokenChangeListener(listener) {
        this.authProvider_.get().then((auth) => auth.removeAuthTokenListener(listener));
      }
      notifyForInvalidToken() {
        let errorMessage = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
        if ("credential" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else if ("serviceAccount" in this.firebaseOptions_) {
          errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
        } else {
          errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
        }
        warn$1(errorMessage);
      }
    };
    var EmulatorTokenProvider = class {
      static {
        __name(this, "EmulatorTokenProvider");
      }
      constructor(accessToken) {
        this.accessToken = accessToken;
      }
      getToken(forceRefresh) {
        return Promise.resolve({
          accessToken: this.accessToken
        });
      }
      addTokenChangeListener(listener) {
        listener(this.accessToken);
      }
      removeTokenChangeListener(listener) {
      }
      notifyForInvalidToken() {
      }
    };
    EmulatorTokenProvider.OWNER = "owner";
    var PacketReceiver = class {
      static {
        __name(this, "PacketReceiver");
      }
      /**
       * @param onMessage_
       */
      constructor(onMessage_) {
        this.onMessage_ = onMessage_;
        this.pendingResponses = [];
        this.currentResponseNum = 0;
        this.closeAfterResponse = -1;
        this.onClose = null;
      }
      closeAfter(responseNum, callback) {
        this.closeAfterResponse = responseNum;
        this.onClose = callback;
        if (this.closeAfterResponse < this.currentResponseNum) {
          this.onClose();
          this.onClose = null;
        }
      }
      /**
       * Each message from the server comes with a response number, and an array of data. The responseNumber
       * allows us to ensure that we process them in the right order, since we can't be guaranteed that all
       * browsers will respond in the same order as the requests we sent
       */
      handleResponse(requestNum, data) {
        this.pendingResponses[requestNum] = data;
        while (this.pendingResponses[this.currentResponseNum]) {
          const toProcess = this.pendingResponses[this.currentResponseNum];
          delete this.pendingResponses[this.currentResponseNum];
          for (let i = 0; i < toProcess.length; ++i) {
            if (toProcess[i]) {
              exceptionGuard(() => {
                this.onMessage_(toProcess[i]);
              });
            }
          }
          if (this.currentResponseNum === this.closeAfterResponse) {
            if (this.onClose) {
              this.onClose();
              this.onClose = null;
            }
            break;
          }
          this.currentResponseNum++;
        }
      }
    };
    var FIREBASE_LONGPOLL_START_PARAM = "start";
    var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
    var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
    var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
    var FIREBASE_LONGPOLL_ID_PARAM = "id";
    var FIREBASE_LONGPOLL_PW_PARAM = "pw";
    var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
    var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
    var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
    var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
    var FIREBASE_LONGPOLL_DATA_PARAM = "d";
    var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
    var MAX_URL_DATA_SIZE = 1870;
    var SEG_HEADER_SIZE = 30;
    var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
    var KEEPALIVE_REQUEST_INTERVAL = 25e3;
    var LP_CONNECT_TIMEOUT = 3e4;
    var BrowserPollConnection = class _BrowserPollConnection {
      static {
        __name(this, "BrowserPollConnection");
      }
      /**
       * @param connId An identifier for this connection, used for logging
       * @param repoInfo The info for the endpoint to send data to.
       * @param applicationId The Firebase App ID for this project.
       * @param appCheckToken The AppCheck token for this client.
       * @param authToken The AuthToken to use for this connection.
       * @param transportSessionId Optional transportSessionid if we are
       * reconnecting for an existing transport session
       * @param lastSessionId Optional lastSessionId if the PersistentConnection has
       * already created a connection previously
       */
      constructor(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
        this.connId = connId;
        this.repoInfo = repoInfo;
        this.applicationId = applicationId;
        this.appCheckToken = appCheckToken;
        this.authToken = authToken;
        this.transportSessionId = transportSessionId;
        this.lastSessionId = lastSessionId;
        this.bytesSent = 0;
        this.bytesReceived = 0;
        this.everConnected_ = false;
        this.log_ = logWrapper(connId);
        this.stats_ = statsManagerGetCollection(repoInfo);
        this.urlFn = (params) => {
          if (this.appCheckToken) {
            params[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          }
          return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
        };
      }
      /**
       * @param onMessage - Callback when messages arrive
       * @param onDisconnect - Callback with connection lost.
       */
      open(onMessage, onDisconnect2) {
        this.curSegmentNum = 0;
        this.onDisconnect_ = onDisconnect2;
        this.myPacketOrderer = new PacketReceiver(onMessage);
        this.isClosed_ = false;
        this.connectTimeoutTimer_ = setTimeout(() => {
          this.log_("Timed out trying to connect.");
          this.onClosed_();
          this.connectTimeoutTimer_ = null;
        }, Math.floor(LP_CONNECT_TIMEOUT));
        executeWhenDOMReady(() => {
          if (this.isClosed_) {
            return;
          }
          this.scriptTagHolder = new FirebaseIFrameScriptHolder((...args) => {
            const [command, arg1, arg2, arg3, arg4] = args;
            this.incrementIncomingBytes_(args);
            if (!this.scriptTagHolder) {
              return;
            }
            if (this.connectTimeoutTimer_) {
              clearTimeout(this.connectTimeoutTimer_);
              this.connectTimeoutTimer_ = null;
            }
            this.everConnected_ = true;
            if (command === FIREBASE_LONGPOLL_START_PARAM) {
              this.id = arg1;
              this.password = arg2;
            } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
              if (arg1) {
                this.scriptTagHolder.sendNewPolls = false;
                this.myPacketOrderer.closeAfter(arg1, () => {
                  this.onClosed_();
                });
              } else {
                this.onClosed_();
              }
            } else {
              throw new Error("Unrecognized command received: " + command);
            }
          }, (...args) => {
            const [pN, data] = args;
            this.incrementIncomingBytes_(args);
            this.myPacketOrderer.handleResponse(pN, data);
          }, () => {
            this.onClosed_();
          }, this.urlFn);
          const urlParams = {};
          urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
          if (this.scriptTagHolder.uniqueCallbackIdentifier) {
            urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = this.scriptTagHolder.uniqueCallbackIdentifier;
          }
          urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
          if (this.transportSessionId) {
            urlParams[TRANSPORT_SESSION_PARAM] = this.transportSessionId;
          }
          if (this.lastSessionId) {
            urlParams[LAST_SESSION_PARAM] = this.lastSessionId;
          }
          if (this.applicationId) {
            urlParams[APPLICATION_ID_PARAM] = this.applicationId;
          }
          if (this.appCheckToken) {
            urlParams[APP_CHECK_TOKEN_PARAM] = this.appCheckToken;
          }
          if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
            urlParams[REFERER_PARAM] = FORGE_REF;
          }
          const connectURL = this.urlFn(urlParams);
          this.log_("Connecting via long-poll to " + connectURL);
          this.scriptTagHolder.addTag(connectURL, () => {
          });
        });
      }
      /**
       * Call this when a handshake has completed successfully and we want to consider the connection established
       */
      start() {
        this.scriptTagHolder.startLongPoll(this.id, this.password);
        this.addDisconnectPingFrame(this.id, this.password);
      }
      /**
       * Forces long polling to be considered as a potential transport
       */
      static forceAllow() {
        _BrowserPollConnection.forceAllow_ = true;
      }
      /**
       * Forces longpolling to not be considered as a potential transport
       */
      static forceDisallow() {
        _BrowserPollConnection.forceDisallow_ = true;
      }
      // Static method, use string literal so it can be accessed in a generic way
      static isAvailable() {
        if (util.isNodeSdk()) {
          return false;
        } else if (_BrowserPollConnection.forceAllow_) {
          return true;
        } else {
          return !_BrowserPollConnection.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
        }
      }
      /**
       * No-op for polling
       */
      markConnectionHealthy() {
      }
      /**
       * Stops polling and cleans up the iframe
       */
      shutdown_() {
        this.isClosed_ = true;
        if (this.scriptTagHolder) {
          this.scriptTagHolder.close();
          this.scriptTagHolder = null;
        }
        if (this.myDisconnFrame) {
          document.body.removeChild(this.myDisconnFrame);
          this.myDisconnFrame = null;
        }
        if (this.connectTimeoutTimer_) {
          clearTimeout(this.connectTimeoutTimer_);
          this.connectTimeoutTimer_ = null;
        }
      }
      /**
       * Triggered when this transport is closed
       */
      onClosed_() {
        if (!this.isClosed_) {
          this.log_("Longpoll is closing itself");
          this.shutdown_();
          if (this.onDisconnect_) {
            this.onDisconnect_(this.everConnected_);
            this.onDisconnect_ = null;
          }
        }
      }
      /**
       * External-facing close handler. RealTime has requested we shut down. Kill our connection and tell the server
       * that we've left.
       */
      close() {
        if (!this.isClosed_) {
          this.log_("Longpoll is being closed.");
          this.shutdown_();
        }
      }
      /**
       * Send the JSON object down to the server. It will need to be stringified, base64 encoded, and then
       * broken into chunks (since URLs have a small maximum length).
       * @param data - The JSON data to transmit.
       */
      send(data) {
        const dataStr = util.stringify(data);
        this.bytesSent += dataStr.length;
        this.stats_.incrementCounter("bytes_sent", dataStr.length);
        const base64data = util.base64Encode(dataStr);
        const dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
        for (let i = 0; i < dataSegs.length; i++) {
          this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
          this.curSegmentNum++;
        }
      }
      /**
       * This is how we notify the server that we're leaving.
       * We aren't able to send requests with DHTML on a window close event, but we can
       * trigger XHR requests in some browsers (everything but Opera basically).
       */
      addDisconnectPingFrame(id, pw) {
        if (util.isNodeSdk()) {
          return;
        }
        this.myDisconnFrame = document.createElement("iframe");
        const urlParams = {};
        urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
        this.myDisconnFrame.src = this.urlFn(urlParams);
        this.myDisconnFrame.style.display = "none";
        document.body.appendChild(this.myDisconnFrame);
      }
      /**
       * Used to track the bytes received by this client
       */
      incrementIncomingBytes_(args) {
        const bytesReceived = util.stringify(args).length;
        this.bytesReceived += bytesReceived;
        this.stats_.incrementCounter("bytes_received", bytesReceived);
      }
    };
    var FirebaseIFrameScriptHolder = class _FirebaseIFrameScriptHolder {
      static {
        __name(this, "FirebaseIFrameScriptHolder");
      }
      /**
       * @param commandCB - The callback to be called when control commands are received from the server.
       * @param onMessageCB - The callback to be triggered when responses arrive from the server.
       * @param onDisconnect - The callback to be triggered when this tag holder is closed
       * @param urlFn - A function that provides the URL of the endpoint to send data to.
       */
      constructor(commandCB, onMessageCB, onDisconnect2, urlFn) {
        this.onDisconnect = onDisconnect2;
        this.urlFn = urlFn;
        this.outstandingRequests = /* @__PURE__ */ new Set();
        this.pendingSegs = [];
        this.currentSerial = Math.floor(Math.random() * 1e8);
        this.sendNewPolls = true;
        if (!util.isNodeSdk()) {
          this.uniqueCallbackIdentifier = LUIDGenerator();
          window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
          window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
          this.myIFrame = _FirebaseIFrameScriptHolder.createIFrame_();
          let script = "";
          if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
            const currentDomain = document.domain;
            script = '<script>document.domain="' + currentDomain + '";<\/script>';
          }
          const iframeContents = "<html><body>" + script + "</body></html>";
          try {
            this.myIFrame.doc.open();
            this.myIFrame.doc.write(iframeContents);
            this.myIFrame.doc.close();
          } catch (e) {
            log4("frame writing exception");
            if (e.stack) {
              log4(e.stack);
            }
            log4(e);
          }
        } else {
          this.commandCB = commandCB;
          this.onMessageCB = onMessageCB;
        }
      }
      /**
       * Each browser has its own funny way to handle iframes. Here we mush them all together into one object that I can
       * actually use.
       */
      static createIFrame_() {
        const iframe = document.createElement("iframe");
        iframe.style.display = "none";
        if (document.body) {
          document.body.appendChild(iframe);
          try {
            const a2 = iframe.contentWindow.document;
            if (!a2) {
              log4("No IE domain setting required");
            }
          } catch (e) {
            const domain2 = document.domain;
            iframe.src = "javascript:void((function(){document.open();document.domain='" + domain2 + "';document.close();})())";
          }
        } else {
          throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        }
        if (iframe.contentDocument) {
          iframe.doc = iframe.contentDocument;
        } else if (iframe.contentWindow) {
          iframe.doc = iframe.contentWindow.document;
        } else if (iframe.document) {
          iframe.doc = iframe.document;
        }
        return iframe;
      }
      /**
       * Cancel all outstanding queries and remove the frame.
       */
      close() {
        this.alive = false;
        if (this.myIFrame) {
          this.myIFrame.doc.body.textContent = "";
          setTimeout(() => {
            if (this.myIFrame !== null) {
              document.body.removeChild(this.myIFrame);
              this.myIFrame = null;
            }
          }, Math.floor(0));
        }
        const onDisconnect2 = this.onDisconnect;
        if (onDisconnect2) {
          this.onDisconnect = null;
          onDisconnect2();
        }
      }
      /**
       * Actually start the long-polling session by adding the first script tag(s) to the iframe.
       * @param id - The ID of this connection
       * @param pw - The password for this connection
       */
      startLongPoll(id, pw) {
        this.myID = id;
        this.myPW = pw;
        this.alive = true;
        while (this.newRequest_()) {
        }
      }
      /**
       * This is called any time someone might want a script tag to be added. It adds a script tag when there aren't
       * too many outstanding requests and we are still alive.
       *
       * If there are outstanding packet segments to send, it sends one. If there aren't, it sends a long-poll anyways if
       * needed.
       */
      newRequest_() {
        if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
          this.currentSerial++;
          const urlParams = {};
          urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
          urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
          urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
          let theURL = this.urlFn(urlParams);
          let curDataString = "";
          let i = 0;
          while (this.pendingSegs.length > 0) {
            const nextSeg = this.pendingSegs[0];
            if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
              const theSeg = this.pendingSegs.shift();
              curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
              i++;
            } else {
              break;
            }
          }
          theURL = theURL + curDataString;
          this.addLongPollTag_(theURL, this.currentSerial);
          return true;
        } else {
          return false;
        }
      }
      /**
       * Queue a packet for transmission to the server.
       * @param segnum - A sequential id for this packet segment used for reassembly
       * @param totalsegs - The total number of segments in this packet
       * @param data - The data for this segment.
       */
      enqueueSegment(segnum, totalsegs, data) {
        this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
        if (this.alive) {
          this.newRequest_();
        }
      }
      /**
       * Add a script tag for a regular long-poll request.
       * @param url - The URL of the script tag.
       * @param serial - The serial number of the request.
       */
      addLongPollTag_(url2, serial) {
        this.outstandingRequests.add(serial);
        const doNewRequest = /* @__PURE__ */ __name(() => {
          this.outstandingRequests.delete(serial);
          this.newRequest_();
        }, "doNewRequest");
        const keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
        const readyStateCB = /* @__PURE__ */ __name(() => {
          clearTimeout(keepaliveTimeout);
          doNewRequest();
        }, "readyStateCB");
        this.addTag(url2, readyStateCB);
      }
      /**
       * Add an arbitrary script tag to the iframe.
       * @param url - The URL for the script tag source.
       * @param loadCB - A callback to be triggered once the script has loaded.
       */
      addTag(url2, loadCB) {
        if (util.isNodeSdk()) {
          this.doNodeLongPoll(url2, loadCB);
        } else {
          setTimeout(() => {
            try {
              if (!this.sendNewPolls) {
                return;
              }
              const newScript = this.myIFrame.doc.createElement("script");
              newScript.type = "text/javascript";
              newScript.async = true;
              newScript.src = url2;
              newScript.onload = newScript.onreadystatechange = function() {
                const rstate = newScript.readyState;
                if (!rstate || rstate === "loaded" || rstate === "complete") {
                  newScript.onload = newScript.onreadystatechange = null;
                  if (newScript.parentNode) {
                    newScript.parentNode.removeChild(newScript);
                  }
                  loadCB();
                }
              };
              newScript.onerror = () => {
                log4("Long-poll script failed to load: " + url2);
                this.sendNewPolls = false;
                this.close();
              };
              this.myIFrame.doc.body.appendChild(newScript);
            } catch (e) {
            }
          }, Math.floor(1));
        }
      }
    };
    var TransportManager = class _TransportManager {
      static {
        __name(this, "TransportManager");
      }
      static get ALL_TRANSPORTS() {
        return [BrowserPollConnection, WebSocketConnection];
      }
      /**
       * Returns whether transport has been selected to ensure WebSocketConnection or BrowserPollConnection are not called after
       * TransportManager has already set up transports_
       */
      static get IS_TRANSPORT_INITIALIZED() {
        return this.globalTransportInitialized_;
      }
      /**
       * @param repoInfo - Metadata around the namespace we're connecting to
       */
      constructor(repoInfo) {
        this.initTransports_(repoInfo);
      }
      initTransports_(repoInfo) {
        const isWebSocketsAvailable = WebSocketConnection && WebSocketConnection["isAvailable"]();
        let isSkipPollConnection = isWebSocketsAvailable && !WebSocketConnection.previouslyFailed();
        if (repoInfo.webSocketOnly) {
          if (!isWebSocketsAvailable) {
            warn$1("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
          }
          isSkipPollConnection = true;
        }
        if (isSkipPollConnection) {
          this.transports_ = [WebSocketConnection];
        } else {
          const transports = this.transports_ = [];
          for (const transport of _TransportManager.ALL_TRANSPORTS) {
            if (transport && transport["isAvailable"]()) {
              transports.push(transport);
            }
          }
          _TransportManager.globalTransportInitialized_ = true;
        }
      }
      /**
       * @returns The constructor for the initial transport to use
       */
      initialTransport() {
        if (this.transports_.length > 0) {
          return this.transports_[0];
        } else {
          throw new Error("No transports available");
        }
      }
      /**
       * @returns The constructor for the next transport, or null
       */
      upgradeTransport() {
        if (this.transports_.length > 1) {
          return this.transports_[1];
        } else {
          return null;
        }
      }
    };
    TransportManager.globalTransportInitialized_ = false;
    var UPGRADE_TIMEOUT = 6e4;
    var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
    var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
    var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
    var MESSAGE_TYPE = "t";
    var MESSAGE_DATA = "d";
    var CONTROL_SHUTDOWN = "s";
    var CONTROL_RESET = "r";
    var CONTROL_ERROR = "e";
    var CONTROL_PONG = "o";
    var SWITCH_ACK = "a";
    var END_TRANSMISSION = "n";
    var PING = "p";
    var SERVER_HELLO = "h";
    var Connection = class {
      static {
        __name(this, "Connection");
      }
      /**
       * @param id - an id for this connection
       * @param repoInfo_ - the info for the endpoint to connect to
       * @param applicationId_ - the Firebase App ID for this project
       * @param appCheckToken_ - The App Check Token for this device.
       * @param authToken_ - The auth token for this session.
       * @param onMessage_ - the callback to be triggered when a server-push message arrives
       * @param onReady_ - the callback to be triggered when this connection is ready to send messages.
       * @param onDisconnect_ - the callback to be triggered when a connection was lost
       * @param onKill_ - the callback to be triggered when this connection has permanently shut down.
       * @param lastSessionId - last session id in persistent connection. is used to clean up old session in real-time server
       */
      constructor(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
        this.id = id;
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.appCheckToken_ = appCheckToken_;
        this.authToken_ = authToken_;
        this.onMessage_ = onMessage_;
        this.onReady_ = onReady_;
        this.onDisconnect_ = onDisconnect_;
        this.onKill_ = onKill_;
        this.lastSessionId = lastSessionId;
        this.connectionCount = 0;
        this.pendingDataMessages = [];
        this.state_ = 0;
        this.log_ = logWrapper("c:" + this.id + ":");
        this.transportManager_ = new TransportManager(repoInfo_);
        this.log_("Connection created");
        this.start_();
      }
      /**
       * Starts a connection attempt
       */
      start_() {
        const conn = this.transportManager_.initialTransport();
        this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
        this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        const onMessageReceived = this.connReceiver_(this.conn_);
        const onConnectionLost = this.disconnReceiver_(this.conn_);
        this.tx_ = this.conn_;
        this.rx_ = this.conn_;
        this.secondaryConn_ = null;
        this.isHealthy_ = false;
        setTimeout(() => {
          this.conn_ && this.conn_.open(onMessageReceived, onConnectionLost);
        }, Math.floor(0));
        const healthyTimeoutMS = conn["healthyTimeout"] || 0;
        if (healthyTimeoutMS > 0) {
          this.healthyTimeout_ = setTimeoutNonBlocking(() => {
            this.healthyTimeout_ = null;
            if (!this.isHealthy_) {
              if (this.conn_ && this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
                this.log_("Connection exceeded healthy timeout but has received " + this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
                this.isHealthy_ = true;
                this.conn_.markConnectionHealthy();
              } else if (this.conn_ && this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
                this.log_("Connection exceeded healthy timeout but has sent " + this.conn_.bytesSent + " bytes.  Leaving connection alive.");
              } else {
                this.log_("Closing unhealthy connection after timeout.");
                this.close();
              }
            }
          }, Math.floor(healthyTimeoutMS));
        }
      }
      nextTransportId_() {
        return "c:" + this.id + ":" + this.connectionCount++;
      }
      disconnReceiver_(conn) {
        return (everConnected) => {
          if (conn === this.conn_) {
            this.onConnectionLost_(everConnected);
          } else if (conn === this.secondaryConn_) {
            this.log_("Secondary connection lost.");
            this.onSecondaryConnectionLost_();
          } else {
            this.log_("closing an old connection");
          }
        };
      }
      connReceiver_(conn) {
        return (message3) => {
          if (this.state_ !== 2) {
            if (conn === this.rx_) {
              this.onPrimaryMessageReceived_(message3);
            } else if (conn === this.secondaryConn_) {
              this.onSecondaryMessageReceived_(message3);
            } else {
              this.log_("message on old connection");
            }
          }
        };
      }
      /**
       * @param dataMsg - An arbitrary data message to be sent to the server
       */
      sendRequest(dataMsg) {
        const msg = { t: "d", d: dataMsg };
        this.sendData_(msg);
      }
      tryCleanupConnection() {
        if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
          this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
          this.conn_ = this.secondaryConn_;
          this.secondaryConn_ = null;
        }
      }
      onSecondaryControl_(controlData) {
        if (MESSAGE_TYPE in controlData) {
          const cmd = controlData[MESSAGE_TYPE];
          if (cmd === SWITCH_ACK) {
            this.upgradeIfSecondaryHealthy_();
          } else if (cmd === CONTROL_RESET) {
            this.log_("Got a reset on secondary, closing it");
            this.secondaryConn_.close();
            if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
              this.close();
            }
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on secondary.");
            this.secondaryResponsesRequired_--;
            this.upgradeIfSecondaryHealthy_();
          }
        }
      }
      onSecondaryMessageReceived_(parsedData) {
        const layer = requireKey("t", parsedData);
        const data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onSecondaryControl_(data);
        } else if (layer === "d") {
          this.pendingDataMessages.push(data);
        } else {
          throw new Error("Unknown protocol layer: " + layer);
        }
      }
      upgradeIfSecondaryHealthy_() {
        if (this.secondaryResponsesRequired_ <= 0) {
          this.log_("Secondary connection is healthy.");
          this.isHealthy_ = true;
          this.secondaryConn_.markConnectionHealthy();
          this.proceedWithUpgrade_();
        } else {
          this.log_("sending ping on secondary.");
          this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
        }
      }
      proceedWithUpgrade_() {
        this.secondaryConn_.start();
        this.log_("sending client ack on secondary");
        this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
        this.log_("Ending transmission on primary");
        this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
        this.tx_ = this.secondaryConn_;
        this.tryCleanupConnection();
      }
      onPrimaryMessageReceived_(parsedData) {
        const layer = requireKey("t", parsedData);
        const data = requireKey("d", parsedData);
        if (layer === "c") {
          this.onControl_(data);
        } else if (layer === "d") {
          this.onDataMessage_(data);
        }
      }
      onDataMessage_(message3) {
        this.onPrimaryResponse_();
        this.onMessage_(message3);
      }
      onPrimaryResponse_() {
        if (!this.isHealthy_) {
          this.primaryResponsesRequired_--;
          if (this.primaryResponsesRequired_ <= 0) {
            this.log_("Primary connection is healthy.");
            this.isHealthy_ = true;
            this.conn_.markConnectionHealthy();
          }
        }
      }
      onControl_(controlData) {
        const cmd = requireKey(MESSAGE_TYPE, controlData);
        if (MESSAGE_DATA in controlData) {
          const payload = controlData[MESSAGE_DATA];
          if (cmd === SERVER_HELLO) {
            const handshakePayload = Object.assign({}, payload);
            if (this.repoInfo_.isUsingEmulator) {
              handshakePayload.h = this.repoInfo_.host;
            }
            this.onHandshake_(handshakePayload);
          } else if (cmd === END_TRANSMISSION) {
            this.log_("recvd end transmission on primary");
            this.rx_ = this.secondaryConn_;
            for (let i = 0; i < this.pendingDataMessages.length; ++i) {
              this.onDataMessage_(this.pendingDataMessages[i]);
            }
            this.pendingDataMessages = [];
            this.tryCleanupConnection();
          } else if (cmd === CONTROL_SHUTDOWN) {
            this.onConnectionShutdown_(payload);
          } else if (cmd === CONTROL_RESET) {
            this.onReset_(payload);
          } else if (cmd === CONTROL_ERROR) {
            error3("Server Error: " + payload);
          } else if (cmd === CONTROL_PONG) {
            this.log_("got pong on primary.");
            this.onPrimaryResponse_();
            this.sendPingOnPrimaryIfNecessary_();
          } else {
            error3("Unknown control packet command: " + cmd);
          }
        }
      }
      /**
       * @param handshake - The handshake data returned from the server
       */
      onHandshake_(handshake) {
        const timestamp = handshake.ts;
        const version3 = handshake.v;
        const host = handshake.h;
        this.sessionId = handshake.s;
        this.repoInfo_.host = host;
        if (this.state_ === 0) {
          this.conn_.start();
          this.onConnectionEstablished_(this.conn_, timestamp);
          if (PROTOCOL_VERSION !== version3) {
            warn$1("Protocol version mismatch detected");
          }
          this.tryStartUpgrade_();
        }
      }
      tryStartUpgrade_() {
        const conn = this.transportManager_.upgradeTransport();
        if (conn) {
          this.startUpgrade_(conn);
        }
      }
      startUpgrade_(conn) {
        this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
        this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
        const onMessage = this.connReceiver_(this.secondaryConn_);
        const onDisconnect2 = this.disconnReceiver_(this.secondaryConn_);
        this.secondaryConn_.open(onMessage, onDisconnect2);
        setTimeoutNonBlocking(() => {
          if (this.secondaryConn_) {
            this.log_("Timed out trying to upgrade.");
            this.secondaryConn_.close();
          }
        }, Math.floor(UPGRADE_TIMEOUT));
      }
      onReset_(host) {
        this.log_("Reset packet received.  New host: " + host);
        this.repoInfo_.host = host;
        if (this.state_ === 1) {
          this.close();
        } else {
          this.closeConnections_();
          this.start_();
        }
      }
      onConnectionEstablished_(conn, timestamp) {
        this.log_("Realtime connection established.");
        this.conn_ = conn;
        this.state_ = 1;
        if (this.onReady_) {
          this.onReady_(timestamp, this.sessionId);
          this.onReady_ = null;
        }
        if (this.primaryResponsesRequired_ === 0) {
          this.log_("Primary connection is healthy.");
          this.isHealthy_ = true;
        } else {
          setTimeoutNonBlocking(() => {
            this.sendPingOnPrimaryIfNecessary_();
          }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
        }
      }
      sendPingOnPrimaryIfNecessary_() {
        if (!this.isHealthy_ && this.state_ === 1) {
          this.log_("sending ping on primary.");
          this.sendData_({ t: "c", d: { t: PING, d: {} } });
        }
      }
      onSecondaryConnectionLost_() {
        const conn = this.secondaryConn_;
        this.secondaryConn_ = null;
        if (this.tx_ === conn || this.rx_ === conn) {
          this.close();
        }
      }
      /**
       * @param everConnected - Whether or not the connection ever reached a server. Used to determine if
       * we should flush the host cache
       */
      onConnectionLost_(everConnected) {
        this.conn_ = null;
        if (!everConnected && this.state_ === 0) {
          this.log_("Realtime connection failed.");
          if (this.repoInfo_.isCacheableHost()) {
            PersistentStorage.remove("host:" + this.repoInfo_.host);
            this.repoInfo_.internalHost = this.repoInfo_.host;
          }
        } else if (this.state_ === 1) {
          this.log_("Realtime connection lost.");
        }
        this.close();
      }
      onConnectionShutdown_(reason) {
        this.log_("Connection shutdown command received. Shutting down...");
        if (this.onKill_) {
          this.onKill_(reason);
          this.onKill_ = null;
        }
        this.onDisconnect_ = null;
        this.close();
      }
      sendData_(data) {
        if (this.state_ !== 1) {
          throw "Connection is not connected";
        } else {
          this.tx_.send(data);
        }
      }
      /**
       * Cleans up this connection, calling the appropriate callbacks
       */
      close() {
        if (this.state_ !== 2) {
          this.log_("Closing realtime connection.");
          this.state_ = 2;
          this.closeConnections_();
          if (this.onDisconnect_) {
            this.onDisconnect_();
            this.onDisconnect_ = null;
          }
        }
      }
      closeConnections_() {
        this.log_("Shutting down all connections");
        if (this.conn_) {
          this.conn_.close();
          this.conn_ = null;
        }
        if (this.secondaryConn_) {
          this.secondaryConn_.close();
          this.secondaryConn_ = null;
        }
        if (this.healthyTimeout_) {
          clearTimeout(this.healthyTimeout_);
          this.healthyTimeout_ = null;
        }
      }
    };
    var ServerActions = class {
      static {
        __name(this, "ServerActions");
      }
      put(pathString, data, onComplete, hash2) {
      }
      merge(pathString, data, onComplete, hash2) {
      }
      /**
       * Refreshes the auth token for the current connection.
       * @param token - The authentication token
       */
      refreshAuthToken(token) {
      }
      /**
       * Refreshes the app check token for the current connection.
       * @param token The app check token
       */
      refreshAppCheckToken(token) {
      }
      onDisconnectPut(pathString, data, onComplete) {
      }
      onDisconnectMerge(pathString, data, onComplete) {
      }
      onDisconnectCancel(pathString, onComplete) {
      }
      reportStats(stats) {
      }
    };
    var EventEmitter3 = class {
      static {
        __name(this, "EventEmitter");
      }
      constructor(allowedEvents_) {
        this.allowedEvents_ = allowedEvents_;
        this.listeners_ = {};
        util.assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
      }
      /**
       * To be called by derived classes to trigger events.
       */
      trigger(eventType, ...varArgs) {
        if (Array.isArray(this.listeners_[eventType])) {
          const listeners2 = [...this.listeners_[eventType]];
          for (let i = 0; i < listeners2.length; i++) {
            listeners2[i].callback.apply(listeners2[i].context, varArgs);
          }
        }
      }
      on(eventType, callback, context2) {
        this.validateEventType_(eventType);
        this.listeners_[eventType] = this.listeners_[eventType] || [];
        this.listeners_[eventType].push({ callback, context: context2 });
        const eventData = this.getInitialEvent(eventType);
        if (eventData) {
          callback.apply(context2, eventData);
        }
      }
      off(eventType, callback, context2) {
        this.validateEventType_(eventType);
        const listeners2 = this.listeners_[eventType] || [];
        for (let i = 0; i < listeners2.length; i++) {
          if (listeners2[i].callback === callback && (!context2 || context2 === listeners2[i].context)) {
            listeners2.splice(i, 1);
            return;
          }
        }
      }
      validateEventType_(eventType) {
        util.assert(this.allowedEvents_.find((et2) => {
          return et2 === eventType;
        }), "Unknown event: " + eventType);
      }
    };
    var OnlineMonitor = class _OnlineMonitor extends EventEmitter3 {
      static {
        __name(this, "OnlineMonitor");
      }
      static getInstance() {
        return new _OnlineMonitor();
      }
      constructor() {
        super(["online"]);
        this.online_ = true;
        if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !util.isMobileCordova()) {
          window.addEventListener("online", () => {
            if (!this.online_) {
              this.online_ = true;
              this.trigger("online", true);
            }
          }, false);
          window.addEventListener("offline", () => {
            if (this.online_) {
              this.online_ = false;
              this.trigger("online", false);
            }
          }, false);
        }
      }
      getInitialEvent(eventType) {
        util.assert(eventType === "online", "Unknown event type: " + eventType);
        return [this.online_];
      }
      currentlyOnline() {
        return this.online_;
      }
    };
    var MAX_PATH_DEPTH = 32;
    var MAX_PATH_LENGTH_BYTES = 768;
    var Path = class {
      static {
        __name(this, "Path");
      }
      /**
       * @param pathOrString - Path string to parse, or another path, or the raw
       * tokens array
       */
      constructor(pathOrString, pieceNum) {
        if (pieceNum === void 0) {
          this.pieces_ = pathOrString.split("/");
          let copyTo = 0;
          for (let i = 0; i < this.pieces_.length; i++) {
            if (this.pieces_[i].length > 0) {
              this.pieces_[copyTo] = this.pieces_[i];
              copyTo++;
            }
          }
          this.pieces_.length = copyTo;
          this.pieceNum_ = 0;
        } else {
          this.pieces_ = pathOrString;
          this.pieceNum_ = pieceNum;
        }
      }
      toString() {
        let pathString = "";
        for (let i = this.pieceNum_; i < this.pieces_.length; i++) {
          if (this.pieces_[i] !== "") {
            pathString += "/" + this.pieces_[i];
          }
        }
        return pathString || "/";
      }
    };
    function newEmptyPath() {
      return new Path("");
    }
    __name(newEmptyPath, "newEmptyPath");
    function pathGetFront(path) {
      if (path.pieceNum_ >= path.pieces_.length) {
        return null;
      }
      return path.pieces_[path.pieceNum_];
    }
    __name(pathGetFront, "pathGetFront");
    function pathGetLength(path) {
      return path.pieces_.length - path.pieceNum_;
    }
    __name(pathGetLength, "pathGetLength");
    function pathPopFront(path) {
      let pieceNum = path.pieceNum_;
      if (pieceNum < path.pieces_.length) {
        pieceNum++;
      }
      return new Path(path.pieces_, pieceNum);
    }
    __name(pathPopFront, "pathPopFront");
    function pathGetBack(path) {
      if (path.pieceNum_ < path.pieces_.length) {
        return path.pieces_[path.pieces_.length - 1];
      }
      return null;
    }
    __name(pathGetBack, "pathGetBack");
    function pathToUrlEncodedString(path) {
      let pathString = "";
      for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        if (path.pieces_[i] !== "") {
          pathString += "/" + encodeURIComponent(String(path.pieces_[i]));
        }
      }
      return pathString || "/";
    }
    __name(pathToUrlEncodedString, "pathToUrlEncodedString");
    function pathSlice(path, begin = 0) {
      return path.pieces_.slice(path.pieceNum_ + begin);
    }
    __name(pathSlice, "pathSlice");
    function pathParent(path) {
      if (path.pieceNum_ >= path.pieces_.length) {
        return null;
      }
      const pieces = [];
      for (let i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
        pieces.push(path.pieces_[i]);
      }
      return new Path(pieces, 0);
    }
    __name(pathParent, "pathParent");
    function pathChild(path, childPathObj) {
      const pieces = [];
      for (let i = path.pieceNum_; i < path.pieces_.length; i++) {
        pieces.push(path.pieces_[i]);
      }
      if (childPathObj instanceof Path) {
        for (let i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
          pieces.push(childPathObj.pieces_[i]);
        }
      } else {
        const childPieces = childPathObj.split("/");
        for (let i = 0; i < childPieces.length; i++) {
          if (childPieces[i].length > 0) {
            pieces.push(childPieces[i]);
          }
        }
      }
      return new Path(pieces, 0);
    }
    __name(pathChild, "pathChild");
    function pathIsEmpty(path) {
      return path.pieceNum_ >= path.pieces_.length;
    }
    __name(pathIsEmpty, "pathIsEmpty");
    function newRelativePath(outerPath, innerPath) {
      const outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
      if (outer === null) {
        return innerPath;
      } else if (outer === inner) {
        return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
      } else {
        throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
      }
    }
    __name(newRelativePath, "newRelativePath");
    function pathCompare(left, right) {
      const leftKeys = pathSlice(left, 0);
      const rightKeys = pathSlice(right, 0);
      for (let i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
        const cmp = nameCompare(leftKeys[i], rightKeys[i]);
        if (cmp !== 0) {
          return cmp;
        }
      }
      if (leftKeys.length === rightKeys.length) {
        return 0;
      }
      return leftKeys.length < rightKeys.length ? -1 : 1;
    }
    __name(pathCompare, "pathCompare");
    function pathEquals(path, other) {
      if (pathGetLength(path) !== pathGetLength(other)) {
        return false;
      }
      for (let i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {
        if (path.pieces_[i] !== other.pieces_[j]) {
          return false;
        }
      }
      return true;
    }
    __name(pathEquals, "pathEquals");
    function pathContains(path, other) {
      let i = path.pieceNum_;
      let j = other.pieceNum_;
      if (pathGetLength(path) > pathGetLength(other)) {
        return false;
      }
      while (i < path.pieces_.length) {
        if (path.pieces_[i] !== other.pieces_[j]) {
          return false;
        }
        ++i;
        ++j;
      }
      return true;
    }
    __name(pathContains, "pathContains");
    var ValidationPath = class {
      static {
        __name(this, "ValidationPath");
      }
      /**
       * @param path - Initial Path.
       * @param errorPrefix_ - Prefix for any error messages.
       */
      constructor(path, errorPrefix_) {
        this.errorPrefix_ = errorPrefix_;
        this.parts_ = pathSlice(path, 0);
        this.byteLength_ = Math.max(1, this.parts_.length);
        for (let i = 0; i < this.parts_.length; i++) {
          this.byteLength_ += util.stringLength(this.parts_[i]);
        }
        validationPathCheckValid(this);
      }
    };
    function validationPathPush(validationPath, child2) {
      if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ += 1;
      }
      validationPath.parts_.push(child2);
      validationPath.byteLength_ += util.stringLength(child2);
      validationPathCheckValid(validationPath);
    }
    __name(validationPathPush, "validationPathPush");
    function validationPathPop(validationPath) {
      const last = validationPath.parts_.pop();
      validationPath.byteLength_ -= util.stringLength(last);
      if (validationPath.parts_.length > 0) {
        validationPath.byteLength_ -= 1;
      }
    }
    __name(validationPathPop, "validationPathPop");
    function validationPathCheckValid(validationPath) {
      if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
        throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
      }
      if (validationPath.parts_.length > MAX_PATH_DEPTH) {
        throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
      }
    }
    __name(validationPathCheckValid, "validationPathCheckValid");
    function validationPathToErrorString(validationPath) {
      if (validationPath.parts_.length === 0) {
        return "";
      }
      return "in property '" + validationPath.parts_.join(".") + "'";
    }
    __name(validationPathToErrorString, "validationPathToErrorString");
    var VisibilityMonitor = class _VisibilityMonitor extends EventEmitter3 {
      static {
        __name(this, "VisibilityMonitor");
      }
      static getInstance() {
        return new _VisibilityMonitor();
      }
      constructor() {
        super(["visible"]);
        let hidden;
        let visibilityChange;
        if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
          if (typeof document["hidden"] !== "undefined") {
            visibilityChange = "visibilitychange";
            hidden = "hidden";
          } else if (typeof document["mozHidden"] !== "undefined") {
            visibilityChange = "mozvisibilitychange";
            hidden = "mozHidden";
          } else if (typeof document["msHidden"] !== "undefined") {
            visibilityChange = "msvisibilitychange";
            hidden = "msHidden";
          } else if (typeof document["webkitHidden"] !== "undefined") {
            visibilityChange = "webkitvisibilitychange";
            hidden = "webkitHidden";
          }
        }
        this.visible_ = true;
        if (visibilityChange) {
          document.addEventListener(visibilityChange, () => {
            const visible = !document[hidden];
            if (visible !== this.visible_) {
              this.visible_ = visible;
              this.trigger("visible", visible);
            }
          }, false);
        }
      }
      getInitialEvent(eventType) {
        util.assert(eventType === "visible", "Unknown event type: " + eventType);
        return [this.visible_];
      }
    };
    var RECONNECT_MIN_DELAY = 1e3;
    var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1e3;
    var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1e3;
    var RECONNECT_DELAY_MULTIPLIER = 1.3;
    var RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
    var SERVER_KILL_INTERRUPT_REASON = "server_kill";
    var INVALID_TOKEN_THRESHOLD = 3;
    var PersistentConnection = class _PersistentConnection extends ServerActions {
      static {
        __name(this, "PersistentConnection");
      }
      /**
       * @param repoInfo_ - Data about the namespace we are connecting to
       * @param applicationId_ - The Firebase App ID for this project
       * @param onDataUpdate_ - A callback for new data from the server
       */
      constructor(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.applicationId_ = applicationId_;
        this.onDataUpdate_ = onDataUpdate_;
        this.onConnectStatus_ = onConnectStatus_;
        this.onServerInfoUpdate_ = onServerInfoUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.authOverride_ = authOverride_;
        this.id = _PersistentConnection.nextPersistentConnectionId_++;
        this.log_ = logWrapper("p:" + this.id + ":");
        this.interruptReasons_ = {};
        this.listens = /* @__PURE__ */ new Map();
        this.outstandingPuts_ = [];
        this.outstandingGets_ = [];
        this.outstandingPutCount_ = 0;
        this.outstandingGetCount_ = 0;
        this.onDisconnectRequestQueue_ = [];
        this.connected_ = false;
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
        this.securityDebugCallback_ = null;
        this.lastSessionId = null;
        this.establishConnectionTimer_ = null;
        this.visible_ = false;
        this.requestCBHash_ = {};
        this.requestNumber_ = 0;
        this.realtime_ = null;
        this.authToken_ = null;
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = false;
        this.invalidAuthTokenCount_ = 0;
        this.invalidAppCheckTokenCount_ = 0;
        this.firstConnection_ = true;
        this.lastConnectionAttemptTime_ = null;
        this.lastConnectionEstablishedTime_ = null;
        if (authOverride_ && !util.isNodeSdk()) {
          throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
        }
        VisibilityMonitor.getInstance().on("visible", this.onVisible_, this);
        if (repoInfo_.host.indexOf("fblocal") === -1) {
          OnlineMonitor.getInstance().on("online", this.onOnline_, this);
        }
      }
      sendRequest(action, body, onResponse) {
        const curReqNum = ++this.requestNumber_;
        const msg = { r: curReqNum, a: action, b: body };
        this.log_(util.stringify(msg));
        util.assert(this.connected_, "sendRequest call when we're not connected not allowed.");
        this.realtime_.sendRequest(msg);
        if (onResponse) {
          this.requestCBHash_[curReqNum] = onResponse;
        }
      }
      get(query2) {
        this.initConnection_();
        const deferred = new util.Deferred();
        const request3 = {
          p: query2._path.toString(),
          q: query2._queryObject
        };
        const outstandingGet = {
          action: "g",
          request: request3,
          onComplete: /* @__PURE__ */ __name((message3) => {
            const payload = message3["d"];
            if (message3["s"] === "ok") {
              deferred.resolve(payload);
            } else {
              deferred.reject(payload);
            }
          }, "onComplete")
        };
        this.outstandingGets_.push(outstandingGet);
        this.outstandingGetCount_++;
        const index = this.outstandingGets_.length - 1;
        if (this.connected_) {
          this.sendGet_(index);
        }
        return deferred.promise;
      }
      listen(query2, currentHashFn, tag, onComplete) {
        this.initConnection_();
        const queryId = query2._queryIdentifier;
        const pathString = query2._path.toString();
        this.log_("Listen called for " + pathString + " " + queryId);
        if (!this.listens.has(pathString)) {
          this.listens.set(pathString, /* @__PURE__ */ new Map());
        }
        util.assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "listen() called for non-default but complete query");
        util.assert(!this.listens.get(pathString).has(queryId), `listen() called twice for same path/queryId.`);
        const listenSpec = {
          onComplete,
          hashFn: currentHashFn,
          query: query2,
          tag
        };
        this.listens.get(pathString).set(queryId, listenSpec);
        if (this.connected_) {
          this.sendListen_(listenSpec);
        }
      }
      sendGet_(index) {
        const get4 = this.outstandingGets_[index];
        this.sendRequest("g", get4.request, (message3) => {
          delete this.outstandingGets_[index];
          this.outstandingGetCount_--;
          if (this.outstandingGetCount_ === 0) {
            this.outstandingGets_ = [];
          }
          if (get4.onComplete) {
            get4.onComplete(message3);
          }
        });
      }
      sendListen_(listenSpec) {
        const query2 = listenSpec.query;
        const pathString = query2._path.toString();
        const queryId = query2._queryIdentifier;
        this.log_("Listen on " + pathString + " for " + queryId);
        const req = {
          /*path*/
          p: pathString
        };
        const action = "q";
        if (listenSpec.tag) {
          req["q"] = query2._queryObject;
          req["t"] = listenSpec.tag;
        }
        req[
          /*hash*/
          "h"
        ] = listenSpec.hashFn();
        this.sendRequest(action, req, (message3) => {
          const payload = message3[
            /*data*/
            "d"
          ];
          const status = message3[
            /*status*/
            "s"
          ];
          _PersistentConnection.warnOnListenWarnings_(payload, query2);
          const currentListenSpec = this.listens.get(pathString) && this.listens.get(pathString).get(queryId);
          if (currentListenSpec === listenSpec) {
            this.log_("listen response", message3);
            if (status !== "ok") {
              this.removeListen_(pathString, queryId);
            }
            if (listenSpec.onComplete) {
              listenSpec.onComplete(status, payload);
            }
          }
        });
      }
      static warnOnListenWarnings_(payload, query2) {
        if (payload && typeof payload === "object" && util.contains(payload, "w")) {
          const warnings = util.safeGet(payload, "w");
          if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
            const indexSpec = '".indexOn": "' + query2._queryParams.getIndex().toString() + '"';
            const indexPath = query2._path.toString();
            warn$1(`Using an unspecified index. Your data will be downloaded and filtered on the client. Consider adding ${indexSpec} at ${indexPath} to your security rules for better performance.`);
          }
        }
      }
      refreshAuthToken(token) {
        this.authToken_ = token;
        this.log_("Auth token refreshed");
        if (this.authToken_) {
          this.tryAuth();
        } else {
          if (this.connected_) {
            this.sendRequest("unauth", {}, () => {
            });
          }
        }
        this.reduceReconnectDelayIfAdminCredential_(token);
      }
      reduceReconnectDelayIfAdminCredential_(credential) {
        const isFirebaseSecret = credential && credential.length === 40;
        if (isFirebaseSecret || util.isAdmin(credential)) {
          this.log_("Admin auth credential detected.  Reducing max reconnect time.");
          this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
        }
      }
      refreshAppCheckToken(token) {
        this.appCheckToken_ = token;
        this.log_("App check token refreshed");
        if (this.appCheckToken_) {
          this.tryAppCheck();
        } else {
          if (this.connected_) {
            this.sendRequest("unappeck", {}, () => {
            });
          }
        }
      }
      /**
       * Attempts to authenticate with the given credentials. If the authentication attempt fails, it's triggered like
       * a auth revoked (the connection is closed).
       */
      tryAuth() {
        if (this.connected_ && this.authToken_) {
          const token = this.authToken_;
          const authMethod = util.isValidFormat(token) ? "auth" : "gauth";
          const requestData = { cred: token };
          if (this.authOverride_ === null) {
            requestData["noauth"] = true;
          } else if (typeof this.authOverride_ === "object") {
            requestData["authvar"] = this.authOverride_;
          }
          this.sendRequest(authMethod, requestData, (res) => {
            const status = res[
              /*status*/
              "s"
            ];
            const data = res[
              /*data*/
              "d"
            ] || "error";
            if (this.authToken_ === token) {
              if (status === "ok") {
                this.invalidAuthTokenCount_ = 0;
              } else {
                this.onAuthRevoked_(status, data);
              }
            }
          });
        }
      }
      /**
       * Attempts to authenticate with the given token. If the authentication
       * attempt fails, it's triggered like the token was revoked (the connection is
       * closed).
       */
      tryAppCheck() {
        if (this.connected_ && this.appCheckToken_) {
          this.sendRequest("appcheck", { "token": this.appCheckToken_ }, (res) => {
            const status = res[
              /*status*/
              "s"
            ];
            const data = res[
              /*data*/
              "d"
            ] || "error";
            if (status === "ok") {
              this.invalidAppCheckTokenCount_ = 0;
            } else {
              this.onAppCheckRevoked_(status, data);
            }
          });
        }
      }
      /**
       * @inheritDoc
       */
      unlisten(query2, tag) {
        const pathString = query2._path.toString();
        const queryId = query2._queryIdentifier;
        this.log_("Unlisten called for " + pathString + " " + queryId);
        util.assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
        const listen = this.removeListen_(pathString, queryId);
        if (listen && this.connected_) {
          this.sendUnlisten_(pathString, queryId, query2._queryObject, tag);
        }
      }
      sendUnlisten_(pathString, queryId, queryObj, tag) {
        this.log_("Unlisten on " + pathString + " for " + queryId);
        const req = {
          /*path*/
          p: pathString
        };
        const action = "n";
        if (tag) {
          req["q"] = queryObj;
          req["t"] = tag;
        }
        this.sendRequest(action, req);
      }
      onDisconnectPut(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("o", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "o",
            data,
            onComplete
          });
        }
      }
      onDisconnectMerge(pathString, data, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("om", pathString, data, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "om",
            data,
            onComplete
          });
        }
      }
      onDisconnectCancel(pathString, onComplete) {
        this.initConnection_();
        if (this.connected_) {
          this.sendOnDisconnect_("oc", pathString, null, onComplete);
        } else {
          this.onDisconnectRequestQueue_.push({
            pathString,
            action: "oc",
            data: null,
            onComplete
          });
        }
      }
      sendOnDisconnect_(action, pathString, data, onComplete) {
        const request3 = {
          /*path*/
          p: pathString,
          /*data*/
          d: data
        };
        this.log_("onDisconnect " + action, request3);
        this.sendRequest(action, request3, (response) => {
          if (onComplete) {
            setTimeout(() => {
              onComplete(response[
                /*status*/
                "s"
              ], response[
                /* data */
                "d"
              ]);
            }, Math.floor(0));
          }
        });
      }
      put(pathString, data, onComplete, hash2) {
        this.putInternal("p", pathString, data, onComplete, hash2);
      }
      merge(pathString, data, onComplete, hash2) {
        this.putInternal("m", pathString, data, onComplete, hash2);
      }
      putInternal(action, pathString, data, onComplete, hash2) {
        this.initConnection_();
        const request3 = {
          /*path*/
          p: pathString,
          /*data*/
          d: data
        };
        if (hash2 !== void 0) {
          request3[
            /*hash*/
            "h"
          ] = hash2;
        }
        this.outstandingPuts_.push({
          action,
          request: request3,
          onComplete
        });
        this.outstandingPutCount_++;
        const index = this.outstandingPuts_.length - 1;
        if (this.connected_) {
          this.sendPut_(index);
        } else {
          this.log_("Buffering put: " + pathString);
        }
      }
      sendPut_(index) {
        const action = this.outstandingPuts_[index].action;
        const request3 = this.outstandingPuts_[index].request;
        const onComplete = this.outstandingPuts_[index].onComplete;
        this.outstandingPuts_[index].queued = this.connected_;
        this.sendRequest(action, request3, (message3) => {
          this.log_(action + " response", message3);
          delete this.outstandingPuts_[index];
          this.outstandingPutCount_--;
          if (this.outstandingPutCount_ === 0) {
            this.outstandingPuts_ = [];
          }
          if (onComplete) {
            onComplete(message3[
              /*status*/
              "s"
            ], message3[
              /* data */
              "d"
            ]);
          }
        });
      }
      reportStats(stats) {
        if (this.connected_) {
          const request3 = {
            /*counters*/
            c: stats
          };
          this.log_("reportStats", request3);
          this.sendRequest(
            /*stats*/
            "s",
            request3,
            (result) => {
              const status = result[
                /*status*/
                "s"
              ];
              if (status !== "ok") {
                const errorReason = result[
                  /* data */
                  "d"
                ];
                this.log_("reportStats", "Error sending stats: " + errorReason);
              }
            }
          );
        }
      }
      onDataMessage_(message3) {
        if ("r" in message3) {
          this.log_("from server: " + util.stringify(message3));
          const reqNum = message3["r"];
          const onResponse = this.requestCBHash_[reqNum];
          if (onResponse) {
            delete this.requestCBHash_[reqNum];
            onResponse(message3[
              /*body*/
              "b"
            ]);
          }
        } else if ("error" in message3) {
          throw "A server-side error has occurred: " + message3["error"];
        } else if ("a" in message3) {
          this.onDataPush_(message3["a"], message3["b"]);
        }
      }
      onDataPush_(action, body) {
        this.log_("handleServerMessage", action, body);
        if (action === "d") {
          this.onDataUpdate_(
            body[
              /*path*/
              "p"
            ],
            body[
              /*data*/
              "d"
            ],
            /*isMerge*/
            false,
            body["t"]
          );
        } else if (action === "m") {
          this.onDataUpdate_(
            body[
              /*path*/
              "p"
            ],
            body[
              /*data*/
              "d"
            ],
            /*isMerge=*/
            true,
            body["t"]
          );
        } else if (action === "c") {
          this.onListenRevoked_(body[
            /*path*/
            "p"
          ], body[
            /*query*/
            "q"
          ]);
        } else if (action === "ac") {
          this.onAuthRevoked_(body[
            /*status code*/
            "s"
          ], body[
            /* explanation */
            "d"
          ]);
        } else if (action === "apc") {
          this.onAppCheckRevoked_(body[
            /*status code*/
            "s"
          ], body[
            /* explanation */
            "d"
          ]);
        } else if (action === "sd") {
          this.onSecurityDebugPacket_(body);
        } else {
          error3("Unrecognized action received from server: " + util.stringify(action) + "\nAre you using the latest client?");
        }
      }
      onReady_(timestamp, sessionId) {
        this.log_("connection ready");
        this.connected_ = true;
        this.lastConnectionEstablishedTime_ = (/* @__PURE__ */ new Date()).getTime();
        this.handleTimestamp_(timestamp);
        this.lastSessionId = sessionId;
        if (this.firstConnection_) {
          this.sendConnectStats_();
        }
        this.restoreState_();
        this.firstConnection_ = false;
        this.onConnectStatus_(true);
      }
      scheduleConnect_(timeout) {
        util.assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
        if (this.establishConnectionTimer_) {
          clearTimeout(this.establishConnectionTimer_);
        }
        this.establishConnectionTimer_ = setTimeout(() => {
          this.establishConnectionTimer_ = null;
          this.establishConnection_();
        }, Math.floor(timeout));
      }
      initConnection_() {
        if (!this.realtime_ && this.firstConnection_) {
          this.scheduleConnect_(0);
        }
      }
      onVisible_(visible) {
        if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
          this.log_("Window became visible.  Reducing delay.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
        this.visible_ = visible;
      }
      onOnline_(online) {
        if (online) {
          this.log_("Browser went online.");
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        } else {
          this.log_("Browser went offline.  Killing connection.");
          if (this.realtime_) {
            this.realtime_.close();
          }
        }
      }
      onRealtimeDisconnect_() {
        this.log_("data client disconnected");
        this.connected_ = false;
        this.realtime_ = null;
        this.cancelSentTransactions_();
        this.requestCBHash_ = {};
        if (this.shouldReconnect_()) {
          if (!this.visible_) {
            this.log_("Window isn't visible.  Delaying reconnect.");
            this.reconnectDelay_ = this.maxReconnectDelay_;
            this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
          } else if (this.lastConnectionEstablishedTime_) {
            const timeSinceLastConnectSucceeded = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionEstablishedTime_;
            if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
              this.reconnectDelay_ = RECONNECT_MIN_DELAY;
            }
            this.lastConnectionEstablishedTime_ = null;
          }
          const timeSinceLastConnectAttempt = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionAttemptTime_;
          let reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
          reconnectDelay = Math.random() * reconnectDelay;
          this.log_("Trying to reconnect in " + reconnectDelay + "ms");
          this.scheduleConnect_(reconnectDelay);
          this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
        }
        this.onConnectStatus_(false);
      }
      async establishConnection_() {
        if (this.shouldReconnect_()) {
          this.log_("Making a connection attempt");
          this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
          this.lastConnectionEstablishedTime_ = null;
          const onDataMessage = this.onDataMessage_.bind(this);
          const onReady = this.onReady_.bind(this);
          const onDisconnect2 = this.onRealtimeDisconnect_.bind(this);
          const connId = this.id + ":" + _PersistentConnection.nextConnectionId_++;
          const lastSessionId = this.lastSessionId;
          let canceled = false;
          let connection = null;
          const closeFn = /* @__PURE__ */ __name(function() {
            if (connection) {
              connection.close();
            } else {
              canceled = true;
              onDisconnect2();
            }
          }, "closeFn");
          const sendRequestFn = /* @__PURE__ */ __name(function(msg) {
            util.assert(connection, "sendRequest call when we're not connected not allowed.");
            connection.sendRequest(msg);
          }, "sendRequestFn");
          this.realtime_ = {
            close: closeFn,
            sendRequest: sendRequestFn
          };
          const forceRefresh = this.forceTokenRefresh_;
          this.forceTokenRefresh_ = false;
          try {
            const [authToken, appCheckToken] = await Promise.all([
              this.authTokenProvider_.getToken(forceRefresh),
              this.appCheckTokenProvider_.getToken(forceRefresh)
            ]);
            if (!canceled) {
              log4("getToken() completed. Creating connection.");
              this.authToken_ = authToken && authToken.accessToken;
              this.appCheckToken_ = appCheckToken && appCheckToken.token;
              connection = new Connection(
                connId,
                this.repoInfo_,
                this.applicationId_,
                this.appCheckToken_,
                this.authToken_,
                onDataMessage,
                onReady,
                onDisconnect2,
                /* onKill= */
                (reason) => {
                  warn$1(reason + " (" + this.repoInfo_.toString() + ")");
                  this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                },
                lastSessionId
              );
            } else {
              log4("getToken() completed but was canceled");
            }
          } catch (error4) {
            this.log_("Failed to get token: " + error4);
            if (!canceled) {
              if (this.repoInfo_.nodeAdmin) {
                warn$1(error4);
              }
              closeFn();
            }
          }
        }
      }
      interrupt(reason) {
        log4("Interrupting connection for reason: " + reason);
        this.interruptReasons_[reason] = true;
        if (this.realtime_) {
          this.realtime_.close();
        } else {
          if (this.establishConnectionTimer_) {
            clearTimeout(this.establishConnectionTimer_);
            this.establishConnectionTimer_ = null;
          }
          if (this.connected_) {
            this.onRealtimeDisconnect_();
          }
        }
      }
      resume(reason) {
        log4("Resuming connection for reason: " + reason);
        delete this.interruptReasons_[reason];
        if (util.isEmpty(this.interruptReasons_)) {
          this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          if (!this.realtime_) {
            this.scheduleConnect_(0);
          }
        }
      }
      handleTimestamp_(timestamp) {
        const delta = timestamp - (/* @__PURE__ */ new Date()).getTime();
        this.onServerInfoUpdate_({ serverTimeOffset: delta });
      }
      cancelSentTransactions_() {
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
          const put = this.outstandingPuts_[i];
          if (put && /*hash*/
          "h" in put.request && put.queued) {
            if (put.onComplete) {
              put.onComplete("disconnect");
            }
            delete this.outstandingPuts_[i];
            this.outstandingPutCount_--;
          }
        }
        if (this.outstandingPutCount_ === 0) {
          this.outstandingPuts_ = [];
        }
      }
      onListenRevoked_(pathString, query2) {
        let queryId;
        if (!query2) {
          queryId = "default";
        } else {
          queryId = query2.map((q) => ObjectToUniqueKey(q)).join("$");
        }
        const listen = this.removeListen_(pathString, queryId);
        if (listen && listen.onComplete) {
          listen.onComplete("permission_denied");
        }
      }
      removeListen_(pathString, queryId) {
        const normalizedPathString = new Path(pathString).toString();
        let listen;
        if (this.listens.has(normalizedPathString)) {
          const map = this.listens.get(normalizedPathString);
          listen = map.get(queryId);
          map.delete(queryId);
          if (map.size === 0) {
            this.listens.delete(normalizedPathString);
          }
        } else {
          listen = void 0;
        }
        return listen;
      }
      onAuthRevoked_(statusCode, explanation) {
        log4("Auth token revoked: " + statusCode + "/" + explanation);
        this.authToken_ = null;
        this.forceTokenRefresh_ = true;
        this.realtime_.close();
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAuthTokenCount_++;
          if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
            this.authTokenProvider_.notifyForInvalidToken();
          }
        }
      }
      onAppCheckRevoked_(statusCode, explanation) {
        log4("App check token revoked: " + statusCode + "/" + explanation);
        this.appCheckToken_ = null;
        this.forceTokenRefresh_ = true;
        if (statusCode === "invalid_token" || statusCode === "permission_denied") {
          this.invalidAppCheckTokenCount_++;
          if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
            this.appCheckTokenProvider_.notifyForInvalidToken();
          }
        }
      }
      onSecurityDebugPacket_(body) {
        if (this.securityDebugCallback_) {
          this.securityDebugCallback_(body);
        } else {
          if ("msg" in body) {
            console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
          }
        }
      }
      restoreState_() {
        this.tryAuth();
        this.tryAppCheck();
        for (const queries of this.listens.values()) {
          for (const listenSpec of queries.values()) {
            this.sendListen_(listenSpec);
          }
        }
        for (let i = 0; i < this.outstandingPuts_.length; i++) {
          if (this.outstandingPuts_[i]) {
            this.sendPut_(i);
          }
        }
        while (this.onDisconnectRequestQueue_.length) {
          const request3 = this.onDisconnectRequestQueue_.shift();
          this.sendOnDisconnect_(request3.action, request3.pathString, request3.data, request3.onComplete);
        }
        for (let i = 0; i < this.outstandingGets_.length; i++) {
          if (this.outstandingGets_[i]) {
            this.sendGet_(i);
          }
        }
      }
      /**
       * Sends client stats for first connection
       */
      sendConnectStats_() {
        const stats = {};
        let clientName = "js";
        if (util.isNodeSdk()) {
          if (this.repoInfo_.nodeAdmin) {
            clientName = "admin_node";
          } else {
            clientName = "node";
          }
        }
        stats["sdk." + clientName + "." + SDK_VERSION2.replace(/\./g, "-")] = 1;
        if (util.isMobileCordova()) {
          stats["framework.cordova"] = 1;
        } else if (util.isReactNative()) {
          stats["framework.reactnative"] = 1;
        }
        this.reportStats(stats);
      }
      shouldReconnect_() {
        const online = OnlineMonitor.getInstance().currentlyOnline();
        return util.isEmpty(this.interruptReasons_) && online;
      }
    };
    PersistentConnection.nextPersistentConnectionId_ = 0;
    PersistentConnection.nextConnectionId_ = 0;
    var NamedNode = class _NamedNode {
      static {
        __name(this, "NamedNode");
      }
      constructor(name, node) {
        this.name = name;
        this.node = node;
      }
      static Wrap(name, node) {
        return new _NamedNode(name, node);
      }
    };
    var Index = class {
      static {
        __name(this, "Index");
      }
      /**
       * @returns A standalone comparison function for
       * this index
       */
      getCompare() {
        return this.compare.bind(this);
      }
      /**
       * Given a before and after value for a node, determine if the indexed value has changed. Even if they are different,
       * it's possible that the changes are isolated to parts of the snapshot that are not indexed.
       *
       *
       * @returns True if the portion of the snapshot being indexed changed between oldNode and newNode
       */
      indexedValueChanged(oldNode, newNode) {
        const oldWrapped = new NamedNode(MIN_NAME, oldNode);
        const newWrapped = new NamedNode(MIN_NAME, newNode);
        return this.compare(oldWrapped, newWrapped) !== 0;
      }
      /**
       * @returns a node wrapper that will sort equal to or less than
       * any other node wrapper, using this index
       */
      minPost() {
        return NamedNode.MIN;
      }
    };
    var __EMPTY_NODE;
    var KeyIndex = class extends Index {
      static {
        __name(this, "KeyIndex");
      }
      static get __EMPTY_NODE() {
        return __EMPTY_NODE;
      }
      static set __EMPTY_NODE(val) {
        __EMPTY_NODE = val;
      }
      compare(a2, b2) {
        return nameCompare(a2.name, b2.name);
      }
      isDefinedOn(node) {
        throw util.assertionError("KeyIndex.isDefinedOn not expected to be called.");
      }
      indexedValueChanged(oldNode, newNode) {
        return false;
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return new NamedNode(MAX_NAME, __EMPTY_NODE);
      }
      makePost(indexValue, name) {
        util.assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
        return new NamedNode(indexValue, __EMPTY_NODE);
      }
      /**
       * @returns String representation for inclusion in a query spec
       */
      toString() {
        return ".key";
      }
    };
    var KEY_INDEX = new KeyIndex();
    var SortedMapIterator = class {
      static {
        __name(this, "SortedMapIterator");
      }
      /**
       * @param node - Node to iterate.
       * @param isReverse_ - Whether or not to iterate in reverse
       */
      constructor(node, startKey, comparator, isReverse_, resultGenerator_ = null) {
        this.isReverse_ = isReverse_;
        this.resultGenerator_ = resultGenerator_;
        this.nodeStack_ = [];
        let cmp = 1;
        while (!node.isEmpty()) {
          node = node;
          cmp = startKey ? comparator(node.key, startKey) : 1;
          if (isReverse_) {
            cmp *= -1;
          }
          if (cmp < 0) {
            if (this.isReverse_) {
              node = node.left;
            } else {
              node = node.right;
            }
          } else if (cmp === 0) {
            this.nodeStack_.push(node);
            break;
          } else {
            this.nodeStack_.push(node);
            if (this.isReverse_) {
              node = node.right;
            } else {
              node = node.left;
            }
          }
        }
      }
      getNext() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        let node = this.nodeStack_.pop();
        let result;
        if (this.resultGenerator_) {
          result = this.resultGenerator_(node.key, node.value);
        } else {
          result = { key: node.key, value: node.value };
        }
        if (this.isReverse_) {
          node = node.left;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.right;
          }
        } else {
          node = node.right;
          while (!node.isEmpty()) {
            this.nodeStack_.push(node);
            node = node.left;
          }
        }
        return result;
      }
      hasNext() {
        return this.nodeStack_.length > 0;
      }
      peek() {
        if (this.nodeStack_.length === 0) {
          return null;
        }
        const node = this.nodeStack_[this.nodeStack_.length - 1];
        if (this.resultGenerator_) {
          return this.resultGenerator_(node.key, node.value);
        } else {
          return { key: node.key, value: node.value };
        }
      }
    };
    var LLRBNode = class _LLRBNode {
      static {
        __name(this, "LLRBNode");
      }
      /**
       * @param key - Key associated with this node.
       * @param value - Value associated with this node.
       * @param color - Whether this node is red.
       * @param left - Left child.
       * @param right - Right child.
       */
      constructor(key2, value, color, left, right) {
        this.key = key2;
        this.value = value;
        this.color = color != null ? color : _LLRBNode.RED;
        this.left = left != null ? left : SortedMap.EMPTY_NODE;
        this.right = right != null ? right : SortedMap.EMPTY_NODE;
      }
      /**
       * Returns a copy of the current node, optionally replacing pieces of it.
       *
       * @param key - New key for the node, or null.
       * @param value - New value for the node, or null.
       * @param color - New color for the node, or null.
       * @param left - New left child for the node, or null.
       * @param right - New right child for the node, or null.
       * @returns The node copy.
       */
      copy(key2, value, color, left, right) {
        return new _LLRBNode(key2 != null ? key2 : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
      }
      /**
       * @returns The total number of nodes in the tree.
       */
      count() {
        return this.left.count() + 1 + this.right.count();
      }
      /**
       * @returns True if the tree is empty.
       */
      isEmpty() {
        return false;
      }
      /**
       * Traverses the tree in key order and calls the specified action function
       * for each node.
       *
       * @param action - Callback function to be called for each
       *   node.  If it returns true, traversal is aborted.
       * @returns The first truthy value returned by action, or the last falsey
       *   value returned by action
       */
      inorderTraversal(action) {
        return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
      }
      /**
       * Traverses the tree in reverse key order and calls the specified action function
       * for each node.
       *
       * @param action - Callback function to be called for each
       * node.  If it returns true, traversal is aborted.
       * @returns True if traversal was aborted.
       */
      reverseTraversal(action) {
        return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
      }
      /**
       * @returns The minimum node in the tree.
       */
      min_() {
        if (this.left.isEmpty()) {
          return this;
        } else {
          return this.left.min_();
        }
      }
      /**
       * @returns The maximum key in the tree.
       */
      minKey() {
        return this.min_().key;
      }
      /**
       * @returns The maximum key in the tree.
       */
      maxKey() {
        if (this.right.isEmpty()) {
          return this.key;
        } else {
          return this.right.maxKey();
        }
      }
      /**
       * @param key - Key to insert.
       * @param value - Value to insert.
       * @param comparator - Comparator.
       * @returns New tree, with the key/value added.
       */
      insert(key2, value, comparator) {
        let n = this;
        const cmp = comparator(key2, n.key);
        if (cmp < 0) {
          n = n.copy(null, null, null, n.left.insert(key2, value, comparator), null);
        } else if (cmp === 0) {
          n = n.copy(null, value, null, null, null);
        } else {
          n = n.copy(null, null, null, null, n.right.insert(key2, value, comparator));
        }
        return n.fixUp_();
      }
      /**
       * @returns New tree, with the minimum key removed.
       */
      removeMin_() {
        if (this.left.isEmpty()) {
          return SortedMap.EMPTY_NODE;
        }
        let n = this;
        if (!n.left.isRed_() && !n.left.left.isRed_()) {
          n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.removeMin_(), null);
        return n.fixUp_();
      }
      /**
       * @param key - The key of the item to remove.
       * @param comparator - Comparator.
       * @returns New tree, with the specified item removed.
       */
      remove(key2, comparator) {
        let n, smallest;
        n = this;
        if (comparator(key2, n.key) < 0) {
          if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
            n = n.moveRedLeft_();
          }
          n = n.copy(null, null, null, n.left.remove(key2, comparator), null);
        } else {
          if (n.left.isRed_()) {
            n = n.rotateRight_();
          }
          if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
            n = n.moveRedRight_();
          }
          if (comparator(key2, n.key) === 0) {
            if (n.right.isEmpty()) {
              return SortedMap.EMPTY_NODE;
            } else {
              smallest = n.right.min_();
              n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
            }
          }
          n = n.copy(null, null, null, null, n.right.remove(key2, comparator));
        }
        return n.fixUp_();
      }
      /**
       * @returns Whether this is a RED node.
       */
      isRed_() {
        return this.color;
      }
      /**
       * @returns New tree after performing any needed rotations.
       */
      fixUp_() {
        let n = this;
        if (n.right.isRed_() && !n.left.isRed_()) {
          n = n.rotateLeft_();
        }
        if (n.left.isRed_() && n.left.left.isRed_()) {
          n = n.rotateRight_();
        }
        if (n.left.isRed_() && n.right.isRed_()) {
          n = n.colorFlip_();
        }
        return n;
      }
      /**
       * @returns New tree, after moveRedLeft.
       */
      moveRedLeft_() {
        let n = this.colorFlip_();
        if (n.right.left.isRed_()) {
          n = n.copy(null, null, null, null, n.right.rotateRight_());
          n = n.rotateLeft_();
          n = n.colorFlip_();
        }
        return n;
      }
      /**
       * @returns New tree, after moveRedRight.
       */
      moveRedRight_() {
        let n = this.colorFlip_();
        if (n.left.left.isRed_()) {
          n = n.rotateRight_();
          n = n.colorFlip_();
        }
        return n;
      }
      /**
       * @returns New tree, after rotateLeft.
       */
      rotateLeft_() {
        const nl = this.copy(null, null, _LLRBNode.RED, null, this.right.left);
        return this.right.copy(null, null, this.color, nl, null);
      }
      /**
       * @returns New tree, after rotateRight.
       */
      rotateRight_() {
        const nr = this.copy(null, null, _LLRBNode.RED, this.left.right, null);
        return this.left.copy(null, null, this.color, null, nr);
      }
      /**
       * @returns Newt ree, after colorFlip.
       */
      colorFlip_() {
        const left = this.left.copy(null, null, !this.left.color, null, null);
        const right = this.right.copy(null, null, !this.right.color, null, null);
        return this.copy(null, null, !this.color, left, right);
      }
      /**
       * For testing.
       *
       * @returns True if all is well.
       */
      checkMaxDepth_() {
        const blackDepth = this.check_();
        return Math.pow(2, blackDepth) <= this.count() + 1;
      }
      check_() {
        if (this.isRed_() && this.left.isRed_()) {
          throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
        }
        if (this.right.isRed_()) {
          throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
        }
        const blackDepth = this.left.check_();
        if (blackDepth !== this.right.check_()) {
          throw new Error("Black depths differ");
        } else {
          return blackDepth + (this.isRed_() ? 0 : 1);
        }
      }
    };
    LLRBNode.RED = true;
    LLRBNode.BLACK = false;
    var LLRBEmptyNode = class {
      static {
        __name(this, "LLRBEmptyNode");
      }
      /**
       * Returns a copy of the current node.
       *
       * @returns The node copy.
       */
      copy(key2, value, color, left, right) {
        return this;
      }
      /**
       * Returns a copy of the tree, with the specified key/value added.
       *
       * @param key - Key to be added.
       * @param value - Value to be added.
       * @param comparator - Comparator.
       * @returns New tree, with item added.
       */
      insert(key2, value, comparator) {
        return new LLRBNode(key2, value, null);
      }
      /**
       * Returns a copy of the tree, with the specified key removed.
       *
       * @param key - The key to remove.
       * @param comparator - Comparator.
       * @returns New tree, with item removed.
       */
      remove(key2, comparator) {
        return this;
      }
      /**
       * @returns The total number of nodes in the tree.
       */
      count() {
        return 0;
      }
      /**
       * @returns True if the tree is empty.
       */
      isEmpty() {
        return true;
      }
      /**
       * Traverses the tree in key order and calls the specified action function
       * for each node.
       *
       * @param action - Callback function to be called for each
       * node.  If it returns true, traversal is aborted.
       * @returns True if traversal was aborted.
       */
      inorderTraversal(action) {
        return false;
      }
      /**
       * Traverses the tree in reverse key order and calls the specified action function
       * for each node.
       *
       * @param action - Callback function to be called for each
       * node.  If it returns true, traversal is aborted.
       * @returns True if traversal was aborted.
       */
      reverseTraversal(action) {
        return false;
      }
      minKey() {
        return null;
      }
      maxKey() {
        return null;
      }
      check_() {
        return 0;
      }
      /**
       * @returns Whether this node is red.
       */
      isRed_() {
        return false;
      }
    };
    var SortedMap = class _SortedMap {
      static {
        __name(this, "SortedMap");
      }
      /**
       * @param comparator_ - Key comparator.
       * @param root_ - Optional root node for the map.
       */
      constructor(comparator_, root_ = _SortedMap.EMPTY_NODE) {
        this.comparator_ = comparator_;
        this.root_ = root_;
      }
      /**
       * Returns a copy of the map, with the specified key/value added or replaced.
       * (TODO: We should perhaps rename this method to 'put')
       *
       * @param key - Key to be added.
       * @param value - Value to be added.
       * @returns New map, with item added.
       */
      insert(key2, value) {
        return new _SortedMap(this.comparator_, this.root_.insert(key2, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      }
      /**
       * Returns a copy of the map, with the specified key removed.
       *
       * @param key - The key to remove.
       * @returns New map, with item removed.
       */
      remove(key2) {
        return new _SortedMap(this.comparator_, this.root_.remove(key2, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
      }
      /**
       * Returns the value of the node with the given key, or null.
       *
       * @param key - The key to look up.
       * @returns The value of the node with the given key, or null if the
       * key doesn't exist.
       */
      get(key2) {
        let cmp;
        let node = this.root_;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key2, node.key);
          if (cmp === 0) {
            return node.value;
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            node = node.right;
          }
        }
        return null;
      }
      /**
       * Returns the key of the item *before* the specified key, or null if key is the first item.
       * @param key - The key to find the predecessor of
       * @returns The predecessor key.
       */
      getPredecessorKey(key2) {
        let cmp, node = this.root_, rightParent = null;
        while (!node.isEmpty()) {
          cmp = this.comparator_(key2, node.key);
          if (cmp === 0) {
            if (!node.left.isEmpty()) {
              node = node.left;
              while (!node.right.isEmpty()) {
                node = node.right;
              }
              return node.key;
            } else if (rightParent) {
              return rightParent.key;
            } else {
              return null;
            }
          } else if (cmp < 0) {
            node = node.left;
          } else if (cmp > 0) {
            rightParent = node;
            node = node.right;
          }
        }
        throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
      }
      /**
       * @returns True if the map is empty.
       */
      isEmpty() {
        return this.root_.isEmpty();
      }
      /**
       * @returns The total number of nodes in the map.
       */
      count() {
        return this.root_.count();
      }
      /**
       * @returns The minimum key in the map.
       */
      minKey() {
        return this.root_.minKey();
      }
      /**
       * @returns The maximum key in the map.
       */
      maxKey() {
        return this.root_.maxKey();
      }
      /**
       * Traverses the map in key order and calls the specified action function
       * for each key/value pair.
       *
       * @param action - Callback function to be called
       * for each key/value pair.  If action returns true, traversal is aborted.
       * @returns The first truthy value returned by action, or the last falsey
       *   value returned by action
       */
      inorderTraversal(action) {
        return this.root_.inorderTraversal(action);
      }
      /**
       * Traverses the map in reverse key order and calls the specified action function
       * for each key/value pair.
       *
       * @param action - Callback function to be called
       * for each key/value pair.  If action returns true, traversal is aborted.
       * @returns True if the traversal was aborted.
       */
      reverseTraversal(action) {
        return this.root_.reverseTraversal(action);
      }
      /**
       * Returns an iterator over the SortedMap.
       * @returns The iterator.
       */
      getIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
      }
      getIteratorFrom(key2, resultGenerator) {
        return new SortedMapIterator(this.root_, key2, this.comparator_, false, resultGenerator);
      }
      getReverseIteratorFrom(key2, resultGenerator) {
        return new SortedMapIterator(this.root_, key2, this.comparator_, true, resultGenerator);
      }
      getReverseIterator(resultGenerator) {
        return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
      }
    };
    SortedMap.EMPTY_NODE = new LLRBEmptyNode();
    function NAME_ONLY_COMPARATOR(left, right) {
      return nameCompare(left.name, right.name);
    }
    __name(NAME_ONLY_COMPARATOR, "NAME_ONLY_COMPARATOR");
    function NAME_COMPARATOR(left, right) {
      return nameCompare(left, right);
    }
    __name(NAME_COMPARATOR, "NAME_COMPARATOR");
    var MAX_NODE$2;
    function setMaxNode$1(val) {
      MAX_NODE$2 = val;
    }
    __name(setMaxNode$1, "setMaxNode$1");
    var priorityHashText = /* @__PURE__ */ __name(function(priority2) {
      if (typeof priority2 === "number") {
        return "number:" + doubleToIEEE754String(priority2);
      } else {
        return "string:" + priority2;
      }
    }, "priorityHashText");
    var validatePriorityNode = /* @__PURE__ */ __name(function(priorityNode) {
      if (priorityNode.isLeafNode()) {
        const val = priorityNode.val();
        util.assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && util.contains(val, ".sv"), "Priority must be a string or number.");
      } else {
        util.assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), "priority of unexpected type.");
      }
      util.assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
    }, "validatePriorityNode");
    var __childrenNodeConstructor;
    var LeafNode = class _LeafNode {
      static {
        __name(this, "LeafNode");
      }
      static set __childrenNodeConstructor(val) {
        __childrenNodeConstructor = val;
      }
      static get __childrenNodeConstructor() {
        return __childrenNodeConstructor;
      }
      /**
       * @param value_ - The value to store in this leaf node. The object type is
       * possible in the event of a deferred value
       * @param priorityNode_ - The priority of this node.
       */
      constructor(value_, priorityNode_ = _LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
        this.value_ = value_;
        this.priorityNode_ = priorityNode_;
        this.lazyHash_ = null;
        util.assert(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
        validatePriorityNode(this.priorityNode_);
      }
      /** @inheritDoc */
      isLeafNode() {
        return true;
      }
      /** @inheritDoc */
      getPriority() {
        return this.priorityNode_;
      }
      /** @inheritDoc */
      updatePriority(newPriorityNode) {
        return new _LeafNode(this.value_, newPriorityNode);
      }
      /** @inheritDoc */
      getImmediateChild(childName) {
        if (childName === ".priority") {
          return this.priorityNode_;
        } else {
          return _LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
      }
      /** @inheritDoc */
      getChild(path) {
        if (pathIsEmpty(path)) {
          return this;
        } else if (pathGetFront(path) === ".priority") {
          return this.priorityNode_;
        } else {
          return _LeafNode.__childrenNodeConstructor.EMPTY_NODE;
        }
      }
      hasChild() {
        return false;
      }
      /** @inheritDoc */
      getPredecessorChildName(childName, childNode) {
        return null;
      }
      /** @inheritDoc */
      updateImmediateChild(childName, newChildNode) {
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else if (newChildNode.isEmpty() && childName !== ".priority") {
          return this;
        } else {
          return _LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
        }
      }
      /** @inheritDoc */
      updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else if (newChildNode.isEmpty() && front !== ".priority") {
          return this;
        } else {
          util.assert(front !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          return this.updateImmediateChild(front, _LeafNode.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
        }
      }
      /** @inheritDoc */
      isEmpty() {
        return false;
      }
      /** @inheritDoc */
      numChildren() {
        return 0;
      }
      /** @inheritDoc */
      forEachChild(index, action) {
        return false;
      }
      val(exportFormat) {
        if (exportFormat && !this.getPriority().isEmpty()) {
          return {
            ".value": this.getValue(),
            ".priority": this.getPriority().val()
          };
        } else {
          return this.getValue();
        }
      }
      /** @inheritDoc */
      hash() {
        if (this.lazyHash_ === null) {
          let toHash = "";
          if (!this.priorityNode_.isEmpty()) {
            toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
          }
          const type2 = typeof this.value_;
          toHash += type2 + ":";
          if (type2 === "number") {
            toHash += doubleToIEEE754String(this.value_);
          } else {
            toHash += this.value_;
          }
          this.lazyHash_ = sha1(toHash);
        }
        return this.lazyHash_;
      }
      /**
       * Returns the value of the leaf node.
       * @returns The value of the node.
       */
      getValue() {
        return this.value_;
      }
      compareTo(other) {
        if (other === _LeafNode.__childrenNodeConstructor.EMPTY_NODE) {
          return 1;
        } else if (other instanceof _LeafNode.__childrenNodeConstructor) {
          return -1;
        } else {
          util.assert(other.isLeafNode(), "Unknown node type");
          return this.compareToLeafNode_(other);
        }
      }
      /**
       * Comparison specifically for two leaf nodes
       */
      compareToLeafNode_(otherLeaf) {
        const otherLeafType = typeof otherLeaf.value_;
        const thisLeafType = typeof this.value_;
        const otherIndex = _LeafNode.VALUE_TYPE_ORDER.indexOf(otherLeafType);
        const thisIndex = _LeafNode.VALUE_TYPE_ORDER.indexOf(thisLeafType);
        util.assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
        util.assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
        if (otherIndex === thisIndex) {
          if (thisLeafType === "object") {
            return 0;
          } else {
            if (this.value_ < otherLeaf.value_) {
              return -1;
            } else if (this.value_ === otherLeaf.value_) {
              return 0;
            } else {
              return 1;
            }
          }
        } else {
          return thisIndex - otherIndex;
        }
      }
      withIndex() {
        return this;
      }
      isIndexed() {
        return true;
      }
      equals(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          const otherLeaf = other;
          return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
        } else {
          return false;
        }
      }
    };
    LeafNode.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
    var nodeFromJSON$1;
    var MAX_NODE$1;
    function setNodeFromJSON(val) {
      nodeFromJSON$1 = val;
    }
    __name(setNodeFromJSON, "setNodeFromJSON");
    function setMaxNode(val) {
      MAX_NODE$1 = val;
    }
    __name(setMaxNode, "setMaxNode");
    var PriorityIndex = class extends Index {
      static {
        __name(this, "PriorityIndex");
      }
      compare(a2, b2) {
        const aPriority = a2.node.getPriority();
        const bPriority = b2.node.getPriority();
        const indexCmp = aPriority.compareTo(bPriority);
        if (indexCmp === 0) {
          return nameCompare(a2.name, b2.name);
        } else {
          return indexCmp;
        }
      }
      isDefinedOn(node) {
        return !node.getPriority().isEmpty();
      }
      indexedValueChanged(oldNode, newNode) {
        return !oldNode.getPriority().equals(newNode.getPriority());
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
      }
      makePost(indexValue, name) {
        const priorityNode = nodeFromJSON$1(indexValue);
        return new NamedNode(name, new LeafNode("[PRIORITY-POST]", priorityNode));
      }
      /**
       * @returns String representation for inclusion in a query spec
       */
      toString() {
        return ".priority";
      }
    };
    var PRIORITY_INDEX = new PriorityIndex();
    var LOG_2 = Math.log(2);
    var Base12Num = class {
      static {
        __name(this, "Base12Num");
      }
      constructor(length) {
        const logBase2 = /* @__PURE__ */ __name((num) => (
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          parseInt(Math.log(num) / LOG_2, 10)
        ), "logBase2");
        const bitMask = /* @__PURE__ */ __name((bits) => parseInt(Array(bits + 1).join("1"), 2), "bitMask");
        this.count = logBase2(length + 1);
        this.current_ = this.count - 1;
        const mask = bitMask(this.count);
        this.bits_ = length + 1 & mask;
      }
      nextBitIsOne() {
        const result = !(this.bits_ & 1 << this.current_);
        this.current_--;
        return result;
      }
    };
    var buildChildSet = /* @__PURE__ */ __name(function(childList, cmp, keyFn, mapSortFn) {
      childList.sort(cmp);
      const buildBalancedTree = /* @__PURE__ */ __name(function(low, high) {
        const length = high - low;
        let namedNode;
        let key2;
        if (length === 0) {
          return null;
        } else if (length === 1) {
          namedNode = childList[low];
          key2 = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key2, namedNode.node, LLRBNode.BLACK, null, null);
        } else {
          const middle = parseInt(length / 2, 10) + low;
          const left = buildBalancedTree(low, middle);
          const right = buildBalancedTree(middle + 1, high);
          namedNode = childList[middle];
          key2 = keyFn ? keyFn(namedNode) : namedNode;
          return new LLRBNode(key2, namedNode.node, LLRBNode.BLACK, left, right);
        }
      }, "buildBalancedTree");
      const buildFrom12Array = /* @__PURE__ */ __name(function(base122) {
        let node = null;
        let root2 = null;
        let index = childList.length;
        const buildPennant = /* @__PURE__ */ __name(function(chunkSize, color) {
          const low = index - chunkSize;
          const high = index;
          index -= chunkSize;
          const childTree = buildBalancedTree(low + 1, high);
          const namedNode = childList[low];
          const key2 = keyFn ? keyFn(namedNode) : namedNode;
          attachPennant(new LLRBNode(key2, namedNode.node, color, null, childTree));
        }, "buildPennant");
        const attachPennant = /* @__PURE__ */ __name(function(pennant) {
          if (node) {
            node.left = pennant;
            node = pennant;
          } else {
            root2 = pennant;
            node = pennant;
          }
        }, "attachPennant");
        for (let i = 0; i < base122.count; ++i) {
          const isOne = base122.nextBitIsOne();
          const chunkSize = Math.pow(2, base122.count - (i + 1));
          if (isOne) {
            buildPennant(chunkSize, LLRBNode.BLACK);
          } else {
            buildPennant(chunkSize, LLRBNode.BLACK);
            buildPennant(chunkSize, LLRBNode.RED);
          }
        }
        return root2;
      }, "buildFrom12Array");
      const base12 = new Base12Num(childList.length);
      const root = buildFrom12Array(base12);
      return new SortedMap(mapSortFn || cmp, root);
    }, "buildChildSet");
    var _defaultIndexMap;
    var fallbackObject = {};
    var IndexMap = class _IndexMap {
      static {
        __name(this, "IndexMap");
      }
      /**
       * The default IndexMap for nodes without a priority
       */
      static get Default() {
        util.assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
        _defaultIndexMap = _defaultIndexMap || new _IndexMap({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
        return _defaultIndexMap;
      }
      constructor(indexes_, indexSet_) {
        this.indexes_ = indexes_;
        this.indexSet_ = indexSet_;
      }
      get(indexKey) {
        const sortedMap = util.safeGet(this.indexes_, indexKey);
        if (!sortedMap) {
          throw new Error("No index defined for " + indexKey);
        }
        if (sortedMap instanceof SortedMap) {
          return sortedMap;
        } else {
          return null;
        }
      }
      hasIndex(indexDefinition) {
        return util.contains(this.indexSet_, indexDefinition.toString());
      }
      addIndex(indexDefinition, existingChildren) {
        util.assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
        const childList = [];
        let sawIndexedValue = false;
        const iter = existingChildren.getIterator(NamedNode.Wrap);
        let next = iter.getNext();
        while (next) {
          sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
          childList.push(next);
          next = iter.getNext();
        }
        let newIndex;
        if (sawIndexedValue) {
          newIndex = buildChildSet(childList, indexDefinition.getCompare());
        } else {
          newIndex = fallbackObject;
        }
        const indexName = indexDefinition.toString();
        const newIndexSet = Object.assign({}, this.indexSet_);
        newIndexSet[indexName] = indexDefinition;
        const newIndexes = Object.assign({}, this.indexes_);
        newIndexes[indexName] = newIndex;
        return new _IndexMap(newIndexes, newIndexSet);
      }
      /**
       * Ensure that this node is properly tracked in any indexes that we're maintaining
       */
      addToIndexes(namedNode, existingChildren) {
        const newIndexes = util.map(this.indexes_, (indexedChildren, indexName) => {
          const index = util.safeGet(this.indexSet_, indexName);
          util.assert(index, "Missing index implementation for " + indexName);
          if (indexedChildren === fallbackObject) {
            if (index.isDefinedOn(namedNode.node)) {
              const childList = [];
              const iter = existingChildren.getIterator(NamedNode.Wrap);
              let next = iter.getNext();
              while (next) {
                if (next.name !== namedNode.name) {
                  childList.push(next);
                }
                next = iter.getNext();
              }
              childList.push(namedNode);
              return buildChildSet(childList, index.getCompare());
            } else {
              return fallbackObject;
            }
          } else {
            const existingSnap = existingChildren.get(namedNode.name);
            let newChildren = indexedChildren;
            if (existingSnap) {
              newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
            }
            return newChildren.insert(namedNode, namedNode.node);
          }
        });
        return new _IndexMap(newIndexes, this.indexSet_);
      }
      /**
       * Create a new IndexMap instance with the given value removed
       */
      removeFromIndexes(namedNode, existingChildren) {
        const newIndexes = util.map(this.indexes_, (indexedChildren) => {
          if (indexedChildren === fallbackObject) {
            return indexedChildren;
          } else {
            const existingSnap = existingChildren.get(namedNode.name);
            if (existingSnap) {
              return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
            } else {
              return indexedChildren;
            }
          }
        });
        return new _IndexMap(newIndexes, this.indexSet_);
      }
    };
    var EMPTY_NODE;
    var ChildrenNode = class _ChildrenNode {
      static {
        __name(this, "ChildrenNode");
      }
      static get EMPTY_NODE() {
        return EMPTY_NODE || (EMPTY_NODE = new _ChildrenNode(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
      }
      /**
       * @param children_ - List of children of this node..
       * @param priorityNode_ - The priority of this node (as a snapshot node).
       */
      constructor(children_, priorityNode_, indexMap_) {
        this.children_ = children_;
        this.priorityNode_ = priorityNode_;
        this.indexMap_ = indexMap_;
        this.lazyHash_ = null;
        if (this.priorityNode_) {
          validatePriorityNode(this.priorityNode_);
        }
        if (this.children_.isEmpty()) {
          util.assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
        }
      }
      /** @inheritDoc */
      isLeafNode() {
        return false;
      }
      /** @inheritDoc */
      getPriority() {
        return this.priorityNode_ || EMPTY_NODE;
      }
      /** @inheritDoc */
      updatePriority(newPriorityNode) {
        if (this.children_.isEmpty()) {
          return this;
        } else {
          return new _ChildrenNode(this.children_, newPriorityNode, this.indexMap_);
        }
      }
      /** @inheritDoc */
      getImmediateChild(childName) {
        if (childName === ".priority") {
          return this.getPriority();
        } else {
          const child2 = this.children_.get(childName);
          return child2 === null ? EMPTY_NODE : child2;
        }
      }
      /** @inheritDoc */
      getChild(path) {
        const front = pathGetFront(path);
        if (front === null) {
          return this;
        }
        return this.getImmediateChild(front).getChild(pathPopFront(path));
      }
      /** @inheritDoc */
      hasChild(childName) {
        return this.children_.get(childName) !== null;
      }
      /** @inheritDoc */
      updateImmediateChild(childName, newChildNode) {
        util.assert(newChildNode, "We should always be passing snapshot nodes");
        if (childName === ".priority") {
          return this.updatePriority(newChildNode);
        } else {
          const namedNode = new NamedNode(childName, newChildNode);
          let newChildren, newIndexMap;
          if (newChildNode.isEmpty()) {
            newChildren = this.children_.remove(childName);
            newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
          } else {
            newChildren = this.children_.insert(childName, newChildNode);
            newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
          }
          const newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
          return new _ChildrenNode(newChildren, newPriority, newIndexMap);
        }
      }
      /** @inheritDoc */
      updateChild(path, newChildNode) {
        const front = pathGetFront(path);
        if (front === null) {
          return newChildNode;
        } else {
          util.assert(pathGetFront(path) !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
          const newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
          return this.updateImmediateChild(front, newImmediateChild);
        }
      }
      /** @inheritDoc */
      isEmpty() {
        return this.children_.isEmpty();
      }
      /** @inheritDoc */
      numChildren() {
        return this.children_.count();
      }
      /** @inheritDoc */
      val(exportFormat) {
        if (this.isEmpty()) {
          return null;
        }
        const obj = {};
        let numKeys = 0, maxKey = 0, allIntegerKeys = true;
        this.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
          obj[key2] = childNode.val(exportFormat);
          numKeys++;
          if (allIntegerKeys && _ChildrenNode.INTEGER_REGEXP_.test(key2)) {
            maxKey = Math.max(maxKey, Number(key2));
          } else {
            allIntegerKeys = false;
          }
        });
        if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
          const array = [];
          for (const key2 in obj) {
            array[key2] = obj[key2];
          }
          return array;
        } else {
          if (exportFormat && !this.getPriority().isEmpty()) {
            obj[".priority"] = this.getPriority().val();
          }
          return obj;
        }
      }
      /** @inheritDoc */
      hash() {
        if (this.lazyHash_ === null) {
          let toHash = "";
          if (!this.getPriority().isEmpty()) {
            toHash += "priority:" + priorityHashText(this.getPriority().val()) + ":";
          }
          this.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
            const childHash = childNode.hash();
            if (childHash !== "") {
              toHash += ":" + key2 + ":" + childHash;
            }
          });
          this.lazyHash_ = toHash === "" ? "" : sha1(toHash);
        }
        return this.lazyHash_;
      }
      /** @inheritDoc */
      getPredecessorChildName(childName, childNode, index) {
        const idx = this.resolveIndex_(index);
        if (idx) {
          const predecessor = idx.getPredecessorKey(new NamedNode(childName, childNode));
          return predecessor ? predecessor.name : null;
        } else {
          return this.children_.getPredecessorKey(childName);
        }
      }
      getFirstChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          const minKey = idx.minKey();
          return minKey && minKey.name;
        } else {
          return this.children_.minKey();
        }
      }
      getFirstChild(indexDefinition) {
        const minKey = this.getFirstChildName(indexDefinition);
        if (minKey) {
          return new NamedNode(minKey, this.children_.get(minKey));
        } else {
          return null;
        }
      }
      /**
       * Given an index, return the key name of the largest value we have, according to that index
       */
      getLastChildName(indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          const maxKey = idx.maxKey();
          return maxKey && maxKey.name;
        } else {
          return this.children_.maxKey();
        }
      }
      getLastChild(indexDefinition) {
        const maxKey = this.getLastChildName(indexDefinition);
        if (maxKey) {
          return new NamedNode(maxKey, this.children_.get(maxKey));
        } else {
          return null;
        }
      }
      forEachChild(index, action) {
        const idx = this.resolveIndex_(index);
        if (idx) {
          return idx.inorderTraversal((wrappedNode) => {
            return action(wrappedNode.name, wrappedNode.node);
          });
        } else {
          return this.children_.inorderTraversal(action);
        }
      }
      getIterator(indexDefinition) {
        return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
      }
      getIteratorFrom(startPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getIteratorFrom(startPost, (key2) => key2);
        } else {
          const iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
          let next = iterator.peek();
          while (next != null && indexDefinition.compare(next, startPost) < 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      }
      getReverseIterator(indexDefinition) {
        return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
      }
      getReverseIteratorFrom(endPost, indexDefinition) {
        const idx = this.resolveIndex_(indexDefinition);
        if (idx) {
          return idx.getReverseIteratorFrom(endPost, (key2) => {
            return key2;
          });
        } else {
          const iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
          let next = iterator.peek();
          while (next != null && indexDefinition.compare(next, endPost) > 0) {
            iterator.getNext();
            next = iterator.peek();
          }
          return iterator;
        }
      }
      compareTo(other) {
        if (this.isEmpty()) {
          if (other.isEmpty()) {
            return 0;
          } else {
            return -1;
          }
        } else if (other.isLeafNode() || other.isEmpty()) {
          return 1;
        } else if (other === MAX_NODE) {
          return -1;
        } else {
          return 0;
        }
      }
      withIndex(indexDefinition) {
        if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
          return this;
        } else {
          const newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
          return new _ChildrenNode(this.children_, this.priorityNode_, newIndexMap);
        }
      }
      isIndexed(index) {
        return index === KEY_INDEX || this.indexMap_.hasIndex(index);
      }
      equals(other) {
        if (other === this) {
          return true;
        } else if (other.isLeafNode()) {
          return false;
        } else {
          const otherChildrenNode = other;
          if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
            return false;
          } else if (this.children_.count() === otherChildrenNode.children_.count()) {
            const thisIter = this.getIterator(PRIORITY_INDEX);
            const otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
            let thisCurrent = thisIter.getNext();
            let otherCurrent = otherIter.getNext();
            while (thisCurrent && otherCurrent) {
              if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
                return false;
              }
              thisCurrent = thisIter.getNext();
              otherCurrent = otherIter.getNext();
            }
            return thisCurrent === null && otherCurrent === null;
          } else {
            return false;
          }
        }
      }
      /**
       * Returns a SortedMap ordered by index, or null if the default (by-key) ordering can be used
       * instead.
       *
       */
      resolveIndex_(indexDefinition) {
        if (indexDefinition === KEY_INDEX) {
          return null;
        } else {
          return this.indexMap_.get(indexDefinition.toString());
        }
      }
    };
    ChildrenNode.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    var MaxNode = class extends ChildrenNode {
      static {
        __name(this, "MaxNode");
      }
      constructor() {
        super(new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default);
      }
      compareTo(other) {
        if (other === this) {
          return 0;
        } else {
          return 1;
        }
      }
      equals(other) {
        return other === this;
      }
      getPriority() {
        return this;
      }
      getImmediateChild(childName) {
        return ChildrenNode.EMPTY_NODE;
      }
      isEmpty() {
        return false;
      }
    };
    var MAX_NODE = new MaxNode();
    Object.defineProperties(NamedNode, {
      MIN: {
        value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
      },
      MAX: {
        value: new NamedNode(MAX_NAME, MAX_NODE)
      }
    });
    KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
    LeafNode.__childrenNodeConstructor = ChildrenNode;
    setMaxNode$1(MAX_NODE);
    setMaxNode(MAX_NODE);
    var USE_HINZE = true;
    function nodeFromJSON(json, priority2 = null) {
      if (json === null) {
        return ChildrenNode.EMPTY_NODE;
      }
      if (typeof json === "object" && ".priority" in json) {
        priority2 = json[".priority"];
      }
      util.assert(priority2 === null || typeof priority2 === "string" || typeof priority2 === "number" || typeof priority2 === "object" && ".sv" in priority2, "Invalid priority type found: " + typeof priority2);
      if (typeof json === "object" && ".value" in json && json[".value"] !== null) {
        json = json[".value"];
      }
      if (typeof json !== "object" || ".sv" in json) {
        const jsonLeaf = json;
        return new LeafNode(jsonLeaf, nodeFromJSON(priority2));
      }
      if (!(json instanceof Array) && USE_HINZE) {
        const children = [];
        let childrenHavePriority = false;
        const hinzeJsonObj = json;
        each(hinzeJsonObj, (key2, child2) => {
          if (key2.substring(0, 1) !== ".") {
            const childNode = nodeFromJSON(child2);
            if (!childNode.isEmpty()) {
              childrenHavePriority = childrenHavePriority || !childNode.getPriority().isEmpty();
              children.push(new NamedNode(key2, childNode));
            }
          }
        });
        if (children.length === 0) {
          return ChildrenNode.EMPTY_NODE;
        }
        const childSet = buildChildSet(children, NAME_ONLY_COMPARATOR, (namedNode) => namedNode.name, NAME_COMPARATOR);
        if (childrenHavePriority) {
          const sortedChildSet = buildChildSet(children, PRIORITY_INDEX.getCompare());
          return new ChildrenNode(childSet, nodeFromJSON(priority2), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
        } else {
          return new ChildrenNode(childSet, nodeFromJSON(priority2), IndexMap.Default);
        }
      } else {
        let node = ChildrenNode.EMPTY_NODE;
        each(json, (key2, childData) => {
          if (util.contains(json, key2)) {
            if (key2.substring(0, 1) !== ".") {
              const childNode = nodeFromJSON(childData);
              if (childNode.isLeafNode() || !childNode.isEmpty()) {
                node = node.updateImmediateChild(key2, childNode);
              }
            }
          }
        });
        return node.updatePriority(nodeFromJSON(priority2));
      }
    }
    __name(nodeFromJSON, "nodeFromJSON");
    setNodeFromJSON(nodeFromJSON);
    var PathIndex = class extends Index {
      static {
        __name(this, "PathIndex");
      }
      constructor(indexPath_) {
        super();
        this.indexPath_ = indexPath_;
        util.assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
      }
      extractChild(snap) {
        return snap.getChild(this.indexPath_);
      }
      isDefinedOn(node) {
        return !node.getChild(this.indexPath_).isEmpty();
      }
      compare(a2, b2) {
        const aChild = this.extractChild(a2.node);
        const bChild = this.extractChild(b2.node);
        const indexCmp = aChild.compareTo(bChild);
        if (indexCmp === 0) {
          return nameCompare(a2.name, b2.name);
        } else {
          return indexCmp;
        }
      }
      makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
        return new NamedNode(name, node);
      }
      maxPost() {
        const node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
        return new NamedNode(MAX_NAME, node);
      }
      toString() {
        return pathSlice(this.indexPath_, 0).join("/");
      }
    };
    var ValueIndex = class extends Index {
      static {
        __name(this, "ValueIndex");
      }
      compare(a2, b2) {
        const indexCmp = a2.node.compareTo(b2.node);
        if (indexCmp === 0) {
          return nameCompare(a2.name, b2.name);
        } else {
          return indexCmp;
        }
      }
      isDefinedOn(node) {
        return true;
      }
      indexedValueChanged(oldNode, newNode) {
        return !oldNode.equals(newNode);
      }
      minPost() {
        return NamedNode.MIN;
      }
      maxPost() {
        return NamedNode.MAX;
      }
      makePost(indexValue, name) {
        const valueNode = nodeFromJSON(indexValue);
        return new NamedNode(name, valueNode);
      }
      /**
       * @returns String representation for inclusion in a query spec
       */
      toString() {
        return ".value";
      }
    };
    var VALUE_INDEX = new ValueIndex();
    function changeValue(snapshotNode) {
      return { type: "value", snapshotNode };
    }
    __name(changeValue, "changeValue");
    function changeChildAdded(childName, snapshotNode) {
      return { type: "child_added", snapshotNode, childName };
    }
    __name(changeChildAdded, "changeChildAdded");
    function changeChildRemoved(childName, snapshotNode) {
      return { type: "child_removed", snapshotNode, childName };
    }
    __name(changeChildRemoved, "changeChildRemoved");
    function changeChildChanged(childName, snapshotNode, oldSnap) {
      return {
        type: "child_changed",
        snapshotNode,
        childName,
        oldSnap
      };
    }
    __name(changeChildChanged, "changeChildChanged");
    function changeChildMoved(childName, snapshotNode) {
      return { type: "child_moved", snapshotNode, childName };
    }
    __name(changeChildMoved, "changeChildMoved");
    var IndexedFilter = class {
      static {
        __name(this, "IndexedFilter");
      }
      constructor(index_) {
        this.index_ = index_;
      }
      updateChild(snap, key2, newChild, affectedPath, source, optChangeAccumulator) {
        util.assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
        const oldChild = snap.getImmediateChild(key2);
        if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
          if (oldChild.isEmpty() === newChild.isEmpty()) {
            return snap;
          }
        }
        if (optChangeAccumulator != null) {
          if (newChild.isEmpty()) {
            if (snap.hasChild(key2)) {
              optChangeAccumulator.trackChildChange(changeChildRemoved(key2, oldChild));
            } else {
              util.assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node");
            }
          } else if (oldChild.isEmpty()) {
            optChangeAccumulator.trackChildChange(changeChildAdded(key2, newChild));
          } else {
            optChangeAccumulator.trackChildChange(changeChildChanged(key2, newChild, oldChild));
          }
        }
        if (snap.isLeafNode() && newChild.isEmpty()) {
          return snap;
        } else {
          return snap.updateImmediateChild(key2, newChild).withIndex(this.index_);
        }
      }
      updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (optChangeAccumulator != null) {
          if (!oldSnap.isLeafNode()) {
            oldSnap.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
              if (!newSnap.hasChild(key2)) {
                optChangeAccumulator.trackChildChange(changeChildRemoved(key2, childNode));
              }
            });
          }
          if (!newSnap.isLeafNode()) {
            newSnap.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
              if (oldSnap.hasChild(key2)) {
                const oldChild = oldSnap.getImmediateChild(key2);
                if (!oldChild.equals(childNode)) {
                  optChangeAccumulator.trackChildChange(changeChildChanged(key2, childNode, oldChild));
                }
              } else {
                optChangeAccumulator.trackChildChange(changeChildAdded(key2, childNode));
              }
            });
          }
        }
        return newSnap.withIndex(this.index_);
      }
      updatePriority(oldSnap, newPriority) {
        if (oldSnap.isEmpty()) {
          return ChildrenNode.EMPTY_NODE;
        } else {
          return oldSnap.updatePriority(newPriority);
        }
      }
      filtersNodes() {
        return false;
      }
      getIndexedFilter() {
        return this;
      }
      getIndex() {
        return this.index_;
      }
    };
    var RangedFilter = class _RangedFilter {
      static {
        __name(this, "RangedFilter");
      }
      constructor(params) {
        this.indexedFilter_ = new IndexedFilter(params.getIndex());
        this.index_ = params.getIndex();
        this.startPost_ = _RangedFilter.getStartPost_(params);
        this.endPost_ = _RangedFilter.getEndPost_(params);
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
      }
      getStartPost() {
        return this.startPost_;
      }
      getEndPost() {
        return this.endPost_;
      }
      matches(node) {
        const isWithinStart = this.startIsInclusive_ ? this.index_.compare(this.getStartPost(), node) <= 0 : this.index_.compare(this.getStartPost(), node) < 0;
        const isWithinEnd = this.endIsInclusive_ ? this.index_.compare(node, this.getEndPost()) <= 0 : this.index_.compare(node, this.getEndPost()) < 0;
        return isWithinStart && isWithinEnd;
      }
      updateChild(snap, key2, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.matches(new NamedNode(key2, newChild))) {
          newChild = ChildrenNode.EMPTY_NODE;
        }
        return this.indexedFilter_.updateChild(snap, key2, newChild, affectedPath, source, optChangeAccumulator);
      }
      updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        if (newSnap.isLeafNode()) {
          newSnap = ChildrenNode.EMPTY_NODE;
        }
        let filtered = newSnap.withIndex(this.index_);
        filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
        const self2 = this;
        newSnap.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
          if (!self2.matches(new NamedNode(key2, childNode))) {
            filtered = filtered.updateImmediateChild(key2, ChildrenNode.EMPTY_NODE);
          }
        });
        return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
      }
      updatePriority(oldSnap, newPriority) {
        return oldSnap;
      }
      filtersNodes() {
        return true;
      }
      getIndexedFilter() {
        return this.indexedFilter_;
      }
      getIndex() {
        return this.index_;
      }
      static getStartPost_(params) {
        if (params.hasStart()) {
          const startName = params.getIndexStartName();
          return params.getIndex().makePost(params.getIndexStartValue(), startName);
        } else {
          return params.getIndex().minPost();
        }
      }
      static getEndPost_(params) {
        if (params.hasEnd()) {
          const endName = params.getIndexEndName();
          return params.getIndex().makePost(params.getIndexEndValue(), endName);
        } else {
          return params.getIndex().maxPost();
        }
      }
    };
    var LimitedFilter = class {
      static {
        __name(this, "LimitedFilter");
      }
      constructor(params) {
        this.withinDirectionalStart = (node) => this.reverse_ ? this.withinEndPost(node) : this.withinStartPost(node);
        this.withinDirectionalEnd = (node) => this.reverse_ ? this.withinStartPost(node) : this.withinEndPost(node);
        this.withinStartPost = (node) => {
          const compareRes = this.index_.compare(this.rangedFilter_.getStartPost(), node);
          return this.startIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.withinEndPost = (node) => {
          const compareRes = this.index_.compare(node, this.rangedFilter_.getEndPost());
          return this.endIsInclusive_ ? compareRes <= 0 : compareRes < 0;
        };
        this.rangedFilter_ = new RangedFilter(params);
        this.index_ = params.getIndex();
        this.limit_ = params.getLimit();
        this.reverse_ = !params.isViewFromLeft();
        this.startIsInclusive_ = !params.startAfterSet_;
        this.endIsInclusive_ = !params.endBeforeSet_;
      }
      updateChild(snap, key2, newChild, affectedPath, source, optChangeAccumulator) {
        if (!this.rangedFilter_.matches(new NamedNode(key2, newChild))) {
          newChild = ChildrenNode.EMPTY_NODE;
        }
        if (snap.getImmediateChild(key2).equals(newChild)) {
          return snap;
        } else if (snap.numChildren() < this.limit_) {
          return this.rangedFilter_.getIndexedFilter().updateChild(snap, key2, newChild, affectedPath, source, optChangeAccumulator);
        } else {
          return this.fullLimitUpdateChild_(snap, key2, newChild, source, optChangeAccumulator);
        }
      }
      updateFullNode(oldSnap, newSnap, optChangeAccumulator) {
        let filtered;
        if (newSnap.isLeafNode() || newSnap.isEmpty()) {
          filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
        } else {
          if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
            filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
            let iterator;
            if (this.reverse_) {
              iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
            } else {
              iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
            }
            let count3 = 0;
            while (iterator.hasNext() && count3 < this.limit_) {
              const next = iterator.getNext();
              if (!this.withinDirectionalStart(next)) {
                continue;
              } else if (!this.withinDirectionalEnd(next)) {
                break;
              } else {
                filtered = filtered.updateImmediateChild(next.name, next.node);
                count3++;
              }
            }
          } else {
            filtered = newSnap.withIndex(this.index_);
            filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
            let iterator;
            if (this.reverse_) {
              iterator = filtered.getReverseIterator(this.index_);
            } else {
              iterator = filtered.getIterator(this.index_);
            }
            let count3 = 0;
            while (iterator.hasNext()) {
              const next = iterator.getNext();
              const inRange = count3 < this.limit_ && this.withinDirectionalStart(next) && this.withinDirectionalEnd(next);
              if (inRange) {
                count3++;
              } else {
                filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
              }
            }
          }
        }
        return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
      }
      updatePriority(oldSnap, newPriority) {
        return oldSnap;
      }
      filtersNodes() {
        return true;
      }
      getIndexedFilter() {
        return this.rangedFilter_.getIndexedFilter();
      }
      getIndex() {
        return this.index_;
      }
      fullLimitUpdateChild_(snap, childKey, childSnap, source, changeAccumulator) {
        let cmp;
        if (this.reverse_) {
          const indexCmp = this.index_.getCompare();
          cmp = /* @__PURE__ */ __name((a2, b2) => indexCmp(b2, a2), "cmp");
        } else {
          cmp = this.index_.getCompare();
        }
        const oldEventCache = snap;
        util.assert(oldEventCache.numChildren() === this.limit_, "");
        const newChildNamedNode = new NamedNode(childKey, childSnap);
        const windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
        const inRange = this.rangedFilter_.matches(newChildNamedNode);
        if (oldEventCache.hasChild(childKey)) {
          const oldChildSnap = oldEventCache.getImmediateChild(childKey);
          let nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
          while (nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
            nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
          }
          const compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
          const remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
          if (remainsInWindow) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
            }
            return oldEventCache.updateImmediateChild(childKey, childSnap);
          } else {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
            }
            const newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
            const nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
            if (nextChildInRange) {
              if (changeAccumulator != null) {
                changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
              }
              return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
            } else {
              return newEventCache;
            }
          }
        } else if (childSnap.isEmpty()) {
          return snap;
        } else if (inRange) {
          if (cmp(windowBoundary, newChildNamedNode) >= 0) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
              changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
            }
            return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
          } else {
            return snap;
          }
        } else {
          return snap;
        }
      }
    };
    var QueryParams = class _QueryParams2 {
      static {
        __name(this, "QueryParams");
      }
      constructor() {
        this.limitSet_ = false;
        this.startSet_ = false;
        this.startNameSet_ = false;
        this.startAfterSet_ = false;
        this.endSet_ = false;
        this.endNameSet_ = false;
        this.endBeforeSet_ = false;
        this.limit_ = 0;
        this.viewFrom_ = "";
        this.indexStartValue_ = null;
        this.indexStartName_ = "";
        this.indexEndValue_ = null;
        this.indexEndName_ = "";
        this.index_ = PRIORITY_INDEX;
      }
      hasStart() {
        return this.startSet_;
      }
      /**
       * @returns True if it would return from left.
       */
      isViewFromLeft() {
        if (this.viewFrom_ === "") {
          return this.startSet_;
        } else {
          return this.viewFrom_ === "l";
        }
      }
      /**
       * Only valid to call if hasStart() returns true
       */
      getIndexStartValue() {
        util.assert(this.startSet_, "Only valid if start has been set");
        return this.indexStartValue_;
      }
      /**
       * Only valid to call if hasStart() returns true.
       * Returns the starting key name for the range defined by these query parameters
       */
      getIndexStartName() {
        util.assert(this.startSet_, "Only valid if start has been set");
        if (this.startNameSet_) {
          return this.indexStartName_;
        } else {
          return MIN_NAME;
        }
      }
      hasEnd() {
        return this.endSet_;
      }
      /**
       * Only valid to call if hasEnd() returns true.
       */
      getIndexEndValue() {
        util.assert(this.endSet_, "Only valid if end has been set");
        return this.indexEndValue_;
      }
      /**
       * Only valid to call if hasEnd() returns true.
       * Returns the end key name for the range defined by these query parameters
       */
      getIndexEndName() {
        util.assert(this.endSet_, "Only valid if end has been set");
        if (this.endNameSet_) {
          return this.indexEndName_;
        } else {
          return MAX_NAME;
        }
      }
      hasLimit() {
        return this.limitSet_;
      }
      /**
       * @returns True if a limit has been set and it has been explicitly anchored
       */
      hasAnchoredLimit() {
        return this.limitSet_ && this.viewFrom_ !== "";
      }
      /**
       * Only valid to call if hasLimit() returns true
       */
      getLimit() {
        util.assert(this.limitSet_, "Only valid if limit has been set");
        return this.limit_;
      }
      getIndex() {
        return this.index_;
      }
      loadsAllData() {
        return !(this.startSet_ || this.endSet_ || this.limitSet_);
      }
      isDefault() {
        return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
      }
      copy() {
        const copy = new _QueryParams2();
        copy.limitSet_ = this.limitSet_;
        copy.limit_ = this.limit_;
        copy.startSet_ = this.startSet_;
        copy.startAfterSet_ = this.startAfterSet_;
        copy.indexStartValue_ = this.indexStartValue_;
        copy.startNameSet_ = this.startNameSet_;
        copy.indexStartName_ = this.indexStartName_;
        copy.endSet_ = this.endSet_;
        copy.endBeforeSet_ = this.endBeforeSet_;
        copy.indexEndValue_ = this.indexEndValue_;
        copy.endNameSet_ = this.endNameSet_;
        copy.indexEndName_ = this.indexEndName_;
        copy.index_ = this.index_;
        copy.viewFrom_ = this.viewFrom_;
        return copy;
      }
    };
    function queryParamsGetNodeFilter(queryParams) {
      if (queryParams.loadsAllData()) {
        return new IndexedFilter(queryParams.getIndex());
      } else if (queryParams.hasLimit()) {
        return new LimitedFilter(queryParams);
      } else {
        return new RangedFilter(queryParams);
      }
    }
    __name(queryParamsGetNodeFilter, "queryParamsGetNodeFilter");
    function queryParamsLimitToFirst(queryParams, newLimit) {
      const newParams = queryParams.copy();
      newParams.limitSet_ = true;
      newParams.limit_ = newLimit;
      newParams.viewFrom_ = "l";
      return newParams;
    }
    __name(queryParamsLimitToFirst, "queryParamsLimitToFirst");
    function queryParamsLimitToLast(queryParams, newLimit) {
      const newParams = queryParams.copy();
      newParams.limitSet_ = true;
      newParams.limit_ = newLimit;
      newParams.viewFrom_ = "r";
      return newParams;
    }
    __name(queryParamsLimitToLast, "queryParamsLimitToLast");
    function queryParamsStartAt(queryParams, indexValue, key2) {
      const newParams = queryParams.copy();
      newParams.startSet_ = true;
      if (indexValue === void 0) {
        indexValue = null;
      }
      newParams.indexStartValue_ = indexValue;
      if (key2 != null) {
        newParams.startNameSet_ = true;
        newParams.indexStartName_ = key2;
      } else {
        newParams.startNameSet_ = false;
        newParams.indexStartName_ = "";
      }
      return newParams;
    }
    __name(queryParamsStartAt, "queryParamsStartAt");
    function queryParamsStartAfter(queryParams, indexValue, key2) {
      let params;
      if (queryParams.index_ === KEY_INDEX || !!key2) {
        params = queryParamsStartAt(queryParams, indexValue, key2);
      } else {
        params = queryParamsStartAt(queryParams, indexValue, MAX_NAME);
      }
      params.startAfterSet_ = true;
      return params;
    }
    __name(queryParamsStartAfter, "queryParamsStartAfter");
    function queryParamsEndAt(queryParams, indexValue, key2) {
      const newParams = queryParams.copy();
      newParams.endSet_ = true;
      if (indexValue === void 0) {
        indexValue = null;
      }
      newParams.indexEndValue_ = indexValue;
      if (key2 !== void 0) {
        newParams.endNameSet_ = true;
        newParams.indexEndName_ = key2;
      } else {
        newParams.endNameSet_ = false;
        newParams.indexEndName_ = "";
      }
      return newParams;
    }
    __name(queryParamsEndAt, "queryParamsEndAt");
    function queryParamsEndBefore(queryParams, indexValue, key2) {
      let params;
      if (queryParams.index_ === KEY_INDEX || !!key2) {
        params = queryParamsEndAt(queryParams, indexValue, key2);
      } else {
        params = queryParamsEndAt(queryParams, indexValue, MIN_NAME);
      }
      params.endBeforeSet_ = true;
      return params;
    }
    __name(queryParamsEndBefore, "queryParamsEndBefore");
    function queryParamsOrderBy(queryParams, index) {
      const newParams = queryParams.copy();
      newParams.index_ = index;
      return newParams;
    }
    __name(queryParamsOrderBy, "queryParamsOrderBy");
    function queryParamsToRestQueryStringParameters(queryParams) {
      const qs = {};
      if (queryParams.isDefault()) {
        return qs;
      }
      let orderBy;
      if (queryParams.index_ === PRIORITY_INDEX) {
        orderBy = "$priority";
      } else if (queryParams.index_ === VALUE_INDEX) {
        orderBy = "$value";
      } else if (queryParams.index_ === KEY_INDEX) {
        orderBy = "$key";
      } else {
        util.assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
        orderBy = queryParams.index_.toString();
      }
      qs[
        "orderBy"
        /* REST_QUERY_CONSTANTS.ORDER_BY */
      ] = util.stringify(orderBy);
      if (queryParams.startSet_) {
        const startParam = queryParams.startAfterSet_ ? "startAfter" : "startAt";
        qs[startParam] = util.stringify(queryParams.indexStartValue_);
        if (queryParams.startNameSet_) {
          qs[startParam] += "," + util.stringify(queryParams.indexStartName_);
        }
      }
      if (queryParams.endSet_) {
        const endParam = queryParams.endBeforeSet_ ? "endBefore" : "endAt";
        qs[endParam] = util.stringify(queryParams.indexEndValue_);
        if (queryParams.endNameSet_) {
          qs[endParam] += "," + util.stringify(queryParams.indexEndName_);
        }
      }
      if (queryParams.limitSet_) {
        if (queryParams.isViewFromLeft()) {
          qs[
            "limitToFirst"
            /* REST_QUERY_CONSTANTS.LIMIT_TO_FIRST */
          ] = queryParams.limit_;
        } else {
          qs[
            "limitToLast"
            /* REST_QUERY_CONSTANTS.LIMIT_TO_LAST */
          ] = queryParams.limit_;
        }
      }
      return qs;
    }
    __name(queryParamsToRestQueryStringParameters, "queryParamsToRestQueryStringParameters");
    function queryParamsGetQueryObject(queryParams) {
      const obj = {};
      if (queryParams.startSet_) {
        obj[
          "sp"
          /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_VALUE */
        ] = queryParams.indexStartValue_;
        if (queryParams.startNameSet_) {
          obj[
            "sn"
            /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_NAME */
          ] = queryParams.indexStartName_;
        }
        obj[
          "sin"
          /* WIRE_PROTOCOL_CONSTANTS.INDEX_START_IS_INCLUSIVE */
        ] = !queryParams.startAfterSet_;
      }
      if (queryParams.endSet_) {
        obj[
          "ep"
          /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_VALUE */
        ] = queryParams.indexEndValue_;
        if (queryParams.endNameSet_) {
          obj[
            "en"
            /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_NAME */
          ] = queryParams.indexEndName_;
        }
        obj[
          "ein"
          /* WIRE_PROTOCOL_CONSTANTS.INDEX_END_IS_INCLUSIVE */
        ] = !queryParams.endBeforeSet_;
      }
      if (queryParams.limitSet_) {
        obj[
          "l"
          /* WIRE_PROTOCOL_CONSTANTS.LIMIT */
        ] = queryParams.limit_;
        let viewFrom = queryParams.viewFrom_;
        if (viewFrom === "") {
          if (queryParams.isViewFromLeft()) {
            viewFrom = "l";
          } else {
            viewFrom = "r";
          }
        }
        obj[
          "vf"
          /* WIRE_PROTOCOL_CONSTANTS.VIEW_FROM */
        ] = viewFrom;
      }
      if (queryParams.index_ !== PRIORITY_INDEX) {
        obj[
          "i"
          /* WIRE_PROTOCOL_CONSTANTS.INDEX */
        ] = queryParams.index_.toString();
      }
      return obj;
    }
    __name(queryParamsGetQueryObject, "queryParamsGetQueryObject");
    var ReadonlyRestClient = class _ReadonlyRestClient extends ServerActions {
      static {
        __name(this, "ReadonlyRestClient");
      }
      reportStats(stats) {
        throw new Error("Method not implemented.");
      }
      static getListenId_(query2, tag) {
        if (tag !== void 0) {
          return "tag$" + tag;
        } else {
          util.assert(query2._queryParams.isDefault(), "should have a tag if it's not a default query.");
          return query2._path.toString();
        }
      }
      /**
       * @param repoInfo_ - Data about the namespace we are connecting to
       * @param onDataUpdate_ - A callback for new data from the server
       */
      constructor(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
        super();
        this.repoInfo_ = repoInfo_;
        this.onDataUpdate_ = onDataUpdate_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckTokenProvider_ = appCheckTokenProvider_;
        this.log_ = logWrapper("p:rest:");
        this.listens_ = {};
      }
      /** @inheritDoc */
      listen(query2, currentHashFn, tag, onComplete) {
        const pathString = query2._path.toString();
        this.log_("Listen called for " + pathString + " " + query2._queryIdentifier);
        const listenId = _ReadonlyRestClient.getListenId_(query2, tag);
        const thisListen = {};
        this.listens_[listenId] = thisListen;
        const queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
        this.restRequest_(pathString + ".json", queryStringParameters, (error4, result) => {
          let data = result;
          if (error4 === 404) {
            data = null;
            error4 = null;
          }
          if (error4 === null) {
            this.onDataUpdate_(
              pathString,
              data,
              /*isMerge=*/
              false,
              tag
            );
          }
          if (util.safeGet(this.listens_, listenId) === thisListen) {
            let status;
            if (!error4) {
              status = "ok";
            } else if (error4 === 401) {
              status = "permission_denied";
            } else {
              status = "rest_error:" + error4;
            }
            onComplete(status, null);
          }
        });
      }
      /** @inheritDoc */
      unlisten(query2, tag) {
        const listenId = _ReadonlyRestClient.getListenId_(query2, tag);
        delete this.listens_[listenId];
      }
      get(query2) {
        const queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
        const pathString = query2._path.toString();
        const deferred = new util.Deferred();
        this.restRequest_(pathString + ".json", queryStringParameters, (error4, result) => {
          let data = result;
          if (error4 === 404) {
            data = null;
            error4 = null;
          }
          if (error4 === null) {
            this.onDataUpdate_(
              pathString,
              data,
              /*isMerge=*/
              false,
              /*tag=*/
              null
            );
            deferred.resolve(data);
          } else {
            deferred.reject(new Error(data));
          }
        });
        return deferred.promise;
      }
      /** @inheritDoc */
      refreshAuthToken(token) {
      }
      /**
       * Performs a REST request to the given path, with the provided query string parameters,
       * and any auth credentials we have.
       */
      restRequest_(pathString, queryStringParameters = {}, callback) {
        queryStringParameters["format"] = "export";
        return Promise.all([
          this.authTokenProvider_.getToken(
            /*forceRefresh=*/
            false
          ),
          this.appCheckTokenProvider_.getToken(
            /*forceRefresh=*/
            false
          )
        ]).then(([authToken, appCheckToken]) => {
          if (authToken && authToken.accessToken) {
            queryStringParameters["auth"] = authToken.accessToken;
          }
          if (appCheckToken && appCheckToken.token) {
            queryStringParameters["ac"] = appCheckToken.token;
          }
          const url2 = (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host + pathString + "?ns=" + this.repoInfo_.namespace + util.querystring(queryStringParameters);
          this.log_("Sending REST request for " + url2);
          const xhr = new XMLHttpRequest();
          xhr.onreadystatechange = () => {
            if (callback && xhr.readyState === 4) {
              this.log_("REST Response for " + url2 + " received. status:", xhr.status, "response:", xhr.responseText);
              let res = null;
              if (xhr.status >= 200 && xhr.status < 300) {
                try {
                  res = util.jsonEval(xhr.responseText);
                } catch (e) {
                  warn$1("Failed to parse JSON response for " + url2 + ": " + xhr.responseText);
                }
                callback(null, res);
              } else {
                if (xhr.status !== 401 && xhr.status !== 404) {
                  warn$1("Got unsuccessful REST response for " + url2 + " Status: " + xhr.status);
                }
                callback(xhr.status);
              }
              callback = null;
            }
          };
          xhr.open(
            "GET",
            url2,
            /*asynchronous=*/
            true
          );
          xhr.send();
        });
      }
    };
    var SnapshotHolder = class {
      static {
        __name(this, "SnapshotHolder");
      }
      constructor() {
        this.rootNode_ = ChildrenNode.EMPTY_NODE;
      }
      getNode(path) {
        return this.rootNode_.getChild(path);
      }
      updateSnapshot(path, newSnapshotNode) {
        this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
      }
    };
    function newSparseSnapshotTree() {
      return {
        value: null,
        children: /* @__PURE__ */ new Map()
      };
    }
    __name(newSparseSnapshotTree, "newSparseSnapshotTree");
    function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
      if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = data;
        sparseSnapshotTree.children.clear();
      } else if (sparseSnapshotTree.value !== null) {
        sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
      } else {
        const childKey = pathGetFront(path);
        if (!sparseSnapshotTree.children.has(childKey)) {
          sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
        }
        const child2 = sparseSnapshotTree.children.get(childKey);
        path = pathPopFront(path);
        sparseSnapshotTreeRemember(child2, path, data);
      }
    }
    __name(sparseSnapshotTreeRemember, "sparseSnapshotTreeRemember");
    function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
      if (pathIsEmpty(path)) {
        sparseSnapshotTree.value = null;
        sparseSnapshotTree.children.clear();
        return true;
      } else {
        if (sparseSnapshotTree.value !== null) {
          if (sparseSnapshotTree.value.isLeafNode()) {
            return false;
          } else {
            const value = sparseSnapshotTree.value;
            sparseSnapshotTree.value = null;
            value.forEachChild(PRIORITY_INDEX, (key2, tree) => {
              sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key2), tree);
            });
            return sparseSnapshotTreeForget(sparseSnapshotTree, path);
          }
        } else if (sparseSnapshotTree.children.size > 0) {
          const childKey = pathGetFront(path);
          path = pathPopFront(path);
          if (sparseSnapshotTree.children.has(childKey)) {
            const safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
            if (safeToRemove) {
              sparseSnapshotTree.children.delete(childKey);
            }
          }
          return sparseSnapshotTree.children.size === 0;
        } else {
          return true;
        }
      }
    }
    __name(sparseSnapshotTreeForget, "sparseSnapshotTreeForget");
    function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
      if (sparseSnapshotTree.value !== null) {
        func(prefixPath, sparseSnapshotTree.value);
      } else {
        sparseSnapshotTreeForEachChild(sparseSnapshotTree, (key2, tree) => {
          const path = new Path(prefixPath.toString() + "/" + key2);
          sparseSnapshotTreeForEachTree(tree, path, func);
        });
      }
    }
    __name(sparseSnapshotTreeForEachTree, "sparseSnapshotTreeForEachTree");
    function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
      sparseSnapshotTree.children.forEach((tree, key2) => {
        func(key2, tree);
      });
    }
    __name(sparseSnapshotTreeForEachChild, "sparseSnapshotTreeForEachChild");
    var StatsListener = class {
      static {
        __name(this, "StatsListener");
      }
      constructor(collection_) {
        this.collection_ = collection_;
        this.last_ = null;
      }
      get() {
        const newStats = this.collection_.get();
        const delta = Object.assign({}, newStats);
        if (this.last_) {
          each(this.last_, (stat3, value) => {
            delta[stat3] = delta[stat3] - value;
          });
        }
        this.last_ = newStats;
        return delta;
      }
    };
    var FIRST_STATS_MIN_TIME = 10 * 1e3;
    var FIRST_STATS_MAX_TIME = 30 * 1e3;
    var REPORT_STATS_INTERVAL = 5 * 60 * 1e3;
    var StatsReporter = class {
      static {
        __name(this, "StatsReporter");
      }
      constructor(collection, server_) {
        this.server_ = server_;
        this.statsToReport_ = {};
        this.statsListener_ = new StatsListener(collection);
        const timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
      }
      reportStats_() {
        const stats = this.statsListener_.get();
        const reportedStats = {};
        let haveStatsToReport = false;
        each(stats, (stat3, value) => {
          if (value > 0 && util.contains(this.statsToReport_, stat3)) {
            reportedStats[stat3] = value;
            haveStatsToReport = true;
          }
        });
        if (haveStatsToReport) {
          this.server_.reportStats(reportedStats);
        }
        setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
      }
    };
    var OperationType;
    (function(OperationType2) {
      OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
      OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
      OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
      OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
    })(OperationType || (OperationType = {}));
    function newOperationSourceUser() {
      return {
        fromUser: true,
        fromServer: false,
        queryId: null,
        tagged: false
      };
    }
    __name(newOperationSourceUser, "newOperationSourceUser");
    function newOperationSourceServer() {
      return {
        fromUser: false,
        fromServer: true,
        queryId: null,
        tagged: false
      };
    }
    __name(newOperationSourceServer, "newOperationSourceServer");
    function newOperationSourceServerTaggedQuery(queryId) {
      return {
        fromUser: false,
        fromServer: true,
        queryId,
        tagged: true
      };
    }
    __name(newOperationSourceServerTaggedQuery, "newOperationSourceServerTaggedQuery");
    var AckUserWrite = class _AckUserWrite {
      static {
        __name(this, "AckUserWrite");
      }
      /**
       * @param affectedTree - A tree containing true for each affected path. Affected paths can't overlap.
       */
      constructor(path, affectedTree, revert) {
        this.path = path;
        this.affectedTree = affectedTree;
        this.revert = revert;
        this.type = OperationType.ACK_USER_WRITE;
        this.source = newOperationSourceUser();
      }
      operationForChild(childName) {
        if (!pathIsEmpty(this.path)) {
          util.assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
          return new _AckUserWrite(pathPopFront(this.path), this.affectedTree, this.revert);
        } else if (this.affectedTree.value != null) {
          util.assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
          return this;
        } else {
          const childTree = this.affectedTree.subtree(new Path(childName));
          return new _AckUserWrite(newEmptyPath(), childTree, this.revert);
        }
      }
    };
    var ListenComplete = class _ListenComplete {
      static {
        __name(this, "ListenComplete");
      }
      constructor(source, path) {
        this.source = source;
        this.path = path;
        this.type = OperationType.LISTEN_COMPLETE;
      }
      operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
          return new _ListenComplete(this.source, newEmptyPath());
        } else {
          return new _ListenComplete(this.source, pathPopFront(this.path));
        }
      }
    };
    var Overwrite = class _Overwrite {
      static {
        __name(this, "Overwrite");
      }
      constructor(source, path, snap) {
        this.source = source;
        this.path = path;
        this.snap = snap;
        this.type = OperationType.OVERWRITE;
      }
      operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
          return new _Overwrite(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
        } else {
          return new _Overwrite(this.source, pathPopFront(this.path), this.snap);
        }
      }
    };
    var Merge = class _Merge {
      static {
        __name(this, "Merge");
      }
      constructor(source, path, children) {
        this.source = source;
        this.path = path;
        this.children = children;
        this.type = OperationType.MERGE;
      }
      operationForChild(childName) {
        if (pathIsEmpty(this.path)) {
          const childTree = this.children.subtree(new Path(childName));
          if (childTree.isEmpty()) {
            return null;
          } else if (childTree.value) {
            return new Overwrite(this.source, newEmptyPath(), childTree.value);
          } else {
            return new _Merge(this.source, newEmptyPath(), childTree);
          }
        } else {
          util.assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
          return new _Merge(this.source, pathPopFront(this.path), this.children);
        }
      }
      toString() {
        return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
      }
    };
    var CacheNode = class {
      static {
        __name(this, "CacheNode");
      }
      constructor(node_, fullyInitialized_, filtered_) {
        this.node_ = node_;
        this.fullyInitialized_ = fullyInitialized_;
        this.filtered_ = filtered_;
      }
      /**
       * Returns whether this node was fully initialized with either server data or a complete overwrite by the client
       */
      isFullyInitialized() {
        return this.fullyInitialized_;
      }
      /**
       * Returns whether this node is potentially missing children due to a filter applied to the node
       */
      isFiltered() {
        return this.filtered_;
      }
      isCompleteForPath(path) {
        if (pathIsEmpty(path)) {
          return this.isFullyInitialized() && !this.filtered_;
        }
        const childKey = pathGetFront(path);
        return this.isCompleteForChild(childKey);
      }
      isCompleteForChild(key2) {
        return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key2);
      }
      getNode() {
        return this.node_;
      }
    };
    var EventGenerator = class {
      static {
        __name(this, "EventGenerator");
      }
      constructor(query_) {
        this.query_ = query_;
        this.index_ = this.query_._queryParams.getIndex();
      }
    };
    function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
      const events = [];
      const moves = [];
      changes.forEach((change) => {
        if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
          moves.push(changeChildMoved(change.childName, change.snapshotNode));
        }
      });
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved", moves, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed", changes, eventRegistrations, eventCache);
      eventGeneratorGenerateEventsForType(eventGenerator, events, "value", changes, eventRegistrations, eventCache);
      return events;
    }
    __name(eventGeneratorGenerateEventsForChanges, "eventGeneratorGenerateEventsForChanges");
    function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
      const filteredChanges = changes.filter((change) => change.type === eventType);
      filteredChanges.sort((a2, b2) => eventGeneratorCompareChanges(eventGenerator, a2, b2));
      filteredChanges.forEach((change) => {
        const materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
        registrations.forEach((registration) => {
          if (registration.respondsTo(change.type)) {
            events.push(registration.createEvent(materializedChange, eventGenerator.query_));
          }
        });
      });
    }
    __name(eventGeneratorGenerateEventsForType, "eventGeneratorGenerateEventsForType");
    function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
      if (change.type === "value" || change.type === "child_removed") {
        return change;
      } else {
        change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
        return change;
      }
    }
    __name(eventGeneratorMaterializeSingleChange, "eventGeneratorMaterializeSingleChange");
    function eventGeneratorCompareChanges(eventGenerator, a2, b2) {
      if (a2.childName == null || b2.childName == null) {
        throw util.assertionError("Should only compare child_ events.");
      }
      const aWrapped = new NamedNode(a2.childName, a2.snapshotNode);
      const bWrapped = new NamedNode(b2.childName, b2.snapshotNode);
      return eventGenerator.index_.compare(aWrapped, bWrapped);
    }
    __name(eventGeneratorCompareChanges, "eventGeneratorCompareChanges");
    function newViewCache(eventCache, serverCache) {
      return { eventCache, serverCache };
    }
    __name(newViewCache, "newViewCache");
    function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
      return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
    }
    __name(viewCacheUpdateEventSnap, "viewCacheUpdateEventSnap");
    function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
      return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
    }
    __name(viewCacheUpdateServerSnap, "viewCacheUpdateServerSnap");
    function viewCacheGetCompleteEventSnap(viewCache) {
      return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
    }
    __name(viewCacheGetCompleteEventSnap, "viewCacheGetCompleteEventSnap");
    function viewCacheGetCompleteServerSnap(viewCache) {
      return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
    }
    __name(viewCacheGetCompleteServerSnap, "viewCacheGetCompleteServerSnap");
    var emptyChildrenSingleton;
    var EmptyChildren = /* @__PURE__ */ __name(() => {
      if (!emptyChildrenSingleton) {
        emptyChildrenSingleton = new SortedMap(stringCompare);
      }
      return emptyChildrenSingleton;
    }, "EmptyChildren");
    var ImmutableTree = class _ImmutableTree {
      static {
        __name(this, "ImmutableTree");
      }
      static fromObject(obj) {
        let tree = new _ImmutableTree(null);
        each(obj, (childPath, childSnap) => {
          tree = tree.set(new Path(childPath), childSnap);
        });
        return tree;
      }
      constructor(value, children = EmptyChildren()) {
        this.value = value;
        this.children = children;
      }
      /**
       * True if the value is empty and there are no children
       */
      isEmpty() {
        return this.value === null && this.children.isEmpty();
      }
      /**
       * Given a path and predicate, return the first node and the path to that node
       * where the predicate returns true.
       *
       * TODO Do a perf test -- If we're creating a bunch of `{path: value:}`
       * objects on the way back out, it may be better to pass down a pathSoFar obj.
       *
       * @param relativePath - The remainder of the path
       * @param predicate - The predicate to satisfy to return a node
       */
      findRootMostMatchingPathAndValue(relativePath, predicate) {
        if (this.value != null && predicate(this.value)) {
          return { path: newEmptyPath(), value: this.value };
        } else {
          if (pathIsEmpty(relativePath)) {
            return null;
          } else {
            const front = pathGetFront(relativePath);
            const child2 = this.children.get(front);
            if (child2 !== null) {
              const childExistingPathAndValue = child2.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
              if (childExistingPathAndValue != null) {
                const fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
                return { path: fullPath, value: childExistingPathAndValue.value };
              } else {
                return null;
              }
            } else {
              return null;
            }
          }
        }
      }
      /**
       * Find, if it exists, the shortest subpath of the given path that points a defined
       * value in the tree
       */
      findRootMostValueAndPath(relativePath) {
        return this.findRootMostMatchingPathAndValue(relativePath, () => true);
      }
      /**
       * @returns The subtree at the given path
       */
      subtree(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this;
        } else {
          const front = pathGetFront(relativePath);
          const childTree = this.children.get(front);
          if (childTree !== null) {
            return childTree.subtree(pathPopFront(relativePath));
          } else {
            return new _ImmutableTree(null);
          }
        }
      }
      /**
       * Sets a value at the specified path.
       *
       * @param relativePath - Path to set value at.
       * @param toSet - Value to set.
       * @returns Resulting tree.
       */
      set(relativePath, toSet) {
        if (pathIsEmpty(relativePath)) {
          return new _ImmutableTree(toSet, this.children);
        } else {
          const front = pathGetFront(relativePath);
          const child2 = this.children.get(front) || new _ImmutableTree(null);
          const newChild = child2.set(pathPopFront(relativePath), toSet);
          const newChildren = this.children.insert(front, newChild);
          return new _ImmutableTree(this.value, newChildren);
        }
      }
      /**
       * Removes the value at the specified path.
       *
       * @param relativePath - Path to value to remove.
       * @returns Resulting tree.
       */
      remove(relativePath) {
        if (pathIsEmpty(relativePath)) {
          if (this.children.isEmpty()) {
            return new _ImmutableTree(null);
          } else {
            return new _ImmutableTree(null, this.children);
          }
        } else {
          const front = pathGetFront(relativePath);
          const child2 = this.children.get(front);
          if (child2) {
            const newChild = child2.remove(pathPopFront(relativePath));
            let newChildren;
            if (newChild.isEmpty()) {
              newChildren = this.children.remove(front);
            } else {
              newChildren = this.children.insert(front, newChild);
            }
            if (this.value === null && newChildren.isEmpty()) {
              return new _ImmutableTree(null);
            } else {
              return new _ImmutableTree(this.value, newChildren);
            }
          } else {
            return this;
          }
        }
      }
      /**
       * Gets a value from the tree.
       *
       * @param relativePath - Path to get value for.
       * @returns Value at path, or null.
       */
      get(relativePath) {
        if (pathIsEmpty(relativePath)) {
          return this.value;
        } else {
          const front = pathGetFront(relativePath);
          const child2 = this.children.get(front);
          if (child2) {
            return child2.get(pathPopFront(relativePath));
          } else {
            return null;
          }
        }
      }
      /**
       * Replace the subtree at the specified path with the given new tree.
       *
       * @param relativePath - Path to replace subtree for.
       * @param newTree - New tree.
       * @returns Resulting tree.
       */
      setTree(relativePath, newTree) {
        if (pathIsEmpty(relativePath)) {
          return newTree;
        } else {
          const front = pathGetFront(relativePath);
          const child2 = this.children.get(front) || new _ImmutableTree(null);
          const newChild = child2.setTree(pathPopFront(relativePath), newTree);
          let newChildren;
          if (newChild.isEmpty()) {
            newChildren = this.children.remove(front);
          } else {
            newChildren = this.children.insert(front, newChild);
          }
          return new _ImmutableTree(this.value, newChildren);
        }
      }
      /**
       * Performs a depth first fold on this tree. Transforms a tree into a single
       * value, given a function that operates on the path to a node, an optional
       * current value, and a map of child names to folded subtrees
       */
      fold(fn) {
        return this.fold_(newEmptyPath(), fn);
      }
      /**
       * Recursive helper for public-facing fold() method
       */
      fold_(pathSoFar, fn) {
        const accum = {};
        this.children.inorderTraversal((childKey, childTree) => {
          accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
        });
        return fn(pathSoFar, this.value, accum);
      }
      /**
       * Find the first matching value on the given path. Return the result of applying f to it.
       */
      findOnPath(path, f) {
        return this.findOnPath_(path, newEmptyPath(), f);
      }
      findOnPath_(pathToFollow, pathSoFar, f) {
        const result = this.value ? f(pathSoFar, this.value) : false;
        if (result) {
          return result;
        } else {
          if (pathIsEmpty(pathToFollow)) {
            return null;
          } else {
            const front = pathGetFront(pathToFollow);
            const nextChild = this.children.get(front);
            if (nextChild) {
              return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
            } else {
              return null;
            }
          }
        }
      }
      foreachOnPath(path, f) {
        return this.foreachOnPath_(path, newEmptyPath(), f);
      }
      foreachOnPath_(pathToFollow, currentRelativePath, f) {
        if (pathIsEmpty(pathToFollow)) {
          return this;
        } else {
          if (this.value) {
            f(currentRelativePath, this.value);
          }
          const front = pathGetFront(pathToFollow);
          const nextChild = this.children.get(front);
          if (nextChild) {
            return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
          } else {
            return new _ImmutableTree(null);
          }
        }
      }
      /**
       * Calls the given function for each node in the tree that has a value.
       *
       * @param f - A function to be called with the path from the root of the tree to
       * a node, and the value at that node. Called in depth-first order.
       */
      foreach(f) {
        this.foreach_(newEmptyPath(), f);
      }
      foreach_(currentRelativePath, f) {
        this.children.inorderTraversal((childName, childTree) => {
          childTree.foreach_(pathChild(currentRelativePath, childName), f);
        });
        if (this.value) {
          f(currentRelativePath, this.value);
        }
      }
      foreachChild(f) {
        this.children.inorderTraversal((childName, childTree) => {
          if (childTree.value) {
            f(childName, childTree.value);
          }
        });
      }
    };
    var CompoundWrite = class _CompoundWrite {
      static {
        __name(this, "CompoundWrite");
      }
      constructor(writeTree_) {
        this.writeTree_ = writeTree_;
      }
      static empty() {
        return new _CompoundWrite(new ImmutableTree(null));
      }
    };
    function compoundWriteAddWrite(compoundWrite, path, node) {
      if (pathIsEmpty(path)) {
        return new CompoundWrite(new ImmutableTree(node));
      } else {
        const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
        if (rootmost != null) {
          const rootMostPath = rootmost.path;
          let value = rootmost.value;
          const relativePath = newRelativePath(rootMostPath, path);
          value = value.updateChild(relativePath, node);
          return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
        } else {
          const subtree = new ImmutableTree(node);
          const newWriteTree2 = compoundWrite.writeTree_.setTree(path, subtree);
          return new CompoundWrite(newWriteTree2);
        }
      }
    }
    __name(compoundWriteAddWrite, "compoundWriteAddWrite");
    function compoundWriteAddWrites(compoundWrite, path, updates) {
      let newWrite = compoundWrite;
      each(updates, (childKey, node) => {
        newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
      });
      return newWrite;
    }
    __name(compoundWriteAddWrites, "compoundWriteAddWrites");
    function compoundWriteRemoveWrite(compoundWrite, path) {
      if (pathIsEmpty(path)) {
        return CompoundWrite.empty();
      } else {
        const newWriteTree2 = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
        return new CompoundWrite(newWriteTree2);
      }
    }
    __name(compoundWriteRemoveWrite, "compoundWriteRemoveWrite");
    function compoundWriteHasCompleteWrite(compoundWrite, path) {
      return compoundWriteGetCompleteNode(compoundWrite, path) != null;
    }
    __name(compoundWriteHasCompleteWrite, "compoundWriteHasCompleteWrite");
    function compoundWriteGetCompleteNode(compoundWrite, path) {
      const rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
      if (rootmost != null) {
        return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));
      } else {
        return null;
      }
    }
    __name(compoundWriteGetCompleteNode, "compoundWriteGetCompleteNode");
    function compoundWriteGetCompleteChildren(compoundWrite) {
      const children = [];
      const node = compoundWrite.writeTree_.value;
      if (node != null) {
        if (!node.isLeafNode()) {
          node.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
            children.push(new NamedNode(childName, childNode));
          });
        }
      } else {
        compoundWrite.writeTree_.children.inorderTraversal((childName, childTree) => {
          if (childTree.value != null) {
            children.push(new NamedNode(childName, childTree.value));
          }
        });
      }
      return children;
    }
    __name(compoundWriteGetCompleteChildren, "compoundWriteGetCompleteChildren");
    function compoundWriteChildCompoundWrite(compoundWrite, path) {
      if (pathIsEmpty(path)) {
        return compoundWrite;
      } else {
        const shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
        if (shadowingNode != null) {
          return new CompoundWrite(new ImmutableTree(shadowingNode));
        } else {
          return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
        }
      }
    }
    __name(compoundWriteChildCompoundWrite, "compoundWriteChildCompoundWrite");
    function compoundWriteIsEmpty(compoundWrite) {
      return compoundWrite.writeTree_.isEmpty();
    }
    __name(compoundWriteIsEmpty, "compoundWriteIsEmpty");
    function compoundWriteApply(compoundWrite, node) {
      return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
    }
    __name(compoundWriteApply, "compoundWriteApply");
    function applySubtreeWrite(relativePath, writeTree, node) {
      if (writeTree.value != null) {
        return node.updateChild(relativePath, writeTree.value);
      } else {
        let priorityWrite = null;
        writeTree.children.inorderTraversal((childKey, childTree) => {
          if (childKey === ".priority") {
            util.assert(childTree.value !== null, "Priority writes must always be leaf nodes");
            priorityWrite = childTree.value;
          } else {
            node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
          }
        });
        if (!node.getChild(relativePath).isEmpty() && priorityWrite !== null) {
          node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite);
        }
        return node;
      }
    }
    __name(applySubtreeWrite, "applySubtreeWrite");
    function writeTreeChildWrites(writeTree, path) {
      return newWriteTreeRef(path, writeTree);
    }
    __name(writeTreeChildWrites, "writeTreeChildWrites");
    function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
      util.assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
      if (visible === void 0) {
        visible = true;
      }
      writeTree.allWrites.push({
        path,
        snap,
        writeId,
        visible
      });
      if (visible) {
        writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
      }
      writeTree.lastWriteId = writeId;
    }
    __name(writeTreeAddOverwrite, "writeTreeAddOverwrite");
    function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
      util.assert(writeId > writeTree.lastWriteId, "Stacking an older merge on top of newer ones");
      writeTree.allWrites.push({
        path,
        children: changedChildren,
        writeId,
        visible: true
      });
      writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
      writeTree.lastWriteId = writeId;
    }
    __name(writeTreeAddMerge, "writeTreeAddMerge");
    function writeTreeGetWrite(writeTree, writeId) {
      for (let i = 0; i < writeTree.allWrites.length; i++) {
        const record = writeTree.allWrites[i];
        if (record.writeId === writeId) {
          return record;
        }
      }
      return null;
    }
    __name(writeTreeGetWrite, "writeTreeGetWrite");
    function writeTreeRemoveWrite(writeTree, writeId) {
      const idx = writeTree.allWrites.findIndex((s) => {
        return s.writeId === writeId;
      });
      util.assert(idx >= 0, "removeWrite called with nonexistent writeId.");
      const writeToRemove = writeTree.allWrites[idx];
      writeTree.allWrites.splice(idx, 1);
      let removedWriteWasVisible = writeToRemove.visible;
      let removedWriteOverlapsWithOtherWrites = false;
      let i = writeTree.allWrites.length - 1;
      while (removedWriteWasVisible && i >= 0) {
        const currentWrite = writeTree.allWrites[i];
        if (currentWrite.visible) {
          if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
            removedWriteWasVisible = false;
          } else if (pathContains(writeToRemove.path, currentWrite.path)) {
            removedWriteOverlapsWithOtherWrites = true;
          }
        }
        i--;
      }
      if (!removedWriteWasVisible) {
        return false;
      } else if (removedWriteOverlapsWithOtherWrites) {
        writeTreeResetTree_(writeTree);
        return true;
      } else {
        if (writeToRemove.snap) {
          writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
        } else {
          const children = writeToRemove.children;
          each(children, (childName) => {
            writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
          });
        }
        return true;
      }
    }
    __name(writeTreeRemoveWrite, "writeTreeRemoveWrite");
    function writeTreeRecordContainsPath_(writeRecord, path) {
      if (writeRecord.snap) {
        return pathContains(writeRecord.path, path);
      } else {
        for (const childName in writeRecord.children) {
          if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {
            return true;
          }
        }
        return false;
      }
    }
    __name(writeTreeRecordContainsPath_, "writeTreeRecordContainsPath_");
    function writeTreeResetTree_(writeTree) {
      writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
      if (writeTree.allWrites.length > 0) {
        writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
      } else {
        writeTree.lastWriteId = -1;
      }
    }
    __name(writeTreeResetTree_, "writeTreeResetTree_");
    function writeTreeDefaultFilter_(write2) {
      return write2.visible;
    }
    __name(writeTreeDefaultFilter_, "writeTreeDefaultFilter_");
    function writeTreeLayerTree_(writes, filter, treeRoot) {
      let compoundWrite = CompoundWrite.empty();
      for (let i = 0; i < writes.length; ++i) {
        const write2 = writes[i];
        if (filter(write2)) {
          const writePath = write2.path;
          let relativePath;
          if (write2.snap) {
            if (pathContains(treeRoot, writePath)) {
              relativePath = newRelativePath(treeRoot, writePath);
              compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write2.snap);
            } else if (pathContains(writePath, treeRoot)) {
              relativePath = newRelativePath(writePath, treeRoot);
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write2.snap.getChild(relativePath));
            } else ;
          } else if (write2.children) {
            if (pathContains(treeRoot, writePath)) {
              relativePath = newRelativePath(treeRoot, writePath);
              compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write2.children);
            } else if (pathContains(writePath, treeRoot)) {
              relativePath = newRelativePath(writePath, treeRoot);
              if (pathIsEmpty(relativePath)) {
                compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write2.children);
              } else {
                const child2 = util.safeGet(write2.children, pathGetFront(relativePath));
                if (child2) {
                  const deepNode = child2.getChild(pathPopFront(relativePath));
                  compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
                }
              }
            } else ;
          } else {
            throw util.assertionError("WriteRecord should have .snap or .children");
          }
        }
      }
      return compoundWrite;
    }
    __name(writeTreeLayerTree_, "writeTreeLayerTree_");
    function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
      if (!writeIdsToExclude && !includeHiddenWrites) {
        const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
        if (shadowingNode != null) {
          return shadowingNode;
        } else {
          const subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
          if (compoundWriteIsEmpty(subMerge)) {
            return completeServerCache;
          } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
            return null;
          } else {
            const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
            return compoundWriteApply(subMerge, layeredCache);
          }
        }
      } else {
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
          return completeServerCache;
        } else {
          if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
            return null;
          } else {
            const filter = /* @__PURE__ */ __name(function(write2) {
              return (write2.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write2.writeId)) && (pathContains(write2.path, treePath) || pathContains(treePath, write2.path));
            }, "filter");
            const mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
            const layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
            return compoundWriteApply(mergeAtPath, layeredCache);
          }
        }
      }
    }
    __name(writeTreeCalcCompleteEventCache, "writeTreeCalcCompleteEventCache");
    function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
      let completeChildren = ChildrenNode.EMPTY_NODE;
      const topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
      if (topLevelSet) {
        if (!topLevelSet.isLeafNode()) {
          topLevelSet.forEachChild(PRIORITY_INDEX, (childName, childSnap) => {
            completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
          });
        }
        return completeChildren;
      } else if (completeServerChildren) {
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        completeServerChildren.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
          const node = compoundWriteApply(compoundWriteChildCompoundWrite(merge, new Path(childName)), childNode);
          completeChildren = completeChildren.updateImmediateChild(childName, node);
        });
        compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
          completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
      } else {
        const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
        compoundWriteGetCompleteChildren(merge).forEach((namedNode) => {
          completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
        });
        return completeChildren;
      }
    }
    __name(writeTreeCalcCompleteEventChildren, "writeTreeCalcCompleteEventChildren");
    function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
      util.assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
      const path = pathChild(treePath, childPath);
      if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
        return null;
      } else {
        const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
        if (compoundWriteIsEmpty(childMerge)) {
          return existingServerSnap.getChild(childPath);
        } else {
          return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
        }
      }
    }
    __name(writeTreeCalcEventCacheAfterServerOverwrite, "writeTreeCalcEventCacheAfterServerOverwrite");
    function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
      const path = pathChild(treePath, childKey);
      const shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
      if (shadowingNode != null) {
        return shadowingNode;
      } else {
        if (existingServerSnap.isCompleteForChild(childKey)) {
          const childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
          return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
        } else {
          return null;
        }
      }
    }
    __name(writeTreeCalcCompleteChild, "writeTreeCalcCompleteChild");
    function writeTreeShadowingWrite(writeTree, path) {
      return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
    }
    __name(writeTreeShadowingWrite, "writeTreeShadowingWrite");
    function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count3, reverse, index) {
      let toIterate;
      const merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      const shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
      if (shadowingNode != null) {
        toIterate = shadowingNode;
      } else if (completeServerData != null) {
        toIterate = compoundWriteApply(merge, completeServerData);
      } else {
        return [];
      }
      toIterate = toIterate.withIndex(index);
      if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
        const nodes = [];
        const cmp = index.getCompare();
        const iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
        let next = iter.getNext();
        while (next && nodes.length < count3) {
          if (cmp(next, startPost) !== 0) {
            nodes.push(next);
          }
          next = iter.getNext();
        }
        return nodes;
      } else {
        return [];
      }
    }
    __name(writeTreeCalcIndexedSlice, "writeTreeCalcIndexedSlice");
    function newWriteTree() {
      return {
        visibleWrites: CompoundWrite.empty(),
        allWrites: [],
        lastWriteId: -1
      };
    }
    __name(newWriteTree, "newWriteTree");
    function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
      return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
    }
    __name(writeTreeRefCalcCompleteEventCache, "writeTreeRefCalcCompleteEventCache");
    function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
      return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
    }
    __name(writeTreeRefCalcCompleteEventChildren, "writeTreeRefCalcCompleteEventChildren");
    function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
      return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
    }
    __name(writeTreeRefCalcEventCacheAfterServerOverwrite, "writeTreeRefCalcEventCacheAfterServerOverwrite");
    function writeTreeRefShadowingWrite(writeTreeRef, path) {
      return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
    }
    __name(writeTreeRefShadowingWrite, "writeTreeRefShadowingWrite");
    function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count3, reverse, index) {
      return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count3, reverse, index);
    }
    __name(writeTreeRefCalcIndexedSlice, "writeTreeRefCalcIndexedSlice");
    function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
      return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
    }
    __name(writeTreeRefCalcCompleteChild, "writeTreeRefCalcCompleteChild");
    function writeTreeRefChild(writeTreeRef, childName) {
      return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
    }
    __name(writeTreeRefChild, "writeTreeRefChild");
    function newWriteTreeRef(path, writeTree) {
      return {
        treePath: path,
        writeTree
      };
    }
    __name(newWriteTreeRef, "newWriteTreeRef");
    var ChildChangeAccumulator = class {
      static {
        __name(this, "ChildChangeAccumulator");
      }
      constructor() {
        this.changeMap = /* @__PURE__ */ new Map();
      }
      trackChildChange(change) {
        const type2 = change.type;
        const childKey = change.childName;
        util.assert(type2 === "child_added" || type2 === "child_changed" || type2 === "child_removed", "Only child changes supported for tracking");
        util.assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
        const oldChange = this.changeMap.get(childKey);
        if (oldChange) {
          const oldType = oldChange.type;
          if (type2 === "child_added" && oldType === "child_removed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
          } else if (type2 === "child_removed" && oldType === "child_added") {
            this.changeMap.delete(childKey);
          } else if (type2 === "child_removed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
          } else if (type2 === "child_changed" && oldType === "child_added") {
            this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
          } else if (type2 === "child_changed" && oldType === "child_changed") {
            this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
          } else {
            throw util.assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
          }
        } else {
          this.changeMap.set(childKey, change);
        }
      }
      getChanges() {
        return Array.from(this.changeMap.values());
      }
    };
    var NoCompleteChildSource_ = class {
      static {
        __name(this, "NoCompleteChildSource_");
      }
      getCompleteChild(childKey) {
        return null;
      }
      getChildAfterChild(index, child2, reverse) {
        return null;
      }
    };
    var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
    var WriteTreeCompleteChildSource = class {
      static {
        __name(this, "WriteTreeCompleteChildSource");
      }
      constructor(writes_, viewCache_, optCompleteServerCache_ = null) {
        this.writes_ = writes_;
        this.viewCache_ = viewCache_;
        this.optCompleteServerCache_ = optCompleteServerCache_;
      }
      getCompleteChild(childKey) {
        const node = this.viewCache_.eventCache;
        if (node.isCompleteForChild(childKey)) {
          return node.getNode().getImmediateChild(childKey);
        } else {
          const serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
          return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
        }
      }
      getChildAfterChild(index, child2, reverse) {
        const completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
        const nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child2, 1, reverse, index);
        if (nodes.length === 0) {
          return null;
        } else {
          return nodes[0];
        }
      }
    };
    function newViewProcessor(filter) {
      return { filter };
    }
    __name(newViewProcessor, "newViewProcessor");
    function viewProcessorAssertIndexed(viewProcessor, viewCache) {
      util.assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
      util.assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
    }
    __name(viewProcessorAssertIndexed, "viewProcessorAssertIndexed");
    function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
      const accumulator = new ChildChangeAccumulator();
      let newViewCache2, filterServerNode;
      if (operation.type === OperationType.OVERWRITE) {
        const overwrite = operation;
        if (overwrite.source.fromUser) {
          newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
        } else {
          util.assert(overwrite.source.fromServer, "Unknown source.");
          filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
          newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
        }
      } else if (operation.type === OperationType.MERGE) {
        const merge = operation;
        if (merge.source.fromUser) {
          newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
        } else {
          util.assert(merge.source.fromServer, "Unknown source.");
          filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
          newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
        }
      } else if (operation.type === OperationType.ACK_USER_WRITE) {
        const ackUserWrite = operation;
        if (!ackUserWrite.revert) {
          newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
        } else {
          newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
        }
      } else if (operation.type === OperationType.LISTEN_COMPLETE) {
        newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
      } else {
        throw util.assertionError("Unknown operation type: " + operation.type);
      }
      const changes = accumulator.getChanges();
      viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
      return { viewCache: newViewCache2, changes };
    }
    __name(viewProcessorApplyOperation, "viewProcessorApplyOperation");
    function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, accumulator) {
      const eventSnap = newViewCache2.eventCache;
      if (eventSnap.isFullyInitialized()) {
        const isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
        const oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
        if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
          accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
        }
      }
    }
    __name(viewProcessorMaybeAddValueEvent, "viewProcessorMaybeAddValueEvent");
    function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
      const oldEventSnap = viewCache.eventCache;
      if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
        return viewCache;
      } else {
        let newEventCache, serverNode;
        if (pathIsEmpty(changePath)) {
          util.assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
          if (viewCache.serverCache.isFiltered()) {
            const serverCache = viewCacheGetCompleteServerSnap(viewCache);
            const completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
            const completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
            newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
          } else {
            const completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
          }
        } else {
          const childKey = pathGetFront(changePath);
          if (childKey === ".priority") {
            util.assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
            const oldEventNode = oldEventSnap.getNode();
            serverNode = viewCache.serverCache.getNode();
            const updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
            if (updatedPriority != null) {
              newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
            } else {
              newEventCache = oldEventSnap.getNode();
            }
          } else {
            const childChangePath = pathPopFront(changePath);
            let newEventChild;
            if (oldEventSnap.isCompleteForChild(childKey)) {
              serverNode = viewCache.serverCache.getNode();
              const eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
              if (eventChildUpdate != null) {
                newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
              } else {
                newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
              }
            } else {
              newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
            }
            if (newEventChild != null) {
              newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
            } else {
              newEventCache = oldEventSnap.getNode();
            }
          }
        }
        return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
      }
    }
    __name(viewProcessorGenerateEventCacheAfterServerEvent, "viewProcessorGenerateEventCacheAfterServerEvent");
    function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
      const oldServerSnap = oldViewCache.serverCache;
      let newServerCache;
      const serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
      if (pathIsEmpty(changePath)) {
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
      } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
        const newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
        newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
      } else {
        const childKey = pathGetFront(changePath);
        if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
          return oldViewCache;
        }
        const childChangePath = pathPopFront(changePath);
        const childNode = oldServerSnap.getNode().getImmediateChild(childKey);
        const newChildNode = childNode.updateChild(childChangePath, changedSnap);
        if (childKey === ".priority") {
          newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
        } else {
          newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
        }
      }
      const newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
      const source = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
      return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source, accumulator);
    }
    __name(viewProcessorApplyServerOverwrite, "viewProcessorApplyServerOverwrite");
    function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
      const oldEventSnap = oldViewCache.eventCache;
      let newViewCache2, newEventCache;
      const source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
      if (pathIsEmpty(changePath)) {
        newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
      } else {
        const childKey = pathGetFront(changePath);
        if (childKey === ".priority") {
          newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
          newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
        } else {
          const childChangePath = pathPopFront(changePath);
          const oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
          let newChild;
          if (pathIsEmpty(childChangePath)) {
            newChild = changedSnap;
          } else {
            const childNode = source.getCompleteChild(childKey);
            if (childNode != null) {
              if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
                newChild = childNode;
              } else {
                newChild = childNode.updateChild(childChangePath, changedSnap);
              }
            } else {
              newChild = ChildrenNode.EMPTY_NODE;
            }
          }
          if (!oldChild.equals(newChild)) {
            const newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
            newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
          } else {
            newViewCache2 = oldViewCache;
          }
        }
      }
      return newViewCache2;
    }
    __name(viewProcessorApplyUserOverwrite, "viewProcessorApplyUserOverwrite");
    function viewProcessorCacheHasChild(viewCache, childKey) {
      return viewCache.eventCache.isCompleteForChild(childKey);
    }
    __name(viewProcessorCacheHasChild, "viewProcessorCacheHasChild");
    function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
      let curViewCache = viewCache;
      changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
          curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
      });
      changedChildren.foreach((relativePath, childNode) => {
        const writePath = pathChild(path, relativePath);
        if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
          curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
        }
      });
      return curViewCache;
    }
    __name(viewProcessorApplyUserMerge, "viewProcessorApplyUserMerge");
    function viewProcessorApplyMerge(viewProcessor, node, merge) {
      merge.foreach((relativePath, childNode) => {
        node = node.updateChild(relativePath, childNode);
      });
      return node;
    }
    __name(viewProcessorApplyMerge, "viewProcessorApplyMerge");
    function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
      if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
        return viewCache;
      }
      let curViewCache = viewCache;
      let viewMergeTree;
      if (pathIsEmpty(path)) {
        viewMergeTree = changedChildren;
      } else {
        viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
      }
      const serverNode = viewCache.serverCache.getNode();
      viewMergeTree.children.inorderTraversal((childKey, childTree) => {
        if (serverNode.hasChild(childKey)) {
          const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
          const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
          curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
      });
      viewMergeTree.children.inorderTraversal((childKey, childMergeTree) => {
        const isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === null;
        if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
          const serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
          const newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
          curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
        }
      });
      return curViewCache;
    }
    __name(viewProcessorApplyServerMerge, "viewProcessorApplyServerMerge");
    function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
      if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
        return viewCache;
      }
      const filterServerNode = viewCache.serverCache.isFiltered();
      const serverCache = viewCache.serverCache;
      if (affectedTree.value != null) {
        if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
          return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
        } else if (pathIsEmpty(ackPath)) {
          let changedChildren = new ImmutableTree(null);
          serverCache.getNode().forEachChild(KEY_INDEX, (name, node) => {
            changedChildren = changedChildren.set(new Path(name), node);
          });
          return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
        } else {
          return viewCache;
        }
      } else {
        let changedChildren = new ImmutableTree(null);
        affectedTree.foreach((mergePath, value) => {
          const serverCachePath = pathChild(ackPath, mergePath);
          if (serverCache.isCompleteForPath(serverCachePath)) {
            changedChildren = changedChildren.set(mergePath, serverCache.getNode().getChild(serverCachePath));
          }
        });
        return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren, writesCache, completeCache, filterServerNode, accumulator);
      }
    }
    __name(viewProcessorAckUserWrite, "viewProcessorAckUserWrite");
    function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
      const oldServerNode = viewCache.serverCache;
      const newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
      return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
    }
    __name(viewProcessorListenComplete, "viewProcessorListenComplete");
    function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
      let complete;
      if (writeTreeRefShadowingWrite(writesCache, path) != null) {
        return viewCache;
      } else {
        const source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
        const oldEventCache = viewCache.eventCache.getNode();
        let newEventCache;
        if (pathIsEmpty(path) || pathGetFront(path) === ".priority") {
          let newNode;
          if (viewCache.serverCache.isFullyInitialized()) {
            newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
          } else {
            const serverChildren = viewCache.serverCache.getNode();
            util.assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
            newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
          }
          newNode = newNode;
          newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
        } else {
          const childKey = pathGetFront(path);
          let newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
          if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
            newChild = oldEventCache.getImmediateChild(childKey);
          }
          if (newChild != null) {
            newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
          } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
            newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
          } else {
            newEventCache = oldEventCache;
          }
          if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
            complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
            if (complete.isLeafNode()) {
              newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
            }
          }
        }
        complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
        return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
      }
    }
    __name(viewProcessorRevertUserWrite, "viewProcessorRevertUserWrite");
    var View = class {
      static {
        __name(this, "View");
      }
      constructor(query_, initialViewCache) {
        this.query_ = query_;
        this.eventRegistrations_ = [];
        const params = this.query_._queryParams;
        const indexFilter = new IndexedFilter(params.getIndex());
        const filter = queryParamsGetNodeFilter(params);
        this.processor_ = newViewProcessor(filter);
        const initialServerCache = initialViewCache.serverCache;
        const initialEventCache = initialViewCache.eventCache;
        const serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
        const eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
        const newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
        const newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
        this.viewCache_ = newViewCache(newEventCache, newServerCache);
        this.eventGenerator_ = new EventGenerator(this.query_);
      }
      get query() {
        return this.query_;
      }
    };
    function viewGetServerCache(view) {
      return view.viewCache_.serverCache.getNode();
    }
    __name(viewGetServerCache, "viewGetServerCache");
    function viewGetCompleteNode(view) {
      return viewCacheGetCompleteEventSnap(view.viewCache_);
    }
    __name(viewGetCompleteNode, "viewGetCompleteNode");
    function viewGetCompleteServerCache(view, path) {
      const cache = viewCacheGetCompleteServerSnap(view.viewCache_);
      if (cache) {
        if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {
          return cache.getChild(path);
        }
      }
      return null;
    }
    __name(viewGetCompleteServerCache, "viewGetCompleteServerCache");
    function viewIsEmpty(view) {
      return view.eventRegistrations_.length === 0;
    }
    __name(viewIsEmpty, "viewIsEmpty");
    function viewAddEventRegistration(view, eventRegistration) {
      view.eventRegistrations_.push(eventRegistration);
    }
    __name(viewAddEventRegistration, "viewAddEventRegistration");
    function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
      const cancelEvents = [];
      if (cancelError) {
        util.assert(eventRegistration == null, "A cancel should cancel all event registrations.");
        const path = view.query._path;
        view.eventRegistrations_.forEach((registration) => {
          const maybeEvent = registration.createCancelEvent(cancelError, path);
          if (maybeEvent) {
            cancelEvents.push(maybeEvent);
          }
        });
      }
      if (eventRegistration) {
        let remaining = [];
        for (let i = 0; i < view.eventRegistrations_.length; ++i) {
          const existing = view.eventRegistrations_[i];
          if (!existing.matches(eventRegistration)) {
            remaining.push(existing);
          } else if (eventRegistration.hasAnyCallback()) {
            remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
            break;
          }
        }
        view.eventRegistrations_ = remaining;
      } else {
        view.eventRegistrations_ = [];
      }
      return cancelEvents;
    }
    __name(viewRemoveEventRegistration, "viewRemoveEventRegistration");
    function viewApplyOperation(view, operation, writesCache, completeServerCache) {
      if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
        util.assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
        util.assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
      }
      const oldViewCache = view.viewCache_;
      const result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
      viewProcessorAssertIndexed(view.processor_, result.viewCache);
      util.assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
      view.viewCache_ = result.viewCache;
      return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
    }
    __name(viewApplyOperation, "viewApplyOperation");
    function viewGetInitialEvents(view, registration) {
      const eventSnap = view.viewCache_.eventCache;
      const initialChanges = [];
      if (!eventSnap.getNode().isLeafNode()) {
        const eventNode = eventSnap.getNode();
        eventNode.forEachChild(PRIORITY_INDEX, (key2, childNode) => {
          initialChanges.push(changeChildAdded(key2, childNode));
        });
      }
      if (eventSnap.isFullyInitialized()) {
        initialChanges.push(changeValue(eventSnap.getNode()));
      }
      return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
    }
    __name(viewGetInitialEvents, "viewGetInitialEvents");
    function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
      const registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
      return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
    }
    __name(viewGenerateEventsForChanges_, "viewGenerateEventsForChanges_");
    var referenceConstructor$1;
    var SyncPoint = class {
      static {
        __name(this, "SyncPoint");
      }
      constructor() {
        this.views = /* @__PURE__ */ new Map();
      }
    };
    function syncPointSetReferenceConstructor(val) {
      util.assert(!referenceConstructor$1, "__referenceConstructor has already been defined");
      referenceConstructor$1 = val;
    }
    __name(syncPointSetReferenceConstructor, "syncPointSetReferenceConstructor");
    function syncPointGetReferenceConstructor() {
      util.assert(referenceConstructor$1, "Reference.ts has not been loaded");
      return referenceConstructor$1;
    }
    __name(syncPointGetReferenceConstructor, "syncPointGetReferenceConstructor");
    function syncPointIsEmpty(syncPoint) {
      return syncPoint.views.size === 0;
    }
    __name(syncPointIsEmpty, "syncPointIsEmpty");
    function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
      const queryId = operation.source.queryId;
      if (queryId !== null) {
        const view = syncPoint.views.get(queryId);
        util.assert(view != null, "SyncTree gave us an op for an invalid query.");
        return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
      } else {
        let events = [];
        for (const view of syncPoint.views.values()) {
          events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
        }
        return events;
      }
    }
    __name(syncPointApplyOperation, "syncPointApplyOperation");
    function syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete) {
      const queryId = query2._queryIdentifier;
      const view = syncPoint.views.get(queryId);
      if (!view) {
        let eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
        let eventCacheComplete = false;
        if (eventCache) {
          eventCacheComplete = true;
        } else if (serverCache instanceof ChildrenNode) {
          eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
          eventCacheComplete = false;
        } else {
          eventCache = ChildrenNode.EMPTY_NODE;
          eventCacheComplete = false;
        }
        const viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
        return new View(query2, viewCache);
      }
      return view;
    }
    __name(syncPointGetView, "syncPointGetView");
    function syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete) {
      const view = syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete);
      if (!syncPoint.views.has(query2._queryIdentifier)) {
        syncPoint.views.set(query2._queryIdentifier, view);
      }
      viewAddEventRegistration(view, eventRegistration);
      return viewGetInitialEvents(view, eventRegistration);
    }
    __name(syncPointAddEventRegistration, "syncPointAddEventRegistration");
    function syncPointRemoveEventRegistration(syncPoint, query2, eventRegistration, cancelError) {
      const queryId = query2._queryIdentifier;
      const removed = [];
      let cancelEvents = [];
      const hadCompleteView = syncPointHasCompleteView(syncPoint);
      if (queryId === "default") {
        for (const [viewQueryId, view] of syncPoint.views.entries()) {
          cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
          if (viewIsEmpty(view)) {
            syncPoint.views.delete(viewQueryId);
            if (!view.query._queryParams.loadsAllData()) {
              removed.push(view.query);
            }
          }
        }
      } else {
        const view = syncPoint.views.get(queryId);
        if (view) {
          cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
          if (viewIsEmpty(view)) {
            syncPoint.views.delete(queryId);
            if (!view.query._queryParams.loadsAllData()) {
              removed.push(view.query);
            }
          }
        }
      }
      if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
        removed.push(new (syncPointGetReferenceConstructor())(query2._repo, query2._path));
      }
      return { removed, events: cancelEvents };
    }
    __name(syncPointRemoveEventRegistration, "syncPointRemoveEventRegistration");
    function syncPointGetQueryViews(syncPoint) {
      const result = [];
      for (const view of syncPoint.views.values()) {
        if (!view.query._queryParams.loadsAllData()) {
          result.push(view);
        }
      }
      return result;
    }
    __name(syncPointGetQueryViews, "syncPointGetQueryViews");
    function syncPointGetCompleteServerCache(syncPoint, path) {
      let serverCache = null;
      for (const view of syncPoint.views.values()) {
        serverCache = serverCache || viewGetCompleteServerCache(view, path);
      }
      return serverCache;
    }
    __name(syncPointGetCompleteServerCache, "syncPointGetCompleteServerCache");
    function syncPointViewForQuery(syncPoint, query2) {
      const params = query2._queryParams;
      if (params.loadsAllData()) {
        return syncPointGetCompleteView(syncPoint);
      } else {
        const queryId = query2._queryIdentifier;
        return syncPoint.views.get(queryId);
      }
    }
    __name(syncPointViewForQuery, "syncPointViewForQuery");
    function syncPointViewExistsForQuery(syncPoint, query2) {
      return syncPointViewForQuery(syncPoint, query2) != null;
    }
    __name(syncPointViewExistsForQuery, "syncPointViewExistsForQuery");
    function syncPointHasCompleteView(syncPoint) {
      return syncPointGetCompleteView(syncPoint) != null;
    }
    __name(syncPointHasCompleteView, "syncPointHasCompleteView");
    function syncPointGetCompleteView(syncPoint) {
      for (const view of syncPoint.views.values()) {
        if (view.query._queryParams.loadsAllData()) {
          return view;
        }
      }
      return null;
    }
    __name(syncPointGetCompleteView, "syncPointGetCompleteView");
    var referenceConstructor;
    function syncTreeSetReferenceConstructor(val) {
      util.assert(!referenceConstructor, "__referenceConstructor has already been defined");
      referenceConstructor = val;
    }
    __name(syncTreeSetReferenceConstructor, "syncTreeSetReferenceConstructor");
    function syncTreeGetReferenceConstructor() {
      util.assert(referenceConstructor, "Reference.ts has not been loaded");
      return referenceConstructor;
    }
    __name(syncTreeGetReferenceConstructor, "syncTreeGetReferenceConstructor");
    var syncTreeNextQueryTag_ = 1;
    var SyncTree = class {
      static {
        __name(this, "SyncTree");
      }
      /**
       * @param listenProvider_ - Used by SyncTree to start / stop listening
       *   to server data.
       */
      constructor(listenProvider_) {
        this.listenProvider_ = listenProvider_;
        this.syncPointTree_ = new ImmutableTree(null);
        this.pendingWriteTree_ = newWriteTree();
        this.tagToQueryMap = /* @__PURE__ */ new Map();
        this.queryToTagMap = /* @__PURE__ */ new Map();
      }
    };
    function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
      writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
      if (!visible) {
        return [];
      } else {
        return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
      }
    }
    __name(syncTreeApplyUserOverwrite, "syncTreeApplyUserOverwrite");
    function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
      writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
      const changeTree = ImmutableTree.fromObject(changedChildren);
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
    }
    __name(syncTreeApplyUserMerge, "syncTreeApplyUserMerge");
    function syncTreeAckUserWrite(syncTree, writeId, revert = false) {
      const write2 = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
      const needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
      if (!needToReevaluate) {
        return [];
      } else {
        let affectedTree = new ImmutableTree(null);
        if (write2.snap != null) {
          affectedTree = affectedTree.set(newEmptyPath(), true);
        } else {
          each(write2.children, (pathString) => {
            affectedTree = affectedTree.set(new Path(pathString), true);
          });
        }
        return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write2.path, affectedTree, revert));
      }
    }
    __name(syncTreeAckUserWrite, "syncTreeAckUserWrite");
    function syncTreeApplyServerOverwrite(syncTree, path, newData) {
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
    }
    __name(syncTreeApplyServerOverwrite, "syncTreeApplyServerOverwrite");
    function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
      const changeTree = ImmutableTree.fromObject(changedChildren);
      return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
    }
    __name(syncTreeApplyServerMerge, "syncTreeApplyServerMerge");
    function syncTreeApplyListenComplete(syncTree, path) {
      return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
    }
    __name(syncTreeApplyListenComplete, "syncTreeApplyListenComplete");
    function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
      const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    __name(syncTreeApplyTaggedListenComplete, "syncTreeApplyTaggedListenComplete");
    function syncTreeRemoveEventRegistration(syncTree, query2, eventRegistration, cancelError, skipListenerDedup = false) {
      const path = query2._path;
      const maybeSyncPoint = syncTree.syncPointTree_.get(path);
      let cancelEvents = [];
      if (maybeSyncPoint && (query2._queryIdentifier === "default" || syncPointViewExistsForQuery(maybeSyncPoint, query2))) {
        const removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query2, eventRegistration, cancelError);
        if (syncPointIsEmpty(maybeSyncPoint)) {
          syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
        }
        const removed = removedAndEvents.removed;
        cancelEvents = removedAndEvents.events;
        if (!skipListenerDedup) {
          const removingDefault = -1 !== removed.findIndex((query3) => {
            return query3._queryParams.loadsAllData();
          });
          const covered = syncTree.syncPointTree_.findOnPath(path, (relativePath, parentSyncPoint) => syncPointHasCompleteView(parentSyncPoint));
          if (removingDefault && !covered) {
            const subtree = syncTree.syncPointTree_.subtree(path);
            if (!subtree.isEmpty()) {
              const newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
              for (let i = 0; i < newViews.length; ++i) {
                const view = newViews[i], newQuery = view.query;
                const listener = syncTreeCreateListenerForView_(syncTree, view);
                syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery(syncTree, newQuery), listener.hashFn, listener.onComplete);
              }
            }
          }
          if (!covered && removed.length > 0 && !cancelError) {
            if (removingDefault) {
              const defaultTag = null;
              syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query2), defaultTag);
            } else {
              removed.forEach((queryToRemove) => {
                const tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
                syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
              });
            }
          }
        }
        syncTreeRemoveTags_(syncTree, removed);
      }
      return cancelEvents;
    }
    __name(syncTreeRemoveEventRegistration, "syncTreeRemoveEventRegistration");
    function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
      const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey != null) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    __name(syncTreeApplyTaggedQueryOverwrite, "syncTreeApplyTaggedQueryOverwrite");
    function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
      const queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
      if (queryKey) {
        const r = syncTreeParseQueryKey_(queryKey);
        const queryPath = r.path, queryId = r.queryId;
        const relativePath = newRelativePath(queryPath, path);
        const changeTree = ImmutableTree.fromObject(changedChildren);
        const op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
        return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
      } else {
        return [];
      }
    }
    __name(syncTreeApplyTaggedQueryMerge, "syncTreeApplyTaggedQueryMerge");
    function syncTreeAddEventRegistration(syncTree, query2, eventRegistration, skipSetupListener = false) {
      const path = query2._path;
      let serverCache = null;
      let foundAncestorDefaultView = false;
      syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);
      });
      let syncPoint = syncTree.syncPointTree_.get(path);
      if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
      } else {
        foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      let serverCacheComplete;
      if (serverCache != null) {
        serverCacheComplete = true;
      } else {
        serverCacheComplete = false;
        serverCache = ChildrenNode.EMPTY_NODE;
        const subtree = syncTree.syncPointTree_.subtree(path);
        subtree.foreachChild((childName, childSyncPoint) => {
          const completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
          if (completeCache) {
            serverCache = serverCache.updateImmediateChild(childName, completeCache);
          }
        });
      }
      const viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query2);
      if (!viewAlreadyExists && !query2._queryParams.loadsAllData()) {
        const queryKey = syncTreeMakeQueryKey_(query2);
        util.assert(!syncTree.queryToTagMap.has(queryKey), "View does not exist, but we have a tag");
        const tag = syncTreeGetNextQueryTag_();
        syncTree.queryToTagMap.set(queryKey, tag);
        syncTree.tagToQueryMap.set(tag, queryKey);
      }
      const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
      let events = syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete);
      if (!viewAlreadyExists && !foundAncestorDefaultView && !skipSetupListener) {
        const view = syncPointViewForQuery(syncPoint, query2);
        events = events.concat(syncTreeSetupListener_(syncTree, query2, view));
      }
      return events;
    }
    __name(syncTreeAddEventRegistration, "syncTreeAddEventRegistration");
    function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
      const includeHiddenSets = true;
      const writeTree = syncTree.pendingWriteTree_;
      const serverCache = syncTree.syncPointTree_.findOnPath(path, (pathSoFar, syncPoint) => {
        const relativePath = newRelativePath(pathSoFar, path);
        const serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
        if (serverCache2) {
          return serverCache2;
        }
      });
      return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
    }
    __name(syncTreeCalcCompleteEventCache, "syncTreeCalcCompleteEventCache");
    function syncTreeGetServerValue(syncTree, query2) {
      const path = query2._path;
      let serverCache = null;
      syncTree.syncPointTree_.foreachOnPath(path, (pathToSyncPoint, sp) => {
        const relativePath = newRelativePath(pathToSyncPoint, path);
        serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
      });
      let syncPoint = syncTree.syncPointTree_.get(path);
      if (!syncPoint) {
        syncPoint = new SyncPoint();
        syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
      } else {
        serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      const serverCacheComplete = serverCache != null;
      const serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;
      const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query2._path);
      const view = syncPointGetView(syncPoint, query2, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
      return viewGetCompleteNode(view);
    }
    __name(syncTreeGetServerValue, "syncTreeGetServerValue");
    function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
      return syncTreeApplyOperationHelper_(
        operation,
        syncTree.syncPointTree_,
        /*serverCache=*/
        null,
        writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath())
      );
    }
    __name(syncTreeApplyOperationToSyncPoints_, "syncTreeApplyOperationToSyncPoints_");
    function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
      if (pathIsEmpty(operation.path)) {
        return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
      } else {
        const syncPoint = syncPointTree.get(newEmptyPath());
        if (serverCache == null && syncPoint != null) {
          serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
        }
        let events = [];
        const childName = pathGetFront(operation.path);
        const childOperation = operation.operationForChild(childName);
        const childTree = syncPointTree.children.get(childName);
        if (childTree && childOperation) {
          const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
          const childWritesCache = writeTreeRefChild(writesCache, childName);
          events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
        if (syncPoint) {
          events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
        }
        return events;
      }
    }
    __name(syncTreeApplyOperationHelper_, "syncTreeApplyOperationHelper_");
    function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
      const syncPoint = syncPointTree.get(newEmptyPath());
      if (serverCache == null && syncPoint != null) {
        serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
      }
      let events = [];
      syncPointTree.children.inorderTraversal((childName, childTree) => {
        const childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
        const childWritesCache = writeTreeRefChild(writesCache, childName);
        const childOperation = operation.operationForChild(childName);
        if (childOperation) {
          events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
        }
      });
      if (syncPoint) {
        events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
      }
      return events;
    }
    __name(syncTreeApplyOperationDescendantsHelper_, "syncTreeApplyOperationDescendantsHelper_");
    function syncTreeCreateListenerForView_(syncTree, view) {
      const query2 = view.query;
      const tag = syncTreeTagForQuery(syncTree, query2);
      return {
        hashFn: /* @__PURE__ */ __name(() => {
          const cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
          return cache.hash();
        }, "hashFn"),
        onComplete: /* @__PURE__ */ __name((status) => {
          if (status === "ok") {
            if (tag) {
              return syncTreeApplyTaggedListenComplete(syncTree, query2._path, tag);
            } else {
              return syncTreeApplyListenComplete(syncTree, query2._path);
            }
          } else {
            const error4 = errorForServerCode(status, query2);
            return syncTreeRemoveEventRegistration(
              syncTree,
              query2,
              /*eventRegistration*/
              null,
              error4
            );
          }
        }, "onComplete")
      };
    }
    __name(syncTreeCreateListenerForView_, "syncTreeCreateListenerForView_");
    function syncTreeTagForQuery(syncTree, query2) {
      const queryKey = syncTreeMakeQueryKey_(query2);
      return syncTree.queryToTagMap.get(queryKey);
    }
    __name(syncTreeTagForQuery, "syncTreeTagForQuery");
    function syncTreeMakeQueryKey_(query2) {
      return query2._path.toString() + "$" + query2._queryIdentifier;
    }
    __name(syncTreeMakeQueryKey_, "syncTreeMakeQueryKey_");
    function syncTreeQueryKeyForTag_(syncTree, tag) {
      return syncTree.tagToQueryMap.get(tag);
    }
    __name(syncTreeQueryKeyForTag_, "syncTreeQueryKeyForTag_");
    function syncTreeParseQueryKey_(queryKey) {
      const splitIndex = queryKey.indexOf("$");
      util.assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
      return {
        queryId: queryKey.substr(splitIndex + 1),
        path: new Path(queryKey.substr(0, splitIndex))
      };
    }
    __name(syncTreeParseQueryKey_, "syncTreeParseQueryKey_");
    function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
      const syncPoint = syncTree.syncPointTree_.get(queryPath);
      util.assert(syncPoint, "Missing sync point for query tag that we're tracking");
      const writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
      return syncPointApplyOperation(syncPoint, operation, writesCache, null);
    }
    __name(syncTreeApplyTaggedOperation_, "syncTreeApplyTaggedOperation_");
    function syncTreeCollectDistinctViewsForSubTree_(subtree) {
      return subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
        if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
          const completeView = syncPointGetCompleteView(maybeChildSyncPoint);
          return [completeView];
        } else {
          let views = [];
          if (maybeChildSyncPoint) {
            views = syncPointGetQueryViews(maybeChildSyncPoint);
          }
          each(childMap, (_key, childViews) => {
            views = views.concat(childViews);
          });
          return views;
        }
      });
    }
    __name(syncTreeCollectDistinctViewsForSubTree_, "syncTreeCollectDistinctViewsForSubTree_");
    function syncTreeQueryForListening_(query2) {
      if (query2._queryParams.loadsAllData() && !query2._queryParams.isDefault()) {
        return new (syncTreeGetReferenceConstructor())(query2._repo, query2._path);
      } else {
        return query2;
      }
    }
    __name(syncTreeQueryForListening_, "syncTreeQueryForListening_");
    function syncTreeRemoveTags_(syncTree, queries) {
      for (let j = 0; j < queries.length; ++j) {
        const removedQuery = queries[j];
        if (!removedQuery._queryParams.loadsAllData()) {
          const removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
          const removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
          syncTree.queryToTagMap.delete(removedQueryKey);
          syncTree.tagToQueryMap.delete(removedQueryTag);
        }
      }
    }
    __name(syncTreeRemoveTags_, "syncTreeRemoveTags_");
    function syncTreeGetNextQueryTag_() {
      return syncTreeNextQueryTag_++;
    }
    __name(syncTreeGetNextQueryTag_, "syncTreeGetNextQueryTag_");
    function syncTreeSetupListener_(syncTree, query2, view) {
      const path = query2._path;
      const tag = syncTreeTagForQuery(syncTree, query2);
      const listener = syncTreeCreateListenerForView_(syncTree, view);
      const events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query2), tag, listener.hashFn, listener.onComplete);
      const subtree = syncTree.syncPointTree_.subtree(path);
      if (tag) {
        util.assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
      } else {
        const queriesToStop = subtree.fold((relativePath, maybeChildSyncPoint, childMap) => {
          if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
            return [syncPointGetCompleteView(maybeChildSyncPoint).query];
          } else {
            let queries = [];
            if (maybeChildSyncPoint) {
              queries = queries.concat(syncPointGetQueryViews(maybeChildSyncPoint).map((view2) => view2.query));
            }
            each(childMap, (_key, childQueries) => {
              queries = queries.concat(childQueries);
            });
            return queries;
          }
        });
        for (let i = 0; i < queriesToStop.length; ++i) {
          const queryToStop = queriesToStop[i];
          syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery(syncTree, queryToStop));
        }
      }
      return events;
    }
    __name(syncTreeSetupListener_, "syncTreeSetupListener_");
    var ExistingValueProvider = class _ExistingValueProvider {
      static {
        __name(this, "ExistingValueProvider");
      }
      constructor(node_) {
        this.node_ = node_;
      }
      getImmediateChild(childName) {
        const child2 = this.node_.getImmediateChild(childName);
        return new _ExistingValueProvider(child2);
      }
      node() {
        return this.node_;
      }
    };
    var DeferredValueProvider = class _DeferredValueProvider {
      static {
        __name(this, "DeferredValueProvider");
      }
      constructor(syncTree, path) {
        this.syncTree_ = syncTree;
        this.path_ = path;
      }
      getImmediateChild(childName) {
        const childPath = pathChild(this.path_, childName);
        return new _DeferredValueProvider(this.syncTree_, childPath);
      }
      node() {
        return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
      }
    };
    var generateWithValues = /* @__PURE__ */ __name(function(values) {
      values = values || {};
      values["timestamp"] = values["timestamp"] || (/* @__PURE__ */ new Date()).getTime();
      return values;
    }, "generateWithValues");
    var resolveDeferredLeafValue = /* @__PURE__ */ __name(function(value, existingVal, serverValues) {
      if (!value || typeof value !== "object") {
        return value;
      }
      util.assert(".sv" in value, "Unexpected leaf node or priority contents");
      if (typeof value[".sv"] === "string") {
        return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
      } else if (typeof value[".sv"] === "object") {
        return resolveComplexDeferredValue(value[".sv"], existingVal);
      } else {
        util.assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
      }
    }, "resolveDeferredLeafValue");
    var resolveScalarDeferredValue = /* @__PURE__ */ __name(function(op, existing, serverValues) {
      switch (op) {
        case "timestamp":
          return serverValues["timestamp"];
        default:
          util.assert(false, "Unexpected server value: " + op);
      }
    }, "resolveScalarDeferredValue");
    var resolveComplexDeferredValue = /* @__PURE__ */ __name(function(op, existing, unused) {
      if (!op.hasOwnProperty("increment")) {
        util.assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
      }
      const delta = op["increment"];
      if (typeof delta !== "number") {
        util.assert(false, "Unexpected increment value: " + delta);
      }
      const existingNode = existing.node();
      util.assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
      if (!existingNode.isLeafNode()) {
        return delta;
      }
      const leaf = existingNode;
      const existingVal = leaf.getValue();
      if (typeof existingVal !== "number") {
        return delta;
      }
      return existingVal + delta;
    }, "resolveComplexDeferredValue");
    var resolveDeferredValueTree = /* @__PURE__ */ __name(function(path, node, syncTree, serverValues) {
      return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
    }, "resolveDeferredValueTree");
    var resolveDeferredValueSnapshot = /* @__PURE__ */ __name(function(node, existing, serverValues) {
      return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
    }, "resolveDeferredValueSnapshot");
    function resolveDeferredValue(node, existingVal, serverValues) {
      const rawPri = node.getPriority().val();
      const priority2 = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
      let newNode;
      if (node.isLeafNode()) {
        const leafNode = node;
        const value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
        if (value !== leafNode.getValue() || priority2 !== leafNode.getPriority().val()) {
          return new LeafNode(value, nodeFromJSON(priority2));
        } else {
          return node;
        }
      } else {
        const childrenNode = node;
        newNode = childrenNode;
        if (priority2 !== childrenNode.getPriority().val()) {
          newNode = newNode.updatePriority(new LeafNode(priority2));
        }
        childrenNode.forEachChild(PRIORITY_INDEX, (childName, childNode) => {
          const newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
          if (newChildNode !== childNode) {
            newNode = newNode.updateImmediateChild(childName, newChildNode);
          }
        });
        return newNode;
      }
    }
    __name(resolveDeferredValue, "resolveDeferredValue");
    var Tree = class {
      static {
        __name(this, "Tree");
      }
      /**
       * @param name - Optional name of the node.
       * @param parent - Optional parent node.
       * @param node - Optional node to wrap.
       */
      constructor(name = "", parent = null, node = { children: {}, childCount: 0 }) {
        this.name = name;
        this.parent = parent;
        this.node = node;
      }
    };
    function treeSubTree(tree, pathObj) {
      let path = pathObj instanceof Path ? pathObj : new Path(pathObj);
      let child2 = tree, next = pathGetFront(path);
      while (next !== null) {
        const childNode = util.safeGet(child2.node.children, next) || {
          children: {},
          childCount: 0
        };
        child2 = new Tree(next, child2, childNode);
        path = pathPopFront(path);
        next = pathGetFront(path);
      }
      return child2;
    }
    __name(treeSubTree, "treeSubTree");
    function treeGetValue(tree) {
      return tree.node.value;
    }
    __name(treeGetValue, "treeGetValue");
    function treeSetValue(tree, value) {
      tree.node.value = value;
      treeUpdateParents(tree);
    }
    __name(treeSetValue, "treeSetValue");
    function treeHasChildren(tree) {
      return tree.node.childCount > 0;
    }
    __name(treeHasChildren, "treeHasChildren");
    function treeIsEmpty(tree) {
      return treeGetValue(tree) === void 0 && !treeHasChildren(tree);
    }
    __name(treeIsEmpty, "treeIsEmpty");
    function treeForEachChild(tree, action) {
      each(tree.node.children, (child2, childTree) => {
        action(new Tree(child2, tree, childTree));
      });
    }
    __name(treeForEachChild, "treeForEachChild");
    function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
      if (includeSelf && !childrenFirst) {
        action(tree);
      }
      treeForEachChild(tree, (child2) => {
        treeForEachDescendant(child2, action, true, childrenFirst);
      });
      if (includeSelf && childrenFirst) {
        action(tree);
      }
    }
    __name(treeForEachDescendant, "treeForEachDescendant");
    function treeForEachAncestor(tree, action, includeSelf) {
      let node = includeSelf ? tree : tree.parent;
      while (node !== null) {
        if (action(node)) {
          return true;
        }
        node = node.parent;
      }
      return false;
    }
    __name(treeForEachAncestor, "treeForEachAncestor");
    function treeGetPath(tree) {
      return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
    }
    __name(treeGetPath, "treeGetPath");
    function treeUpdateParents(tree) {
      if (tree.parent !== null) {
        treeUpdateChild(tree.parent, tree.name, tree);
      }
    }
    __name(treeUpdateParents, "treeUpdateParents");
    function treeUpdateChild(tree, childName, child2) {
      const childEmpty = treeIsEmpty(child2);
      const childExists = util.contains(tree.node.children, childName);
      if (childEmpty && childExists) {
        delete tree.node.children[childName];
        tree.node.childCount--;
        treeUpdateParents(tree);
      } else if (!childEmpty && !childExists) {
        tree.node.children[childName] = child2.node;
        tree.node.childCount++;
        treeUpdateParents(tree);
      }
    }
    __name(treeUpdateChild, "treeUpdateChild");
    var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
    var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
    var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
    var isValidKey = /* @__PURE__ */ __name(function(key2) {
      return typeof key2 === "string" && key2.length !== 0 && !INVALID_KEY_REGEX_.test(key2);
    }, "isValidKey");
    var isValidPathString = /* @__PURE__ */ __name(function(pathString) {
      return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
    }, "isValidPathString");
    var isValidRootPathString = /* @__PURE__ */ __name(function(pathString) {
      if (pathString) {
        pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
      }
      return isValidPathString(pathString);
    }, "isValidRootPathString");
    var isValidPriority = /* @__PURE__ */ __name(function(priority2) {
      return priority2 === null || typeof priority2 === "string" || typeof priority2 === "number" && !isInvalidJSONNumber(priority2) || priority2 && typeof priority2 === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
      util.contains(priority2, ".sv");
    }, "isValidPriority");
    var validateFirebaseDataArg = /* @__PURE__ */ __name(function(fnName, value, path, optional) {
      if (optional && value === void 0) {
        return;
      }
      validateFirebaseData(util.errorPrefix(fnName, "value"), value, path);
    }, "validateFirebaseDataArg");
    var validateFirebaseData = /* @__PURE__ */ __name(function(errorPrefix, data, path_) {
      const path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix) : path_;
      if (data === void 0) {
        throw new Error(errorPrefix + "contains undefined " + validationPathToErrorString(path));
      }
      if (typeof data === "function") {
        throw new Error(errorPrefix + "contains a function " + validationPathToErrorString(path) + " with contents = " + data.toString());
      }
      if (isInvalidJSONNumber(data)) {
        throw new Error(errorPrefix + "contains " + data.toString() + " " + validationPathToErrorString(path));
      }
      if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && util.stringLength(data) > MAX_LEAF_SIZE_) {
        throw new Error(errorPrefix + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path) + " ('" + data.substring(0, 50) + "...')");
      }
      if (data && typeof data === "object") {
        let hasDotValue = false;
        let hasActualChild = false;
        each(data, (key2, value) => {
          if (key2 === ".value") {
            hasDotValue = true;
          } else if (key2 !== ".priority" && key2 !== ".sv") {
            hasActualChild = true;
            if (!isValidKey(key2)) {
              throw new Error(errorPrefix + " contains an invalid key (" + key2 + ") " + validationPathToErrorString(path) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
            }
          }
          validationPathPush(path, key2);
          validateFirebaseData(errorPrefix, value, path);
          validationPathPop(path);
        });
        if (hasDotValue && hasActualChild) {
          throw new Error(errorPrefix + ' contains ".value" child ' + validationPathToErrorString(path) + " in addition to actual children.");
        }
      }
    }, "validateFirebaseData");
    var validateFirebaseMergePaths = /* @__PURE__ */ __name(function(errorPrefix, mergePaths) {
      let i, curPath;
      for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        const keys = pathSlice(curPath);
        for (let j = 0; j < keys.length; j++) {
          if (keys[j] === ".priority" && j === keys.length - 1) ;
          else if (!isValidKey(keys[j])) {
            throw new Error(errorPrefix + "contains an invalid key (" + keys[j] + ") in path " + curPath.toString() + `. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
          }
        }
      }
      mergePaths.sort(pathCompare);
      let prevPath = null;
      for (i = 0; i < mergePaths.length; i++) {
        curPath = mergePaths[i];
        if (prevPath !== null && pathContains(prevPath, curPath)) {
          throw new Error(errorPrefix + "contains a path " + prevPath.toString() + " that is ancestor of another path " + curPath.toString());
        }
        prevPath = curPath;
      }
    }, "validateFirebaseMergePaths");
    var validateFirebaseMergeDataArg = /* @__PURE__ */ __name(function(fnName, data, path, optional) {
      if (optional && data === void 0) {
        return;
      }
      const errorPrefix = util.errorPrefix(fnName, "values");
      if (!(data && typeof data === "object") || Array.isArray(data)) {
        throw new Error(errorPrefix + " must be an object containing the children to replace.");
      }
      const mergePaths = [];
      each(data, (key2, value) => {
        const curPath = new Path(key2);
        validateFirebaseData(errorPrefix, value, pathChild(path, curPath));
        if (pathGetBack(curPath) === ".priority") {
          if (!isValidPriority(value)) {
            throw new Error(errorPrefix + "contains an invalid value for '" + curPath.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
          }
        }
        mergePaths.push(curPath);
      });
      validateFirebaseMergePaths(errorPrefix, mergePaths);
    }, "validateFirebaseMergeDataArg");
    var validatePriority = /* @__PURE__ */ __name(function(fnName, priority2, optional) {
      if (optional && priority2 === void 0) {
        return;
      }
      if (isInvalidJSONNumber(priority2)) {
        throw new Error(util.errorPrefix(fnName, "priority") + "is " + priority2.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
      if (!isValidPriority(priority2)) {
        throw new Error(util.errorPrefix(fnName, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
    }, "validatePriority");
    var validateKey = /* @__PURE__ */ __name(function(fnName, argumentName, key2, optional) {
      if (optional && key2 === void 0) {
        return;
      }
      if (!isValidKey(key2)) {
        throw new Error(util.errorPrefix(fnName, argumentName) + 'was an invalid key = "' + key2 + `".  Firebase keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]").`);
      }
    }, "validateKey");
    var validatePathString = /* @__PURE__ */ __name(function(fnName, argumentName, pathString, optional) {
      if (optional && pathString === void 0) {
        return;
      }
      if (!isValidPathString(pathString)) {
        throw new Error(util.errorPrefix(fnName, argumentName) + 'was an invalid path = "' + pathString + `". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`);
      }
    }, "validatePathString");
    var validateRootPathString = /* @__PURE__ */ __name(function(fnName, argumentName, pathString, optional) {
      if (pathString) {
        pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
      }
      validatePathString(fnName, argumentName, pathString, optional);
    }, "validateRootPathString");
    var validateWritablePath = /* @__PURE__ */ __name(function(fnName, path) {
      if (pathGetFront(path) === ".info") {
        throw new Error(fnName + " failed = Can't modify data under /.info/");
      }
    }, "validateWritablePath");
    var validateUrl = /* @__PURE__ */ __name(function(fnName, parsedUrl) {
      const pathString = parsedUrl.path.toString();
      if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
        throw new Error(util.errorPrefix(fnName, "url") + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`);
      }
    }, "validateUrl");
    var EventQueue = class {
      static {
        __name(this, "EventQueue");
      }
      constructor() {
        this.eventLists_ = [];
        this.recursionDepth_ = 0;
      }
    };
    function eventQueueQueueEvents(eventQueue, eventDataList) {
      let currList = null;
      for (let i = 0; i < eventDataList.length; i++) {
        const data = eventDataList[i];
        const path = data.getPath();
        if (currList !== null && !pathEquals(path, currList.path)) {
          eventQueue.eventLists_.push(currList);
          currList = null;
        }
        if (currList === null) {
          currList = { events: [], path };
        }
        currList.events.push(data);
      }
      if (currList) {
        eventQueue.eventLists_.push(currList);
      }
    }
    __name(eventQueueQueueEvents, "eventQueueQueueEvents");
    function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
      eventQueueQueueEvents(eventQueue, eventDataList);
      eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath) => pathEquals(eventPath, path));
    }
    __name(eventQueueRaiseEventsAtPath, "eventQueueRaiseEventsAtPath");
    function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
      eventQueueQueueEvents(eventQueue, eventDataList);
      eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, (eventPath) => pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath));
    }
    __name(eventQueueRaiseEventsForChangedPath, "eventQueueRaiseEventsForChangedPath");
    function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
      eventQueue.recursionDepth_++;
      let sentAll = true;
      for (let i = 0; i < eventQueue.eventLists_.length; i++) {
        const eventList = eventQueue.eventLists_[i];
        if (eventList) {
          const eventPath = eventList.path;
          if (predicate(eventPath)) {
            eventListRaise(eventQueue.eventLists_[i]);
            eventQueue.eventLists_[i] = null;
          } else {
            sentAll = false;
          }
        }
      }
      if (sentAll) {
        eventQueue.eventLists_ = [];
      }
      eventQueue.recursionDepth_--;
    }
    __name(eventQueueRaiseQueuedEventsMatchingPredicate, "eventQueueRaiseQueuedEventsMatchingPredicate");
    function eventListRaise(eventList) {
      for (let i = 0; i < eventList.events.length; i++) {
        const eventData = eventList.events[i];
        if (eventData !== null) {
          eventList.events[i] = null;
          const eventFn = eventData.getEventRunner();
          if (logger) {
            log4("event: " + eventData.toString());
          }
          exceptionGuard(eventFn);
        }
      }
    }
    __name(eventListRaise, "eventListRaise");
    var INTERRUPT_REASON = "repo_interrupt";
    var MAX_TRANSACTION_RETRIES = 25;
    var Repo = class {
      static {
        __name(this, "Repo");
      }
      constructor(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
        this.repoInfo_ = repoInfo_;
        this.forceRestClient_ = forceRestClient_;
        this.authTokenProvider_ = authTokenProvider_;
        this.appCheckProvider_ = appCheckProvider_;
        this.dataUpdateCount = 0;
        this.statsListener_ = null;
        this.eventQueue_ = new EventQueue();
        this.nextWriteId_ = 1;
        this.interceptServerDataCallback_ = null;
        this.onDisconnect_ = newSparseSnapshotTree();
        this.transactionQueueTree_ = new Tree();
        this.persistentConnection_ = null;
        this.key = this.repoInfo_.toURLString();
      }
      /**
       * @returns The URL corresponding to the root of this Firebase.
       */
      toString() {
        return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
      }
    };
    function repoStart(repo, appId, authOverride) {
      repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
      if (repo.forceRestClient_ || beingCrawled()) {
        repo.server_ = new ReadonlyRestClient(repo.repoInfo_, (pathString, data, isMerge, tag) => {
          repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, repo.authTokenProvider_, repo.appCheckProvider_);
        setTimeout(() => repoOnConnectStatus(
          repo,
          /* connectStatus= */
          true
        ), 0);
      } else {
        if (typeof authOverride !== "undefined" && authOverride !== null) {
          if (typeof authOverride !== "object") {
            throw new Error("Only objects are supported for option databaseAuthVariableOverride");
          }
          try {
            util.stringify(authOverride);
          } catch (e) {
            throw new Error("Invalid authOverride provided: " + e);
          }
        }
        repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, (pathString, data, isMerge, tag) => {
          repoOnDataUpdate(repo, pathString, data, isMerge, tag);
        }, (connectStatus) => {
          repoOnConnectStatus(repo, connectStatus);
        }, (updates) => {
          repoOnServerInfoUpdate(repo, updates);
        }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
        repo.server_ = repo.persistentConnection_;
      }
      repo.authTokenProvider_.addTokenChangeListener((token) => {
        repo.server_.refreshAuthToken(token);
      });
      repo.appCheckProvider_.addTokenChangeListener((result) => {
        repo.server_.refreshAppCheckToken(result.token);
      });
      repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, () => new StatsReporter(repo.stats_, repo.server_));
      repo.infoData_ = new SnapshotHolder();
      repo.infoSyncTree_ = new SyncTree({
        startListening: /* @__PURE__ */ __name((query2, tag, currentHashFn, onComplete) => {
          let infoEvents = [];
          const node = repo.infoData_.getNode(query2._path);
          if (!node.isEmpty()) {
            infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query2._path, node);
            setTimeout(() => {
              onComplete("ok");
            }, 0);
          }
          return infoEvents;
        }, "startListening"),
        stopListening: /* @__PURE__ */ __name(() => {
        }, "stopListening")
      });
      repoUpdateInfo(repo, "connected", false);
      repo.serverSyncTree_ = new SyncTree({
        startListening: /* @__PURE__ */ __name((query2, tag, currentHashFn, onComplete) => {
          repo.server_.listen(query2, currentHashFn, tag, (status, data) => {
            const events = onComplete(status, data);
            eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query2._path, events);
          });
          return [];
        }, "startListening"),
        stopListening: /* @__PURE__ */ __name((query2, tag) => {
          repo.server_.unlisten(query2, tag);
        }, "stopListening")
      });
    }
    __name(repoStart, "repoStart");
    function repoServerTime(repo) {
      const offsetNode = repo.infoData_.getNode(new Path(".info/serverTimeOffset"));
      const offset = offsetNode.val() || 0;
      return (/* @__PURE__ */ new Date()).getTime() + offset;
    }
    __name(repoServerTime, "repoServerTime");
    function repoGenerateServerValues(repo) {
      return generateWithValues({
        timestamp: repoServerTime(repo)
      });
    }
    __name(repoGenerateServerValues, "repoGenerateServerValues");
    function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
      repo.dataUpdateCount++;
      const path = new Path(pathString);
      data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
      let events = [];
      if (tag) {
        if (isMerge) {
          const taggedChildren = util.map(data, (raw) => nodeFromJSON(raw));
          events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
        } else {
          const taggedSnap = nodeFromJSON(data);
          events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
        }
      } else if (isMerge) {
        const changedChildren = util.map(data, (raw) => nodeFromJSON(raw));
        events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
      } else {
        const snap = nodeFromJSON(data);
        events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
      }
      let affectedPath = path;
      if (events.length > 0) {
        affectedPath = repoRerunTransactions(repo, path);
      }
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
    }
    __name(repoOnDataUpdate, "repoOnDataUpdate");
    function repoOnConnectStatus(repo, connectStatus) {
      repoUpdateInfo(repo, "connected", connectStatus);
      if (connectStatus === false) {
        repoRunOnDisconnectEvents(repo);
      }
    }
    __name(repoOnConnectStatus, "repoOnConnectStatus");
    function repoOnServerInfoUpdate(repo, updates) {
      each(updates, (key2, value) => {
        repoUpdateInfo(repo, key2, value);
      });
    }
    __name(repoOnServerInfoUpdate, "repoOnServerInfoUpdate");
    function repoUpdateInfo(repo, pathString, value) {
      const path = new Path("/.info/" + pathString);
      const newNode = nodeFromJSON(value);
      repo.infoData_.updateSnapshot(path, newNode);
      const events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    }
    __name(repoUpdateInfo, "repoUpdateInfo");
    function repoGetNextWriteId(repo) {
      return repo.nextWriteId_++;
    }
    __name(repoGetNextWriteId, "repoGetNextWriteId");
    function repoGetValue(repo, query2, eventRegistration) {
      const cached = syncTreeGetServerValue(repo.serverSyncTree_, query2);
      if (cached != null) {
        return Promise.resolve(cached);
      }
      return repo.server_.get(query2).then((payload) => {
        const node = nodeFromJSON(payload).withIndex(query2._queryParams.getIndex());
        syncTreeAddEventRegistration(repo.serverSyncTree_, query2, eventRegistration, true);
        let events;
        if (query2._queryParams.loadsAllData()) {
          events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query2._path, node);
        } else {
          const tag = syncTreeTagForQuery(repo.serverSyncTree_, query2);
          events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, query2._path, node, tag);
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query2._path, events);
        syncTreeRemoveEventRegistration(repo.serverSyncTree_, query2, eventRegistration, null, true);
        return node;
      }, (err) => {
        repoLog(repo, "get for query " + util.stringify(query2) + " failed: " + err);
        return Promise.reject(new Error(err));
      });
    }
    __name(repoGetValue, "repoGetValue");
    function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
      repoLog(repo, "set", {
        path: path.toString(),
        value: newVal,
        priority: newPriority
      });
      const serverValues = repoGenerateServerValues(repo);
      const newNodeUnresolved = nodeFromJSON(newVal, newPriority);
      const existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
      const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
      const writeId = repoGetNextWriteId(repo);
      const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
      eventQueueQueueEvents(repo.eventQueue_, events);
      repo.server_.put(path.toString(), newNodeUnresolved.val(
        /*export=*/
        true
      ), (status, errorReason) => {
        const success = status === "ok";
        if (!success) {
          warn$1("set at " + path + " failed: " + status);
        }
        const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
      const affectedPath = repoAbortTransactions(repo, path);
      repoRerunTransactions(repo, affectedPath);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
    }
    __name(repoSetWithPriority, "repoSetWithPriority");
    function repoUpdate(repo, path, childrenToMerge, onComplete) {
      repoLog(repo, "update", { path: path.toString(), value: childrenToMerge });
      let empty = true;
      const serverValues = repoGenerateServerValues(repo);
      const changedChildren = {};
      each(childrenToMerge, (changedKey, changedValue) => {
        empty = false;
        changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
      });
      if (!empty) {
        const writeId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId);
        eventQueueQueueEvents(repo.eventQueue_, events);
        repo.server_.merge(path.toString(), childrenToMerge, (status, errorReason) => {
          const success = status === "ok";
          if (!success) {
            warn$1("update at " + path + " failed: " + status);
          }
          const clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
          const affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
          eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
          repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
        });
        each(childrenToMerge, (changedPath) => {
          const affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
          repoRerunTransactions(repo, affectedPath);
        });
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
      } else {
        log4("update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
      }
    }
    __name(repoUpdate, "repoUpdate");
    function repoRunOnDisconnectEvents(repo) {
      repoLog(repo, "onDisconnectEvents");
      const serverValues = repoGenerateServerValues(repo);
      const resolvedOnDisconnectTree = newSparseSnapshotTree();
      sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), (path, node) => {
        const resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
        sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
      });
      let events = [];
      sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), (path, snap) => {
        events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
        const affectedPath = repoAbortTransactions(repo, path);
        repoRerunTransactions(repo, affectedPath);
      });
      repo.onDisconnect_ = newSparseSnapshotTree();
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
    }
    __name(repoRunOnDisconnectEvents, "repoRunOnDisconnectEvents");
    function repoOnDisconnectCancel(repo, path, onComplete) {
      repo.server_.onDisconnectCancel(path.toString(), (status, errorReason) => {
        if (status === "ok") {
          sparseSnapshotTreeForget(repo.onDisconnect_, path);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    __name(repoOnDisconnectCancel, "repoOnDisconnectCancel");
    function repoOnDisconnectSet(repo, path, value, onComplete) {
      const newNode = nodeFromJSON(value);
      repo.server_.onDisconnectPut(path.toString(), newNode.val(
        /*export=*/
        true
      ), (status, errorReason) => {
        if (status === "ok") {
          sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    __name(repoOnDisconnectSet, "repoOnDisconnectSet");
    function repoOnDisconnectSetWithPriority(repo, path, value, priority2, onComplete) {
      const newNode = nodeFromJSON(value, priority2);
      repo.server_.onDisconnectPut(path.toString(), newNode.val(
        /*export=*/
        true
      ), (status, errorReason) => {
        if (status === "ok") {
          sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    __name(repoOnDisconnectSetWithPriority, "repoOnDisconnectSetWithPriority");
    function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
      if (util.isEmpty(childrenToMerge)) {
        log4("onDisconnect().update() called with empty data.  Don't do anything.");
        repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
        return;
      }
      repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, (status, errorReason) => {
        if (status === "ok") {
          each(childrenToMerge, (childName, childNode) => {
            const newChildNode = nodeFromJSON(childNode);
            sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
          });
        }
        repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
      });
    }
    __name(repoOnDisconnectUpdate, "repoOnDisconnectUpdate");
    function repoAddEventCallbackForQuery(repo, query2, eventRegistration) {
      let events;
      if (pathGetFront(query2._path) === ".info") {
        events = syncTreeAddEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
      } else {
        events = syncTreeAddEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
      }
      eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
    }
    __name(repoAddEventCallbackForQuery, "repoAddEventCallbackForQuery");
    function repoRemoveEventCallbackForQuery(repo, query2, eventRegistration) {
      let events;
      if (pathGetFront(query2._path) === ".info") {
        events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
      } else {
        events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
      }
      eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
    }
    __name(repoRemoveEventCallbackForQuery, "repoRemoveEventCallbackForQuery");
    function repoInterrupt(repo) {
      if (repo.persistentConnection_) {
        repo.persistentConnection_.interrupt(INTERRUPT_REASON);
      }
    }
    __name(repoInterrupt, "repoInterrupt");
    function repoResume(repo) {
      if (repo.persistentConnection_) {
        repo.persistentConnection_.resume(INTERRUPT_REASON);
      }
    }
    __name(repoResume, "repoResume");
    function repoLog(repo, ...varArgs) {
      let prefix = "";
      if (repo.persistentConnection_) {
        prefix = repo.persistentConnection_.id + ":";
      }
      log4(prefix, ...varArgs);
    }
    __name(repoLog, "repoLog");
    function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
      if (callback) {
        exceptionGuard(() => {
          if (status === "ok") {
            callback(null);
          } else {
            const code = (status || "error").toUpperCase();
            let message3 = code;
            if (errorReason) {
              message3 += ": " + errorReason;
            }
            const error4 = new Error(message3);
            error4.code = code;
            callback(error4);
          }
        });
      }
    }
    __name(repoCallOnCompleteCallback, "repoCallOnCompleteCallback");
    function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {
      repoLog(repo, "transaction on " + path);
      const transaction = {
        path,
        update: transactionUpdate,
        onComplete,
        // One of TransactionStatus enums.
        status: null,
        // Used when combining transactions at different locations to figure out
        // which one goes first.
        order: LUIDGenerator(),
        // Whether to raise local events for this transaction.
        applyLocally,
        // Count of how many times we've retried the transaction.
        retryCount: 0,
        // Function to call to clean up our .on() listener.
        unwatcher,
        // Stores why a transaction was aborted.
        abortReason: null,
        currentWriteId: null,
        currentInputSnapshot: null,
        currentOutputSnapshotRaw: null,
        currentOutputSnapshotResolved: null
      };
      const currentState = repoGetLatestState(repo, path, void 0);
      transaction.currentInputSnapshot = currentState;
      const newVal = transaction.update(currentState.val());
      if (newVal === void 0) {
        transaction.unwatcher();
        transaction.currentOutputSnapshotRaw = null;
        transaction.currentOutputSnapshotResolved = null;
        if (transaction.onComplete) {
          transaction.onComplete(null, false, transaction.currentInputSnapshot);
        }
      } else {
        validateFirebaseData("transaction failed: Data returned ", newVal, transaction.path);
        transaction.status = 0;
        const queueNode = treeSubTree(repo.transactionQueueTree_, path);
        const nodeQueue = treeGetValue(queueNode) || [];
        nodeQueue.push(transaction);
        treeSetValue(queueNode, nodeQueue);
        let priorityForNode;
        if (typeof newVal === "object" && newVal !== null && util.contains(newVal, ".priority")) {
          priorityForNode = util.safeGet(newVal, ".priority");
          util.assert(isValidPriority(priorityForNode), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.");
        } else {
          const currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;
          priorityForNode = currentNode.getPriority().val();
        }
        const serverValues = repoGenerateServerValues(repo);
        const newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
        const newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
        transaction.currentOutputSnapshotRaw = newNodeUnresolved;
        transaction.currentOutputSnapshotResolved = newNode;
        transaction.currentWriteId = repoGetNextWriteId(repo);
        const events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      }
    }
    __name(repoStartTransaction, "repoStartTransaction");
    function repoGetLatestState(repo, path, excludeSets) {
      return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;
    }
    __name(repoGetLatestState, "repoGetLatestState");
    function repoSendReadyTransactions(repo, node = repo.transactionQueueTree_) {
      if (!node) {
        repoPruneCompletedTransactionsBelowNode(repo, node);
      }
      if (treeGetValue(node)) {
        const queue = repoBuildTransactionQueue(repo, node);
        util.assert(queue.length > 0, "Sending zero length transaction queue");
        const allRun = queue.every(
          (transaction) => transaction.status === 0
          /* TransactionStatus.RUN */
        );
        if (allRun) {
          repoSendTransactionQueue(repo, treeGetPath(node), queue);
        }
      } else if (treeHasChildren(node)) {
        treeForEachChild(node, (childNode) => {
          repoSendReadyTransactions(repo, childNode);
        });
      }
    }
    __name(repoSendReadyTransactions, "repoSendReadyTransactions");
    function repoSendTransactionQueue(repo, path, queue) {
      const setsToIgnore = queue.map((txn) => {
        return txn.currentWriteId;
      });
      const latestState = repoGetLatestState(repo, path, setsToIgnore);
      let snapToSend = latestState;
      const latestHash = latestState.hash();
      for (let i = 0; i < queue.length; i++) {
        const txn = queue[i];
        util.assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
        txn.status = 1;
        txn.retryCount++;
        const relativePath = newRelativePath(path, txn.path);
        snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
      }
      const dataToSend = snapToSend.val(true);
      const pathToSend = path;
      repo.server_.put(pathToSend.toString(), dataToSend, (status) => {
        repoLog(repo, "transaction put response", {
          path: pathToSend.toString(),
          status
        });
        let events = [];
        if (status === "ok") {
          const callbacks = [];
          for (let i = 0; i < queue.length; i++) {
            queue[i].status = 2;
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId));
            if (queue[i].onComplete) {
              callbacks.push(() => queue[i].onComplete(null, true, queue[i].currentOutputSnapshotResolved));
            }
            queue[i].unwatcher();
          }
          repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
          repoSendReadyTransactions(repo, repo.transactionQueueTree_);
          eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
          for (let i = 0; i < callbacks.length; i++) {
            exceptionGuard(callbacks[i]);
          }
        } else {
          if (status === "datastale") {
            for (let i = 0; i < queue.length; i++) {
              if (queue[i].status === 3) {
                queue[i].status = 4;
              } else {
                queue[i].status = 0;
              }
            }
          } else {
            warn$1("transaction at " + pathToSend.toString() + " failed: " + status);
            for (let i = 0; i < queue.length; i++) {
              queue[i].status = 4;
              queue[i].abortReason = status;
            }
          }
          repoRerunTransactions(repo, path);
        }
      }, latestHash);
    }
    __name(repoSendTransactionQueue, "repoSendTransactionQueue");
    function repoRerunTransactions(repo, changedPath) {
      const rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
      const path = treeGetPath(rootMostTransactionNode);
      const queue = repoBuildTransactionQueue(repo, rootMostTransactionNode);
      repoRerunTransactionQueue(repo, queue, path);
      return path;
    }
    __name(repoRerunTransactions, "repoRerunTransactions");
    function repoRerunTransactionQueue(repo, queue, path) {
      if (queue.length === 0) {
        return;
      }
      const callbacks = [];
      let events = [];
      const txnsToRerun = queue.filter((q) => {
        return q.status === 0;
      });
      const setsToIgnore = txnsToRerun.map((q) => {
        return q.currentWriteId;
      });
      for (let i = 0; i < queue.length; i++) {
        const transaction = queue[i];
        const relativePath = newRelativePath(path, transaction.path);
        let abortTransaction = false, abortReason;
        util.assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
        if (transaction.status === 4) {
          abortTransaction = true;
          abortReason = transaction.abortReason;
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        } else if (transaction.status === 0) {
          if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
            abortTransaction = true;
            abortReason = "maxretry";
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
          } else {
            const currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
            transaction.currentInputSnapshot = currentNode;
            const newData = queue[i].update(currentNode.val());
            if (newData !== void 0) {
              validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
              let newDataNode = nodeFromJSON(newData);
              const hasExplicitPriority = typeof newData === "object" && newData != null && util.contains(newData, ".priority");
              if (!hasExplicitPriority) {
                newDataNode = newDataNode.updatePriority(currentNode.getPriority());
              }
              const oldWriteId = transaction.currentWriteId;
              const serverValues = repoGenerateServerValues(repo);
              const newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
              transaction.currentOutputSnapshotRaw = newDataNode;
              transaction.currentOutputSnapshotResolved = newNodeResolved;
              transaction.currentWriteId = repoGetNextWriteId(repo);
              setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
              events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
              events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
            } else {
              abortTransaction = true;
              abortReason = "nodata";
              events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
            }
          }
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
        events = [];
        if (abortTransaction) {
          queue[i].status = 2;
          (function(unwatcher) {
            setTimeout(unwatcher, Math.floor(0));
          })(queue[i].unwatcher);
          if (queue[i].onComplete) {
            if (abortReason === "nodata") {
              callbacks.push(() => queue[i].onComplete(null, false, queue[i].currentInputSnapshot));
            } else {
              callbacks.push(() => queue[i].onComplete(new Error(abortReason), false, null));
            }
          }
        }
      }
      repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
      for (let i = 0; i < callbacks.length; i++) {
        exceptionGuard(callbacks[i]);
      }
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
    }
    __name(repoRerunTransactionQueue, "repoRerunTransactionQueue");
    function repoGetAncestorTransactionNode(repo, path) {
      let front;
      let transactionNode = repo.transactionQueueTree_;
      front = pathGetFront(path);
      while (front !== null && treeGetValue(transactionNode) === void 0) {
        transactionNode = treeSubTree(transactionNode, front);
        path = pathPopFront(path);
        front = pathGetFront(path);
      }
      return transactionNode;
    }
    __name(repoGetAncestorTransactionNode, "repoGetAncestorTransactionNode");
    function repoBuildTransactionQueue(repo, transactionNode) {
      const transactionQueue = [];
      repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
      transactionQueue.sort((a2, b2) => a2.order - b2.order);
      return transactionQueue;
    }
    __name(repoBuildTransactionQueue, "repoBuildTransactionQueue");
    function repoAggregateTransactionQueuesForNode(repo, node, queue) {
      const nodeQueue = treeGetValue(node);
      if (nodeQueue) {
        for (let i = 0; i < nodeQueue.length; i++) {
          queue.push(nodeQueue[i]);
        }
      }
      treeForEachChild(node, (child2) => {
        repoAggregateTransactionQueuesForNode(repo, child2, queue);
      });
    }
    __name(repoAggregateTransactionQueuesForNode, "repoAggregateTransactionQueuesForNode");
    function repoPruneCompletedTransactionsBelowNode(repo, node) {
      const queue = treeGetValue(node);
      if (queue) {
        let to = 0;
        for (let from = 0; from < queue.length; from++) {
          if (queue[from].status !== 2) {
            queue[to] = queue[from];
            to++;
          }
        }
        queue.length = to;
        treeSetValue(node, queue.length > 0 ? queue : void 0);
      }
      treeForEachChild(node, (childNode) => {
        repoPruneCompletedTransactionsBelowNode(repo, childNode);
      });
    }
    __name(repoPruneCompletedTransactionsBelowNode, "repoPruneCompletedTransactionsBelowNode");
    function repoAbortTransactions(repo, path) {
      const affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
      const transactionNode = treeSubTree(repo.transactionQueueTree_, path);
      treeForEachAncestor(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
      });
      repoAbortTransactionsOnNode(repo, transactionNode);
      treeForEachDescendant(transactionNode, (node) => {
        repoAbortTransactionsOnNode(repo, node);
      });
      return affectedPath;
    }
    __name(repoAbortTransactions, "repoAbortTransactions");
    function repoAbortTransactionsOnNode(repo, node) {
      const queue = treeGetValue(node);
      if (queue) {
        const callbacks = [];
        let events = [];
        let lastSent = -1;
        for (let i = 0; i < queue.length; i++) {
          if (queue[i].status === 3) ;
          else if (queue[i].status === 1) {
            util.assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
            lastSent = i;
            queue[i].status = 3;
            queue[i].abortReason = "set";
          } else {
            util.assert(queue[i].status === 0, "Unexpected transaction status in abort");
            queue[i].unwatcher();
            events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue[i].currentWriteId, true));
            if (queue[i].onComplete) {
              callbacks.push(queue[i].onComplete.bind(null, new Error("set"), false, null));
            }
          }
        }
        if (lastSent === -1) {
          treeSetValue(node, void 0);
        } else {
          queue.length = lastSent + 1;
        }
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
        for (let i = 0; i < callbacks.length; i++) {
          exceptionGuard(callbacks[i]);
        }
      }
    }
    __name(repoAbortTransactionsOnNode, "repoAbortTransactionsOnNode");
    function decodePath(pathString) {
      let pathStringDecoded = "";
      const pieces = pathString.split("/");
      for (let i = 0; i < pieces.length; i++) {
        if (pieces[i].length > 0) {
          let piece = pieces[i];
          try {
            piece = decodeURIComponent(piece.replace(/\+/g, " "));
          } catch (e) {
          }
          pathStringDecoded += "/" + piece;
        }
      }
      return pathStringDecoded;
    }
    __name(decodePath, "decodePath");
    function decodeQuery(queryString) {
      const results = {};
      if (queryString.charAt(0) === "?") {
        queryString = queryString.substring(1);
      }
      for (const segment of queryString.split("&")) {
        if (segment.length === 0) {
          continue;
        }
        const kv = segment.split("=");
        if (kv.length === 2) {
          results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
        } else {
          warn$1(`Invalid query segment '${segment}' in query '${queryString}'`);
        }
      }
      return results;
    }
    __name(decodeQuery, "decodeQuery");
    var parseRepoInfo = /* @__PURE__ */ __name(function(dataURL, nodeAdmin) {
      const parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
      if (parsedUrl.domain === "firebase.com") {
        fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
      }
      if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
        fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
      }
      if (!parsedUrl.secure) {
        warnIfPageIsSecure();
      }
      const webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
      return {
        repoInfo: new RepoInfo(
          parsedUrl.host,
          parsedUrl.secure,
          namespace,
          webSocketOnly,
          nodeAdmin,
          /*persistenceKey=*/
          "",
          /*includeNamespaceInQueryParams=*/
          namespace !== parsedUrl.subdomain
        ),
        path: new Path(parsedUrl.pathString)
      };
    }, "parseRepoInfo");
    var parseDatabaseURL = /* @__PURE__ */ __name(function(dataURL) {
      let host = "", domain2 = "", subdomain = "", pathString = "", namespace = "";
      let secure = true, scheme = "https", port = 443;
      if (typeof dataURL === "string") {
        let colonInd = dataURL.indexOf("//");
        if (colonInd >= 0) {
          scheme = dataURL.substring(0, colonInd - 1);
          dataURL = dataURL.substring(colonInd + 2);
        }
        let slashInd = dataURL.indexOf("/");
        if (slashInd === -1) {
          slashInd = dataURL.length;
        }
        let questionMarkInd = dataURL.indexOf("?");
        if (questionMarkInd === -1) {
          questionMarkInd = dataURL.length;
        }
        host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
        if (slashInd < questionMarkInd) {
          pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
        }
        const queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
        colonInd = host.indexOf(":");
        if (colonInd >= 0) {
          secure = scheme === "https" || scheme === "wss";
          port = parseInt(host.substring(colonInd + 1), 10);
        } else {
          colonInd = host.length;
        }
        const hostWithoutPort = host.slice(0, colonInd);
        if (hostWithoutPort.toLowerCase() === "localhost") {
          domain2 = "localhost";
        } else if (hostWithoutPort.split(".").length <= 2) {
          domain2 = hostWithoutPort;
        } else {
          const dotInd = host.indexOf(".");
          subdomain = host.substring(0, dotInd).toLowerCase();
          domain2 = host.substring(dotInd + 1);
          namespace = subdomain;
        }
        if ("ns" in queryParams) {
          namespace = queryParams["ns"];
        }
      }
      return {
        host,
        port,
        domain: domain2,
        subdomain,
        secure,
        scheme,
        pathString,
        namespace
      };
    }, "parseDatabaseURL");
    var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
    var nextPushId = /* @__PURE__ */ function() {
      let lastPushTime = 0;
      const lastRandChars = [];
      return function(now) {
        const duplicateTime = now === lastPushTime;
        lastPushTime = now;
        let i;
        const timeStampChars = new Array(8);
        for (i = 7; i >= 0; i--) {
          timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
          now = Math.floor(now / 64);
        }
        util.assert(now === 0, "Cannot push at time == 0");
        let id = timeStampChars.join("");
        if (!duplicateTime) {
          for (i = 0; i < 12; i++) {
            lastRandChars[i] = Math.floor(Math.random() * 64);
          }
        } else {
          for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
            lastRandChars[i] = 0;
          }
          lastRandChars[i]++;
        }
        for (i = 0; i < 12; i++) {
          id += PUSH_CHARS.charAt(lastRandChars[i]);
        }
        util.assert(id.length === 20, "nextPushId: Length should be 20.");
        return id;
      };
    }();
    var DataEvent = class {
      static {
        __name(this, "DataEvent");
      }
      /**
       * @param eventType - One of: value, child_added, child_changed, child_moved, child_removed
       * @param eventRegistration - The function to call to with the event data. User provided
       * @param snapshot - The data backing the event
       * @param prevName - Optional, the name of the previous child for child_* events.
       */
      constructor(eventType, eventRegistration, snapshot, prevName) {
        this.eventType = eventType;
        this.eventRegistration = eventRegistration;
        this.snapshot = snapshot;
        this.prevName = prevName;
      }
      getPath() {
        const ref2 = this.snapshot.ref;
        if (this.eventType === "value") {
          return ref2._path;
        } else {
          return ref2.parent._path;
        }
      }
      getEventType() {
        return this.eventType;
      }
      getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
      }
      toString() {
        return this.getPath().toString() + ":" + this.eventType + ":" + util.stringify(this.snapshot.exportVal());
      }
    };
    var CancelEvent = class {
      static {
        __name(this, "CancelEvent");
      }
      constructor(eventRegistration, error4, path) {
        this.eventRegistration = eventRegistration;
        this.error = error4;
        this.path = path;
      }
      getPath() {
        return this.path;
      }
      getEventType() {
        return "cancel";
      }
      getEventRunner() {
        return this.eventRegistration.getEventRunner(this);
      }
      toString() {
        return this.path.toString() + ":cancel";
      }
    };
    var CallbackContext = class {
      static {
        __name(this, "CallbackContext");
      }
      constructor(snapshotCallback, cancelCallback) {
        this.snapshotCallback = snapshotCallback;
        this.cancelCallback = cancelCallback;
      }
      onValue(expDataSnapshot, previousChildName) {
        this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
      }
      onCancel(error4) {
        util.assert(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback");
        return this.cancelCallback.call(null, error4);
      }
      get hasCancelCallback() {
        return !!this.cancelCallback;
      }
      matches(other) {
        return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== void 0 && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;
      }
    };
    var OnDisconnect$1 = class {
      static {
        __name(this, "OnDisconnect$1");
      }
      /** @hideconstructor */
      constructor(_repo, _path) {
        this._repo = _repo;
        this._path = _path;
      }
      /**
       * Cancels all previously queued `onDisconnect()` set or update events for this
       * location and all children.
       *
       * If a write has been queued for this location via a `set()` or `update()` at a
       * parent location, the write at this location will be canceled, though writes
       * to sibling locations will still occur.
       *
       * @returns Resolves when synchronization to the server is complete.
       */
      cancel() {
        const deferred = new util.Deferred();
        repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(() => {
        }));
        return deferred.promise;
      }
      /**
       * Ensures the data at this location is deleted when the client is disconnected
       * (due to closing the browser, navigating to a new page, or network issues).
       *
       * @returns Resolves when synchronization to the server is complete.
       */
      remove() {
        validateWritablePath("OnDisconnect.remove", this._path);
        const deferred = new util.Deferred();
        repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(() => {
        }));
        return deferred.promise;
      }
      /**
       * Ensures the data at this location is set to the specified value when the
       * client is disconnected (due to closing the browser, navigating to a new page,
       * or network issues).
       *
       * `set()` is especially useful for implementing "presence" systems, where a
       * value should be changed or cleared when a user disconnects so that they
       * appear "offline" to other users. See
       * {@link https://firebase.google.com/docs/database/web/offline-capabilities | Enabling Offline Capabilities in JavaScript}
       * for more information.
       *
       * Note that `onDisconnect` operations are only triggered once. If you want an
       * operation to occur each time a disconnect occurs, you'll need to re-establish
       * the `onDisconnect` operations each time.
       *
       * @param value - The value to be written to this location on disconnect (can
       * be an object, array, string, number, boolean, or null).
       * @returns Resolves when synchronization to the Database is complete.
       */
      set(value) {
        validateWritablePath("OnDisconnect.set", this._path);
        validateFirebaseDataArg("OnDisconnect.set", value, this._path, false);
        const deferred = new util.Deferred();
        repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(() => {
        }));
        return deferred.promise;
      }
      /**
       * Ensures the data at this location is set to the specified value and priority
       * when the client is disconnected (due to closing the browser, navigating to a
       * new page, or network issues).
       *
       * @param value - The value to be written to this location on disconnect (can
       * be an object, array, string, number, boolean, or null).
       * @param priority - The priority to be written (string, number, or null).
       * @returns Resolves when synchronization to the Database is complete.
       */
      setWithPriority(value, priority2) {
        validateWritablePath("OnDisconnect.setWithPriority", this._path);
        validateFirebaseDataArg("OnDisconnect.setWithPriority", value, this._path, false);
        validatePriority("OnDisconnect.setWithPriority", priority2, false);
        const deferred = new util.Deferred();
        repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority2, deferred.wrapCallback(() => {
        }));
        return deferred.promise;
      }
      /**
       * Writes multiple values at this location when the client is disconnected (due
       * to closing the browser, navigating to a new page, or network issues).
       *
       * The `values` argument contains multiple property-value pairs that will be
       * written to the Database together. Each child property can either be a simple
       * property (for example, "name") or a relative path (for example, "name/first")
       * from the current location to the data to update.
       *
       * As opposed to the `set()` method, `update()` can be use to selectively update
       * only the referenced properties at the current location (instead of replacing
       * all the child properties at the current location).
       *
       * @param values - Object containing multiple values.
       * @returns Resolves when synchronization to the Database is complete.
       */
      update(values) {
        validateWritablePath("OnDisconnect.update", this._path);
        validateFirebaseMergeDataArg("OnDisconnect.update", values, this._path, false);
        const deferred = new util.Deferred();
        repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(() => {
        }));
        return deferred.promise;
      }
    };
    var QueryImpl = class _QueryImpl2 {
      static {
        __name(this, "QueryImpl");
      }
      /**
       * @hideconstructor
       */
      constructor(_repo, _path, _queryParams, _orderByCalled) {
        this._repo = _repo;
        this._path = _path;
        this._queryParams = _queryParams;
        this._orderByCalled = _orderByCalled;
      }
      get key() {
        if (pathIsEmpty(this._path)) {
          return null;
        } else {
          return pathGetBack(this._path);
        }
      }
      get ref() {
        return new ReferenceImpl(this._repo, this._path);
      }
      get _queryIdentifier() {
        const obj = queryParamsGetQueryObject(this._queryParams);
        const id = ObjectToUniqueKey(obj);
        return id === "{}" ? "default" : id;
      }
      /**
       * An object representation of the query parameters used by this Query.
       */
      get _queryObject() {
        return queryParamsGetQueryObject(this._queryParams);
      }
      isEqual(other) {
        other = util.getModularInstance(other);
        if (!(other instanceof _QueryImpl2)) {
          return false;
        }
        const sameRepo = this._repo === other._repo;
        const samePath = pathEquals(this._path, other._path);
        const sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
        return sameRepo && samePath && sameQueryIdentifier;
      }
      toJSON() {
        return this.toString();
      }
      toString() {
        return this._repo.toString() + pathToUrlEncodedString(this._path);
      }
    };
    function validateNoPreviousOrderByCall(query2, fnName) {
      if (query2._orderByCalled === true) {
        throw new Error(fnName + ": You can't combine multiple orderBy calls.");
      }
    }
    __name(validateNoPreviousOrderByCall, "validateNoPreviousOrderByCall");
    function validateQueryEndpoints(params) {
      let startNode = null;
      let endNode = null;
      if (params.hasStart()) {
        startNode = params.getIndexStartValue();
      }
      if (params.hasEnd()) {
        endNode = params.getIndexEndValue();
      }
      if (params.getIndex() === KEY_INDEX) {
        const tooManyArgsError = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().";
        const wrongArgTypeError = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
        if (params.hasStart()) {
          const startName = params.getIndexStartName();
          if (startName !== MIN_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof startNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
        if (params.hasEnd()) {
          const endName = params.getIndexEndName();
          if (endName !== MAX_NAME) {
            throw new Error(tooManyArgsError);
          } else if (typeof endNode !== "string") {
            throw new Error(wrongArgTypeError);
          }
        }
      } else if (params.getIndex() === PRIORITY_INDEX) {
        if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {
          throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
        }
      } else {
        util.assert(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, "unknown index type.");
        if (startNode != null && typeof startNode === "object" || endNode != null && typeof endNode === "object") {
          throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");
        }
      }
    }
    __name(validateQueryEndpoints, "validateQueryEndpoints");
    function validateLimit(params) {
      if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {
        throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
      }
    }
    __name(validateLimit, "validateLimit");
    var ReferenceImpl = class _ReferenceImpl2 extends QueryImpl {
      static {
        __name(this, "ReferenceImpl");
      }
      /** @hideconstructor */
      constructor(repo, path) {
        super(repo, path, new QueryParams(), false);
      }
      get parent() {
        const parentPath = pathParent(this._path);
        return parentPath === null ? null : new _ReferenceImpl2(this._repo, parentPath);
      }
      get root() {
        let ref2 = this;
        while (ref2.parent !== null) {
          ref2 = ref2.parent;
        }
        return ref2;
      }
    };
    var DataSnapshot$1 = class _DataSnapshot$1 {
      static {
        __name(this, "DataSnapshot$1");
      }
      /**
       * @param _node - A SnapshotNode to wrap.
       * @param ref - The location this snapshot came from.
       * @param _index - The iteration order for this snapshot
       * @hideconstructor
       */
      constructor(_node, ref2, _index) {
        this._node = _node;
        this.ref = ref2;
        this._index = _index;
      }
      /**
       * Gets the priority value of the data in this `DataSnapshot`.
       *
       * Applications need not use priority but can order collections by
       * ordinary properties (see
       * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
       * ).
       */
      get priority() {
        return this._node.getPriority().val();
      }
      /**
       * The key (last part of the path) of the location of this `DataSnapshot`.
       *
       * The last token in a Database location is considered its key. For example,
       * "ada" is the key for the /users/ada/ node. Accessing the key on any
       * `DataSnapshot` will return the key for the location that generated it.
       * However, accessing the key on the root URL of a Database will return
       * `null`.
       */
      get key() {
        return this.ref.key;
      }
      /** Returns the number of child properties of this `DataSnapshot`. */
      get size() {
        return this._node.numChildren();
      }
      /**
       * Gets another `DataSnapshot` for the location at the specified relative path.
       *
       * Passing a relative path to the `child()` method of a DataSnapshot returns
       * another `DataSnapshot` for the location at the specified relative path. The
       * relative path can either be a simple child name (for example, "ada") or a
       * deeper, slash-separated path (for example, "ada/name/first"). If the child
       * location has no data, an empty `DataSnapshot` (that is, a `DataSnapshot`
       * whose value is `null`) is returned.
       *
       * @param path - A relative path to the location of child data.
       */
      child(path) {
        const childPath = new Path(path);
        const childRef = child(this.ref, path);
        return new _DataSnapshot$1(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
      }
      /**
       * Returns true if this `DataSnapshot` contains any data. It is slightly more
       * efficient than using `snapshot.val() !== null`.
       */
      exists() {
        return !this._node.isEmpty();
      }
      /**
       * Exports the entire contents of the DataSnapshot as a JavaScript object.
       *
       * The `exportVal()` method is similar to `val()`, except priority information
       * is included (if available), making it suitable for backing up your data.
       *
       * @returns The DataSnapshot's contents as a JavaScript value (Object,
       *   Array, string, number, boolean, or `null`).
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      exportVal() {
        return this._node.val(true);
      }
      /**
       * Enumerates the top-level children in the `IteratedDataSnapshot`.
       *
       * Because of the way JavaScript objects work, the ordering of data in the
       * JavaScript object returned by `val()` is not guaranteed to match the
       * ordering on the server nor the ordering of `onChildAdded()` events. That is
       * where `forEach()` comes in handy. It guarantees the children of a
       * `DataSnapshot` will be iterated in their query order.
       *
       * If no explicit `orderBy*()` method is used, results are returned
       * ordered by key (unless priorities are used, in which case, results are
       * returned by priority).
       *
       * @param action - A function that will be called for each child DataSnapshot.
       * The callback can return true to cancel further enumeration.
       * @returns true if enumeration was canceled due to your callback returning
       * true.
       */
      forEach(action) {
        if (this._node.isLeafNode()) {
          return false;
        }
        const childrenNode = this._node;
        return !!childrenNode.forEachChild(this._index, (key2, node) => {
          return action(new _DataSnapshot$1(node, child(this.ref, key2), PRIORITY_INDEX));
        });
      }
      /**
       * Returns true if the specified child path has (non-null) data.
       *
       * @param path - A relative path to the location of a potential child.
       * @returns `true` if data exists at the specified child path; else
       *  `false`.
       */
      hasChild(path) {
        const childPath = new Path(path);
        return !this._node.getChild(childPath).isEmpty();
      }
      /**
       * Returns whether or not the `DataSnapshot` has any non-`null` child
       * properties.
       *
       * You can use `hasChildren()` to determine if a `DataSnapshot` has any
       * children. If it does, you can enumerate them using `forEach()`. If it
       * doesn't, then either this snapshot contains a primitive value (which can be
       * retrieved with `val()`) or it is empty (in which case, `val()` will return
       * `null`).
       *
       * @returns true if this snapshot has any children; else false.
       */
      hasChildren() {
        if (this._node.isLeafNode()) {
          return false;
        } else {
          return !this._node.isEmpty();
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       */
      toJSON() {
        return this.exportVal();
      }
      /**
       * Extracts a JavaScript value from a `DataSnapshot`.
       *
       * Depending on the data in a `DataSnapshot`, the `val()` method may return a
       * scalar type (string, number, or boolean), an array, or an object. It may
       * also return null, indicating that the `DataSnapshot` is empty (contains no
       * data).
       *
       * @returns The DataSnapshot's contents as a JavaScript value (Object,
       *   Array, string, number, boolean, or `null`).
       */
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      val() {
        return this._node.val();
      }
    };
    function ref(db, path) {
      db = util.getModularInstance(db);
      db._checkNotDeleted("ref");
      return path !== void 0 ? child(db._root, path) : db._root;
    }
    __name(ref, "ref");
    function refFromURL(db, url2) {
      db = util.getModularInstance(db);
      db._checkNotDeleted("refFromURL");
      const parsedURL = parseRepoInfo(url2, db._repo.repoInfo_.nodeAdmin);
      validateUrl("refFromURL", parsedURL);
      const repoInfo = parsedURL.repoInfo;
      if (!db._repo.repoInfo_.isCustomHost() && repoInfo.host !== db._repo.repoInfo_.host) {
        fatal("refFromURL: Host name does not match the current database: (found " + repoInfo.host + " but expected " + db._repo.repoInfo_.host + ")");
      }
      return ref(db, parsedURL.path.toString());
    }
    __name(refFromURL, "refFromURL");
    function child(parent, path) {
      parent = util.getModularInstance(parent);
      if (pathGetFront(parent._path) === null) {
        validateRootPathString("child", "path", path, false);
      } else {
        validatePathString("child", "path", path, false);
      }
      return new ReferenceImpl(parent._repo, pathChild(parent._path, path));
    }
    __name(child, "child");
    function onDisconnect(ref2) {
      ref2 = util.getModularInstance(ref2);
      return new OnDisconnect$1(ref2._repo, ref2._path);
    }
    __name(onDisconnect, "onDisconnect");
    function push(parent, value) {
      parent = util.getModularInstance(parent);
      validateWritablePath("push", parent._path);
      validateFirebaseDataArg("push", value, parent._path, true);
      const now = repoServerTime(parent._repo);
      const name = nextPushId(now);
      const thenablePushRef = child(parent, name);
      const pushRef = child(parent, name);
      let promise;
      if (value != null) {
        promise = set(pushRef, value).then(() => pushRef);
      } else {
        promise = Promise.resolve(pushRef);
      }
      thenablePushRef.then = promise.then.bind(promise);
      thenablePushRef.catch = promise.then.bind(promise, void 0);
      return thenablePushRef;
    }
    __name(push, "push");
    function remove(ref2) {
      validateWritablePath("remove", ref2._path);
      return set(ref2, null);
    }
    __name(remove, "remove");
    function set(ref2, value) {
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("set", ref2._path);
      validateFirebaseDataArg("set", value, ref2._path, false);
      const deferred = new util.Deferred();
      repoSetWithPriority(
        ref2._repo,
        ref2._path,
        value,
        /*priority=*/
        null,
        deferred.wrapCallback(() => {
        })
      );
      return deferred.promise;
    }
    __name(set, "set");
    function setPriority2(ref2, priority2) {
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("setPriority", ref2._path);
      validatePriority("setPriority", priority2, false);
      const deferred = new util.Deferred();
      repoSetWithPriority(ref2._repo, pathChild(ref2._path, ".priority"), priority2, null, deferred.wrapCallback(() => {
      }));
      return deferred.promise;
    }
    __name(setPriority2, "setPriority");
    function setWithPriority(ref2, value, priority2) {
      validateWritablePath("setWithPriority", ref2._path);
      validateFirebaseDataArg("setWithPriority", value, ref2._path, false);
      validatePriority("setWithPriority", priority2, false);
      if (ref2.key === ".length" || ref2.key === ".keys") {
        throw "setWithPriority failed: " + ref2.key + " is a read-only object.";
      }
      const deferred = new util.Deferred();
      repoSetWithPriority(ref2._repo, ref2._path, value, priority2, deferred.wrapCallback(() => {
      }));
      return deferred.promise;
    }
    __name(setWithPriority, "setWithPriority");
    function update(ref2, values) {
      validateFirebaseMergeDataArg("update", values, ref2._path, false);
      const deferred = new util.Deferred();
      repoUpdate(ref2._repo, ref2._path, values, deferred.wrapCallback(() => {
      }));
      return deferred.promise;
    }
    __name(update, "update");
    function get3(query2) {
      query2 = util.getModularInstance(query2);
      const callbackContext = new CallbackContext(() => {
      });
      const container = new ValueEventRegistration(callbackContext);
      return repoGetValue(query2._repo, query2, container).then((node) => {
        return new DataSnapshot$1(node, new ReferenceImpl(query2._repo, query2._path), query2._queryParams.getIndex());
      });
    }
    __name(get3, "get");
    var ValueEventRegistration = class _ValueEventRegistration {
      static {
        __name(this, "ValueEventRegistration");
      }
      constructor(callbackContext) {
        this.callbackContext = callbackContext;
      }
      respondsTo(eventType) {
        return eventType === "value";
      }
      createEvent(change, query2) {
        const index = query2._queryParams.getIndex();
        return new DataEvent("value", this, new DataSnapshot$1(change.snapshotNode, new ReferenceImpl(query2._repo, query2._path), index));
      }
      getEventRunner(eventData) {
        if (eventData.getEventType() === "cancel") {
          return () => this.callbackContext.onCancel(eventData.error);
        } else {
          return () => this.callbackContext.onValue(eventData.snapshot, null);
        }
      }
      createCancelEvent(error4, path) {
        if (this.callbackContext.hasCancelCallback) {
          return new CancelEvent(this, error4, path);
        } else {
          return null;
        }
      }
      matches(other) {
        if (!(other instanceof _ValueEventRegistration)) {
          return false;
        } else if (!other.callbackContext || !this.callbackContext) {
          return true;
        } else {
          return other.callbackContext.matches(this.callbackContext);
        }
      }
      hasAnyCallback() {
        return this.callbackContext !== null;
      }
    };
    var ChildEventRegistration = class _ChildEventRegistration {
      static {
        __name(this, "ChildEventRegistration");
      }
      constructor(eventType, callbackContext) {
        this.eventType = eventType;
        this.callbackContext = callbackContext;
      }
      respondsTo(eventType) {
        let eventToCheck = eventType === "children_added" ? "child_added" : eventType;
        eventToCheck = eventToCheck === "children_removed" ? "child_removed" : eventToCheck;
        return this.eventType === eventToCheck;
      }
      createCancelEvent(error4, path) {
        if (this.callbackContext.hasCancelCallback) {
          return new CancelEvent(this, error4, path);
        } else {
          return null;
        }
      }
      createEvent(change, query2) {
        util.assert(change.childName != null, "Child events should have a childName.");
        const childRef = child(new ReferenceImpl(query2._repo, query2._path), change.childName);
        const index = query2._queryParams.getIndex();
        return new DataEvent(change.type, this, new DataSnapshot$1(change.snapshotNode, childRef, index), change.prevName);
      }
      getEventRunner(eventData) {
        if (eventData.getEventType() === "cancel") {
          return () => this.callbackContext.onCancel(eventData.error);
        } else {
          return () => this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
        }
      }
      matches(other) {
        if (other instanceof _ChildEventRegistration) {
          return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));
        }
        return false;
      }
      hasAnyCallback() {
        return !!this.callbackContext;
      }
    };
    function addEventListener(query2, eventType, callback, cancelCallbackOrListenOptions, options) {
      let cancelCallback;
      if (typeof cancelCallbackOrListenOptions === "object") {
        cancelCallback = void 0;
        options = cancelCallbackOrListenOptions;
      }
      if (typeof cancelCallbackOrListenOptions === "function") {
        cancelCallback = cancelCallbackOrListenOptions;
      }
      if (options && options.onlyOnce) {
        const userCallback = callback;
        const onceCallback = /* @__PURE__ */ __name((dataSnapshot, previousChildName) => {
          repoRemoveEventCallbackForQuery(query2._repo, query2, container);
          userCallback(dataSnapshot, previousChildName);
        }, "onceCallback");
        onceCallback.userCallback = callback.userCallback;
        onceCallback.context = callback.context;
        callback = onceCallback;
      }
      const callbackContext = new CallbackContext(callback, cancelCallback || void 0);
      const container = eventType === "value" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);
      repoAddEventCallbackForQuery(query2._repo, query2, container);
      return () => repoRemoveEventCallbackForQuery(query2._repo, query2, container);
    }
    __name(addEventListener, "addEventListener");
    function onValue(query2, callback, cancelCallbackOrListenOptions, options) {
      return addEventListener(query2, "value", callback, cancelCallbackOrListenOptions, options);
    }
    __name(onValue, "onValue");
    function onChildAdded(query2, callback, cancelCallbackOrListenOptions, options) {
      return addEventListener(query2, "child_added", callback, cancelCallbackOrListenOptions, options);
    }
    __name(onChildAdded, "onChildAdded");
    function onChildChanged(query2, callback, cancelCallbackOrListenOptions, options) {
      return addEventListener(query2, "child_changed", callback, cancelCallbackOrListenOptions, options);
    }
    __name(onChildChanged, "onChildChanged");
    function onChildMoved(query2, callback, cancelCallbackOrListenOptions, options) {
      return addEventListener(query2, "child_moved", callback, cancelCallbackOrListenOptions, options);
    }
    __name(onChildMoved, "onChildMoved");
    function onChildRemoved(query2, callback, cancelCallbackOrListenOptions, options) {
      return addEventListener(query2, "child_removed", callback, cancelCallbackOrListenOptions, options);
    }
    __name(onChildRemoved, "onChildRemoved");
    function off2(query2, eventType, callback) {
      let container = null;
      const expCallback = callback ? new CallbackContext(callback) : null;
      if (eventType === "value") {
        container = new ValueEventRegistration(expCallback);
      } else if (eventType) {
        container = new ChildEventRegistration(eventType, expCallback);
      }
      repoRemoveEventCallbackForQuery(query2._repo, query2, container);
    }
    __name(off2, "off");
    var QueryConstraint = class {
      static {
        __name(this, "QueryConstraint");
      }
    };
    var QueryEndAtConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryEndAtConstraint");
      }
      constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
        this.type = "endAt";
      }
      _apply(query2) {
        validateFirebaseDataArg("endAt", this._value, query2._path, true);
        const newParams = queryParamsEndAt(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasEnd()) {
          throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      }
    };
    function endAt(value, key2) {
      validateKey("endAt", "key", key2, true);
      return new QueryEndAtConstraint(value, key2);
    }
    __name(endAt, "endAt");
    var QueryEndBeforeConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryEndBeforeConstraint");
      }
      constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
        this.type = "endBefore";
      }
      _apply(query2) {
        validateFirebaseDataArg("endBefore", this._value, query2._path, false);
        const newParams = queryParamsEndBefore(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasEnd()) {
          throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      }
    };
    function endBefore(value, key2) {
      validateKey("endBefore", "key", key2, true);
      return new QueryEndBeforeConstraint(value, key2);
    }
    __name(endBefore, "endBefore");
    var QueryStartAtConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryStartAtConstraint");
      }
      constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
        this.type = "startAt";
      }
      _apply(query2) {
        validateFirebaseDataArg("startAt", this._value, query2._path, true);
        const newParams = queryParamsStartAt(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasStart()) {
          throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      }
    };
    function startAt(value = null, key2) {
      validateKey("startAt", "key", key2, true);
      return new QueryStartAtConstraint(value, key2);
    }
    __name(startAt, "startAt");
    var QueryStartAfterConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryStartAfterConstraint");
      }
      constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
        this.type = "startAfter";
      }
      _apply(query2) {
        validateFirebaseDataArg("startAfter", this._value, query2._path, false);
        const newParams = queryParamsStartAfter(query2._queryParams, this._value, this._key);
        validateLimit(newParams);
        validateQueryEndpoints(newParams);
        if (query2._queryParams.hasStart()) {
          throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");
        }
        return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
      }
    };
    function startAfter(value, key2) {
      validateKey("startAfter", "key", key2, true);
      return new QueryStartAfterConstraint(value, key2);
    }
    __name(startAfter, "startAfter");
    var QueryLimitToFirstConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryLimitToFirstConstraint");
      }
      constructor(_limit) {
        super();
        this._limit = _limit;
        this.type = "limitToFirst";
      }
      _apply(query2) {
        if (query2._queryParams.hasLimit()) {
          throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");
        }
        return new QueryImpl(query2._repo, query2._path, queryParamsLimitToFirst(query2._queryParams, this._limit), query2._orderByCalled);
      }
    };
    function limitToFirst(limit) {
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("limitToFirst: First argument must be a positive integer.");
      }
      return new QueryLimitToFirstConstraint(limit);
    }
    __name(limitToFirst, "limitToFirst");
    var QueryLimitToLastConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryLimitToLastConstraint");
      }
      constructor(_limit) {
        super();
        this._limit = _limit;
        this.type = "limitToLast";
      }
      _apply(query2) {
        if (query2._queryParams.hasLimit()) {
          throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");
        }
        return new QueryImpl(query2._repo, query2._path, queryParamsLimitToLast(query2._queryParams, this._limit), query2._orderByCalled);
      }
    };
    function limitToLast(limit) {
      if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
        throw new Error("limitToLast: First argument must be a positive integer.");
      }
      return new QueryLimitToLastConstraint(limit);
    }
    __name(limitToLast, "limitToLast");
    var QueryOrderByChildConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryOrderByChildConstraint");
      }
      constructor(_path) {
        super();
        this._path = _path;
        this.type = "orderByChild";
      }
      _apply(query2) {
        validateNoPreviousOrderByCall(query2, "orderByChild");
        const parsedPath = new Path(this._path);
        if (pathIsEmpty(parsedPath)) {
          throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");
        }
        const index = new PathIndex(parsedPath);
        const newParams = queryParamsOrderBy(query2._queryParams, index);
        validateQueryEndpoints(newParams);
        return new QueryImpl(
          query2._repo,
          query2._path,
          newParams,
          /*orderByCalled=*/
          true
        );
      }
    };
    function orderByChild(path) {
      if (path === "$key") {
        throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
      } else if (path === "$priority") {
        throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
      } else if (path === "$value") {
        throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
      }
      validatePathString("orderByChild", "path", path, false);
      return new QueryOrderByChildConstraint(path);
    }
    __name(orderByChild, "orderByChild");
    var QueryOrderByKeyConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryOrderByKeyConstraint");
      }
      constructor() {
        super(...arguments);
        this.type = "orderByKey";
      }
      _apply(query2) {
        validateNoPreviousOrderByCall(query2, "orderByKey");
        const newParams = queryParamsOrderBy(query2._queryParams, KEY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(
          query2._repo,
          query2._path,
          newParams,
          /*orderByCalled=*/
          true
        );
      }
    };
    function orderByKey() {
      return new QueryOrderByKeyConstraint();
    }
    __name(orderByKey, "orderByKey");
    var QueryOrderByPriorityConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryOrderByPriorityConstraint");
      }
      constructor() {
        super(...arguments);
        this.type = "orderByPriority";
      }
      _apply(query2) {
        validateNoPreviousOrderByCall(query2, "orderByPriority");
        const newParams = queryParamsOrderBy(query2._queryParams, PRIORITY_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(
          query2._repo,
          query2._path,
          newParams,
          /*orderByCalled=*/
          true
        );
      }
    };
    function orderByPriority() {
      return new QueryOrderByPriorityConstraint();
    }
    __name(orderByPriority, "orderByPriority");
    var QueryOrderByValueConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryOrderByValueConstraint");
      }
      constructor() {
        super(...arguments);
        this.type = "orderByValue";
      }
      _apply(query2) {
        validateNoPreviousOrderByCall(query2, "orderByValue");
        const newParams = queryParamsOrderBy(query2._queryParams, VALUE_INDEX);
        validateQueryEndpoints(newParams);
        return new QueryImpl(
          query2._repo,
          query2._path,
          newParams,
          /*orderByCalled=*/
          true
        );
      }
    };
    function orderByValue() {
      return new QueryOrderByValueConstraint();
    }
    __name(orderByValue, "orderByValue");
    var QueryEqualToValueConstraint = class extends QueryConstraint {
      static {
        __name(this, "QueryEqualToValueConstraint");
      }
      constructor(_value, _key) {
        super();
        this._value = _value;
        this._key = _key;
        this.type = "equalTo";
      }
      _apply(query2) {
        validateFirebaseDataArg("equalTo", this._value, query2._path, false);
        if (query2._queryParams.hasStart()) {
          throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
        }
        if (query2._queryParams.hasEnd()) {
          throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
        }
        return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query2));
      }
    };
    function equalTo(value, key2) {
      validateKey("equalTo", "key", key2, true);
      return new QueryEqualToValueConstraint(value, key2);
    }
    __name(equalTo, "equalTo");
    function query(query2, ...queryConstraints) {
      let queryImpl = util.getModularInstance(query2);
      for (const constraint of queryConstraints) {
        queryImpl = constraint._apply(queryImpl);
      }
      return queryImpl;
    }
    __name(query, "query");
    syncPointSetReferenceConstructor(ReferenceImpl);
    syncTreeSetReferenceConstructor(ReferenceImpl);
    var FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
    var repos = {};
    var useRestClient = false;
    function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
      repo.repoInfo_ = new RepoInfo(
        `${host}:${port}`,
        /* secure= */
        false,
        repo.repoInfo_.namespace,
        repo.repoInfo_.webSocketOnly,
        repo.repoInfo_.nodeAdmin,
        repo.repoInfo_.persistenceKey,
        repo.repoInfo_.includeNamespaceInQueryParams,
        /*isUsingEmulator=*/
        true
      );
      if (tokenProvider) {
        repo.authTokenProvider_ = tokenProvider;
      }
    }
    __name(repoManagerApplyEmulatorSettings, "repoManagerApplyEmulatorSettings");
    function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url2, nodeAdmin) {
      let dbUrl = url2 || app.options.databaseURL;
      if (dbUrl === void 0) {
        if (!app.options.projectId) {
          fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
        }
        log4("Using default host for project ", app.options.projectId);
        dbUrl = `${app.options.projectId}-default-rtdb.firebaseio.com`;
      }
      let parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
      let repoInfo = parsedUrl.repoInfo;
      let isEmulator;
      let dbEmulatorHost = void 0;
      if (typeof process !== "undefined" && process.env) {
        dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
      }
      if (dbEmulatorHost) {
        isEmulator = true;
        dbUrl = `http://${dbEmulatorHost}?ns=${repoInfo.namespace}`;
        parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
        repoInfo = parsedUrl.repoInfo;
      } else {
        isEmulator = !parsedUrl.repoInfo.secure;
      }
      const authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
      validateUrl("Invalid Firebase Database URL", parsedUrl);
      if (!pathIsEmpty(parsedUrl.path)) {
        fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
      }
      const repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
      return new Database$1(repo, app);
    }
    __name(repoManagerDatabaseFromApp, "repoManagerDatabaseFromApp");
    function repoManagerDeleteRepo(repo, appName) {
      const appRepos = repos[appName];
      if (!appRepos || appRepos[repo.key] !== repo) {
        fatal(`Database ${appName}(${repo.repoInfo_}) has already been deleted.`);
      }
      repoInterrupt(repo);
      delete appRepos[repo.key];
    }
    __name(repoManagerDeleteRepo, "repoManagerDeleteRepo");
    function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
      let appRepos = repos[app.name];
      if (!appRepos) {
        appRepos = {};
        repos[app.name] = appRepos;
      }
      let repo = appRepos[repoInfo.toURLString()];
      if (repo) {
        fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
      }
      repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
      appRepos[repoInfo.toURLString()] = repo;
      return repo;
    }
    __name(repoManagerCreateRepo, "repoManagerCreateRepo");
    function repoManagerForceRestClient(forceRestClient2) {
      useRestClient = forceRestClient2;
    }
    __name(repoManagerForceRestClient, "repoManagerForceRestClient");
    var Database$1 = class {
      static {
        __name(this, "Database$1");
      }
      /** @hideconstructor */
      constructor(_repoInternal, app) {
        this._repoInternal = _repoInternal;
        this.app = app;
        this["type"] = "database";
        this._instanceStarted = false;
      }
      get _repo() {
        if (!this._instanceStarted) {
          repoStart(this._repoInternal, this.app.options.appId, this.app.options["databaseAuthVariableOverride"]);
          this._instanceStarted = true;
        }
        return this._repoInternal;
      }
      get _root() {
        if (!this._rootInternal) {
          this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
        }
        return this._rootInternal;
      }
      _delete() {
        if (this._rootInternal !== null) {
          repoManagerDeleteRepo(this._repo, this.app.name);
          this._repoInternal = null;
          this._rootInternal = null;
        }
        return Promise.resolve();
      }
      _checkNotDeleted(apiName) {
        if (this._rootInternal === null) {
          fatal("Cannot call " + apiName + " on a deleted database.");
        }
      }
    };
    function checkTransportInit() {
      if (TransportManager.IS_TRANSPORT_INITIALIZED) {
        warn$1("Transport has already been initialized. Please call this function before calling ref or setting up a listener");
      }
    }
    __name(checkTransportInit, "checkTransportInit");
    function forceWebSockets() {
      checkTransportInit();
      BrowserPollConnection.forceDisallow();
    }
    __name(forceWebSockets, "forceWebSockets");
    function forceLongPolling() {
      checkTransportInit();
      WebSocketConnection.forceDisallow();
      BrowserPollConnection.forceAllow();
    }
    __name(forceLongPolling, "forceLongPolling");
    function connectDatabaseEmulator(db, host, port, options = {}) {
      db = util.getModularInstance(db);
      db._checkNotDeleted("useEmulator");
      if (db._instanceStarted) {
        fatal("Cannot call useEmulator() after instance has already been initialized.");
      }
      const repo = db._repoInternal;
      let tokenProvider = void 0;
      if (repo.repoInfo_.nodeAdmin) {
        if (options.mockUserToken) {
          fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
        }
        tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
      } else if (options.mockUserToken) {
        const token = typeof options.mockUserToken === "string" ? options.mockUserToken : util.createMockUserToken(options.mockUserToken, db.app.options.projectId);
        tokenProvider = new EmulatorTokenProvider(token);
      }
      repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
    }
    __name(connectDatabaseEmulator, "connectDatabaseEmulator");
    function goOffline(db) {
      db = util.getModularInstance(db);
      db._checkNotDeleted("goOffline");
      repoInterrupt(db._repo);
    }
    __name(goOffline, "goOffline");
    function goOnline(db) {
      db = util.getModularInstance(db);
      db._checkNotDeleted("goOnline");
      repoResume(db._repo);
    }
    __name(goOnline, "goOnline");
    function enableLogging2(logger2, persistent) {
      enableLogging$1(logger2, persistent);
    }
    __name(enableLogging2, "enableLogging");
    var SERVER_TIMESTAMP = {
      ".sv": "timestamp"
    };
    function serverTimestamp() {
      return SERVER_TIMESTAMP;
    }
    __name(serverTimestamp, "serverTimestamp");
    function increment(delta) {
      return {
        ".sv": {
          "increment": delta
        }
      };
    }
    __name(increment, "increment");
    var TransactionResult$1 = class {
      static {
        __name(this, "TransactionResult$1");
      }
      /** @hideconstructor */
      constructor(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
      }
      /** Returns a JSON-serializable representation of this object. */
      toJSON() {
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
      }
    };
    function runTransaction(ref2, transactionUpdate, options) {
      var _a;
      ref2 = util.getModularInstance(ref2);
      validateWritablePath("Reference.transaction", ref2._path);
      if (ref2.key === ".length" || ref2.key === ".keys") {
        throw "Reference.transaction failed: " + ref2.key + " is a read-only object.";
      }
      const applyLocally = (_a = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a !== void 0 ? _a : true;
      const deferred = new util.Deferred();
      const promiseComplete = /* @__PURE__ */ __name((error4, committed, node) => {
        let dataSnapshot = null;
        if (error4) {
          deferred.reject(error4);
        } else {
          dataSnapshot = new DataSnapshot$1(node, new ReferenceImpl(ref2._repo, ref2._path), PRIORITY_INDEX);
          deferred.resolve(new TransactionResult$1(committed, dataSnapshot));
        }
      }, "promiseComplete");
      const unwatcher = onValue(ref2, () => {
      });
      repoStartTransaction(ref2._repo, ref2._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
      return deferred.promise;
    }
    __name(runTransaction, "runTransaction");
    PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
      this.sendRequest("q", { p: pathString }, onComplete);
    };
    PersistentConnection.prototype.echo = function(data, onEcho) {
      this.sendRequest("echo", { d: data }, onEcho);
    };
    var hijackHash = /* @__PURE__ */ __name(function(newHash) {
      const oldPut = PersistentConnection.prototype.put;
      PersistentConnection.prototype.put = function(pathString, data, onComplete, hash2) {
        if (hash2 !== void 0) {
          hash2 = newHash();
        }
        oldPut.call(this, pathString, data, onComplete, hash2);
      };
      return function() {
        PersistentConnection.prototype.put = oldPut;
      };
    }, "hijackHash");
    var forceRestClient = /* @__PURE__ */ __name(function(forceRestClient2) {
      repoManagerForceRestClient(forceRestClient2);
    }, "forceRestClient");
    function _initStandalone({ app, url: url2, version: version3, customAuthImpl, customAppCheckImpl, nodeAdmin = false }) {
      setSDKVersion(version3);
      const componentContainer = new component.ComponentContainer("database-standalone");
      const authProvider = new component.Provider("auth-internal", componentContainer);
      let appCheckProvider;
      if (customAppCheckImpl) {
        appCheckProvider = new component.Provider("app-check-internal", componentContainer);
        appCheckProvider.setComponent(new component.Component(
          "app-check-internal",
          () => customAppCheckImpl,
          "PRIVATE"
          /* ComponentType.PRIVATE */
        ));
      }
      authProvider.setComponent(new component.Component(
        "auth-internal",
        () => customAuthImpl,
        "PRIVATE"
        /* ComponentType.PRIVATE */
      ));
      return repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url2, nodeAdmin);
    }
    __name(_initStandalone, "_initStandalone");
    setWebSocketImpl(Websocket__default["default"].Client);
    index_standalone.DataSnapshot = DataSnapshot$1;
    index_standalone.Database = Database$1;
    var OnDisconnect_1 = index_standalone.OnDisconnect = OnDisconnect$1;
    index_standalone.QueryConstraint = QueryConstraint;
    index_standalone.TransactionResult = TransactionResult$1;
    var _QueryImpl = index_standalone._QueryImpl = QueryImpl;
    var _QueryParams = index_standalone._QueryParams = QueryParams;
    var _ReferenceImpl = index_standalone._ReferenceImpl = ReferenceImpl;
    index_standalone._TEST_ACCESS_forceRestClient = forceRestClient;
    index_standalone._TEST_ACCESS_hijackHash = hijackHash;
    index_standalone._initStandalone = _initStandalone;
    var _repoManagerDatabaseFromApp = index_standalone._repoManagerDatabaseFromApp = repoManagerDatabaseFromApp;
    var _setSDKVersion = index_standalone._setSDKVersion = setSDKVersion;
    var _validatePathString = index_standalone._validatePathString = validatePathString;
    var _validateWritablePath = index_standalone._validateWritablePath = validateWritablePath;
    var child_1 = index_standalone.child = child;
    var connectDatabaseEmulator_1 = index_standalone.connectDatabaseEmulator = connectDatabaseEmulator;
    var enableLogging_1 = index_standalone.enableLogging = enableLogging2;
    var endAt_1 = index_standalone.endAt = endAt;
    var endBefore_1 = index_standalone.endBefore = endBefore;
    var equalTo_1 = index_standalone.equalTo = equalTo;
    var forceLongPolling_1 = index_standalone.forceLongPolling = forceLongPolling;
    var forceWebSockets_1 = index_standalone.forceWebSockets = forceWebSockets;
    var get_1 = index_standalone.get = get3;
    var goOffline_1 = index_standalone.goOffline = goOffline;
    var goOnline_1 = index_standalone.goOnline = goOnline;
    var increment_1 = index_standalone.increment = increment;
    var limitToFirst_1 = index_standalone.limitToFirst = limitToFirst;
    var limitToLast_1 = index_standalone.limitToLast = limitToLast;
    var off_1 = index_standalone.off = off2;
    var onChildAdded_1 = index_standalone.onChildAdded = onChildAdded;
    var onChildChanged_1 = index_standalone.onChildChanged = onChildChanged;
    var onChildMoved_1 = index_standalone.onChildMoved = onChildMoved;
    var onChildRemoved_1 = index_standalone.onChildRemoved = onChildRemoved;
    index_standalone.onDisconnect = onDisconnect;
    var onValue_1 = index_standalone.onValue = onValue;
    var orderByChild_1 = index_standalone.orderByChild = orderByChild;
    var orderByKey_1 = index_standalone.orderByKey = orderByKey;
    var orderByPriority_1 = index_standalone.orderByPriority = orderByPriority;
    var orderByValue_1 = index_standalone.orderByValue = orderByValue;
    var push_1 = index_standalone.push = push;
    var query_1 = index_standalone.query = query;
    var ref_1 = index_standalone.ref = ref;
    var refFromURL_1 = index_standalone.refFromURL = refFromURL;
    var remove_1 = index_standalone.remove = remove;
    var runTransaction_1 = index_standalone.runTransaction = runTransaction;
    var serverTimestamp_1 = index_standalone.serverTimestamp = serverTimestamp;
    var set_1 = index_standalone.set = set;
    var setPriority_1 = index_standalone.setPriority = setPriority2;
    var setWithPriority_1 = index_standalone.setWithPriority = setWithPriority;
    var startAfter_1 = index_standalone.startAfter = startAfter;
    var startAt_1 = index_standalone.startAt = startAt;
    var update_1 = index_standalone.update = update;
    var logClient = new require$$2$3.Logger("@firebase/database-compat");
    var warn3 = /* @__PURE__ */ __name(function(msg) {
      const message3 = "FIREBASE WARNING: " + msg;
      logClient.warn(message3);
    }, "warn");
    var validateBoolean = /* @__PURE__ */ __name(function(fnName, argumentName, bool, optional) {
      if (optional && bool === void 0) {
        return;
      }
      if (typeof bool !== "boolean") {
        throw new Error(require$$1$3.errorPrefix(fnName, argumentName) + "must be a boolean.");
      }
    }, "validateBoolean");
    var validateEventType = /* @__PURE__ */ __name(function(fnName, eventType, optional) {
      if (optional && eventType === void 0) {
        return;
      }
      switch (eventType) {
        case "value":
        case "child_added":
        case "child_removed":
        case "child_changed":
        case "child_moved":
          break;
        default:
          throw new Error(require$$1$3.errorPrefix(fnName, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
      }
    }, "validateEventType");
    var OnDisconnect = class {
      static {
        __name(this, "OnDisconnect");
      }
      constructor(_delegate) {
        this._delegate = _delegate;
      }
      cancel(onComplete) {
        require$$1$3.validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
        require$$1$3.validateCallback("OnDisconnect.cancel", "onComplete", onComplete, true);
        const result = this._delegate.cancel();
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      remove(onComplete) {
        require$$1$3.validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
        require$$1$3.validateCallback("OnDisconnect.remove", "onComplete", onComplete, true);
        const result = this._delegate.remove();
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      set(value, onComplete) {
        require$$1$3.validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
        require$$1$3.validateCallback("OnDisconnect.set", "onComplete", onComplete, true);
        const result = this._delegate.set(value);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      setWithPriority(value, priority2, onComplete) {
        require$$1$3.validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
        require$$1$3.validateCallback("OnDisconnect.setWithPriority", "onComplete", onComplete, true);
        const result = this._delegate.setWithPriority(value, priority2);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      update(objectToMerge, onComplete) {
        require$$1$3.validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
        if (Array.isArray(objectToMerge)) {
          const newObjectToMerge = {};
          for (let i = 0; i < objectToMerge.length; ++i) {
            newObjectToMerge["" + i] = objectToMerge[i];
          }
          objectToMerge = newObjectToMerge;
          warn3("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        require$$1$3.validateCallback("OnDisconnect.update", "onComplete", onComplete, true);
        const result = this._delegate.update(objectToMerge);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
    };
    var TransactionResult = class {
      static {
        __name(this, "TransactionResult");
      }
      /**
       * A type for the resolve value of Firebase.transaction.
       */
      constructor(committed, snapshot) {
        this.committed = committed;
        this.snapshot = snapshot;
      }
      // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
      // for end-users
      toJSON() {
        require$$1$3.validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
        return { committed: this.committed, snapshot: this.snapshot.toJSON() };
      }
    };
    var DataSnapshot = class _DataSnapshot {
      static {
        __name(this, "DataSnapshot");
      }
      constructor(_database, _delegate) {
        this._database = _database;
        this._delegate = _delegate;
      }
      /**
       * Retrieves the snapshot contents as JSON.  Returns null if the snapshot is
       * empty.
       *
       * @returns JSON representation of the DataSnapshot contents, or null if empty.
       */
      val() {
        require$$1$3.validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
        return this._delegate.val();
      }
      /**
       * Returns the snapshot contents as JSON, including priorities of node.  Suitable for exporting
       * the entire node contents.
       * @returns JSON representation of the DataSnapshot contents, or null if empty.
       */
      exportVal() {
        require$$1$3.validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
        return this._delegate.exportVal();
      }
      // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
      // for end-users
      toJSON() {
        require$$1$3.validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
        return this._delegate.toJSON();
      }
      /**
       * Returns whether the snapshot contains a non-null value.
       *
       * @returns Whether the snapshot contains a non-null value, or is empty.
       */
      exists() {
        require$$1$3.validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
        return this._delegate.exists();
      }
      /**
       * Returns a DataSnapshot of the specified child node's contents.
       *
       * @param path - Path to a child.
       * @returns DataSnapshot for child node.
       */
      child(path) {
        require$$1$3.validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
        path = String(path);
        _validatePathString("DataSnapshot.child", "path", path, false);
        return new _DataSnapshot(this._database, this._delegate.child(path));
      }
      /**
       * Returns whether the snapshot contains a child at the specified path.
       *
       * @param path - Path to a child.
       * @returns Whether the child exists.
       */
      hasChild(path) {
        require$$1$3.validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
        _validatePathString("DataSnapshot.hasChild", "path", path, false);
        return this._delegate.hasChild(path);
      }
      /**
       * Returns the priority of the object, or null if no priority was set.
       *
       * @returns The priority.
       */
      getPriority() {
        require$$1$3.validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
        return this._delegate.priority;
      }
      /**
       * Iterates through child nodes and calls the specified action for each one.
       *
       * @param action - Callback function to be called
       * for each child.
       * @returns True if forEach was canceled by action returning true for
       * one of the child nodes.
       */
      forEach(action) {
        require$$1$3.validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
        require$$1$3.validateCallback("DataSnapshot.forEach", "action", action, false);
        return this._delegate.forEach((expDataSnapshot) => action(new _DataSnapshot(this._database, expDataSnapshot)));
      }
      /**
       * Returns whether this DataSnapshot has children.
       * @returns True if the DataSnapshot contains 1 or more child nodes.
       */
      hasChildren() {
        require$$1$3.validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
        return this._delegate.hasChildren();
      }
      get key() {
        return this._delegate.key;
      }
      /**
       * Returns the number of children for this DataSnapshot.
       * @returns The number of children that this DataSnapshot contains.
       */
      numChildren() {
        require$$1$3.validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
        return this._delegate.size;
      }
      /**
       * @returns The Firebase reference for the location this snapshot's data came
       * from.
       */
      getRef() {
        require$$1$3.validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
        return new Reference(this._database, this._delegate.ref);
      }
      get ref() {
        return this.getRef();
      }
    };
    var Query = class _Query {
      static {
        __name(this, "Query");
      }
      constructor(database, _delegate) {
        this.database = database;
        this._delegate = _delegate;
      }
      on(eventType, callback, cancelCallbackOrContext, context2) {
        var _a;
        require$$1$3.validateArgCount("Query.on", 2, 4, arguments.length);
        require$$1$3.validateCallback("Query.on", "callback", callback, false);
        const ret = _Query.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context2);
        const valueCallback = /* @__PURE__ */ __name((expSnapshot, previousChildName) => {
          callback.call(ret.context, new DataSnapshot(this.database, expSnapshot), previousChildName);
        }, "valueCallback");
        valueCallback.userCallback = callback;
        valueCallback.context = ret.context;
        const cancelCallback = (_a = ret.cancel) === null || _a === void 0 ? void 0 : _a.bind(ret.context);
        switch (eventType) {
          case "value":
            onValue_1(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_added":
            onChildAdded_1(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_removed":
            onChildRemoved_1(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_changed":
            onChildChanged_1(this._delegate, valueCallback, cancelCallback);
            return callback;
          case "child_moved":
            onChildMoved_1(this._delegate, valueCallback, cancelCallback);
            return callback;
          default:
            throw new Error(require$$1$3.errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
      }
      off(eventType, callback, context2) {
        require$$1$3.validateArgCount("Query.off", 0, 3, arguments.length);
        validateEventType("Query.off", eventType, true);
        require$$1$3.validateCallback("Query.off", "callback", callback, true);
        require$$1$3.validateContextObject("Query.off", "context", context2, true);
        if (callback) {
          const valueCallback = /* @__PURE__ */ __name(() => {
          }, "valueCallback");
          valueCallback.userCallback = callback;
          valueCallback.context = context2;
          off_1(this._delegate, eventType, valueCallback);
        } else {
          off_1(this._delegate, eventType);
        }
      }
      /**
       * Get the server-value for this query, or return a cached value if not connected.
       */
      get() {
        return get_1(this._delegate).then((expSnapshot) => {
          return new DataSnapshot(this.database, expSnapshot);
        });
      }
      /**
       * Attaches a listener, waits for the first event, and then removes the listener
       */
      once(eventType, callback, failureCallbackOrContext, context2) {
        require$$1$3.validateArgCount("Query.once", 1, 4, arguments.length);
        require$$1$3.validateCallback("Query.once", "callback", callback, true);
        const ret = _Query.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context2);
        const deferred = new require$$1$3.Deferred();
        const valueCallback = /* @__PURE__ */ __name((expSnapshot, previousChildName) => {
          const result = new DataSnapshot(this.database, expSnapshot);
          if (callback) {
            callback.call(ret.context, result, previousChildName);
          }
          deferred.resolve(result);
        }, "valueCallback");
        valueCallback.userCallback = callback;
        valueCallback.context = ret.context;
        const cancelCallback = /* @__PURE__ */ __name((error4) => {
          if (ret.cancel) {
            ret.cancel.call(ret.context, error4);
          }
          deferred.reject(error4);
        }, "cancelCallback");
        switch (eventType) {
          case "value":
            onValue_1(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_added":
            onChildAdded_1(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_removed":
            onChildRemoved_1(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_changed":
            onChildChanged_1(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          case "child_moved":
            onChildMoved_1(this._delegate, valueCallback, cancelCallback, {
              onlyOnce: true
            });
            break;
          default:
            throw new Error(require$$1$3.errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
        }
        return deferred.promise;
      }
      /**
       * Set a limit and anchor it to the start of the window.
       */
      limitToFirst(limit) {
        require$$1$3.validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
        return new _Query(this.database, query_1(this._delegate, limitToFirst_1(limit)));
      }
      /**
       * Set a limit and anchor it to the end of the window.
       */
      limitToLast(limit) {
        require$$1$3.validateArgCount("Query.limitToLast", 1, 1, arguments.length);
        return new _Query(this.database, query_1(this._delegate, limitToLast_1(limit)));
      }
      /**
       * Given a child path, return a new query ordered by the specified grandchild path.
       */
      orderByChild(path) {
        require$$1$3.validateArgCount("Query.orderByChild", 1, 1, arguments.length);
        return new _Query(this.database, query_1(this._delegate, orderByChild_1(path)));
      }
      /**
       * Return a new query ordered by the KeyIndex
       */
      orderByKey() {
        require$$1$3.validateArgCount("Query.orderByKey", 0, 0, arguments.length);
        return new _Query(this.database, query_1(this._delegate, orderByKey_1()));
      }
      /**
       * Return a new query ordered by the PriorityIndex
       */
      orderByPriority() {
        require$$1$3.validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
        return new _Query(this.database, query_1(this._delegate, orderByPriority_1()));
      }
      /**
       * Return a new query ordered by the ValueIndex
       */
      orderByValue() {
        require$$1$3.validateArgCount("Query.orderByValue", 0, 0, arguments.length);
        return new _Query(this.database, query_1(this._delegate, orderByValue_1()));
      }
      startAt(value = null, name) {
        require$$1$3.validateArgCount("Query.startAt", 0, 2, arguments.length);
        return new _Query(this.database, query_1(this._delegate, startAt_1(value, name)));
      }
      startAfter(value = null, name) {
        require$$1$3.validateArgCount("Query.startAfter", 0, 2, arguments.length);
        return new _Query(this.database, query_1(this._delegate, startAfter_1(value, name)));
      }
      endAt(value = null, name) {
        require$$1$3.validateArgCount("Query.endAt", 0, 2, arguments.length);
        return new _Query(this.database, query_1(this._delegate, endAt_1(value, name)));
      }
      endBefore(value = null, name) {
        require$$1$3.validateArgCount("Query.endBefore", 0, 2, arguments.length);
        return new _Query(this.database, query_1(this._delegate, endBefore_1(value, name)));
      }
      /**
       * Load the selection of children with exactly the specified value, and, optionally,
       * the specified name.
       */
      equalTo(value, name) {
        require$$1$3.validateArgCount("Query.equalTo", 1, 2, arguments.length);
        return new _Query(this.database, query_1(this._delegate, equalTo_1(value, name)));
      }
      /**
       * @returns URL for this location.
       */
      toString() {
        require$$1$3.validateArgCount("Query.toString", 0, 0, arguments.length);
        return this._delegate.toString();
      }
      // Do not create public documentation. This is intended to make JSON serialization work but is otherwise unnecessary
      // for end-users.
      toJSON() {
        require$$1$3.validateArgCount("Query.toJSON", 0, 1, arguments.length);
        return this._delegate.toJSON();
      }
      /**
       * Return true if this query and the provided query are equivalent; otherwise, return false.
       */
      isEqual(other) {
        require$$1$3.validateArgCount("Query.isEqual", 1, 1, arguments.length);
        if (!(other instanceof _Query)) {
          const error4 = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
          throw new Error(error4);
        }
        return this._delegate.isEqual(other._delegate);
      }
      /**
       * Helper used by .on and .once to extract the context and or cancel arguments.
       * @param fnName - The function name (on or once)
       *
       */
      static getCancelAndContextArgs_(fnName, cancelOrContext, context2) {
        const ret = { cancel: void 0, context: void 0 };
        if (cancelOrContext && context2) {
          ret.cancel = cancelOrContext;
          require$$1$3.validateCallback(fnName, "cancel", ret.cancel, true);
          ret.context = context2;
          require$$1$3.validateContextObject(fnName, "context", ret.context, true);
        } else if (cancelOrContext) {
          if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
            ret.context = cancelOrContext;
          } else if (typeof cancelOrContext === "function") {
            ret.cancel = cancelOrContext;
          } else {
            throw new Error(require$$1$3.errorPrefix(fnName, "cancelOrContext") + " must either be a cancel callback or a context object.");
          }
        }
        return ret;
      }
      get ref() {
        return new Reference(this.database, new _ReferenceImpl(this._delegate._repo, this._delegate._path));
      }
    };
    var Reference = class _Reference extends Query {
      static {
        __name(this, "Reference");
      }
      /**
       * Call options:
       *   new Reference(Repo, Path) or
       *   new Reference(url: string, string|RepoManager)
       *
       * Externally - this is the firebase.database.Reference type.
       */
      constructor(database, _delegate) {
        super(database, new _QueryImpl(_delegate._repo, _delegate._path, new _QueryParams(), false));
        this.database = database;
        this._delegate = _delegate;
      }
      /** @returns {?string} */
      getKey() {
        require$$1$3.validateArgCount("Reference.key", 0, 0, arguments.length);
        return this._delegate.key;
      }
      child(pathString) {
        require$$1$3.validateArgCount("Reference.child", 1, 1, arguments.length);
        if (typeof pathString === "number") {
          pathString = String(pathString);
        }
        return new _Reference(this.database, child_1(this._delegate, pathString));
      }
      /** @returns {?Reference} */
      getParent() {
        require$$1$3.validateArgCount("Reference.parent", 0, 0, arguments.length);
        const parent = this._delegate.parent;
        return parent ? new _Reference(this.database, parent) : null;
      }
      /** @returns {!Reference} */
      getRoot() {
        require$$1$3.validateArgCount("Reference.root", 0, 0, arguments.length);
        return new _Reference(this.database, this._delegate.root);
      }
      set(newVal, onComplete) {
        require$$1$3.validateArgCount("Reference.set", 1, 2, arguments.length);
        require$$1$3.validateCallback("Reference.set", "onComplete", onComplete, true);
        const result = set_1(this._delegate, newVal);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      update(values, onComplete) {
        require$$1$3.validateArgCount("Reference.update", 1, 2, arguments.length);
        if (Array.isArray(values)) {
          const newObjectToMerge = {};
          for (let i = 0; i < values.length; ++i) {
            newObjectToMerge["" + i] = values[i];
          }
          values = newObjectToMerge;
          warn3("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
        }
        _validateWritablePath("Reference.update", this._delegate._path);
        require$$1$3.validateCallback("Reference.update", "onComplete", onComplete, true);
        const result = update_1(this._delegate, values);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      setWithPriority(newVal, newPriority, onComplete) {
        require$$1$3.validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
        require$$1$3.validateCallback("Reference.setWithPriority", "onComplete", onComplete, true);
        const result = setWithPriority_1(this._delegate, newVal, newPriority);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      remove(onComplete) {
        require$$1$3.validateArgCount("Reference.remove", 0, 1, arguments.length);
        require$$1$3.validateCallback("Reference.remove", "onComplete", onComplete, true);
        const result = remove_1(this._delegate);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      transaction(transactionUpdate, onComplete, applyLocally) {
        require$$1$3.validateArgCount("Reference.transaction", 1, 3, arguments.length);
        require$$1$3.validateCallback("Reference.transaction", "transactionUpdate", transactionUpdate, false);
        require$$1$3.validateCallback("Reference.transaction", "onComplete", onComplete, true);
        validateBoolean("Reference.transaction", "applyLocally", applyLocally, true);
        const result = runTransaction_1(this._delegate, transactionUpdate, {
          applyLocally
        }).then((transactionResult) => new TransactionResult(transactionResult.committed, new DataSnapshot(this.database, transactionResult.snapshot)));
        if (onComplete) {
          result.then((transactionResult) => onComplete(null, transactionResult.committed, transactionResult.snapshot), (error4) => onComplete(error4, false, null));
        }
        return result;
      }
      setPriority(priority2, onComplete) {
        require$$1$3.validateArgCount("Reference.setPriority", 1, 2, arguments.length);
        require$$1$3.validateCallback("Reference.setPriority", "onComplete", onComplete, true);
        const result = setPriority_1(this._delegate, priority2);
        if (onComplete) {
          result.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        return result;
      }
      push(value, onComplete) {
        require$$1$3.validateArgCount("Reference.push", 0, 2, arguments.length);
        require$$1$3.validateCallback("Reference.push", "onComplete", onComplete, true);
        const expPromise = push_1(this._delegate, value);
        const promise = expPromise.then((expRef) => new _Reference(this.database, expRef));
        if (onComplete) {
          promise.then(() => onComplete(null), (error4) => onComplete(error4));
        }
        const result = new _Reference(this.database, expPromise);
        result.then = promise.then.bind(promise);
        result.catch = promise.catch.bind(promise, void 0);
        return result;
      }
      onDisconnect() {
        _validateWritablePath("Reference.onDisconnect", this._delegate._path);
        return new OnDisconnect(new OnDisconnect_1(this._delegate._repo, this._delegate._path));
      }
      get key() {
        return this.getKey();
      }
      get parent() {
        return this.getParent();
      }
      get root() {
        return this.getRoot();
      }
    };
    var Database = class {
      static {
        __name(this, "Database");
      }
      /**
       * The constructor should not be called by users of our public API.
       */
      constructor(_delegate, app) {
        this._delegate = _delegate;
        this.app = app;
        this.INTERNAL = {
          delete: /* @__PURE__ */ __name(() => this._delegate._delete(), "delete"),
          forceWebSockets: forceWebSockets_1,
          forceLongPolling: forceLongPolling_1
        };
      }
      /**
       * Modify this instance to communicate with the Realtime Database emulator.
       *
       * <p>Note: This method must be called before performing any other operation.
       *
       * @param host - the emulator host (ex: localhost)
       * @param port - the emulator port (ex: 8080)
       * @param options.mockUserToken - the mock auth token to use for unit testing Security Rules
       */
      useEmulator(host, port, options = {}) {
        connectDatabaseEmulator_1(this._delegate, host, port, options);
      }
      ref(path) {
        require$$1$3.validateArgCount("database.ref", 0, 1, arguments.length);
        if (path instanceof Reference) {
          const childRef = refFromURL_1(this._delegate, path.toString());
          return new Reference(this, childRef);
        } else {
          const childRef = ref_1(this._delegate, path);
          return new Reference(this, childRef);
        }
      }
      /**
       * Returns a reference to the root or the path specified in url.
       * We throw a exception if the url is not in the same domain as the
       * current repo.
       * @returns Firebase reference.
       */
      refFromURL(url2) {
        const apiName = "database.refFromURL";
        require$$1$3.validateArgCount(apiName, 1, 1, arguments.length);
        const childRef = refFromURL_1(this._delegate, url2);
        return new Reference(this, childRef);
      }
      // Make individual repo go offline.
      goOffline() {
        require$$1$3.validateArgCount("database.goOffline", 0, 0, arguments.length);
        return goOffline_1(this._delegate);
      }
      goOnline() {
        require$$1$3.validateArgCount("database.goOnline", 0, 0, arguments.length);
        return goOnline_1(this._delegate);
      }
    };
    Database.ServerValue = {
      TIMESTAMP: serverTimestamp_1(),
      increment: /* @__PURE__ */ __name((delta) => increment_1(delta), "increment")
    };
    function initStandalone$1({ app, url: url2, version: version3, customAuthImpl, customAppCheckImpl, namespace, nodeAdmin = false }) {
      _setSDKVersion(version3);
      const container = new require$$3.ComponentContainer("database-standalone");
      const authProvider = new require$$3.Provider("auth-internal", container);
      authProvider.setComponent(new require$$3.Component(
        "auth-internal",
        () => customAuthImpl,
        "PRIVATE"
        /* ComponentType.PRIVATE */
      ));
      let appCheckProvider = void 0;
      if (customAppCheckImpl) {
        appCheckProvider = new require$$3.Provider("app-check-internal", container);
        appCheckProvider.setComponent(new require$$3.Component(
          "app-check-internal",
          () => customAppCheckImpl,
          "PRIVATE"
          /* ComponentType.PRIVATE */
        ));
      }
      return {
        instance: new Database(_repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url2, nodeAdmin), app),
        namespace
      };
    }
    __name(initStandalone$1, "initStandalone$1");
    var INTERNAL = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      initStandalone: initStandalone$1
    });
    var ServerValue2 = Database.ServerValue;
    function initStandalone(app, url2, version3, nodeAdmin = true) {
      require$$1$3.CONSTANTS.NODE_ADMIN = nodeAdmin;
      return initStandalone$1({
        app,
        url: url2,
        version: version3,
        // firebase-admin-node's app.INTERNAL implements FirebaseAuthInternal interface
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        customAuthImpl: app.INTERNAL,
        namespace: {
          Reference,
          Query,
          Database,
          DataSnapshot,
          enableLogging: enableLogging_1,
          INTERNAL,
          ServerValue: ServerValue2
        },
        nodeAdmin
      });
    }
    __name(initStandalone, "initStandalone");
    exports.DataSnapshot = DataSnapshot;
    exports.Database = Database;
    exports.OnDisconnect = OnDisconnect_1;
    exports.Query = Query;
    exports.Reference = Reference;
    exports.ServerValue = ServerValue2;
    exports.enableLogging = enableLogging_1;
    exports.initStandalone = initStandalone;
  }
});

// node_modules/firebase-admin/lib/database/database.js
var require_database = __commonJS({
  "node_modules/firebase-admin/lib/database/database.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DatabaseService = void 0;
    var url_1 = require_url();
    var path = require_path();
    var error_1 = require_error();
    var validator = require_validator();
    var api_request_1 = require_api_request();
    var index_1 = require_utils();
    var TOKEN_REFRESH_THRESHOLD_MILLIS = 5 * 60 * 1e3;
    var DatabaseService = class {
      static {
        __name(this, "DatabaseService");
      }
      constructor(app) {
        this.databases = {};
        if (!validator.isNonNullObject(app) || !("options" in app)) {
          throw new error_1.FirebaseDatabaseError({
            code: "invalid-argument",
            message: "First argument passed to admin.database() must be a valid Firebase app instance."
          });
        }
        this.appInternal = app;
      }
      get firebaseApp() {
        return this.app;
      }
      /**
       * @internal
       */
      delete() {
        if (this.tokenListener) {
          this.firebaseApp.INTERNAL.removeAuthTokenListener(this.tokenListener);
          clearTimeout(this.tokenRefreshTimeout);
        }
        const promises = [];
        for (const dbUrl of Object.keys(this.databases)) {
          const db = this.databases[dbUrl];
          promises.push(db.INTERNAL.delete());
        }
        return Promise.all(promises).then(() => {
          this.databases = {};
        });
      }
      /**
       * Returns the app associated with this DatabaseService instance.
       *
       * @returns The app associated with this DatabaseService instance.
       */
      get app() {
        return this.appInternal;
      }
      getDatabase(url) {
        const dbUrl = this.ensureUrl(url);
        if (!validator.isNonEmptyString(dbUrl)) {
          throw new error_1.FirebaseDatabaseError({
            code: "invalid-argument",
            message: "Database URL must be a valid, non-empty URL string."
          });
        }
        let db = this.databases[dbUrl];
        if (typeof db === "undefined") {
          const rtdb = require_index_standalone();
          db = rtdb.initStandalone(this.appInternal, dbUrl, (0, index_1.getSdkVersion)()).instance;
          const rulesClient = new DatabaseRulesClient(this.app, dbUrl);
          db.getRules = () => {
            return rulesClient.getRules();
          };
          db.getRulesJSON = () => {
            return rulesClient.getRulesJSON();
          };
          db.setRules = (source) => {
            return rulesClient.setRules(source);
          };
          this.databases[dbUrl] = db;
        }
        if (!this.tokenListener) {
          this.tokenListener = this.onTokenChange.bind(this);
          this.firebaseApp.INTERNAL.addAuthTokenListener(this.tokenListener);
        }
        return db;
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      onTokenChange(_) {
        const token = this.firebaseApp.INTERNAL.getCachedToken();
        if (token) {
          const delayMillis = token.expirationTime - TOKEN_REFRESH_THRESHOLD_MILLIS - Date.now();
          if (delayMillis > 0) {
            this.scheduleTokenRefresh(delayMillis);
          }
        }
      }
      scheduleTokenRefresh(delayMillis) {
        clearTimeout(this.tokenRefreshTimeout);
        this.tokenRefreshTimeout = setTimeout(() => {
          this.firebaseApp.INTERNAL.getToken(
            /*forceRefresh=*/
            true
          ).catch(() => {
          });
        }, delayMillis);
      }
      ensureUrl(url) {
        if (typeof url !== "undefined") {
          return url;
        } else if (typeof this.appInternal.options.databaseURL !== "undefined") {
          return this.appInternal.options.databaseURL;
        }
        throw new error_1.FirebaseDatabaseError({
          code: "invalid-argument",
          message: "Can't determine Firebase Database URL."
        });
      }
    };
    exports.DatabaseService = DatabaseService;
    var RULES_URL_PATH = ".settings/rules.json";
    var DatabaseRulesClient = class {
      static {
        __name(this, "DatabaseRulesClient");
      }
      constructor(app, dbUrl) {
        let parsedUrl = new url_1.URL(dbUrl);
        const emulatorHost = process.env.FIREBASE_DATABASE_EMULATOR_HOST;
        if (emulatorHost) {
          const namespace = extractNamespace(parsedUrl);
          parsedUrl = new url_1.URL(`http://${emulatorHost}?ns=${namespace}`);
        }
        parsedUrl.pathname = path.join(parsedUrl.pathname, RULES_URL_PATH);
        this.dbUrl = parsedUrl.toString();
        this.httpClient = new api_request_1.AuthorizedHttpClient(app);
      }
      /**
       * Gets the currently applied security rules as a string. The return value consists of
       * the rules source including comments.
       *
       * @returns A promise fulfilled with the rules as a raw string.
       */
      getRules() {
        const req = {
          method: "GET",
          url: this.dbUrl
        };
        return this.httpClient.send(req).then((resp) => {
          if (!resp.text) {
            throw new error_1.FirebaseAppError(error_1.AppErrorCodes.INTERNAL_ERROR, "HTTP response missing data.");
          }
          return resp.text;
        }).catch((err) => {
          throw this.handleError(err);
        });
      }
      /**
       * Gets the currently applied security rules as a parsed JSON object. Any comments in
       * the original source are stripped away.
       *
       * @returns {Promise<object>} A promise fulfilled with the parsed rules source.
       */
      getRulesJSON() {
        const req = {
          method: "GET",
          url: this.dbUrl,
          data: { format: "strict" }
        };
        return this.httpClient.send(req).then((resp) => {
          return resp.data;
        }).catch((err) => {
          throw this.handleError(err);
        });
      }
      /**
       * Sets the specified rules on the Firebase Database instance. If the rules source is
       * specified as a string or a Buffer, it may include comments.
       *
       * @param {string|Buffer|object} source Source of the rules to apply. Must not be `null`
       *  or empty.
       * @returns {Promise<void>} Resolves when the rules are set on the Database.
       */
      setRules(source) {
        if (!validator.isNonEmptyString(source) && !validator.isBuffer(source) && !validator.isNonNullObject(source)) {
          const error3 = new error_1.FirebaseDatabaseError({
            code: "invalid-argument",
            message: "Source must be a non-empty string, Buffer or an object."
          });
          return Promise.reject(error3);
        }
        const req = {
          method: "PUT",
          url: this.dbUrl,
          data: source,
          headers: {
            "content-type": "application/json; charset=utf-8"
          }
        };
        return this.httpClient.send(req).then(() => {
          return;
        }).catch((err) => {
          throw this.handleError(err);
        });
      }
      handleError(err) {
        if (err instanceof api_request_1.RequestResponseError) {
          return new error_1.FirebaseDatabaseError({
            code: error_1.AppErrorCodes.INTERNAL_ERROR,
            message: this.getErrorMessage(err)
          });
        }
        return err;
      }
      getErrorMessage(err) {
        const intro = "Error while accessing security rules";
        try {
          const body = err.response.data;
          if (body && body.error) {
            return `${intro}: ${body.error.trim()}`;
          }
        } catch {
        }
        return `${intro}: ${err.response.text}`;
      }
    };
    function extractNamespace(parsedUrl) {
      const ns2 = parsedUrl.searchParams.get("ns");
      if (ns2) {
        return ns2;
      }
      const hostname2 = parsedUrl.hostname;
      const dotIndex = hostname2.indexOf(".");
      return hostname2.substring(0, dotIndex).toLowerCase();
    }
    __name(extractNamespace, "extractNamespace");
  }
});

// node_modules/firebase-admin/lib/database/index.js
var require_database2 = __commonJS({
  "node_modules/firebase-admin/lib/database/index.js"(exports) {
    "use strict";
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
    init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
    init_performance2();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FirebaseDatabaseError = exports.ServerValue = exports.enableLogging = void 0;
    exports.getDatabase = getDatabase2;
    exports.getDatabaseWithUrl = getDatabaseWithUrl2;
    var standalone_1 = require_index_standalone();
    var app_1 = require_app();
    var database_1 = require_database();
    exports.enableLogging = standalone_1.enableLogging;
    exports.ServerValue = standalone_1.ServerValue;
    function getDatabase2(app) {
      return getDatabaseInstance({ app });
    }
    __name(getDatabase2, "getDatabase");
    function getDatabaseWithUrl2(url, app) {
      return getDatabaseInstance({ url, app });
    }
    __name(getDatabaseWithUrl2, "getDatabaseWithUrl");
    function getDatabaseInstance(options) {
      let { app } = options;
      if (typeof app === "undefined") {
        app = (0, app_1.getApp)();
      }
      const firebaseApp = app;
      const dbService = firebaseApp.getOrInitService("database", (app2) => new database_1.DatabaseService(app2));
      return dbService.getDatabase(options.url);
    }
    __name(getDatabaseInstance, "getDatabaseInstance");
    var error_1 = require_error();
    Object.defineProperty(exports, "FirebaseDatabaseError", { enumerable: true, get: /* @__PURE__ */ __name(function() {
      return error_1.FirebaseDatabaseError;
    }, "get") });
  }
});

// .wrangler/tmp/bundle-JHzrC7/middleware-loader.entry.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// .wrangler/tmp/bundle-JHzrC7/middleware-insertion-facade.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// api/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// api/routes/packages.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/@neondatabase/serverless/index.mjs
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var vo = Object.create;
var Te = Object.defineProperty;
var xo = Object.getOwnPropertyDescriptor;
var So = Object.getOwnPropertyNames;
var Eo = Object.getPrototypeOf;
var Ao = Object.prototype.hasOwnProperty;
var Co = /* @__PURE__ */ __name((r, e, t) => e in r ? Te(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t, "Co");
var a = /* @__PURE__ */ __name((r, e) => Te(r, "name", { value: e, configurable: true }), "a");
var z = /* @__PURE__ */ __name((r, e) => () => (r && (e = r(r = 0)), e), "z");
var I = /* @__PURE__ */ __name((r, e) => () => (e || r((e = { exports: {} }).exports, e), e.exports), "I");
var ne = /* @__PURE__ */ __name((r, e) => {
  for (var t in e) Te(r, t, {
    get: e[t],
    enumerable: true
  });
}, "ne");
var Mn = /* @__PURE__ */ __name((r, e, t, n) => {
  if (e && typeof e == "object" || typeof e == "function") for (let i of So(e)) !Ao.call(r, i) && i !== t && Te(r, i, { get: /* @__PURE__ */ __name(() => e[i], "get"), enumerable: !(n = xo(e, i)) || n.enumerable });
  return r;
}, "Mn");
var xe = /* @__PURE__ */ __name((r, e, t) => (t = r != null ? vo(Eo(r)) : {}, Mn(e || !r || !r.__esModule ? Te(t, "default", { value: r, enumerable: true }) : t, r)), "xe");
var D = /* @__PURE__ */ __name((r) => Mn(Te({}, "__esModule", { value: true }), r), "D");
var E = /* @__PURE__ */ __name((r, e, t) => Co(r, typeof e != "symbol" ? e + "" : e, t), "E");
var On = I((ct) => {
  "use strict";
  p();
  ct.byteLength = To;
  ct.toByteArray = Po;
  ct.fromByteArray = Lo;
  var ue = [], ee = [], _o = typeof Uint8Array < "u" ? Uint8Array : Array, Ut = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (Se = 0, Un = Ut.length; Se < Un; ++Se) ue[Se] = Ut[Se], ee[Ut.charCodeAt(Se)] = Se;
  var Se, Un;
  ee[45] = 62;
  ee[95] = 63;
  function Dn(r) {
    var e = r.length;
    if (e % 4 > 0) throw new Error("Invalid string. Length must be a multiple of 4");
    var t = r.indexOf("=");
    t === -1 && (t = e);
    var n = t === e ? 0 : 4 - t % 4;
    return [t, n];
  }
  __name(Dn, "Dn");
  a(Dn, "getLens");
  function To(r) {
    var e = Dn(r), t = e[0], n = e[1];
    return (t + n) * 3 / 4 - n;
  }
  __name(To, "To");
  a(To, "byteLength");
  function Io(r, e, t) {
    return (e + t) * 3 / 4 - t;
  }
  __name(Io, "Io");
  a(Io, "_byteLength");
  function Po(r) {
    var e, t = Dn(r), n = t[0], i = t[1], s = new _o(Io(r, n, i)), o = 0, u = i > 0 ? n - 4 : n, c;
    for (c = 0; c < u; c += 4) e = ee[r.charCodeAt(c)] << 18 | ee[r.charCodeAt(c + 1)] << 12 | ee[r.charCodeAt(c + 2)] << 6 | ee[r.charCodeAt(c + 3)], s[o++] = e >> 16 & 255, s[o++] = e >> 8 & 255, s[o++] = e & 255;
    return i === 2 && (e = ee[r.charCodeAt(
      c
    )] << 2 | ee[r.charCodeAt(c + 1)] >> 4, s[o++] = e & 255), i === 1 && (e = ee[r.charCodeAt(c)] << 10 | ee[r.charCodeAt(c + 1)] << 4 | ee[r.charCodeAt(c + 2)] >> 2, s[o++] = e >> 8 & 255, s[o++] = e & 255), s;
  }
  __name(Po, "Po");
  a(Po, "toByteArray");
  function Ro(r) {
    return ue[r >> 18 & 63] + ue[r >> 12 & 63] + ue[r >> 6 & 63] + ue[r & 63];
  }
  __name(Ro, "Ro");
  a(Ro, "tripletToBase64");
  function Bo(r, e, t) {
    for (var n, i = [], s = e; s < t; s += 3) n = (r[s] << 16 & 16711680) + (r[s + 1] << 8 & 65280) + (r[s + 2] & 255), i.push(Ro(n));
    return i.join("");
  }
  __name(Bo, "Bo");
  a(Bo, "encodeChunk");
  function Lo(r) {
    for (var e, t = r.length, n = t % 3, i = [], s = 16383, o = 0, u = t - n; o < u; o += s) i.push(Bo(
      r,
      o,
      o + s > u ? u : o + s
    ));
    return n === 1 ? (e = r[t - 1], i.push(ue[e >> 2] + ue[e << 4 & 63] + "==")) : n === 2 && (e = (r[t - 2] << 8) + r[t - 1], i.push(ue[e >> 10] + ue[e >> 4 & 63] + ue[e << 2 & 63] + "=")), i.join("");
  }
  __name(Lo, "Lo");
  a(Lo, "fromByteArray");
});
var qn = I((Dt) => {
  p();
  Dt.read = function(r, e, t, n, i) {
    var s, o, u = i * 8 - n - 1, c = (1 << u) - 1, l = c >> 1, f = -7, y = t ? i - 1 : 0, g = t ? -1 : 1, A = r[e + y];
    for (y += g, s = A & (1 << -f) - 1, A >>= -f, f += u; f > 0; s = s * 256 + r[e + y], y += g, f -= 8) ;
    for (o = s & (1 << -f) - 1, s >>= -f, f += n; f > 0; o = o * 256 + r[e + y], y += g, f -= 8) ;
    if (s === 0) s = 1 - l;
    else {
      if (s === c) return o ? NaN : (A ? -1 : 1) * (1 / 0);
      o = o + Math.pow(2, n), s = s - l;
    }
    return (A ? -1 : 1) * o * Math.pow(2, s - n);
  };
  Dt.write = function(r, e, t, n, i, s) {
    var o, u, c, l = s * 8 - i - 1, f = (1 << l) - 1, y = f >> 1, g = i === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, A = n ? 0 : s - 1, C = n ? 1 : -1, Q = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
    for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (u = isNaN(e) ? 1 : 0, o = f) : (o = Math.floor(Math.log(e) / Math.LN2), e * (c = Math.pow(2, -o)) < 1 && (o--, c *= 2), o + y >= 1 ? e += g / c : e += g * Math.pow(2, 1 - y), e * c >= 2 && (o++, c /= 2), o + y >= f ? (u = 0, o = f) : o + y >= 1 ? (u = (e * c - 1) * Math.pow(2, i), o = o + y) : (u = e * Math.pow(2, y - 1) * Math.pow(2, i), o = 0)); i >= 8; r[t + A] = u & 255, A += C, u /= 256, i -= 8) ;
    for (o = o << i | u, l += i; l > 0; r[t + A] = o & 255, A += C, o /= 256, l -= 8) ;
    r[t + A - C] |= Q * 128;
  };
});
var ri = I((Be) => {
  "use strict";
  p();
  var Ot = On(), Pe = qn(), Qn = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  Be.Buffer = h;
  Be.SlowBuffer = Oo;
  Be.INSPECT_MAX_BYTES = 50;
  var lt = 2147483647;
  Be.kMaxLength = lt;
  h.TYPED_ARRAY_SUPPORT = Fo();
  !h.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  function Fo() {
    try {
      let r = new Uint8Array(1), e = { foo: a(function() {
        return 42;
      }, "foo") };
      return Object.setPrototypeOf(e, Uint8Array.prototype), Object.setPrototypeOf(r, e), r.foo() === 42;
    } catch {
      return false;
    }
  }
  __name(Fo, "Fo");
  a(Fo, "typedArraySupport");
  Object.defineProperty(h.prototype, "parent", { enumerable: true, get: a(function() {
    if (h.isBuffer(this)) return this.buffer;
  }, "get") });
  Object.defineProperty(h.prototype, "offset", { enumerable: true, get: a(function() {
    if (h.isBuffer(
      this
    )) return this.byteOffset;
  }, "get") });
  function pe(r) {
    if (r > lt) throw new RangeError('The value "' + r + '" is invalid for option "size"');
    let e = new Uint8Array(r);
    return Object.setPrototypeOf(e, h.prototype), e;
  }
  __name(pe, "pe");
  a(pe, "createBuffer");
  function h(r, e, t) {
    if (typeof r == "number") {
      if (typeof e == "string") throw new TypeError(
        'The "string" argument must be of type string. Received type number'
      );
      return jt(r);
    }
    return Hn(r, e, t);
  }
  __name(h, "h");
  a(h, "Buffer");
  h.poolSize = 8192;
  function Hn(r, e, t) {
    if (typeof r == "string") return Mo(r, e);
    if (ArrayBuffer.isView(r)) return Uo(r);
    if (r == null) throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
    if (ce(r, ArrayBuffer) || r && ce(r.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (ce(r, SharedArrayBuffer) || r && ce(
      r.buffer,
      SharedArrayBuffer
    ))) return Qt(r, e, t);
    if (typeof r == "number") throw new TypeError('The "value" argument must not be of type number. Received type number');
    let n = r.valueOf && r.valueOf();
    if (n != null && n !== r) return h.from(n, e, t);
    let i = Do(r);
    if (i) return i;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof r[Symbol.toPrimitive] == "function") return h.from(r[Symbol.toPrimitive]("string"), e, t);
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof r);
  }
  __name(Hn, "Hn");
  a(Hn, "from");
  h.from = function(r, e, t) {
    return Hn(r, e, t);
  };
  Object.setPrototypeOf(
    h.prototype,
    Uint8Array.prototype
  );
  Object.setPrototypeOf(h, Uint8Array);
  function $n(r) {
    if (typeof r != "number") throw new TypeError(
      '"size" argument must be of type number'
    );
    if (r < 0) throw new RangeError('The value "' + r + '" is invalid for option "size"');
  }
  __name($n, "$n");
  a($n, "assertSize");
  function ko(r, e, t) {
    return $n(r), r <= 0 ? pe(r) : e !== void 0 ? typeof t == "string" ? pe(r).fill(e, t) : pe(r).fill(e) : pe(r);
  }
  __name(ko, "ko");
  a(ko, "alloc");
  h.alloc = function(r, e, t) {
    return ko(r, e, t);
  };
  function jt(r) {
    return $n(r), pe(r < 0 ? 0 : Wt(r) | 0);
  }
  __name(jt, "jt");
  a(jt, "allocUnsafe");
  h.allocUnsafe = function(r) {
    return jt(
      r
    );
  };
  h.allocUnsafeSlow = function(r) {
    return jt(r);
  };
  function Mo(r, e) {
    if ((typeof e != "string" || e === "") && (e = "utf8"), !h.isEncoding(e)) throw new TypeError("Unknown encoding: " + e);
    let t = Gn(r, e) | 0, n = pe(t), i = n.write(
      r,
      e
    );
    return i !== t && (n = n.slice(0, i)), n;
  }
  __name(Mo, "Mo");
  a(Mo, "fromString");
  function qt(r) {
    let e = r.length < 0 ? 0 : Wt(r.length) | 0, t = pe(e);
    for (let n = 0; n < e; n += 1) t[n] = r[n] & 255;
    return t;
  }
  __name(qt, "qt");
  a(qt, "fromArrayLike");
  function Uo(r) {
    if (ce(r, Uint8Array)) {
      let e = new Uint8Array(r);
      return Qt(e.buffer, e.byteOffset, e.byteLength);
    }
    return qt(r);
  }
  __name(Uo, "Uo");
  a(Uo, "fromArrayView");
  function Qt(r, e, t) {
    if (e < 0 || r.byteLength < e) throw new RangeError('"offset" is outside of buffer bounds');
    if (r.byteLength < e + (t || 0)) throw new RangeError('"length" is outside of buffer bounds');
    let n;
    return e === void 0 && t === void 0 ? n = new Uint8Array(r) : t === void 0 ? n = new Uint8Array(r, e) : n = new Uint8Array(
      r,
      e,
      t
    ), Object.setPrototypeOf(n, h.prototype), n;
  }
  __name(Qt, "Qt");
  a(Qt, "fromArrayBuffer");
  function Do(r) {
    if (h.isBuffer(r)) {
      let e = Wt(r.length) | 0, t = pe(e);
      return t.length === 0 || r.copy(t, 0, 0, e), t;
    }
    if (r.length !== void 0) return typeof r.length != "number" || $t(r.length) ? pe(0) : qt(r);
    if (r.type === "Buffer" && Array.isArray(r.data)) return qt(r.data);
  }
  __name(Do, "Do");
  a(Do, "fromObject");
  function Wt(r) {
    if (r >= lt) throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + lt.toString(16) + " bytes");
    return r | 0;
  }
  __name(Wt, "Wt");
  a(Wt, "checked");
  function Oo(r) {
    return +r != r && (r = 0), h.alloc(+r);
  }
  __name(Oo, "Oo");
  a(Oo, "SlowBuffer");
  h.isBuffer = a(function(e) {
    return e != null && e._isBuffer === true && e !== h.prototype;
  }, "isBuffer");
  h.compare = a(function(e, t) {
    if (ce(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), ce(t, Uint8Array) && (t = h.from(t, t.offset, t.byteLength)), !h.isBuffer(e) || !h.isBuffer(t)) throw new TypeError(
      'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
    );
    if (e === t) return 0;
    let n = e.length, i = t.length;
    for (let s = 0, o = Math.min(n, i); s < o; ++s) if (e[s] !== t[s]) {
      n = e[s], i = t[s];
      break;
    }
    return n < i ? -1 : i < n ? 1 : 0;
  }, "compare");
  h.isEncoding = a(function(e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, "isEncoding");
  h.concat = a(function(e, t) {
    if (!Array.isArray(e)) throw new TypeError(
      '"list" argument must be an Array of Buffers'
    );
    if (e.length === 0) return h.alloc(0);
    let n;
    if (t === void 0)
      for (t = 0, n = 0; n < e.length; ++n) t += e[n].length;
    let i = h.allocUnsafe(t), s = 0;
    for (n = 0; n < e.length; ++n) {
      let o = e[n];
      if (ce(o, Uint8Array)) s + o.length > i.length ? (h.isBuffer(o) || (o = h.from(o)), o.copy(i, s)) : Uint8Array.prototype.set.call(i, o, s);
      else if (h.isBuffer(o)) o.copy(i, s);
      else throw new TypeError('"list" argument must be an Array of Buffers');
      s += o.length;
    }
    return i;
  }, "concat");
  function Gn(r, e) {
    if (h.isBuffer(r)) return r.length;
    if (ArrayBuffer.isView(r) || ce(r, ArrayBuffer)) return r.byteLength;
    if (typeof r != "string") throw new TypeError(
      'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof r
    );
    let t = r.length, n = arguments.length > 2 && arguments[2] === true;
    if (!n && t === 0) return 0;
    let i = false;
    for (; ; ) switch (e) {
      case "ascii":
      case "latin1":
      case "binary":
        return t;
      case "utf8":
      case "utf-8":
        return Nt(r).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return t * 2;
      case "hex":
        return t >>> 1;
      case "base64":
        return ti(r).length;
      default:
        if (i) return n ? -1 : Nt(r).length;
        e = ("" + e).toLowerCase(), i = true;
    }
  }
  __name(Gn, "Gn");
  a(Gn, "byteLength");
  h.byteLength = Gn;
  function qo(r, e, t) {
    let n = false;
    if ((e === void 0 || e < 0) && (e = 0), e > this.length || ((t === void 0 || t > this.length) && (t = this.length), t <= 0) || (t >>>= 0, e >>>= 0, t <= e)) return "";
    for (r || (r = "utf8"); ; ) switch (r) {
      case "hex":
        return Ko(this, e, t);
      case "utf8":
      case "utf-8":
        return zn(this, e, t);
      case "ascii":
        return Vo(this, e, t);
      case "latin1":
      case "binary":
        return zo(
          this,
          e,
          t
        );
      case "base64":
        return $o(this, e, t);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Yo(
          this,
          e,
          t
        );
      default:
        if (n) throw new TypeError("Unknown encoding: " + r);
        r = (r + "").toLowerCase(), n = true;
    }
  }
  __name(qo, "qo");
  a(
    qo,
    "slowToString"
  );
  h.prototype._isBuffer = true;
  function Ee(r, e, t) {
    let n = r[e];
    r[e] = r[t], r[t] = n;
  }
  __name(Ee, "Ee");
  a(Ee, "swap");
  h.prototype.swap16 = a(function() {
    let e = this.length;
    if (e % 2 !== 0) throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let t = 0; t < e; t += 2) Ee(this, t, t + 1);
    return this;
  }, "swap16");
  h.prototype.swap32 = a(function() {
    let e = this.length;
    if (e % 4 !== 0) throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let t = 0; t < e; t += 4) Ee(this, t, t + 3), Ee(this, t + 1, t + 2);
    return this;
  }, "swap32");
  h.prototype.swap64 = a(
    function() {
      let e = this.length;
      if (e % 8 !== 0) throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (let t = 0; t < e; t += 8) Ee(this, t, t + 7), Ee(this, t + 1, t + 6), Ee(this, t + 2, t + 5), Ee(this, t + 3, t + 4);
      return this;
    },
    "swap64"
  );
  h.prototype.toString = a(function() {
    let e = this.length;
    return e === 0 ? "" : arguments.length === 0 ? zn(
      this,
      0,
      e
    ) : qo.apply(this, arguments);
  }, "toString");
  h.prototype.toLocaleString = h.prototype.toString;
  h.prototype.equals = a(function(e) {
    if (!h.isBuffer(e)) throw new TypeError("Argument must be a Buffer");
    return this === e ? true : h.compare(this, e) === 0;
  }, "equals");
  h.prototype.inspect = a(function() {
    let e = "", t = Be.INSPECT_MAX_BYTES;
    return e = this.toString("hex", 0, t).replace(/(.{2})/g, "$1 ").trim(), this.length > t && (e += " ... "), "<Buffer " + e + ">";
  }, "inspect");
  Qn && (h.prototype[Qn] = h.prototype.inspect);
  h.prototype.compare = a(function(e, t, n, i, s) {
    if (ce(e, Uint8Array) && (e = h.from(e, e.offset, e.byteLength)), !h.isBuffer(e)) throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof e);
    if (t === void 0 && (t = 0), n === void 0 && (n = e ? e.length : 0), i === void 0 && (i = 0), s === void 0 && (s = this.length), t < 0 || n > e.length || i < 0 || s > this.length) throw new RangeError("out of range index");
    if (i >= s && t >= n) return 0;
    if (i >= s) return -1;
    if (t >= n) return 1;
    if (t >>>= 0, n >>>= 0, i >>>= 0, s >>>= 0, this === e) return 0;
    let o = s - i, u = n - t, c = Math.min(o, u), l = this.slice(
      i,
      s
    ), f = e.slice(t, n);
    for (let y = 0; y < c; ++y) if (l[y] !== f[y]) {
      o = l[y], u = f[y];
      break;
    }
    return o < u ? -1 : u < o ? 1 : 0;
  }, "compare");
  function Vn(r, e, t, n, i) {
    if (r.length === 0) return -1;
    if (typeof t == "string" ? (n = t, t = 0) : t > 2147483647 ? t = 2147483647 : t < -2147483648 && (t = -2147483648), t = +t, $t(t) && (t = i ? 0 : r.length - 1), t < 0 && (t = r.length + t), t >= r.length) {
      if (i) return -1;
      t = r.length - 1;
    } else if (t < 0) if (i) t = 0;
    else return -1;
    if (typeof e == "string" && (e = h.from(
      e,
      n
    )), h.isBuffer(e)) return e.length === 0 ? -1 : Nn(r, e, t, n, i);
    if (typeof e == "number") return e = e & 255, typeof Uint8Array.prototype.indexOf == "function" ? i ? Uint8Array.prototype.indexOf.call(r, e, t) : Uint8Array.prototype.lastIndexOf.call(r, e, t) : Nn(r, [e], t, n, i);
    throw new TypeError("val must be string, number or Buffer");
  }
  __name(Vn, "Vn");
  a(Vn, "bidirectionalIndexOf");
  function Nn(r, e, t, n, i) {
    let s = 1, o = r.length, u = e.length;
    if (n !== void 0 && (n = String(n).toLowerCase(), n === "ucs2" || n === "ucs-2" || n === "utf16le" || n === "utf-16le")) {
      if (r.length < 2 || e.length < 2) return -1;
      s = 2, o /= 2, u /= 2, t /= 2;
    }
    function c(f, y) {
      return s === 1 ? f[y] : f.readUInt16BE(y * s);
    }
    __name(c, "c");
    a(c, "read");
    let l;
    if (i) {
      let f = -1;
      for (l = t; l < o; l++) if (c(r, l) === c(e, f === -1 ? 0 : l - f)) {
        if (f === -1 && (f = l), l - f + 1 === u) return f * s;
      } else f !== -1 && (l -= l - f), f = -1;
    } else for (t + u > o && (t = o - u), l = t; l >= 0; l--) {
      let f = true;
      for (let y = 0; y < u; y++) if (c(r, l + y) !== c(e, y)) {
        f = false;
        break;
      }
      if (f) return l;
    }
    return -1;
  }
  __name(Nn, "Nn");
  a(Nn, "arrayIndexOf");
  h.prototype.includes = a(function(e, t, n) {
    return this.indexOf(
      e,
      t,
      n
    ) !== -1;
  }, "includes");
  h.prototype.indexOf = a(function(e, t, n) {
    return Vn(this, e, t, n, true);
  }, "indexOf");
  h.prototype.lastIndexOf = a(function(e, t, n) {
    return Vn(this, e, t, n, false);
  }, "lastIndexOf");
  function Qo(r, e, t, n) {
    t = Number(t) || 0;
    let i = r.length - t;
    n ? (n = Number(n), n > i && (n = i)) : n = i;
    let s = e.length;
    n > s / 2 && (n = s / 2);
    let o;
    for (o = 0; o < n; ++o) {
      let u = parseInt(e.substr(o * 2, 2), 16);
      if ($t(u)) return o;
      r[t + o] = u;
    }
    return o;
  }
  __name(Qo, "Qo");
  a(Qo, "hexWrite");
  function No(r, e, t, n) {
    return ft(Nt(e, r.length - t), r, t, n);
  }
  __name(No, "No");
  a(No, "utf8Write");
  function jo(r, e, t, n) {
    return ft(ea(e), r, t, n);
  }
  __name(jo, "jo");
  a(
    jo,
    "asciiWrite"
  );
  function Wo(r, e, t, n) {
    return ft(ti(e), r, t, n);
  }
  __name(Wo, "Wo");
  a(Wo, "base64Write");
  function Ho(r, e, t, n) {
    return ft(
      ta(e, r.length - t),
      r,
      t,
      n
    );
  }
  __name(Ho, "Ho");
  a(Ho, "ucs2Write");
  h.prototype.write = a(function(e, t, n, i) {
    if (t === void 0) i = "utf8", n = this.length, t = 0;
    else if (n === void 0 && typeof t == "string") i = t, n = this.length, t = 0;
    else if (isFinite(t))
      t = t >>> 0, isFinite(n) ? (n = n >>> 0, i === void 0 && (i = "utf8")) : (i = n, n = void 0);
    else throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    let s = this.length - t;
    if ((n === void 0 || n > s) && (n = s), e.length > 0 && (n < 0 || t < 0) || t > this.length) throw new RangeError("Attempt to write outside buffer bounds");
    i || (i = "utf8");
    let o = false;
    for (; ; ) switch (i) {
      case "hex":
        return Qo(this, e, t, n);
      case "utf8":
      case "utf-8":
        return No(this, e, t, n);
      case "ascii":
      case "latin1":
      case "binary":
        return jo(this, e, t, n);
      case "base64":
        return Wo(this, e, t, n);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return Ho(this, e, t, n);
      default:
        if (o) throw new TypeError("Unknown encoding: " + i);
        i = ("" + i).toLowerCase(), o = true;
    }
  }, "write");
  h.prototype.toJSON = a(function() {
    return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
  }, "toJSON");
  function $o(r, e, t) {
    return e === 0 && t === r.length ? Ot.fromByteArray(r) : Ot.fromByteArray(r.slice(e, t));
  }
  __name($o, "$o");
  a($o, "base64Slice");
  function zn(r, e, t) {
    t = Math.min(r.length, t);
    let n = [], i = e;
    for (; i < t; ) {
      let s = r[i], o = null, u = s > 239 ? 4 : s > 223 ? 3 : s > 191 ? 2 : 1;
      if (i + u <= t) {
        let c, l, f, y;
        switch (u) {
          case 1:
            s < 128 && (o = s);
            break;
          case 2:
            c = r[i + 1], (c & 192) === 128 && (y = (s & 31) << 6 | c & 63, y > 127 && (o = y));
            break;
          case 3:
            c = r[i + 1], l = r[i + 2], (c & 192) === 128 && (l & 192) === 128 && (y = (s & 15) << 12 | (c & 63) << 6 | l & 63, y > 2047 && (y < 55296 || y > 57343) && (o = y));
            break;
          case 4:
            c = r[i + 1], l = r[i + 2], f = r[i + 3], (c & 192) === 128 && (l & 192) === 128 && (f & 192) === 128 && (y = (s & 15) << 18 | (c & 63) << 12 | (l & 63) << 6 | f & 63, y > 65535 && y < 1114112 && (o = y));
        }
      }
      o === null ? (o = 65533, u = 1) : o > 65535 && (o -= 65536, n.push(o >>> 10 & 1023 | 55296), o = 56320 | o & 1023), n.push(o), i += u;
    }
    return Go(n);
  }
  __name(zn, "zn");
  a(zn, "utf8Slice");
  var jn = 4096;
  function Go(r) {
    let e = r.length;
    if (e <= jn) return String.fromCharCode.apply(String, r);
    let t = "", n = 0;
    for (; n < e; ) t += String.fromCharCode.apply(String, r.slice(n, n += jn));
    return t;
  }
  __name(Go, "Go");
  a(Go, "decodeCodePointsArray");
  function Vo(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i) n += String.fromCharCode(r[i] & 127);
    return n;
  }
  __name(Vo, "Vo");
  a(Vo, "asciiSlice");
  function zo(r, e, t) {
    let n = "";
    t = Math.min(r.length, t);
    for (let i = e; i < t; ++i) n += String.fromCharCode(r[i]);
    return n;
  }
  __name(zo, "zo");
  a(zo, "latin1Slice");
  function Ko(r, e, t) {
    let n = r.length;
    (!e || e < 0) && (e = 0), (!t || t < 0 || t > n) && (t = n);
    let i = "";
    for (let s = e; s < t; ++s) i += ra[r[s]];
    return i;
  }
  __name(Ko, "Ko");
  a(Ko, "hexSlice");
  function Yo(r, e, t) {
    let n = r.slice(e, t), i = "";
    for (let s = 0; s < n.length - 1; s += 2) i += String.fromCharCode(n[s] + n[s + 1] * 256);
    return i;
  }
  __name(Yo, "Yo");
  a(Yo, "utf16leSlice");
  h.prototype.slice = a(function(e, t) {
    let n = this.length;
    e = ~~e, t = t === void 0 ? n : ~~t, e < 0 ? (e += n, e < 0 && (e = 0)) : e > n && (e = n), t < 0 ? (t += n, t < 0 && (t = 0)) : t > n && (t = n), t < e && (t = e);
    let i = this.subarray(e, t);
    return Object.setPrototypeOf(i, h.prototype), i;
  }, "slice");
  function O(r, e, t) {
    if (r % 1 !== 0 || r < 0) throw new RangeError("offset is not uint");
    if (r + e > t) throw new RangeError("Trying to access beyond buffer length");
  }
  __name(O, "O");
  a(O, "checkOffset");
  h.prototype.readUintLE = h.prototype.readUIntLE = a(
    function(e, t, n) {
      e = e >>> 0, t = t >>> 0, n || O(e, t, this.length);
      let i = this[e], s = 1, o = 0;
      for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
      return i;
    },
    "readUIntLE"
  );
  h.prototype.readUintBE = h.prototype.readUIntBE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || O(
      e,
      t,
      this.length
    );
    let i = this[e + --t], s = 1;
    for (; t > 0 && (s *= 256); ) i += this[e + --t] * s;
    return i;
  }, "readUIntBE");
  h.prototype.readUint8 = h.prototype.readUInt8 = a(
    function(e, t) {
      return e = e >>> 0, t || O(e, 1, this.length), this[e];
    },
    "readUInt8"
  );
  h.prototype.readUint16LE = h.prototype.readUInt16LE = a(function(e, t) {
    return e = e >>> 0, t || O(
      e,
      2,
      this.length
    ), this[e] | this[e + 1] << 8;
  }, "readUInt16LE");
  h.prototype.readUint16BE = h.prototype.readUInt16BE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 2, this.length), this[e] << 8 | this[e + 1];
  }, "readUInt16BE");
  h.prototype.readUint32LE = h.prototype.readUInt32LE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), (this[e] | this[e + 1] << 8 | this[e + 2] << 16) + this[e + 3] * 16777216;
  }, "readUInt32LE");
  h.prototype.readUint32BE = h.prototype.readUInt32BE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), this[e] * 16777216 + (this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3]);
  }, "readUInt32BE");
  h.prototype.readBigUInt64LE = ye(a(function(e) {
    e = e >>> 0, Re(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24, s = this[++e] + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + n * 2 ** 24;
    return BigInt(i) + (BigInt(s) << BigInt(32));
  }, "readBigUInt64LE"));
  h.prototype.readBigUInt64BE = ye(a(function(e) {
    e = e >>> 0, Re(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = t * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e], s = this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n;
    return (BigInt(i) << BigInt(
      32
    )) + BigInt(s);
  }, "readBigUInt64BE"));
  h.prototype.readIntLE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || O(
      e,
      t,
      this.length
    );
    let i = this[e], s = 1, o = 0;
    for (; ++o < t && (s *= 256); ) i += this[e + o] * s;
    return s *= 128, i >= s && (i -= Math.pow(2, 8 * t)), i;
  }, "readIntLE");
  h.prototype.readIntBE = a(function(e, t, n) {
    e = e >>> 0, t = t >>> 0, n || O(e, t, this.length);
    let i = t, s = 1, o = this[e + --i];
    for (; i > 0 && (s *= 256); ) o += this[e + --i] * s;
    return s *= 128, o >= s && (o -= Math.pow(2, 8 * t)), o;
  }, "readIntBE");
  h.prototype.readInt8 = a(function(e, t) {
    return e = e >>> 0, t || O(e, 1, this.length), this[e] & 128 ? (255 - this[e] + 1) * -1 : this[e];
  }, "readInt8");
  h.prototype.readInt16LE = a(function(e, t) {
    e = e >>> 0, t || O(
      e,
      2,
      this.length
    );
    let n = this[e] | this[e + 1] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, "readInt16LE");
  h.prototype.readInt16BE = a(function(e, t) {
    e = e >>> 0, t || O(e, 2, this.length);
    let n = this[e + 1] | this[e] << 8;
    return n & 32768 ? n | 4294901760 : n;
  }, "readInt16BE");
  h.prototype.readInt32LE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), this[e] | this[e + 1] << 8 | this[e + 2] << 16 | this[e + 3] << 24;
  }, "readInt32LE");
  h.prototype.readInt32BE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), this[e] << 24 | this[e + 1] << 16 | this[e + 2] << 8 | this[e + 3];
  }, "readInt32BE");
  h.prototype.readBigInt64LE = ye(a(function(e) {
    e = e >>> 0, Re(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = this[e + 4] + this[e + 5] * 2 ** 8 + this[e + 6] * 2 ** 16 + (n << 24);
    return (BigInt(i) << BigInt(
      32
    )) + BigInt(t + this[++e] * 2 ** 8 + this[++e] * 2 ** 16 + this[++e] * 2 ** 24);
  }, "readBigInt64LE"));
  h.prototype.readBigInt64BE = ye(a(function(e) {
    e = e >>> 0, Re(e, "offset");
    let t = this[e], n = this[e + 7];
    (t === void 0 || n === void 0) && je(e, this.length - 8);
    let i = (t << 24) + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + this[++e];
    return (BigInt(i) << BigInt(32)) + BigInt(
      this[++e] * 2 ** 24 + this[++e] * 2 ** 16 + this[++e] * 2 ** 8 + n
    );
  }, "readBigInt64BE"));
  h.prototype.readFloatLE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), Pe.read(this, e, true, 23, 4);
  }, "readFloatLE");
  h.prototype.readFloatBE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 4, this.length), Pe.read(this, e, false, 23, 4);
  }, "readFloatBE");
  h.prototype.readDoubleLE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 8, this.length), Pe.read(this, e, true, 52, 8);
  }, "readDoubleLE");
  h.prototype.readDoubleBE = a(function(e, t) {
    return e = e >>> 0, t || O(e, 8, this.length), Pe.read(
      this,
      e,
      false,
      52,
      8
    );
  }, "readDoubleBE");
  function K(r, e, t, n, i, s) {
    if (!h.isBuffer(r)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (e > i || e < s) throw new RangeError('"value" argument is out of bounds');
    if (t + n > r.length) throw new RangeError("Index out of range");
  }
  __name(K, "K");
  a(K, "checkInt");
  h.prototype.writeUintLE = h.prototype.writeUIntLE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let u = Math.pow(2, 8 * n) - 1;
      K(
        this,
        e,
        t,
        n,
        u,
        0
      );
    }
    let s = 1, o = 0;
    for (this[t] = e & 255; ++o < n && (s *= 256); ) this[t + o] = e / s & 255;
    return t + n;
  }, "writeUIntLE");
  h.prototype.writeUintBE = h.prototype.writeUIntBE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, n = n >>> 0, !i) {
      let u = Math.pow(2, 8 * n) - 1;
      K(this, e, t, n, u, 0);
    }
    let s = n - 1, o = 1;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); ) this[t + s] = e / o & 255;
    return t + n;
  }, "writeUIntBE");
  h.prototype.writeUint8 = h.prototype.writeUInt8 = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 1, 255, 0), this[t] = e & 255, t + 1;
  }, "writeUInt8");
  h.prototype.writeUint16LE = h.prototype.writeUInt16LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 2, 65535, 0), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, "writeUInt16LE");
  h.prototype.writeUint16BE = h.prototype.writeUInt16BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 2, 65535, 0), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, "writeUInt16BE");
  h.prototype.writeUint32LE = h.prototype.writeUInt32LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(
      this,
      e,
      t,
      4,
      4294967295,
      0
    ), this[t + 3] = e >>> 24, this[t + 2] = e >>> 16, this[t + 1] = e >>> 8, this[t] = e & 255, t + 4;
  }, "writeUInt32LE");
  h.prototype.writeUint32BE = h.prototype.writeUInt32BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(
      this,
      e,
      t,
      4,
      4294967295,
      0
    ), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, "writeUInt32BE");
  function Kn(r, e, t, n, i) {
    ei(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s, s = s >> 8, r[t++] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, o = o >> 8, r[t++] = o, t;
  }
  __name(Kn, "Kn");
  a(Kn, "wrtBigUInt64LE");
  function Yn(r, e, t, n, i) {
    ei(e, n, i, r, t, 7);
    let s = Number(e & BigInt(4294967295));
    r[t + 7] = s, s = s >> 8, r[t + 6] = s, s = s >> 8, r[t + 5] = s, s = s >> 8, r[t + 4] = s;
    let o = Number(e >> BigInt(32) & BigInt(4294967295));
    return r[t + 3] = o, o = o >> 8, r[t + 2] = o, o = o >> 8, r[t + 1] = o, o = o >> 8, r[t] = o, t + 8;
  }
  __name(Yn, "Yn");
  a(Yn, "wrtBigUInt64BE");
  h.prototype.writeBigUInt64LE = ye(a(function(e, t = 0) {
    return Kn(this, e, t, BigInt(0), BigInt("0xffffffffffffffff"));
  }, "writeBigUInt64LE"));
  h.prototype.writeBigUInt64BE = ye(a(function(e, t = 0) {
    return Yn(this, e, t, BigInt(0), BigInt(
      "0xffffffffffffffff"
    ));
  }, "writeBigUInt64BE"));
  h.prototype.writeIntLE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let c = Math.pow(2, 8 * n - 1);
      K(this, e, t, n, c - 1, -c);
    }
    let s = 0, o = 1, u = 0;
    for (this[t] = e & 255; ++s < n && (o *= 256); )
      e < 0 && u === 0 && this[t + s - 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
    return t + n;
  }, "writeIntLE");
  h.prototype.writeIntBE = a(function(e, t, n, i) {
    if (e = +e, t = t >>> 0, !i) {
      let c = Math.pow(2, 8 * n - 1);
      K(this, e, t, n, c - 1, -c);
    }
    let s = n - 1, o = 1, u = 0;
    for (this[t + s] = e & 255; --s >= 0 && (o *= 256); ) e < 0 && u === 0 && this[t + s + 1] !== 0 && (u = 1), this[t + s] = (e / o >> 0) - u & 255;
    return t + n;
  }, "writeIntBE");
  h.prototype.writeInt8 = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 1, 127, -128), e < 0 && (e = 255 + e + 1), this[t] = e & 255, t + 1;
  }, "writeInt8");
  h.prototype.writeInt16LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 2, 32767, -32768), this[t] = e & 255, this[t + 1] = e >>> 8, t + 2;
  }, "writeInt16LE");
  h.prototype.writeInt16BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(this, e, t, 2, 32767, -32768), this[t] = e >>> 8, this[t + 1] = e & 255, t + 2;
  }, "writeInt16BE");
  h.prototype.writeInt32LE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(
      this,
      e,
      t,
      4,
      2147483647,
      -2147483648
    ), this[t] = e & 255, this[t + 1] = e >>> 8, this[t + 2] = e >>> 16, this[t + 3] = e >>> 24, t + 4;
  }, "writeInt32LE");
  h.prototype.writeInt32BE = a(function(e, t, n) {
    return e = +e, t = t >>> 0, n || K(
      this,
      e,
      t,
      4,
      2147483647,
      -2147483648
    ), e < 0 && (e = 4294967295 + e + 1), this[t] = e >>> 24, this[t + 1] = e >>> 16, this[t + 2] = e >>> 8, this[t + 3] = e & 255, t + 4;
  }, "writeInt32BE");
  h.prototype.writeBigInt64LE = ye(a(function(e, t = 0) {
    return Kn(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }, "writeBigInt64LE"));
  h.prototype.writeBigInt64BE = ye(
    a(function(e, t = 0) {
      return Yn(this, e, t, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
    }, "writeBigInt64BE")
  );
  function Zn(r, e, t, n, i, s) {
    if (t + n > r.length) throw new RangeError("Index out of range");
    if (t < 0) throw new RangeError("Index out of range");
  }
  __name(Zn, "Zn");
  a(Zn, "checkIEEE754");
  function Jn(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Zn(r, e, t, 4, 34028234663852886e22, -34028234663852886e22), Pe.write(r, e, t, n, 23, 4), t + 4;
  }
  __name(Jn, "Jn");
  a(
    Jn,
    "writeFloat"
  );
  h.prototype.writeFloatLE = a(function(e, t, n) {
    return Jn(this, e, t, true, n);
  }, "writeFloatLE");
  h.prototype.writeFloatBE = a(function(e, t, n) {
    return Jn(this, e, t, false, n);
  }, "writeFloatBE");
  function Xn(r, e, t, n, i) {
    return e = +e, t = t >>> 0, i || Zn(r, e, t, 8, 17976931348623157e292, -17976931348623157e292), Pe.write(
      r,
      e,
      t,
      n,
      52,
      8
    ), t + 8;
  }
  __name(Xn, "Xn");
  a(Xn, "writeDouble");
  h.prototype.writeDoubleLE = a(function(e, t, n) {
    return Xn(this, e, t, true, n);
  }, "writeDoubleLE");
  h.prototype.writeDoubleBE = a(function(e, t, n) {
    return Xn(this, e, t, false, n);
  }, "writeDoubleBE");
  h.prototype.copy = a(function(e, t, n, i) {
    if (!h.isBuffer(e)) throw new TypeError("argument should be a Buffer");
    if (n || (n = 0), !i && i !== 0 && (i = this.length), t >= e.length && (t = e.length), t || (t = 0), i > 0 && i < n && (i = n), i === n || e.length === 0 || this.length === 0) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (n < 0 || n >= this.length) throw new RangeError("Index out of range");
    if (i < 0) throw new RangeError("sourceEnd out of bounds");
    i > this.length && (i = this.length), e.length - t < i - n && (i = e.length - t + n);
    let s = i - n;
    return this === e && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(t, n, i) : Uint8Array.prototype.set.call(e, this.subarray(n, i), t), s;
  }, "copy");
  h.prototype.fill = a(function(e, t, n, i) {
    if (typeof e == "string") {
      if (typeof t == "string" ? (i = t, t = 0, n = this.length) : typeof n == "string" && (i = n, n = this.length), i !== void 0 && typeof i != "string") throw new TypeError("encoding must be a string");
      if (typeof i == "string" && !h.isEncoding(i)) throw new TypeError(
        "Unknown encoding: " + i
      );
      if (e.length === 1) {
        let o = e.charCodeAt(0);
        (i === "utf8" && o < 128 || i === "latin1") && (e = o);
      }
    } else typeof e == "number" ? e = e & 255 : typeof e == "boolean" && (e = Number(e));
    if (t < 0 || this.length < t || this.length < n) throw new RangeError("Out of range index");
    if (n <= t) return this;
    t = t >>> 0, n = n === void 0 ? this.length : n >>> 0, e || (e = 0);
    let s;
    if (typeof e == "number") for (s = t; s < n; ++s) this[s] = e;
    else {
      let o = h.isBuffer(e) ? e : h.from(
        e,
        i
      ), u = o.length;
      if (u === 0) throw new TypeError('The value "' + e + '" is invalid for argument "value"');
      for (s = 0; s < n - t; ++s) this[s + t] = o[s % u];
    }
    return this;
  }, "fill");
  var Ie = {};
  function Ht(r, e, t) {
    var n;
    Ie[r] = (n = class extends t {
      static {
        __name(this, "n");
      }
      constructor() {
        super(), Object.defineProperty(this, "message", { value: e.apply(this, arguments), writable: true, configurable: true }), this.name = `${this.name} [${r}]`, this.stack, delete this.name;
      }
      get code() {
        return r;
      }
      set code(s) {
        Object.defineProperty(
          this,
          "code",
          { configurable: true, enumerable: true, value: s, writable: true }
        );
      }
      toString() {
        return `${this.name} [${r}]: ${this.message}`;
      }
    }, a(n, "NodeError"), n);
  }
  __name(Ht, "Ht");
  a(Ht, "E");
  Ht("ERR_BUFFER_OUT_OF_BOUNDS", function(r) {
    return r ? `${r} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
  }, RangeError);
  Ht(
    "ERR_INVALID_ARG_TYPE",
    function(r, e) {
      return `The "${r}" argument must be of type number. Received type ${typeof e}`;
    },
    TypeError
  );
  Ht("ERR_OUT_OF_RANGE", function(r, e, t) {
    let n = `The value of "${r}" is out of range.`, i = t;
    return Number.isInteger(t) && Math.abs(t) > 2 ** 32 ? i = Wn(String(t)) : typeof t == "bigint" && (i = String(
      t
    ), (t > BigInt(2) ** BigInt(32) || t < -(BigInt(2) ** BigInt(32))) && (i = Wn(i)), i += "n"), n += ` It must be ${e}. Received ${i}`, n;
  }, RangeError);
  function Wn(r) {
    let e = "", t = r.length, n = r[0] === "-" ? 1 : 0;
    for (; t >= n + 4; t -= 3) e = `_${r.slice(t - 3, t)}${e}`;
    return `${r.slice(0, t)}${e}`;
  }
  __name(Wn, "Wn");
  a(Wn, "addNumericalSeparator");
  function Zo(r, e, t) {
    Re(e, "offset"), (r[e] === void 0 || r[e + t] === void 0) && je(e, r.length - (t + 1));
  }
  __name(Zo, "Zo");
  a(Zo, "checkBounds");
  function ei(r, e, t, n, i, s) {
    if (r > t || r < e) {
      let o = typeof e == "bigint" ? "n" : "", u;
      throw s > 3 ? e === 0 || e === BigInt(0) ? u = `>= 0${o} and < 2${o} ** ${(s + 1) * 8}${o}` : u = `>= -(2${o} ** ${(s + 1) * 8 - 1}${o}) and < 2 ** ${(s + 1) * 8 - 1}${o}` : u = `>= ${e}${o} and <= ${t}${o}`, new Ie.ERR_OUT_OF_RANGE("value", u, r);
    }
    Zo(n, i, s);
  }
  __name(ei, "ei");
  a(ei, "checkIntBI");
  function Re(r, e) {
    if (typeof r != "number") throw new Ie.ERR_INVALID_ARG_TYPE(e, "number", r);
  }
  __name(Re, "Re");
  a(Re, "validateNumber");
  function je(r, e, t) {
    throw Math.floor(r) !== r ? (Re(r, t), new Ie.ERR_OUT_OF_RANGE(t || "offset", "an integer", r)) : e < 0 ? new Ie.ERR_BUFFER_OUT_OF_BOUNDS() : new Ie.ERR_OUT_OF_RANGE(t || "offset", `>= ${t ? 1 : 0} and <= ${e}`, r);
  }
  __name(je, "je");
  a(je, "boundsError");
  var Jo = /[^+/0-9A-Za-z-_]/g;
  function Xo(r) {
    if (r = r.split("=")[0], r = r.trim().replace(Jo, ""), r.length < 2) return "";
    for (; r.length % 4 !== 0; ) r = r + "=";
    return r;
  }
  __name(Xo, "Xo");
  a(Xo, "base64clean");
  function Nt(r, e) {
    e = e || 1 / 0;
    let t, n = r.length, i = null, s = [];
    for (let o = 0; o < n; ++o) {
      if (t = r.charCodeAt(o), t > 55295 && t < 57344) {
        if (!i) {
          if (t > 56319) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          } else if (o + 1 === n) {
            (e -= 3) > -1 && s.push(239, 191, 189);
            continue;
          }
          i = t;
          continue;
        }
        if (t < 56320) {
          (e -= 3) > -1 && s.push(239, 191, 189), i = t;
          continue;
        }
        t = (i - 55296 << 10 | t - 56320) + 65536;
      } else i && (e -= 3) > -1 && s.push(239, 191, 189);
      if (i = null, t < 128) {
        if ((e -= 1) < 0) break;
        s.push(t);
      } else if (t < 2048) {
        if ((e -= 2) < 0) break;
        s.push(t >> 6 | 192, t & 63 | 128);
      } else if (t < 65536) {
        if ((e -= 3) < 0) break;
        s.push(t >> 12 | 224, t >> 6 & 63 | 128, t & 63 | 128);
      } else if (t < 1114112) {
        if ((e -= 4) < 0) break;
        s.push(t >> 18 | 240, t >> 12 & 63 | 128, t >> 6 & 63 | 128, t & 63 | 128);
      } else throw new Error("Invalid code point");
    }
    return s;
  }
  __name(Nt, "Nt");
  a(Nt, "utf8ToBytes");
  function ea(r) {
    let e = [];
    for (let t = 0; t < r.length; ++t) e.push(r.charCodeAt(t) & 255);
    return e;
  }
  __name(ea, "ea");
  a(
    ea,
    "asciiToBytes"
  );
  function ta(r, e) {
    let t, n, i, s = [];
    for (let o = 0; o < r.length && !((e -= 2) < 0); ++o) t = r.charCodeAt(
      o
    ), n = t >> 8, i = t % 256, s.push(i), s.push(n);
    return s;
  }
  __name(ta, "ta");
  a(ta, "utf16leToBytes");
  function ti(r) {
    return Ot.toByteArray(
      Xo(r)
    );
  }
  __name(ti, "ti");
  a(ti, "base64ToBytes");
  function ft(r, e, t, n) {
    let i;
    for (i = 0; i < n && !(i + t >= e.length || i >= r.length); ++i)
      e[i + t] = r[i];
    return i;
  }
  __name(ft, "ft");
  a(ft, "blitBuffer");
  function ce(r, e) {
    return r instanceof e || r != null && r.constructor != null && r.constructor.name != null && r.constructor.name === e.name;
  }
  __name(ce, "ce");
  a(ce, "isInstance");
  function $t(r) {
    return r !== r;
  }
  __name($t, "$t");
  a($t, "numberIsNaN");
  var ra = function() {
    let r = "0123456789abcdef", e = new Array(256);
    for (let t = 0; t < 16; ++t) {
      let n = t * 16;
      for (let i = 0; i < 16; ++i) e[n + i] = r[t] + r[i];
    }
    return e;
  }();
  function ye(r) {
    return typeof BigInt > "u" ? na : r;
  }
  __name(ye, "ye");
  a(ye, "defineBigIntMethod");
  function na() {
    throw new Error("BigInt not supported");
  }
  __name(na, "na");
  a(na, "BufferBigIntNotDefined");
});
var w;
var b;
var v;
var d;
var m;
var p = z(() => {
  "use strict";
  w = globalThis, b = globalThis.setImmediate ?? ((r) => setTimeout(r, 0)), v = globalThis.clearImmediate ?? ((r) => clearTimeout(r)), d = typeof globalThis.Buffer == "function" && typeof globalThis.Buffer.allocUnsafe == "function" ? globalThis.Buffer : ri().Buffer, m = globalThis.process ?? {};
  m.env ?? (m.env = {});
  try {
    m.nextTick(() => {
    });
  } catch {
    let e = Promise.resolve();
    m.nextTick = e.then.bind(e);
  }
});
var me = I((Pl, Gt) => {
  "use strict";
  p();
  var Le = typeof Reflect == "object" ? Reflect : null, ni = Le && typeof Le.apply == "function" ? Le.apply : a(function(e, t, n) {
    return Function.prototype.apply.call(e, t, n);
  }, "ReflectApply"), ht;
  Le && typeof Le.ownKeys == "function" ? ht = Le.ownKeys : Object.getOwnPropertySymbols ? ht = a(function(e) {
    return Object.getOwnPropertyNames(e).concat(Object.getOwnPropertySymbols(e));
  }, "ReflectOwnKeys") : ht = a(function(e) {
    return Object.getOwnPropertyNames(e);
  }, "ReflectOwnKeys");
  function ia(r) {
    console && console.warn && console.warn(r);
  }
  __name(ia, "ia");
  a(
    ia,
    "ProcessEmitWarning"
  );
  var si = Number.isNaN || a(function(e) {
    return e !== e;
  }, "NumberIsNaN");
  function R() {
    R.init.call(this);
  }
  __name(R, "R");
  a(R, "EventEmitter");
  Gt.exports = R;
  Gt.exports.once = ua;
  R.EventEmitter = R;
  R.prototype._events = void 0;
  R.prototype._eventsCount = 0;
  R.prototype._maxListeners = void 0;
  var ii = 10;
  function pt(r) {
    if (typeof r != "function") throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof r);
  }
  __name(pt, "pt");
  a(pt, "checkListener");
  Object.defineProperty(R, "defaultMaxListeners", { enumerable: true, get: a(function() {
    return ii;
  }, "get"), set: a(
    function(r) {
      if (typeof r != "number" || r < 0 || si(r)) throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + r + ".");
      ii = r;
    },
    "set"
  ) });
  R.init = function() {
    (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) && (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
  };
  R.prototype.setMaxListeners = a(function(e) {
    if (typeof e != "number" || e < 0 || si(e)) throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + e + ".");
    return this._maxListeners = e, this;
  }, "setMaxListeners");
  function oi(r) {
    return r._maxListeners === void 0 ? R.defaultMaxListeners : r._maxListeners;
  }
  __name(oi, "oi");
  a(oi, "_getMaxListeners");
  R.prototype.getMaxListeners = a(function() {
    return oi(this);
  }, "getMaxListeners");
  R.prototype.emit = a(function(e) {
    for (var t = [], n = 1; n < arguments.length; n++) t.push(arguments[n]);
    var i = e === "error", s = this._events;
    if (s !== void 0) i = i && s.error === void 0;
    else if (!i) return false;
    if (i) {
      var o;
      if (t.length > 0 && (o = t[0]), o instanceof Error) throw o;
      var u = new Error("Unhandled error." + (o ? " (" + o.message + ")" : ""));
      throw u.context = o, u;
    }
    var c = s[e];
    if (c === void 0) return false;
    if (typeof c == "function") ni(c, this, t);
    else for (var l = c.length, f = fi(c, l), n = 0; n < l; ++n) ni(f[n], this, t);
    return true;
  }, "emit");
  function ai(r, e, t, n) {
    var i, s, o;
    if (pt(
      t
    ), s = r._events, s === void 0 ? (s = r._events = /* @__PURE__ */ Object.create(null), r._eventsCount = 0) : (s.newListener !== void 0 && (r.emit("newListener", e, t.listener ? t.listener : t), s = r._events), o = s[e]), o === void 0) o = s[e] = t, ++r._eventsCount;
    else if (typeof o == "function" ? o = s[e] = n ? [t, o] : [o, t] : n ? o.unshift(t) : o.push(t), i = oi(r), i > 0 && o.length > i && !o.warned) {
      o.warned = true;
      var u = new Error("Possible EventEmitter memory leak detected. " + o.length + " " + String(e) + " listeners added. Use emitter.setMaxListeners() to increase limit");
      u.name = "MaxListenersExceededWarning", u.emitter = r, u.type = e, u.count = o.length, ia(u);
    }
    return r;
  }
  __name(ai, "ai");
  a(ai, "_addListener");
  R.prototype.addListener = a(function(e, t) {
    return ai(this, e, t, false);
  }, "addListener");
  R.prototype.on = R.prototype.addListener;
  R.prototype.prependListener = a(function(e, t) {
    return ai(this, e, t, true);
  }, "prependListener");
  function sa() {
    if (!this.fired) return this.target.removeListener(this.type, this.wrapFn), this.fired = true, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
  }
  __name(sa, "sa");
  a(sa, "onceWrapper");
  function ui(r, e, t) {
    var n = {
      fired: false,
      wrapFn: void 0,
      target: r,
      type: e,
      listener: t
    }, i = sa.bind(n);
    return i.listener = t, n.wrapFn = i, i;
  }
  __name(ui, "ui");
  a(ui, "_onceWrap");
  R.prototype.once = a(function(e, t) {
    return pt(t), this.on(e, ui(this, e, t)), this;
  }, "once");
  R.prototype.prependOnceListener = a(function(e, t) {
    return pt(t), this.prependListener(e, ui(this, e, t)), this;
  }, "prependOnceListener");
  R.prototype.removeListener = a(function(e, t) {
    var n, i, s, o, u;
    if (pt(t), i = this._events, i === void 0) return this;
    if (n = i[e], n === void 0) return this;
    if (n === t || n.listener === t) --this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete i[e], i.removeListener && this.emit("removeListener", e, n.listener || t));
    else if (typeof n != "function") {
      for (s = -1, o = n.length - 1; o >= 0; o--) if (n[o] === t || n[o].listener === t) {
        u = n[o].listener, s = o;
        break;
      }
      if (s < 0) return this;
      s === 0 ? n.shift() : oa(n, s), n.length === 1 && (i[e] = n[0]), i.removeListener !== void 0 && this.emit("removeListener", e, u || t);
    }
    return this;
  }, "removeListener");
  R.prototype.off = R.prototype.removeListener;
  R.prototype.removeAllListeners = a(function(e) {
    var t, n, i;
    if (n = this._events, n === void 0) return this;
    if (n.removeListener === void 0) return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : n[e] !== void 0 && (--this._eventsCount === 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete n[e]), this;
    if (arguments.length === 0) {
      var s = Object.keys(n), o;
      for (i = 0; i < s.length; ++i) o = s[i], o !== "removeListener" && this.removeAllListeners(
        o
      );
      return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
    }
    if (t = n[e], typeof t == "function") this.removeListener(e, t);
    else if (t !== void 0) for (i = t.length - 1; i >= 0; i--) this.removeListener(e, t[i]);
    return this;
  }, "removeAllListeners");
  function ci(r, e, t) {
    var n = r._events;
    if (n === void 0) return [];
    var i = n[e];
    return i === void 0 ? [] : typeof i == "function" ? t ? [i.listener || i] : [i] : t ? aa(i) : fi(i, i.length);
  }
  __name(ci, "ci");
  a(ci, "_listeners");
  R.prototype.listeners = a(function(e) {
    return ci(this, e, true);
  }, "listeners");
  R.prototype.rawListeners = a(function(e) {
    return ci(this, e, false);
  }, "rawListeners");
  R.listenerCount = function(r, e) {
    return typeof r.listenerCount == "function" ? r.listenerCount(e) : li.call(r, e);
  };
  R.prototype.listenerCount = li;
  function li(r) {
    var e = this._events;
    if (e !== void 0) {
      var t = e[r];
      if (typeof t == "function")
        return 1;
      if (t !== void 0) return t.length;
    }
    return 0;
  }
  __name(li, "li");
  a(li, "listenerCount");
  R.prototype.eventNames = a(function() {
    return this._eventsCount > 0 ? ht(this._events) : [];
  }, "eventNames");
  function fi(r, e) {
    for (var t = new Array(e), n = 0; n < e; ++n) t[n] = r[n];
    return t;
  }
  __name(fi, "fi");
  a(fi, "arrayClone");
  function oa(r, e) {
    for (; e + 1 < r.length; e++) r[e] = r[e + 1];
    r.pop();
  }
  __name(oa, "oa");
  a(oa, "spliceOne");
  function aa(r) {
    for (var e = new Array(r.length), t = 0; t < e.length; ++t) e[t] = r[t].listener || r[t];
    return e;
  }
  __name(aa, "aa");
  a(aa, "unwrapListeners");
  function ua(r, e) {
    return new Promise(function(t, n) {
      function i(o) {
        r.removeListener(e, s), n(o);
      }
      __name(i, "i");
      a(i, "errorListener");
      function s() {
        typeof r.removeListener == "function" && r.removeListener("error", i), t([].slice.call(arguments));
      }
      __name(s, "s");
      a(s, "resolver"), hi(r, e, s, { once: true }), e !== "error" && ca(r, i, { once: true });
    });
  }
  __name(ua, "ua");
  a(ua, "once");
  function ca(r, e, t) {
    typeof r.on == "function" && hi(r, "error", e, t);
  }
  __name(ca, "ca");
  a(
    ca,
    "addErrorHandlerIfEventEmitter"
  );
  function hi(r, e, t, n) {
    if (typeof r.on == "function") n.once ? r.once(e, t) : r.on(e, t);
    else if (typeof r.addEventListener == "function") r.addEventListener(e, a(/* @__PURE__ */ __name(function i(s) {
      n.once && r.removeEventListener(e, i), t(s);
    }, "i"), "wrapListener"));
    else throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof r);
  }
  __name(hi, "hi");
  a(hi, "eventTargetAgnosticAddListener");
});
var yi = {};
ne(yi, { Socket: /* @__PURE__ */ __name(() => ge, "Socket"), isIP: /* @__PURE__ */ __name(() => la, "isIP") });
function la(r) {
  return 0;
}
__name(la, "la");
var di;
var pi;
var S;
var ge;
var We = z(() => {
  "use strict";
  p();
  di = xe(me(), 1);
  a(la, "isIP");
  pi = /^[^.]+\./, S = class S2 extends di.EventEmitter {
    static {
      __name(this, "S");
    }
    constructor() {
      super(...arguments);
      E(this, "opts", {});
      E(this, "connecting", false);
      E(this, "pending", true);
      E(
        this,
        "writable",
        true
      );
      E(this, "encrypted", false);
      E(this, "authorized", false);
      E(this, "destroyed", false);
      E(this, "ws", null);
      E(this, "writeBuffer");
      E(this, "tlsState", 0);
      E(this, "tlsRead");
      E(this, "tlsWrite");
    }
    static get poolQueryViaFetch() {
      return S2.opts.poolQueryViaFetch ?? S2.defaults.poolQueryViaFetch;
    }
    static set poolQueryViaFetch(t) {
      S2.opts.poolQueryViaFetch = t;
    }
    static get fetchEndpoint() {
      return S2.opts.fetchEndpoint ?? S2.defaults.fetchEndpoint;
    }
    static set fetchEndpoint(t) {
      S2.opts.fetchEndpoint = t;
    }
    static get fetchConnectionCache() {
      return true;
    }
    static set fetchConnectionCache(t) {
      console.warn("The `fetchConnectionCache` option is deprecated (now always `true`)");
    }
    static get fetchFunction() {
      return S2.opts.fetchFunction ?? S2.defaults.fetchFunction;
    }
    static set fetchFunction(t) {
      S2.opts.fetchFunction = t;
    }
    static get webSocketConstructor() {
      return S2.opts.webSocketConstructor ?? S2.defaults.webSocketConstructor;
    }
    static set webSocketConstructor(t) {
      S2.opts.webSocketConstructor = t;
    }
    get webSocketConstructor() {
      return this.opts.webSocketConstructor ?? S2.webSocketConstructor;
    }
    set webSocketConstructor(t) {
      this.opts.webSocketConstructor = t;
    }
    static get wsProxy() {
      return S2.opts.wsProxy ?? S2.defaults.wsProxy;
    }
    static set wsProxy(t) {
      S2.opts.wsProxy = t;
    }
    get wsProxy() {
      return this.opts.wsProxy ?? S2.wsProxy;
    }
    set wsProxy(t) {
      this.opts.wsProxy = t;
    }
    static get coalesceWrites() {
      return S2.opts.coalesceWrites ?? S2.defaults.coalesceWrites;
    }
    static set coalesceWrites(t) {
      S2.opts.coalesceWrites = t;
    }
    get coalesceWrites() {
      return this.opts.coalesceWrites ?? S2.coalesceWrites;
    }
    set coalesceWrites(t) {
      this.opts.coalesceWrites = t;
    }
    static get useSecureWebSocket() {
      return S2.opts.useSecureWebSocket ?? S2.defaults.useSecureWebSocket;
    }
    static set useSecureWebSocket(t) {
      S2.opts.useSecureWebSocket = t;
    }
    get useSecureWebSocket() {
      return this.opts.useSecureWebSocket ?? S2.useSecureWebSocket;
    }
    set useSecureWebSocket(t) {
      this.opts.useSecureWebSocket = t;
    }
    static get forceDisablePgSSL() {
      return S2.opts.forceDisablePgSSL ?? S2.defaults.forceDisablePgSSL;
    }
    static set forceDisablePgSSL(t) {
      S2.opts.forceDisablePgSSL = t;
    }
    get forceDisablePgSSL() {
      return this.opts.forceDisablePgSSL ?? S2.forceDisablePgSSL;
    }
    set forceDisablePgSSL(t) {
      this.opts.forceDisablePgSSL = t;
    }
    static get disableSNI() {
      return S2.opts.disableSNI ?? S2.defaults.disableSNI;
    }
    static set disableSNI(t) {
      S2.opts.disableSNI = t;
    }
    get disableSNI() {
      return this.opts.disableSNI ?? S2.disableSNI;
    }
    set disableSNI(t) {
      this.opts.disableSNI = t;
    }
    static get pipelineConnect() {
      return S2.opts.pipelineConnect ?? S2.defaults.pipelineConnect;
    }
    static set pipelineConnect(t) {
      S2.opts.pipelineConnect = t;
    }
    get pipelineConnect() {
      return this.opts.pipelineConnect ?? S2.pipelineConnect;
    }
    set pipelineConnect(t) {
      this.opts.pipelineConnect = t;
    }
    static get subtls() {
      return S2.opts.subtls ?? S2.defaults.subtls;
    }
    static set subtls(t) {
      S2.opts.subtls = t;
    }
    get subtls() {
      return this.opts.subtls ?? S2.subtls;
    }
    set subtls(t) {
      this.opts.subtls = t;
    }
    static get pipelineTLS() {
      return S2.opts.pipelineTLS ?? S2.defaults.pipelineTLS;
    }
    static set pipelineTLS(t) {
      S2.opts.pipelineTLS = t;
    }
    get pipelineTLS() {
      return this.opts.pipelineTLS ?? S2.pipelineTLS;
    }
    set pipelineTLS(t) {
      this.opts.pipelineTLS = t;
    }
    static get rootCerts() {
      return S2.opts.rootCerts ?? S2.defaults.rootCerts;
    }
    static set rootCerts(t) {
      S2.opts.rootCerts = t;
    }
    get rootCerts() {
      return this.opts.rootCerts ?? S2.rootCerts;
    }
    set rootCerts(t) {
      this.opts.rootCerts = t;
    }
    wsProxyAddrForHost(t, n) {
      let i = this.wsProxy;
      if (i === void 0) throw new Error("No WebSocket proxy is configured. Please see https://github.com/neondatabase/serverless/blob/main/CONFIG.md#wsproxy-string--host-string-port-number--string--string");
      return typeof i == "function" ? i(t, n) : `${i}?address=${t}:${n}`;
    }
    setNoDelay() {
      return this;
    }
    setKeepAlive() {
      return this;
    }
    ref() {
      return this;
    }
    unref() {
      return this;
    }
    connect(t, n, i) {
      this.connecting = true, i && this.once("connect", i);
      let s = a(() => {
        this.connecting = false, this.pending = false, this.emit("connect"), this.emit("ready");
      }, "handleWebSocketOpen"), o = a((c, l = false) => {
        c.binaryType = "arraybuffer", c.addEventListener("error", (f) => {
          this.emit("error", f), this.emit("close");
        }), c.addEventListener("message", (f) => {
          if (this.tlsState === 0) {
            let y = d.from(f.data);
            this.emit("data", y);
          }
        }), c.addEventListener("close", () => {
          this.emit("close");
        }), l ? s() : c.addEventListener(
          "open",
          s
        );
      }, "configureWebSocket"), u;
      try {
        u = this.wsProxyAddrForHost(n, typeof t == "string" ? parseInt(t, 10) : t);
      } catch (c) {
        this.emit("error", c), this.emit("close");
        return;
      }
      try {
        let l = (this.useSecureWebSocket ? "wss:" : "ws:") + "//" + u;
        if (this.webSocketConstructor !== void 0) this.ws = new this.webSocketConstructor(l), o(this.ws);
        else try {
          this.ws = new WebSocket(l), o(this.ws);
        } catch {
          this.ws = new __unstable_WebSocket(l), o(this.ws);
        }
      } catch (c) {
        let f = (this.useSecureWebSocket ? "https:" : "http:") + "//" + u;
        fetch(f, { headers: { Upgrade: "websocket" } }).then(
          (y) => {
            if (this.ws = y.webSocket, this.ws == null) throw c;
            this.ws.accept(), o(this.ws, true);
          }
        ).catch((y) => {
          this.emit(
            "error",
            new Error(`All attempts to open a WebSocket to connect to the database failed. Please refer to https://github.com/neondatabase/serverless/blob/main/CONFIG.md#websocketconstructor-typeof-websocket--undefined. Details: ${y}`)
          ), this.emit("close");
        });
      }
    }
    async startTls(t) {
      if (this.subtls === void 0) throw new Error(
        "For Postgres SSL connections, you must set `neonConfig.subtls` to the subtls library. See https://github.com/neondatabase/serverless/blob/main/CONFIG.md for more information."
      );
      this.tlsState = 1;
      let n = await this.subtls.TrustedCert.databaseFromPEM(this.rootCerts), i = new this.subtls.WebSocketReadQueue(this.ws), s = i.read.bind(i), o = this.rawWrite.bind(this), { read: u, write: c } = await this.subtls.startTls(t, n, s, o, { useSNI: !this.disableSNI, expectPreData: this.pipelineTLS ? new Uint8Array([83]) : void 0 });
      this.tlsRead = u, this.tlsWrite = c, this.tlsState = 2, this.encrypted = true, this.authorized = true, this.emit("secureConnection", this), this.tlsReadLoop();
    }
    async tlsReadLoop() {
      for (; ; ) {
        let t = await this.tlsRead();
        if (t === void 0) break;
        {
          let n = d.from(t);
          this.emit("data", n);
        }
      }
    }
    rawWrite(t) {
      if (!this.coalesceWrites) {
        this.ws.send(t);
        return;
      }
      if (this.writeBuffer === void 0) this.writeBuffer = t, setTimeout(
        () => {
          this.ws.send(this.writeBuffer), this.writeBuffer = void 0;
        },
        0
      );
      else {
        let n = new Uint8Array(this.writeBuffer.length + t.length);
        n.set(this.writeBuffer), n.set(t, this.writeBuffer.length), this.writeBuffer = n;
      }
    }
    write(t, n = "utf8", i = (s) => {
    }) {
      return t.length === 0 ? (i(), true) : (typeof t == "string" && (t = d.from(t, n)), this.tlsState === 0 ? (this.rawWrite(t), i()) : this.tlsState === 1 ? this.once("secureConnection", () => {
        this.write(t, n, i);
      }) : (this.tlsWrite(
        t
      ), i()), true);
    }
    end(t = d.alloc(0), n = "utf8", i = () => {
    }) {
      return this.write(t, n, () => {
        this.ws.close(), i();
      }), this;
    }
    destroy() {
      return this.destroyed = true, this.end();
    }
  };
  a(S, "Socket"), E(S, "defaults", { poolQueryViaFetch: false, fetchEndpoint: a(
    (t, n, i) => {
      let s;
      return i?.jwtAuth ? s = t.replace(pi, "apiauth.") : s = t.replace(pi, "api."), "https://" + s + "/sql";
    },
    "fetchEndpoint"
  ), fetchConnectionCache: true, fetchFunction: void 0, webSocketConstructor: void 0, wsProxy: a(
    (t) => t + "/v2",
    "wsProxy"
  ), useSecureWebSocket: true, forceDisablePgSSL: true, coalesceWrites: true, pipelineConnect: "password", subtls: void 0, rootCerts: "", pipelineTLS: false, disableSNI: false }), E(S, "opts", {});
  ge = S;
});
var mi = {};
ne(mi, { parse: /* @__PURE__ */ __name(() => Vt, "parse") });
function Vt(r, e = false) {
  let { protocol: t } = new URL(r), n = "http:" + r.substring(
    t.length
  ), { username: i, password: s, host: o, hostname: u, port: c, pathname: l, search: f, searchParams: y, hash: g } = new URL(
    n
  );
  s = decodeURIComponent(s), i = decodeURIComponent(i), l = decodeURIComponent(l);
  let A = i + ":" + s, C = e ? Object.fromEntries(y.entries()) : f;
  return {
    href: r,
    protocol: t,
    auth: A,
    username: i,
    password: s,
    host: o,
    hostname: u,
    port: c,
    pathname: l,
    search: f,
    query: C,
    hash: g
  };
}
__name(Vt, "Vt");
var zt = z(() => {
  "use strict";
  p();
  a(Vt, "parse");
});
var Jt = I((Si) => {
  "use strict";
  p();
  Si.parse = function(r, e) {
    return new Zt(r, e).parse();
  };
  var wt = class wt2 {
    static {
      __name(this, "wt");
    }
    constructor(e, t) {
      this.source = e, this.transform = t || Ea, this.position = 0, this.entries = [], this.recorded = [], this.dimension = 0;
    }
    isEof() {
      return this.position >= this.source.length;
    }
    nextCharacter() {
      var e = this.source[this.position++];
      return e === "\\" ? { value: this.source[this.position++], escaped: true } : { value: e, escaped: false };
    }
    record(e) {
      this.recorded.push(
        e
      );
    }
    newEntry(e) {
      var t;
      (this.recorded.length > 0 || e) && (t = this.recorded.join(""), t === "NULL" && !e && (t = null), t !== null && (t = this.transform(t)), this.entries.push(t), this.recorded = []);
    }
    consumeDimensions() {
      if (this.source[0] === "[") for (; !this.isEof(); ) {
        var e = this.nextCharacter();
        if (e.value === "=") break;
      }
    }
    parse(e) {
      var t, n, i;
      for (this.consumeDimensions(); !this.isEof(); ) if (t = this.nextCharacter(), t.value === "{" && !i) this.dimension++, this.dimension > 1 && (n = new wt2(this.source.substr(this.position - 1), this.transform), this.entries.push(n.parse(
        true
      )), this.position += n.position - 2);
      else if (t.value === "}" && !i) {
        if (this.dimension--, !this.dimension && (this.newEntry(), e)) return this.entries;
      } else t.value === '"' && !t.escaped ? (i && this.newEntry(true), i = !i) : t.value === "," && !i ? this.newEntry() : this.record(t.value);
      if (this.dimension !== 0) throw new Error("array dimension not balanced");
      return this.entries;
    }
  };
  a(wt, "ArrayParser");
  var Zt = wt;
  function Ea(r) {
    return r;
  }
  __name(Ea, "Ea");
  a(Ea, "identity");
});
var Xt = I((Gl, Ei) => {
  p();
  var Aa = Jt();
  Ei.exports = { create: a(function(r, e) {
    return { parse: a(function() {
      return Aa.parse(r, e);
    }, "parse") };
  }, "create") };
});
var _i = I((Kl, Ci) => {
  "use strict";
  p();
  var Ca = /(\d{1,})-(\d{2})-(\d{2}) (\d{2}):(\d{2}):(\d{2})(\.\d{1,})?.*?( BC)?$/, _a = /^(\d{1,})-(\d{2})-(\d{2})( BC)?$/, Ta = /([Z+-])(\d{2})?:?(\d{2})?:?(\d{2})?/, Ia = /^-?infinity$/;
  Ci.exports = a(function(e) {
    if (Ia.test(e)) return Number(e.replace("i", "I"));
    var t = Ca.exec(e);
    if (!t) return Pa(
      e
    ) || null;
    var n = !!t[8], i = parseInt(t[1], 10);
    n && (i = Ai(i));
    var s = parseInt(t[2], 10) - 1, o = t[3], u = parseInt(
      t[4],
      10
    ), c = parseInt(t[5], 10), l = parseInt(t[6], 10), f = t[7];
    f = f ? 1e3 * parseFloat(f) : 0;
    var y, g = Ra(e);
    return g != null ? (y = new Date(Date.UTC(i, s, o, u, c, l, f)), er(i) && y.setUTCFullYear(i), g !== 0 && y.setTime(y.getTime() - g)) : (y = new Date(i, s, o, u, c, l, f), er(i) && y.setFullYear(i)), y;
  }, "parseDate");
  function Pa(r) {
    var e = _a.exec(r);
    if (e) {
      var t = parseInt(e[1], 10), n = !!e[4];
      n && (t = Ai(t));
      var i = parseInt(e[2], 10) - 1, s = e[3], o = new Date(t, i, s);
      return er(
        t
      ) && o.setFullYear(t), o;
    }
  }
  __name(Pa, "Pa");
  a(Pa, "getDate");
  function Ra(r) {
    if (r.endsWith("+00")) return 0;
    var e = Ta.exec(r.split(" ")[1]);
    if (e) {
      var t = e[1];
      if (t === "Z") return 0;
      var n = t === "-" ? -1 : 1, i = parseInt(e[2], 10) * 3600 + parseInt(
        e[3] || 0,
        10
      ) * 60 + parseInt(e[4] || 0, 10);
      return i * n * 1e3;
    }
  }
  __name(Ra, "Ra");
  a(Ra, "timeZoneOffset");
  function Ai(r) {
    return -(r - 1);
  }
  __name(Ai, "Ai");
  a(Ai, "bcYearToNegativeYear");
  function er(r) {
    return r >= 0 && r < 100;
  }
  __name(er, "er");
  a(er, "is0To99");
});
var Ii = I((Jl, Ti) => {
  p();
  Ti.exports = La;
  var Ba = Object.prototype.hasOwnProperty;
  function La(r) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var n in t) Ba.call(t, n) && (r[n] = t[n]);
    }
    return r;
  }
  __name(La, "La");
  a(La, "extend");
});
var Bi = I((tf, Ri) => {
  "use strict";
  p();
  var Fa = Ii();
  Ri.exports = Fe;
  function Fe(r) {
    if (!(this instanceof Fe))
      return new Fe(r);
    Fa(this, $a(r));
  }
  __name(Fe, "Fe");
  a(Fe, "PostgresInterval");
  var ka = [
    "seconds",
    "minutes",
    "hours",
    "days",
    "months",
    "years"
  ];
  Fe.prototype.toPostgres = function() {
    var r = ka.filter(this.hasOwnProperty, this);
    return this.milliseconds && r.indexOf("seconds") < 0 && r.push("seconds"), r.length === 0 ? "0" : r.map(function(e) {
      var t = this[e] || 0;
      return e === "seconds" && this.milliseconds && (t = (t + this.milliseconds / 1e3).toFixed(6).replace(
        /\.?0+$/,
        ""
      )), t + " " + e;
    }, this).join(" ");
  };
  var Ma = { years: "Y", months: "M", days: "D", hours: "H", minutes: "M", seconds: "S" }, Ua = ["years", "months", "days"], Da = ["hours", "minutes", "seconds"];
  Fe.prototype.toISOString = Fe.prototype.toISO = function() {
    var r = Ua.map(t, this).join(""), e = Da.map(t, this).join("");
    return "P" + r + "T" + e;
    function t(n) {
      var i = this[n] || 0;
      return n === "seconds" && this.milliseconds && (i = (i + this.milliseconds / 1e3).toFixed(6).replace(
        /0+$/,
        ""
      )), i + Ma[n];
    }
    __name(t, "t");
  };
  var tr = "([+-]?\\d+)", Oa = tr + "\\s+years?", qa = tr + "\\s+mons?", Qa = tr + "\\s+days?", Na = "([+-])?([\\d]*):(\\d\\d):(\\d\\d)\\.?(\\d{1,6})?", ja = new RegExp([Oa, qa, Qa, Na].map(function(r) {
    return "(" + r + ")?";
  }).join("\\s*")), Pi = { years: 2, months: 4, days: 6, hours: 9, minutes: 10, seconds: 11, milliseconds: 12 }, Wa = ["hours", "minutes", "seconds", "milliseconds"];
  function Ha(r) {
    var e = r + "000000".slice(r.length);
    return parseInt(
      e,
      10
    ) / 1e3;
  }
  __name(Ha, "Ha");
  a(Ha, "parseMilliseconds");
  function $a(r) {
    if (!r) return {};
    var e = ja.exec(r), t = e[8] === "-";
    return Object.keys(Pi).reduce(function(n, i) {
      var s = Pi[i], o = e[s];
      return !o || (o = i === "milliseconds" ? Ha(o) : parseInt(o, 10), !o) || (t && ~Wa.indexOf(i) && (o *= -1), n[i] = o), n;
    }, {});
  }
  __name($a, "$a");
  a($a, "parse");
});
var Fi = I((sf, Li) => {
  "use strict";
  p();
  Li.exports = a(function(e) {
    if (/^\\x/.test(e)) return new d(e.substr(
      2
    ), "hex");
    for (var t = "", n = 0; n < e.length; ) if (e[n] !== "\\") t += e[n], ++n;
    else if (/[0-7]{3}/.test(e.substr(n + 1, 3))) t += String.fromCharCode(parseInt(e.substr(n + 1, 3), 8)), n += 4;
    else {
      for (var i = 1; n + i < e.length && e[n + i] === "\\"; ) i++;
      for (var s = 0; s < Math.floor(i / 2); ++s) t += "\\";
      n += Math.floor(i / 2) * 2;
    }
    return new d(t, "binary");
  }, "parseBytea");
});
var Qi = I((uf, qi) => {
  p();
  var Ve = Jt(), ze = Xt(), bt = _i(), Mi = Bi(), Ui = Fi();
  function vt(r) {
    return a(function(t) {
      return t === null ? t : r(t);
    }, "nullAllowed");
  }
  __name(vt, "vt");
  a(vt, "allowNull");
  function Di(r) {
    return r === null ? r : r === "TRUE" || r === "t" || r === "true" || r === "y" || r === "yes" || r === "on" || r === "1";
  }
  __name(Di, "Di");
  a(Di, "parseBool");
  function Ga(r) {
    return r ? Ve.parse(r, Di) : null;
  }
  __name(Ga, "Ga");
  a(Ga, "parseBoolArray");
  function Va(r) {
    return parseInt(r, 10);
  }
  __name(Va, "Va");
  a(Va, "parseBaseTenInt");
  function rr(r) {
    return r ? Ve.parse(r, vt(Va)) : null;
  }
  __name(rr, "rr");
  a(rr, "parseIntegerArray");
  function za(r) {
    return r ? Ve.parse(r, vt(function(e) {
      return Oi(e).trim();
    })) : null;
  }
  __name(za, "za");
  a(za, "parseBigIntegerArray");
  var Ka = a(function(r) {
    if (!r) return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = or(t)), t;
    });
    return e.parse();
  }, "parsePointArray"), nr = a(function(r) {
    if (!r) return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = parseFloat(t)), t;
    });
    return e.parse();
  }, "parseFloatArray"), te = a(function(r) {
    if (!r) return null;
    var e = ze.create(r);
    return e.parse();
  }, "parseStringArray"), ir = a(function(r) {
    if (!r) return null;
    var e = ze.create(
      r,
      function(t) {
        return t !== null && (t = bt(t)), t;
      }
    );
    return e.parse();
  }, "parseDateArray"), Ya = a(function(r) {
    if (!r)
      return null;
    var e = ze.create(r, function(t) {
      return t !== null && (t = Mi(t)), t;
    });
    return e.parse();
  }, "parseIntervalArray"), Za = a(function(r) {
    return r ? Ve.parse(r, vt(Ui)) : null;
  }, "parseByteAArray"), sr = a(function(r) {
    return parseInt(r, 10);
  }, "parseInteger"), Oi = a(function(r) {
    var e = String(r);
    return /^\d+$/.test(e) ? e : r;
  }, "parseBigInteger"), ki = a(function(r) {
    return r ? Ve.parse(r, vt(JSON.parse)) : null;
  }, "parseJsonArray"), or = a(
    function(r) {
      return r[0] !== "(" ? null : (r = r.substring(1, r.length - 1).split(","), { x: parseFloat(r[0]), y: parseFloat(
        r[1]
      ) });
    },
    "parsePoint"
  ), Ja = a(function(r) {
    if (r[0] !== "<" && r[1] !== "(") return null;
    for (var e = "(", t = "", n = false, i = 2; i < r.length - 1; i++) {
      if (n || (e += r[i]), r[i] === ")") {
        n = true;
        continue;
      } else if (!n) continue;
      r[i] !== "," && (t += r[i]);
    }
    var s = or(e);
    return s.radius = parseFloat(t), s;
  }, "parseCircle"), Xa = a(function(r) {
    r(20, Oi), r(21, sr), r(23, sr), r(26, sr), r(700, parseFloat), r(701, parseFloat), r(16, Di), r(1082, bt), r(1114, bt), r(1184, bt), r(
      600,
      or
    ), r(651, te), r(718, Ja), r(1e3, Ga), r(1001, Za), r(1005, rr), r(1007, rr), r(1028, rr), r(1016, za), r(1017, Ka), r(1021, nr), r(1022, nr), r(1231, nr), r(1014, te), r(1015, te), r(1008, te), r(1009, te), r(1040, te), r(1041, te), r(
      1115,
      ir
    ), r(1182, ir), r(1185, ir), r(1186, Mi), r(1187, Ya), r(17, Ui), r(114, JSON.parse.bind(JSON)), r(3802, JSON.parse.bind(JSON)), r(199, ki), r(3807, ki), r(3907, te), r(2951, te), r(791, te), r(1183, te), r(1270, te);
  }, "init");
  qi.exports = { init: Xa };
});
var ji = I((ff, Ni) => {
  "use strict";
  p();
  var Y = 1e6;
  function eu(r) {
    var e = r.readInt32BE(0), t = r.readUInt32BE(
      4
    ), n = "";
    e < 0 && (e = ~e + (t === 0), t = ~t + 1 >>> 0, n = "-");
    var i = "", s, o, u, c, l, f;
    {
      if (s = e % Y, e = e / Y >>> 0, o = 4294967296 * s + t, t = o / Y >>> 0, u = "" + (o - Y * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    {
      if (s = e % Y, e = e / Y >>> 0, o = 4294967296 * s + t, t = o / Y >>> 0, u = "" + (o - Y * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    {
      if (s = e % Y, e = e / Y >>> 0, o = 4294967296 * s + t, t = o / Y >>> 0, u = "" + (o - Y * t), t === 0 && e === 0) return n + u + i;
      for (c = "", l = 6 - u.length, f = 0; f < l; f++) c += "0";
      i = c + u + i;
    }
    return s = e % Y, o = 4294967296 * s + t, u = "" + o % Y, n + u + i;
  }
  __name(eu, "eu");
  a(eu, "readInt8");
  Ni.exports = eu;
});
var Vi = I((df, Gi) => {
  p();
  var tu = ji(), F = a(function(r, e, t, n, i) {
    t = t || 0, n = n || false, i = i || function(A, C, Q) {
      return A * Math.pow(2, Q) + C;
    };
    var s = t >> 3, o = a(function(A) {
      return n ? ~A & 255 : A;
    }, "inv"), u = 255, c = 8 - t % 8;
    e < c && (u = 255 << 8 - e & 255, c = e), t && (u = u >> t % 8);
    var l = 0;
    t % 8 + e >= 8 && (l = i(0, o(r[s]) & u, c));
    for (var f = e + t >> 3, y = s + 1; y < f; y++) l = i(l, o(
      r[y]
    ), 8);
    var g = (e + t) % 8;
    return g > 0 && (l = i(l, o(r[f]) >> 8 - g, g)), l;
  }, "parseBits"), $i = a(function(r, e, t) {
    var n = Math.pow(2, t - 1) - 1, i = F(r, 1), s = F(r, t, 1);
    if (s === 0) return 0;
    var o = 1, u = a(function(l, f, y) {
      l === 0 && (l = 1);
      for (var g = 1; g <= y; g++) o /= 2, (f & 1 << y - g) > 0 && (l += o);
      return l;
    }, "parsePrecisionBits"), c = F(r, e, t + 1, false, u);
    return s == Math.pow(
      2,
      t + 1
    ) - 1 ? c === 0 ? i === 0 ? 1 / 0 : -1 / 0 : NaN : (i === 0 ? 1 : -1) * Math.pow(2, s - n) * c;
  }, "parseFloatFromBits"), ru = a(function(r) {
    return F(r, 1) == 1 ? -1 * (F(r, 15, 1, true) + 1) : F(r, 15, 1);
  }, "parseInt16"), Wi = a(function(r) {
    return F(r, 1) == 1 ? -1 * (F(
      r,
      31,
      1,
      true
    ) + 1) : F(r, 31, 1);
  }, "parseInt32"), nu = a(function(r) {
    return $i(r, 23, 8);
  }, "parseFloat32"), iu = a(function(r) {
    return $i(r, 52, 11);
  }, "parseFloat64"), su = a(function(r) {
    var e = F(r, 16, 32);
    if (e == 49152) return NaN;
    for (var t = Math.pow(1e4, F(r, 16, 16)), n = 0, i = [], s = F(r, 16), o = 0; o < s; o++) n += F(r, 16, 64 + 16 * o) * t, t /= 1e4;
    var u = Math.pow(10, F(
      r,
      16,
      48
    ));
    return (e === 0 ? 1 : -1) * Math.round(n * u) / u;
  }, "parseNumeric"), Hi = a(function(r, e) {
    var t = F(e, 1), n = F(
      e,
      63,
      1
    ), i = new Date((t === 0 ? 1 : -1) * n / 1e3 + 9466848e5);
    return r || i.setTime(i.getTime() + i.getTimezoneOffset() * 6e4), i.usec = n % 1e3, i.getMicroSeconds = function() {
      return this.usec;
    }, i.setMicroSeconds = function(s) {
      this.usec = s;
    }, i.getUTCMicroSeconds = function() {
      return this.usec;
    }, i;
  }, "parseDate"), Ke = a(
    function(r) {
      for (var e = F(
        r,
        32
      ), t = F(r, 32, 32), n = F(r, 32, 64), i = 96, s = [], o = 0; o < e; o++) s[o] = F(r, 32, i), i += 32, i += 32;
      var u = a(function(l) {
        var f = F(r, 32, i);
        if (i += 32, f == 4294967295) return null;
        var y;
        if (l == 23 || l == 20) return y = F(r, f * 8, i), i += f * 8, y;
        if (l == 25) return y = r.toString(this.encoding, i >> 3, (i += f << 3) >> 3), y;
        console.log("ERROR: ElementType not implemented: " + l);
      }, "parseElement"), c = a(function(l, f) {
        var y = [], g;
        if (l.length > 1) {
          var A = l.shift();
          for (g = 0; g < A; g++) y[g] = c(l, f);
          l.unshift(A);
        } else for (g = 0; g < l[0]; g++) y[g] = u(f);
        return y;
      }, "parse");
      return c(s, n);
    },
    "parseArray"
  ), ou = a(function(r) {
    return r.toString("utf8");
  }, "parseText"), au = a(function(r) {
    return r === null ? null : F(r, 8) > 0;
  }, "parseBool"), uu = a(function(r) {
    r(20, tu), r(21, ru), r(23, Wi), r(26, Wi), r(1700, su), r(700, nu), r(701, iu), r(16, au), r(1114, Hi.bind(null, false)), r(1184, Hi.bind(null, true)), r(1e3, Ke), r(1007, Ke), r(1016, Ke), r(1008, Ke), r(1009, Ke), r(25, ou);
  }, "init");
  Gi.exports = { init: uu };
});
var Ki = I((gf, zi) => {
  p();
  zi.exports = {
    BOOL: 16,
    BYTEA: 17,
    CHAR: 18,
    INT8: 20,
    INT2: 21,
    INT4: 23,
    REGPROC: 24,
    TEXT: 25,
    OID: 26,
    TID: 27,
    XID: 28,
    CID: 29,
    JSON: 114,
    XML: 142,
    PG_NODE_TREE: 194,
    SMGR: 210,
    PATH: 602,
    POLYGON: 604,
    CIDR: 650,
    FLOAT4: 700,
    FLOAT8: 701,
    ABSTIME: 702,
    RELTIME: 703,
    TINTERVAL: 704,
    CIRCLE: 718,
    MACADDR8: 774,
    MONEY: 790,
    MACADDR: 829,
    INET: 869,
    ACLITEM: 1033,
    BPCHAR: 1042,
    VARCHAR: 1043,
    DATE: 1082,
    TIME: 1083,
    TIMESTAMP: 1114,
    TIMESTAMPTZ: 1184,
    INTERVAL: 1186,
    TIMETZ: 1266,
    BIT: 1560,
    VARBIT: 1562,
    NUMERIC: 1700,
    REFCURSOR: 1790,
    REGPROCEDURE: 2202,
    REGOPER: 2203,
    REGOPERATOR: 2204,
    REGCLASS: 2205,
    REGTYPE: 2206,
    UUID: 2950,
    TXID_SNAPSHOT: 2970,
    PG_LSN: 3220,
    PG_NDISTINCT: 3361,
    PG_DEPENDENCIES: 3402,
    TSVECTOR: 3614,
    TSQUERY: 3615,
    GTSVECTOR: 3642,
    REGCONFIG: 3734,
    REGDICTIONARY: 3769,
    JSONB: 3802,
    REGNAMESPACE: 4089,
    REGROLE: 4096
  };
});
var Je = I((Ze) => {
  p();
  var cu = Qi(), lu = Vi(), fu = Xt(), hu = Ki();
  Ze.getTypeParser = pu;
  Ze.setTypeParser = du;
  Ze.arrayParser = fu;
  Ze.builtins = hu;
  var Ye = { text: {}, binary: {} };
  function Yi(r) {
    return String(r);
  }
  __name(Yi, "Yi");
  a(Yi, "noParse");
  function pu(r, e) {
    return e = e || "text", Ye[e] && Ye[e][r] || Yi;
  }
  __name(pu, "pu");
  a(pu, "getTypeParser");
  function du(r, e, t) {
    typeof e == "function" && (t = e, e = "text"), Ye[e][r] = t;
  }
  __name(du, "du");
  a(du, "setTypeParser");
  cu.init(function(r, e) {
    Ye.text[r] = e;
  });
  lu.init(function(r, e) {
    Ye.binary[r] = e;
  });
});
var St = I((Sf, Zi) => {
  "use strict";
  p();
  var yu = Je();
  function xt(r) {
    this._types = r || yu, this.text = {}, this.binary = {};
  }
  __name(xt, "xt");
  a(xt, "TypeOverrides");
  xt.prototype.getOverrides = function(r) {
    switch (r) {
      case "text":
        return this.text;
      case "binary":
        return this.binary;
      default:
        return {};
    }
  };
  xt.prototype.setTypeParser = function(r, e, t) {
    typeof e == "function" && (t = e, e = "text"), this.getOverrides(e)[r] = t;
  };
  xt.prototype.getTypeParser = function(r, e) {
    return e = e || "text", this.getOverrides(e)[r] || this._types.getTypeParser(r, e);
  };
  Zi.exports = xt;
});
function Xe(r) {
  let e = 1779033703, t = 3144134277, n = 1013904242, i = 2773480762, s = 1359893119, o = 2600822924, u = 528734635, c = 1541459225, l = 0, f = 0, y = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ], g = a((_, x) => _ >>> x | _ << 32 - x, "rrot"), A = new Uint32Array(64), C = new Uint8Array(64), Q = a(() => {
    for (let B = 0, $ = 0; B < 16; B++, $ += 4) A[B] = C[$] << 24 | C[$ + 1] << 16 | C[$ + 2] << 8 | C[$ + 3];
    for (let B = 16; B < 64; B++) {
      let $ = g(A[B - 15], 7) ^ g(A[B - 15], 18) ^ A[B - 15] >>> 3, fe = g(
        A[B - 2],
        17
      ) ^ g(A[B - 2], 19) ^ A[B - 2] >>> 10;
      A[B] = A[B - 16] + $ + A[B - 7] + fe | 0;
    }
    let _ = e, x = t, H = n, le = i, N = s, ie = o, se = u, oe = c;
    for (let B = 0; B < 64; B++) {
      let $ = g(N, 6) ^ g(N, 11) ^ g(N, 25), fe = N & ie ^ ~N & se, Ce = oe + $ + fe + y[B] + A[B] | 0, he = g(_, 2) ^ g(
        _,
        13
      ) ^ g(_, 22), _e = _ & x ^ _ & H ^ x & H, ae = he + _e | 0;
      oe = se, se = ie, ie = N, N = le + Ce | 0, le = H, H = x, x = _, _ = Ce + ae | 0;
    }
    e = e + _ | 0, t = t + x | 0, n = n + H | 0, i = i + le | 0, s = s + N | 0, o = o + ie | 0, u = u + se | 0, c = c + oe | 0, f = 0;
  }, "process"), P = a((_) => {
    typeof _ == "string" && (_ = new TextEncoder().encode(_));
    for (let x = 0; x < _.length; x++) C[f++] = _[x], f === 64 && Q();
    l += _.length;
  }, "add"), L = a(() => {
    if (C[f++] = 128, f == 64 && Q(), f + 8 > 64) {
      for (; f < 64; ) C[f++] = 0;
      Q();
    }
    for (; f < 58; ) C[f++] = 0;
    let _ = l * 8;
    C[f++] = _ / 1099511627776 & 255, C[f++] = _ / 4294967296 & 255, C[f++] = _ >>> 24, C[f++] = _ >>> 16 & 255, C[f++] = _ >>> 8 & 255, C[f++] = _ & 255, Q();
    let x = new Uint8Array(32);
    return x[0] = e >>> 24, x[1] = e >>> 16 & 255, x[2] = e >>> 8 & 255, x[3] = e & 255, x[4] = t >>> 24, x[5] = t >>> 16 & 255, x[6] = t >>> 8 & 255, x[7] = t & 255, x[8] = n >>> 24, x[9] = n >>> 16 & 255, x[10] = n >>> 8 & 255, x[11] = n & 255, x[12] = i >>> 24, x[13] = i >>> 16 & 255, x[14] = i >>> 8 & 255, x[15] = i & 255, x[16] = s >>> 24, x[17] = s >>> 16 & 255, x[18] = s >>> 8 & 255, x[19] = s & 255, x[20] = o >>> 24, x[21] = o >>> 16 & 255, x[22] = o >>> 8 & 255, x[23] = o & 255, x[24] = u >>> 24, x[25] = u >>> 16 & 255, x[26] = u >>> 8 & 255, x[27] = u & 255, x[28] = c >>> 24, x[29] = c >>> 16 & 255, x[30] = c >>> 8 & 255, x[31] = c & 255, x;
  }, "digest");
  return r === void 0 ? { add: P, digest: L } : (P(r), L());
}
__name(Xe, "Xe");
var Ji = z(() => {
  "use strict";
  p();
  a(Xe, "sha256");
});
var U;
var et;
var Xi = z(() => {
  "use strict";
  p();
  U = class U2 {
    static {
      __name(this, "U");
    }
    constructor() {
      E(this, "_dataLength", 0);
      E(this, "_bufferLength", 0);
      E(this, "_state", new Int32Array(4));
      E(this, "_buffer", new ArrayBuffer(68));
      E(this, "_buffer8");
      E(this, "_buffer32");
      this._buffer8 = new Uint8Array(this._buffer, 0, 68), this._buffer32 = new Uint32Array(this._buffer, 0, 17), this.start();
    }
    static hashByteArray(e, t = false) {
      return this.onePassHasher.start().appendByteArray(
        e
      ).end(t);
    }
    static hashStr(e, t = false) {
      return this.onePassHasher.start().appendStr(e).end(t);
    }
    static hashAsciiStr(e, t = false) {
      return this.onePassHasher.start().appendAsciiStr(e).end(t);
    }
    static _hex(e) {
      let t = U2.hexChars, n = U2.hexOut, i, s, o, u;
      for (u = 0; u < 4; u += 1) for (s = u * 8, i = e[u], o = 0; o < 8; o += 2) n[s + 1 + o] = t.charAt(i & 15), i >>>= 4, n[s + 0 + o] = t.charAt(
        i & 15
      ), i >>>= 4;
      return n.join("");
    }
    static _md5cycle(e, t) {
      let n = e[0], i = e[1], s = e[2], o = e[3];
      n += (i & s | ~i & o) + t[0] - 680876936 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[1] - 389564586 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[2] + 606105819 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[3] - 1044525330 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[4] - 176418897 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[5] + 1200080426 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[6] - 1473231341 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[7] - 45705983 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[8] + 1770035416 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[9] - 1958414417 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[10] - 42063 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[11] - 1990404162 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & s | ~i & o) + t[12] + 1804603682 | 0, n = (n << 7 | n >>> 25) + i | 0, o += (n & i | ~n & s) + t[13] - 40341101 | 0, o = (o << 12 | o >>> 20) + n | 0, s += (o & n | ~o & i) + t[14] - 1502002290 | 0, s = (s << 17 | s >>> 15) + o | 0, i += (s & o | ~s & n) + t[15] + 1236535329 | 0, i = (i << 22 | i >>> 10) + s | 0, n += (i & o | s & ~o) + t[1] - 165796510 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[6] - 1069501632 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[11] + 643717713 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[0] - 373897302 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[5] - 701558691 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[10] + 38016083 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[15] - 660478335 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[4] - 405537848 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[9] + 568446438 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[14] - 1019803690 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[3] - 187363961 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[8] + 1163531501 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i & o | s & ~o) + t[13] - 1444681467 | 0, n = (n << 5 | n >>> 27) + i | 0, o += (n & s | i & ~s) + t[2] - 51403784 | 0, o = (o << 9 | o >>> 23) + n | 0, s += (o & i | n & ~i) + t[7] + 1735328473 | 0, s = (s << 14 | s >>> 18) + o | 0, i += (s & n | o & ~n) + t[12] - 1926607734 | 0, i = (i << 20 | i >>> 12) + s | 0, n += (i ^ s ^ o) + t[5] - 378558 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[8] - 2022574463 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[11] + 1839030562 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[14] - 35309556 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[1] - 1530992060 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[4] + 1272893353 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[7] - 155497632 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[10] - 1094730640 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[13] + 681279174 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[0] - 358537222 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[3] - 722521979 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[6] + 76029189 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (i ^ s ^ o) + t[9] - 640364487 | 0, n = (n << 4 | n >>> 28) + i | 0, o += (n ^ i ^ s) + t[12] - 421815835 | 0, o = (o << 11 | o >>> 21) + n | 0, s += (o ^ n ^ i) + t[15] + 530742520 | 0, s = (s << 16 | s >>> 16) + o | 0, i += (s ^ o ^ n) + t[2] - 995338651 | 0, i = (i << 23 | i >>> 9) + s | 0, n += (s ^ (i | ~o)) + t[0] - 198630844 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[7] + 1126891415 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[14] - 1416354905 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[5] - 57434055 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[12] + 1700485571 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[3] - 1894986606 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[10] - 1051523 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[1] - 2054922799 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[8] + 1873313359 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[15] - 30611744 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[6] - 1560198380 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[13] + 1309151649 | 0, i = (i << 21 | i >>> 11) + s | 0, n += (s ^ (i | ~o)) + t[4] - 145523070 | 0, n = (n << 6 | n >>> 26) + i | 0, o += (i ^ (n | ~s)) + t[11] - 1120210379 | 0, o = (o << 10 | o >>> 22) + n | 0, s += (n ^ (o | ~i)) + t[2] + 718787259 | 0, s = (s << 15 | s >>> 17) + o | 0, i += (o ^ (s | ~n)) + t[9] - 343485551 | 0, i = (i << 21 | i >>> 11) + s | 0, e[0] = n + e[0] | 0, e[1] = i + e[1] | 0, e[2] = s + e[2] | 0, e[3] = o + e[3] | 0;
    }
    start() {
      return this._dataLength = 0, this._bufferLength = 0, this._state.set(U2.stateIdentity), this;
    }
    appendStr(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o;
      for (o = 0; o < e.length; o += 1) {
        if (s = e.charCodeAt(o), s < 128) t[i++] = s;
        else if (s < 2048) t[i++] = (s >>> 6) + 192, t[i++] = s & 63 | 128;
        else if (s < 55296 || s > 56319) t[i++] = (s >>> 12) + 224, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
        else {
          if (s = (s - 55296) * 1024 + (e.charCodeAt(++o) - 56320) + 65536, s > 1114111) throw new Error(
            "Unicode standard supports code points up to U+10FFFF"
          );
          t[i++] = (s >>> 18) + 240, t[i++] = s >>> 12 & 63 | 128, t[i++] = s >>> 6 & 63 | 128, t[i++] = s & 63 | 128;
        }
        i >= 64 && (this._dataLength += 64, U2._md5cycle(this._state, n), i -= 64, n[0] = n[16]);
      }
      return this._bufferLength = i, this;
    }
    appendAsciiStr(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
      for (; ; ) {
        for (s = Math.min(e.length - o, 64 - i); s--; ) t[i++] = e.charCodeAt(o++);
        if (i < 64) break;
        this._dataLength += 64, U2._md5cycle(this._state, n), i = 0;
      }
      return this._bufferLength = i, this;
    }
    appendByteArray(e) {
      let t = this._buffer8, n = this._buffer32, i = this._bufferLength, s, o = 0;
      for (; ; ) {
        for (s = Math.min(e.length - o, 64 - i); s--; ) t[i++] = e[o++];
        if (i < 64) break;
        this._dataLength += 64, U2._md5cycle(this._state, n), i = 0;
      }
      return this._bufferLength = i, this;
    }
    getState() {
      let e = this._state;
      return { buffer: String.fromCharCode.apply(null, Array.from(this._buffer8)), buflen: this._bufferLength, length: this._dataLength, state: [e[0], e[1], e[2], e[3]] };
    }
    setState(e) {
      let t = e.buffer, n = e.state, i = this._state, s;
      for (this._dataLength = e.length, this._bufferLength = e.buflen, i[0] = n[0], i[1] = n[1], i[2] = n[2], i[3] = n[3], s = 0; s < t.length; s += 1) this._buffer8[s] = t.charCodeAt(s);
    }
    end(e = false) {
      let t = this._bufferLength, n = this._buffer8, i = this._buffer32, s = (t >> 2) + 1;
      this._dataLength += t;
      let o = this._dataLength * 8;
      if (n[t] = 128, n[t + 1] = n[t + 2] = n[t + 3] = 0, i.set(U2.buffer32Identity.subarray(s), s), t > 55 && (U2._md5cycle(this._state, i), i.set(U2.buffer32Identity)), o <= 4294967295) i[14] = o;
      else {
        let u = o.toString(16).match(/(.*?)(.{0,8})$/);
        if (u === null) return;
        let c = parseInt(
          u[2],
          16
        ), l = parseInt(u[1], 16) || 0;
        i[14] = c, i[15] = l;
      }
      return U2._md5cycle(this._state, i), e ? this._state : U2._hex(
        this._state
      );
    }
  };
  a(U, "Md5"), E(U, "stateIdentity", new Int32Array([1732584193, -271733879, -1732584194, 271733878])), E(U, "buffer32Identity", new Int32Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0])), E(U, "hexChars", "0123456789abcdef"), E(U, "hexOut", []), E(U, "onePassHasher", new U());
  et = U;
});
var ar = {};
ne(ar, { createHash: /* @__PURE__ */ __name(() => gu, "createHash"), createHmac: /* @__PURE__ */ __name(() => wu, "createHmac"), randomBytes: /* @__PURE__ */ __name(() => mu, "randomBytes") });
function mu(r) {
  return crypto.getRandomValues(d.alloc(r));
}
__name(mu, "mu");
function gu(r) {
  if (r === "sha256") return { update: a(function(e) {
    return { digest: a(
      function() {
        return d.from(Xe(e));
      },
      "digest"
    ) };
  }, "update") };
  if (r === "md5") return { update: a(function(e) {
    return {
      digest: a(function() {
        return typeof e == "string" ? et.hashStr(e) : et.hashByteArray(e);
      }, "digest")
    };
  }, "update") };
  throw new Error(`Hash type '${r}' not supported`);
}
__name(gu, "gu");
function wu(r, e) {
  if (r !== "sha256") throw new Error(`Only sha256 is supported (requested: '${r}')`);
  return { update: a(function(t) {
    return { digest: a(
      function() {
        typeof e == "string" && (e = new TextEncoder().encode(e)), typeof t == "string" && (t = new TextEncoder().encode(
          t
        ));
        let n = e.length;
        if (n > 64) e = Xe(e);
        else if (n < 64) {
          let c = new Uint8Array(64);
          c.set(e), e = c;
        }
        let i = new Uint8Array(
          64
        ), s = new Uint8Array(64);
        for (let c = 0; c < 64; c++) i[c] = 54 ^ e[c], s[c] = 92 ^ e[c];
        let o = new Uint8Array(t.length + 64);
        o.set(i, 0), o.set(t, 64);
        let u = new Uint8Array(96);
        return u.set(s, 0), u.set(Xe(o), 64), d.from(Xe(u));
      },
      "digest"
    ) };
  }, "update") };
}
__name(wu, "wu");
var ur = z(() => {
  "use strict";
  p();
  Ji();
  Xi();
  a(mu, "randomBytes");
  a(gu, "createHash");
  a(wu, "createHmac");
});
var tt = I((Mf, cr) => {
  "use strict";
  p();
  cr.exports = {
    host: "localhost",
    user: m.platform === "win32" ? m.env.USERNAME : m.env.USER,
    database: void 0,
    password: null,
    connectionString: void 0,
    port: 5432,
    rows: 0,
    binary: false,
    max: 10,
    idleTimeoutMillis: 3e4,
    client_encoding: "",
    ssl: false,
    application_name: void 0,
    fallback_application_name: void 0,
    options: void 0,
    parseInputDatesAsUTC: false,
    statement_timeout: false,
    lock_timeout: false,
    idle_in_transaction_session_timeout: false,
    query_timeout: false,
    connect_timeout: 0,
    keepalives: 1,
    keepalives_idle: 0
  };
  var ke = Je(), bu = ke.getTypeParser(20, "text"), vu = ke.getTypeParser(
    1016,
    "text"
  );
  cr.exports.__defineSetter__("parseInt8", function(r) {
    ke.setTypeParser(20, "text", r ? ke.getTypeParser(
      23,
      "text"
    ) : bu), ke.setTypeParser(1016, "text", r ? ke.getTypeParser(1007, "text") : vu);
  });
});
var rt = I((Df, ts) => {
  "use strict";
  p();
  var xu = (ur(), D(ar)), Su = tt();
  function Eu(r) {
    var e = r.replace(
      /\\/g,
      "\\\\"
    ).replace(/"/g, '\\"');
    return '"' + e + '"';
  }
  __name(Eu, "Eu");
  a(Eu, "escapeElement");
  function es(r) {
    for (var e = "{", t = 0; t < r.length; t++) t > 0 && (e = e + ","), r[t] === null || typeof r[t] > "u" ? e = e + "NULL" : Array.isArray(r[t]) ? e = e + es(r[t]) : r[t] instanceof d ? e += "\\\\x" + r[t].toString("hex") : e += Eu(Et(r[t]));
    return e = e + "}", e;
  }
  __name(es, "es");
  a(es, "arrayString");
  var Et = a(function(r, e) {
    if (r == null) return null;
    if (r instanceof d) return r;
    if (ArrayBuffer.isView(r)) {
      var t = d.from(r.buffer, r.byteOffset, r.byteLength);
      return t.length === r.byteLength ? t : t.slice(r.byteOffset, r.byteOffset + r.byteLength);
    }
    return r instanceof Date ? Su.parseInputDatesAsUTC ? _u(r) : Cu(r) : Array.isArray(r) ? es(r) : typeof r == "object" ? Au(r, e) : r.toString();
  }, "prepareValue");
  function Au(r, e) {
    if (r && typeof r.toPostgres == "function") {
      if (e = e || [], e.indexOf(r) !== -1) throw new Error('circular reference detected while preparing "' + r + '" for query');
      return e.push(r), Et(r.toPostgres(Et), e);
    }
    return JSON.stringify(r);
  }
  __name(Au, "Au");
  a(Au, "prepareObject");
  function W(r, e) {
    for (r = "" + r; r.length < e; ) r = "0" + r;
    return r;
  }
  __name(W, "W");
  a(W, "pad");
  function Cu(r) {
    var e = -r.getTimezoneOffset(), t = r.getFullYear(), n = t < 1;
    n && (t = Math.abs(t) + 1);
    var i = W(t, 4) + "-" + W(r.getMonth() + 1, 2) + "-" + W(r.getDate(), 2) + "T" + W(
      r.getHours(),
      2
    ) + ":" + W(r.getMinutes(), 2) + ":" + W(r.getSeconds(), 2) + "." + W(r.getMilliseconds(), 3);
    return e < 0 ? (i += "-", e *= -1) : i += "+", i += W(Math.floor(e / 60), 2) + ":" + W(e % 60, 2), n && (i += " BC"), i;
  }
  __name(Cu, "Cu");
  a(Cu, "dateToString");
  function _u(r) {
    var e = r.getUTCFullYear(), t = e < 1;
    t && (e = Math.abs(e) + 1);
    var n = W(e, 4) + "-" + W(r.getUTCMonth() + 1, 2) + "-" + W(r.getUTCDate(), 2) + "T" + W(r.getUTCHours(), 2) + ":" + W(r.getUTCMinutes(), 2) + ":" + W(r.getUTCSeconds(), 2) + "." + W(
      r.getUTCMilliseconds(),
      3
    );
    return n += "+00:00", t && (n += " BC"), n;
  }
  __name(_u, "_u");
  a(_u, "dateToStringUTC");
  function Tu(r, e, t) {
    return r = typeof r == "string" ? { text: r } : r, e && (typeof e == "function" ? r.callback = e : r.values = e), t && (r.callback = t), r;
  }
  __name(Tu, "Tu");
  a(Tu, "normalizeQueryConfig");
  var lr = a(function(r) {
    return xu.createHash("md5").update(r, "utf-8").digest("hex");
  }, "md5"), Iu = a(
    function(r, e, t) {
      var n = lr(e + r), i = lr(d.concat([d.from(n), t]));
      return "md5" + i;
    },
    "postgresMd5PasswordHash"
  );
  ts.exports = {
    prepareValue: a(function(e) {
      return Et(e);
    }, "prepareValueWrapper"),
    normalizeQueryConfig: Tu,
    postgresMd5PasswordHash: Iu,
    md5: lr
  };
});
var nt = {};
ne(nt, { default: /* @__PURE__ */ __name(() => Lu, "default") });
var Lu;
var it = z(() => {
  "use strict";
  p();
  Lu = {};
});
var hs = I((zf, fs) => {
  "use strict";
  p();
  var hr = (ur(), D(ar));
  function Fu(r) {
    if (r.indexOf("SCRAM-SHA-256") === -1) throw new Error("SASL: Only mechanism SCRAM-SHA-256 is currently supported");
    let e = hr.randomBytes(
      18
    ).toString("base64");
    return { mechanism: "SCRAM-SHA-256", clientNonce: e, response: "n,,n=*,r=" + e, message: "SASLInitialResponse" };
  }
  __name(Fu, "Fu");
  a(Fu, "startSession");
  function ku(r, e, t) {
    if (r.message !== "SASLInitialResponse") throw new Error(
      "SASL: Last message was not SASLInitialResponse"
    );
    if (typeof e != "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: client password must be a string");
    if (typeof t != "string") throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: serverData must be a string");
    let n = Du(t);
    if (n.nonce.startsWith(r.clientNonce)) {
      if (n.nonce.length === r.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    var i = d.from(n.salt, "base64"), s = Qu(e, i, n.iteration), o = Me(s, "Client Key"), u = qu(
      o
    ), c = "n=*,r=" + r.clientNonce, l = "r=" + n.nonce + ",s=" + n.salt + ",i=" + n.iteration, f = "c=biws,r=" + n.nonce, y = c + "," + l + "," + f, g = Me(u, y), A = ls(o, g), C = A.toString("base64"), Q = Me(s, "Server Key"), P = Me(Q, y);
    r.message = "SASLResponse", r.serverSignature = P.toString("base64"), r.response = f + ",p=" + C;
  }
  __name(ku, "ku");
  a(ku, "continueSession");
  function Mu(r, e) {
    if (r.message !== "SASLResponse") throw new Error("SASL: Last message was not SASLResponse");
    if (typeof e != "string") throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: serverData must be a string");
    let { serverSignature: t } = Ou(
      e
    );
    if (t !== r.serverSignature) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature does not match");
  }
  __name(Mu, "Mu");
  a(Mu, "finalizeSession");
  function Uu(r) {
    if (typeof r != "string") throw new TypeError("SASL: text must be a string");
    return r.split("").map((e, t) => r.charCodeAt(t)).every((e) => e >= 33 && e <= 43 || e >= 45 && e <= 126);
  }
  __name(Uu, "Uu");
  a(Uu, "isPrintableChars");
  function us(r) {
    return /^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(r);
  }
  __name(us, "us");
  a(us, "isBase64");
  function cs(r) {
    if (typeof r != "string") throw new TypeError("SASL: attribute pairs text must be a string");
    return new Map(r.split(",").map((e) => {
      if (!/^.=/.test(e)) throw new Error("SASL: Invalid attribute pair entry");
      let t = e[0], n = e.substring(2);
      return [t, n];
    }));
  }
  __name(cs, "cs");
  a(cs, "parseAttributePairs");
  function Du(r) {
    let e = cs(r), t = e.get("r");
    if (t) {
      if (!Uu(t)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce must only contain printable characters");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing");
    let n = e.get("s");
    if (n) {
      if (!us(n)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt must be base64");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing");
    let i = e.get("i");
    if (i) {
      if (!/^[1-9][0-9]*$/.test(i)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: invalid iteration count");
    } else throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: iteration missing");
    let s = parseInt(i, 10);
    return { nonce: t, salt: n, iteration: s };
  }
  __name(Du, "Du");
  a(Du, "parseServerFirstMessage");
  function Ou(r) {
    let t = cs(r).get("v");
    if (t) {
      if (!us(t)) throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature must be base64");
    } else throw new Error("SASL: SCRAM-SERVER-FINAL-MESSAGE: server signature is missing");
    return { serverSignature: t };
  }
  __name(Ou, "Ou");
  a(Ou, "parseServerFinalMessage");
  function ls(r, e) {
    if (!d.isBuffer(r)) throw new TypeError("first argument must be a Buffer");
    if (!d.isBuffer(e)) throw new TypeError(
      "second argument must be a Buffer"
    );
    if (r.length !== e.length) throw new Error("Buffer lengths must match");
    if (r.length === 0) throw new Error("Buffers cannot be empty");
    return d.from(r.map((t, n) => r[n] ^ e[n]));
  }
  __name(ls, "ls");
  a(ls, "xorBuffers");
  function qu(r) {
    return hr.createHash("sha256").update(r).digest();
  }
  __name(qu, "qu");
  a(qu, "sha256");
  function Me(r, e) {
    return hr.createHmac("sha256", r).update(e).digest();
  }
  __name(Me, "Me");
  a(Me, "hmacSha256");
  function Qu(r, e, t) {
    for (var n = Me(
      r,
      d.concat([e, d.from([0, 0, 0, 1])])
    ), i = n, s = 0; s < t - 1; s++) n = Me(r, n), i = ls(i, n);
    return i;
  }
  __name(Qu, "Qu");
  a(Qu, "Hi");
  fs.exports = { startSession: Fu, continueSession: ku, finalizeSession: Mu };
});
var pr = {};
ne(pr, { join: /* @__PURE__ */ __name(() => Nu, "join") });
function Nu(...r) {
  return r.join("/");
}
__name(Nu, "Nu");
var dr = z(() => {
  "use strict";
  p();
  a(
    Nu,
    "join"
  );
});
var yr = {};
ne(yr, { stat: /* @__PURE__ */ __name(() => ju, "stat") });
function ju(r, e) {
  e(new Error("No filesystem"));
}
__name(ju, "ju");
var mr = z(() => {
  "use strict";
  p();
  a(ju, "stat");
});
var gr = {};
ne(gr, { default: /* @__PURE__ */ __name(() => Wu, "default") });
var Wu;
var wr = z(() => {
  "use strict";
  p();
  Wu = {};
});
var ps = {};
ne(ps, { StringDecoder: /* @__PURE__ */ __name(() => br, "StringDecoder") });
var vr;
var br;
var ds = z(() => {
  "use strict";
  p();
  vr = class vr {
    static {
      __name(this, "vr");
    }
    constructor(e) {
      E(this, "td");
      this.td = new TextDecoder(e);
    }
    write(e) {
      return this.td.decode(e, { stream: true });
    }
    end(e) {
      return this.td.decode(e);
    }
  };
  a(vr, "StringDecoder");
  br = vr;
});
var ws = I((ih, gs) => {
  "use strict";
  p();
  var { Transform: Hu } = (wr(), D(gr)), { StringDecoder: $u } = (ds(), D(ps)), be = Symbol(
    "last"
  ), Ct = Symbol("decoder");
  function Gu(r, e, t) {
    let n;
    if (this.overflow) {
      if (n = this[Ct].write(r).split(
        this.matcher
      ), n.length === 1) return t();
      n.shift(), this.overflow = false;
    } else this[be] += this[Ct].write(r), n = this[be].split(this.matcher);
    this[be] = n.pop();
    for (let i = 0; i < n.length; i++) try {
      ms(this, this.mapper(n[i]));
    } catch (s) {
      return t(s);
    }
    if (this.overflow = this[be].length > this.maxLength, this.overflow && !this.skipOverflow) {
      t(new Error(
        "maximum buffer reached"
      ));
      return;
    }
    t();
  }
  __name(Gu, "Gu");
  a(Gu, "transform");
  function Vu(r) {
    if (this[be] += this[Ct].end(), this[be])
      try {
        ms(this, this.mapper(this[be]));
      } catch (e) {
        return r(e);
      }
    r();
  }
  __name(Vu, "Vu");
  a(Vu, "flush");
  function ms(r, e) {
    e !== void 0 && r.push(e);
  }
  __name(ms, "ms");
  a(ms, "push");
  function ys(r) {
    return r;
  }
  __name(ys, "ys");
  a(ys, "noop");
  function zu(r, e, t) {
    switch (r = r || /\r?\n/, e = e || ys, t = t || {}, arguments.length) {
      case 1:
        typeof r == "function" ? (e = r, r = /\r?\n/) : typeof r == "object" && !(r instanceof RegExp) && !r[Symbol.split] && (t = r, r = /\r?\n/);
        break;
      case 2:
        typeof r == "function" ? (t = e, e = r, r = /\r?\n/) : typeof e == "object" && (t = e, e = ys);
    }
    t = Object.assign({}, t), t.autoDestroy = true, t.transform = Gu, t.flush = Vu, t.readableObjectMode = true;
    let n = new Hu(t);
    return n[be] = "", n[Ct] = new $u("utf8"), n.matcher = r, n.mapper = e, n.maxLength = t.maxLength, n.skipOverflow = t.skipOverflow || false, n.overflow = false, n._destroy = function(i, s) {
      this._writableState.errorEmitted = false, s(i);
    }, n;
  }
  __name(zu, "zu");
  a(zu, "split");
  gs.exports = zu;
});
var xs = I((ah, de) => {
  "use strict";
  p();
  var bs = (dr(), D(pr)), Ku = (wr(), D(gr)).Stream, Yu = ws(), vs = (it(), D(nt)), Zu = 5432, _t = m.platform === "win32", st = m.stderr, Ju = 56, Xu = 7, ec = 61440, tc = 32768;
  function rc(r) {
    return (r & ec) == tc;
  }
  __name(rc, "rc");
  a(rc, "isRegFile");
  var Ue = ["host", "port", "database", "user", "password"], xr = Ue.length, nc = Ue[xr - 1];
  function Sr() {
    var r = st instanceof Ku && st.writable === true;
    if (r) {
      var e = Array.prototype.slice.call(arguments).concat(`
`);
      st.write(vs.format.apply(vs, e));
    }
  }
  __name(Sr, "Sr");
  a(Sr, "warn");
  Object.defineProperty(de.exports, "isWin", { get: a(function() {
    return _t;
  }, "get"), set: a(function(r) {
    _t = r;
  }, "set") });
  de.exports.warnTo = function(r) {
    var e = st;
    return st = r, e;
  };
  de.exports.getFileName = function(r) {
    var e = r || m.env, t = e.PGPASSFILE || (_t ? bs.join(e.APPDATA || "./", "postgresql", "pgpass.conf") : bs.join(e.HOME || "./", ".pgpass"));
    return t;
  };
  de.exports.usePgPass = function(r, e) {
    return Object.prototype.hasOwnProperty.call(m.env, "PGPASSWORD") ? false : _t ? true : (e = e || "<unkn>", rc(r.mode) ? r.mode & (Ju | Xu) ? (Sr('WARNING: password file "%s" has group or world access; permissions should be u=rw (0600) or less', e), false) : true : (Sr('WARNING: password file "%s" is not a plain file', e), false));
  };
  var ic = de.exports.match = function(r, e) {
    return Ue.slice(0, -1).reduce(function(t, n, i) {
      return i == 1 && Number(r[n] || Zu) === Number(
        e[n]
      ) ? t && true : t && (e[n] === "*" || e[n] === r[n]);
    }, true);
  };
  de.exports.getPassword = function(r, e, t) {
    var n, i = e.pipe(
      Yu()
    );
    function s(c) {
      var l = sc(c);
      l && oc(l) && ic(r, l) && (n = l[nc], i.end());
    }
    __name(s, "s");
    a(s, "onLine");
    var o = a(function() {
      e.destroy(), t(n);
    }, "onEnd"), u = a(function(c) {
      e.destroy(), Sr("WARNING: error on reading file: %s", c), t(
        void 0
      );
    }, "onErr");
    e.on("error", u), i.on("data", s).on("end", o).on("error", u);
  };
  var sc = de.exports.parseLine = function(r) {
    if (r.length < 11 || r.match(/^\s+#/)) return null;
    for (var e = "", t = "", n = 0, i = 0, s = 0, o = {}, u = false, c = a(
      function(f, y, g) {
        var A = r.substring(y, g);
        Object.hasOwnProperty.call(m.env, "PGPASS_NO_DEESCAPE") || (A = A.replace(/\\([:\\])/g, "$1")), o[Ue[f]] = A;
      },
      "addToObj"
    ), l = 0; l < r.length - 1; l += 1) {
      if (e = r.charAt(l + 1), t = r.charAt(
        l
      ), u = n == xr - 1, u) {
        c(n, i);
        break;
      }
      l >= 0 && e == ":" && t !== "\\" && (c(n, i, l + 1), i = l + 2, n += 1);
    }
    return o = Object.keys(o).length === xr ? o : null, o;
  }, oc = de.exports.isValidEntry = function(r) {
    for (var e = { 0: function(o) {
      return o.length > 0;
    }, 1: function(o) {
      return o === "*" ? true : (o = Number(o), isFinite(o) && o > 0 && o < 9007199254740992 && Math.floor(o) === o);
    }, 2: function(o) {
      return o.length > 0;
    }, 3: function(o) {
      return o.length > 0;
    }, 4: function(o) {
      return o.length > 0;
    } }, t = 0; t < Ue.length; t += 1) {
      var n = e[t], i = r[Ue[t]] || "", s = n(i);
      if (!s) return false;
    }
    return true;
  };
});
var Es = I((fh, Er) => {
  "use strict";
  p();
  var lh = (dr(), D(pr)), Ss = (mr(), D(yr)), Tt = xs();
  Er.exports = function(r, e) {
    var t = Tt.getFileName();
    Ss.stat(t, function(n, i) {
      if (n || !Tt.usePgPass(i, t)) return e(void 0);
      var s = Ss.createReadStream(
        t
      );
      Tt.getPassword(r, s, e);
    });
  };
  Er.exports.warnTo = Tt.warnTo;
});
var As = {};
ne(As, { default: /* @__PURE__ */ __name(() => ac, "default") });
var ac;
var Cs = z(() => {
  "use strict";
  p();
  ac = {};
});
var Ts = I((dh, _s) => {
  "use strict";
  p();
  var uc = (zt(), D(mi)), Ar = (mr(), D(yr));
  function Cr(r) {
    if (r.charAt(0) === "/") {
      var t = r.split(" ");
      return { host: t[0], database: t[1] };
    }
    var e = uc.parse(/ |%[^a-f0-9]|%[a-f0-9][^a-f0-9]/i.test(r) ? encodeURI(r).replace(/\%25(\d\d)/g, "%$1") : r, true), t = e.query;
    for (var n in t) Array.isArray(t[n]) && (t[n] = t[n][t[n].length - 1]);
    var i = (e.auth || ":").split(":");
    if (t.user = i[0], t.password = i.splice(1).join(
      ":"
    ), t.port = e.port, e.protocol == "socket:") return t.host = decodeURI(e.pathname), t.database = e.query.db, t.client_encoding = e.query.encoding, t;
    t.host || (t.host = e.hostname);
    var s = e.pathname;
    if (!t.host && s && /^%2f/i.test(s)) {
      var o = s.split("/");
      t.host = decodeURIComponent(o[0]), s = o.splice(1).join("/");
    }
    switch (s && s.charAt(
      0
    ) === "/" && (s = s.slice(1) || null), t.database = s && decodeURI(s), (t.ssl === "true" || t.ssl === "1") && (t.ssl = true), t.ssl === "0" && (t.ssl = false), (t.sslcert || t.sslkey || t.sslrootcert || t.sslmode) && (t.ssl = {}), t.sslcert && (t.ssl.cert = Ar.readFileSync(t.sslcert).toString()), t.sslkey && (t.ssl.key = Ar.readFileSync(t.sslkey).toString()), t.sslrootcert && (t.ssl.ca = Ar.readFileSync(t.sslrootcert).toString()), t.sslmode) {
      case "disable": {
        t.ssl = false;
        break;
      }
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        break;
      case "no-verify": {
        t.ssl.rejectUnauthorized = false;
        break;
      }
    }
    return t;
  }
  __name(Cr, "Cr");
  a(Cr, "parse");
  _s.exports = Cr;
  Cr.parse = Cr;
});
var It = I((gh, Rs) => {
  "use strict";
  p();
  var cc = (Cs(), D(As)), Ps = tt(), Is = Ts().parse, G = a(function(r, e, t) {
    return t === void 0 ? t = m.env["PG" + r.toUpperCase()] : t === false || (t = m.env[t]), e[r] || t || Ps[r];
  }, "val"), lc = a(function() {
    switch (m.env.PGSSLMODE) {
      case "disable":
        return false;
      case "prefer":
      case "require":
      case "verify-ca":
      case "verify-full":
        return true;
      case "no-verify":
        return { rejectUnauthorized: false };
    }
    return Ps.ssl;
  }, "readSSLConfigFromEnvironment"), De = a(function(r) {
    return "'" + ("" + r).replace(/\\/g, "\\\\").replace(/'/g, "\\'") + "'";
  }, "quoteParamValue"), re = a(function(r, e, t) {
    var n = e[t];
    n != null && r.push(t + "=" + De(n));
  }, "add"), Tr = class Tr {
    static {
      __name(this, "Tr");
    }
    constructor(e) {
      e = typeof e == "string" ? Is(e) : e || {}, e.connectionString && (e = Object.assign({}, e, Is(e.connectionString))), this.user = G("user", e), this.database = G("database", e), this.database === void 0 && (this.database = this.user), this.port = parseInt(G("port", e), 10), this.host = G("host", e), Object.defineProperty(this, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: G("password", e)
      }), this.binary = G("binary", e), this.options = G("options", e), this.ssl = typeof e.ssl > "u" ? lc() : e.ssl, typeof this.ssl == "string" && this.ssl === "true" && (this.ssl = true), this.ssl === "no-verify" && (this.ssl = { rejectUnauthorized: false }), this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this.client_encoding = G("client_encoding", e), this.replication = G("replication", e), this.isDomainSocket = !(this.host || "").indexOf("/"), this.application_name = G("application_name", e, "PGAPPNAME"), this.fallback_application_name = G("fallback_application_name", e, false), this.statement_timeout = G("statement_timeout", e, false), this.lock_timeout = G("lock_timeout", e, false), this.idle_in_transaction_session_timeout = G("idle_in_transaction_session_timeout", e, false), this.query_timeout = G("query_timeout", e, false), e.connectionTimeoutMillis === void 0 ? this.connect_timeout = m.env.PGCONNECT_TIMEOUT || 0 : this.connect_timeout = Math.floor(e.connectionTimeoutMillis / 1e3), e.keepAlive === false ? this.keepalives = 0 : e.keepAlive === true && (this.keepalives = 1), typeof e.keepAliveInitialDelayMillis == "number" && (this.keepalives_idle = Math.floor(e.keepAliveInitialDelayMillis / 1e3));
    }
    getLibpqConnectionString(e) {
      var t = [];
      re(t, this, "user"), re(t, this, "password"), re(t, this, "port"), re(t, this, "application_name"), re(
        t,
        this,
        "fallback_application_name"
      ), re(t, this, "connect_timeout"), re(t, this, "options");
      var n = typeof this.ssl == "object" ? this.ssl : this.ssl ? { sslmode: this.ssl } : {};
      if (re(t, n, "sslmode"), re(t, n, "sslca"), re(t, n, "sslkey"), re(t, n, "sslcert"), re(t, n, "sslrootcert"), this.database && t.push("dbname=" + De(this.database)), this.replication && t.push("replication=" + De(this.replication)), this.host && t.push("host=" + De(this.host)), this.isDomainSocket) return e(null, t.join(" "));
      this.client_encoding && t.push("client_encoding=" + De(this.client_encoding)), cc.lookup(this.host, function(i, s) {
        return i ? e(i, null) : (t.push("hostaddr=" + De(s)), e(null, t.join(" ")));
      });
    }
  };
  a(Tr, "ConnectionParameters");
  var _r = Tr;
  Rs.exports = _r;
});
var Fs = I((vh, Ls) => {
  "use strict";
  p();
  var fc = Je(), Bs = /^([A-Za-z]+)(?: (\d+))?(?: (\d+))?/, Pr = class Pr {
    static {
      __name(this, "Pr");
    }
    constructor(e, t) {
      this.command = null, this.rowCount = null, this.oid = null, this.rows = [], this.fields = [], this._parsers = void 0, this._types = t, this.RowCtor = null, this.rowAsArray = e === "array", this.rowAsArray && (this.parseRow = this._parseRowAsArray);
    }
    addCommandComplete(e) {
      var t;
      e.text ? t = Bs.exec(e.text) : t = Bs.exec(e.command), t && (this.command = t[1], t[3] ? (this.oid = parseInt(
        t[2],
        10
      ), this.rowCount = parseInt(t[3], 10)) : t[2] && (this.rowCount = parseInt(t[2], 10)));
    }
    _parseRowAsArray(e) {
      for (var t = new Array(
        e.length
      ), n = 0, i = e.length; n < i; n++) {
        var s = e[n];
        s !== null ? t[n] = this._parsers[n](s) : t[n] = null;
      }
      return t;
    }
    parseRow(e) {
      for (var t = {}, n = 0, i = e.length; n < i; n++) {
        var s = e[n], o = this.fields[n].name;
        s !== null ? t[o] = this._parsers[n](
          s
        ) : t[o] = null;
      }
      return t;
    }
    addRow(e) {
      this.rows.push(e);
    }
    addFields(e) {
      this.fields = e, this.fields.length && (this._parsers = new Array(e.length));
      for (var t = 0; t < e.length; t++) {
        var n = e[t];
        this._types ? this._parsers[t] = this._types.getTypeParser(n.dataTypeID, n.format || "text") : this._parsers[t] = fc.getTypeParser(n.dataTypeID, n.format || "text");
      }
    }
  };
  a(Pr, "Result");
  var Ir = Pr;
  Ls.exports = Ir;
});
var Ds = I((Eh, Us) => {
  "use strict";
  p();
  var { EventEmitter: hc } = me(), ks = Fs(), Ms = rt(), Br = class Br extends hc {
    static {
      __name(this, "Br");
    }
    constructor(e, t, n) {
      super(), e = Ms.normalizeQueryConfig(e, t, n), this.text = e.text, this.values = e.values, this.rows = e.rows, this.types = e.types, this.name = e.name, this.binary = e.binary, this.portal = e.portal || "", this.callback = e.callback, this._rowMode = e.rowMode, m.domain && e.callback && (this.callback = m.domain.bind(e.callback)), this._result = new ks(this._rowMode, this.types), this._results = this._result, this.isPreparedStatement = false, this._canceledDueToError = false, this._promise = null;
    }
    requiresPreparation() {
      return this.name || this.rows ? true : !this.text || !this.values ? false : this.values.length > 0;
    }
    _checkForMultirow() {
      this._result.command && (Array.isArray(this._results) || (this._results = [this._result]), this._result = new ks(this._rowMode, this.types), this._results.push(this._result));
    }
    handleRowDescription(e) {
      this._checkForMultirow(), this._result.addFields(e.fields), this._accumulateRows = this.callback || !this.listeners("row").length;
    }
    handleDataRow(e) {
      let t;
      if (!this._canceledDueToError) {
        try {
          t = this._result.parseRow(
            e.fields
          );
        } catch (n) {
          this._canceledDueToError = n;
          return;
        }
        this.emit("row", t, this._result), this._accumulateRows && this._result.addRow(t);
      }
    }
    handleCommandComplete(e, t) {
      this._checkForMultirow(), this._result.addCommandComplete(
        e
      ), this.rows && t.sync();
    }
    handleEmptyQuery(e) {
      this.rows && e.sync();
    }
    handleError(e, t) {
      if (this._canceledDueToError && (e = this._canceledDueToError, this._canceledDueToError = false), this.callback) return this.callback(e);
      this.emit("error", e);
    }
    handleReadyForQuery(e) {
      if (this._canceledDueToError) return this.handleError(
        this._canceledDueToError,
        e
      );
      if (this.callback) try {
        this.callback(null, this._results);
      } catch (t) {
        m.nextTick(() => {
          throw t;
        });
      }
      this.emit(
        "end",
        this._results
      );
    }
    submit(e) {
      if (typeof this.text != "string" && typeof this.name != "string") return new Error(
        "A query must have either text or a name. Supplying neither is unsupported."
      );
      let t = e.parsedStatements[this.name];
      return this.text && t && this.text !== t ? new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`) : this.values && !Array.isArray(this.values) ? new Error("Query values must be an array") : (this.requiresPreparation() ? this.prepare(e) : e.query(this.text), null);
    }
    hasBeenParsed(e) {
      return this.name && e.parsedStatements[this.name];
    }
    handlePortalSuspended(e) {
      this._getRows(e, this.rows);
    }
    _getRows(e, t) {
      e.execute({ portal: this.portal, rows: t }), t ? e.flush() : e.sync();
    }
    prepare(e) {
      this.isPreparedStatement = true, this.hasBeenParsed(e) || e.parse({ text: this.text, name: this.name, types: this.types });
      try {
        e.bind({ portal: this.portal, statement: this.name, values: this.values, binary: this.binary, valueMapper: Ms.prepareValue });
      } catch (t) {
        this.handleError(t, e);
        return;
      }
      e.describe({ type: "P", name: this.portal || "" }), this._getRows(e, this.rows);
    }
    handleCopyInResponse(e) {
      e.sendCopyFail("No source stream defined");
    }
    handleCopyData(e, t) {
    }
  };
  a(Br, "Query");
  var Rr = Br;
  Us.exports = Rr;
});
var an = I((T) => {
  "use strict";
  p();
  Object.defineProperty(T, "__esModule", { value: true });
  T.NoticeMessage = T.DataRowMessage = T.CommandCompleteMessage = T.ReadyForQueryMessage = T.NotificationResponseMessage = T.BackendKeyDataMessage = T.AuthenticationMD5Password = T.ParameterStatusMessage = T.ParameterDescriptionMessage = T.RowDescriptionMessage = T.Field = T.CopyResponse = T.CopyDataMessage = T.DatabaseError = T.copyDone = T.emptyQuery = T.replicationStart = T.portalSuspended = T.noData = T.closeComplete = T.bindComplete = T.parseComplete = void 0;
  T.parseComplete = { name: "parseComplete", length: 5 };
  T.bindComplete = { name: "bindComplete", length: 5 };
  T.closeComplete = { name: "closeComplete", length: 5 };
  T.noData = { name: "noData", length: 5 };
  T.portalSuspended = { name: "portalSuspended", length: 5 };
  T.replicationStart = { name: "replicationStart", length: 4 };
  T.emptyQuery = { name: "emptyQuery", length: 4 };
  T.copyDone = { name: "copyDone", length: 4 };
  var Gr = class Gr extends Error {
    static {
      __name(this, "Gr");
    }
    constructor(e, t, n) {
      super(e), this.length = t, this.name = n;
    }
  };
  a(Gr, "DatabaseError");
  var Lr = Gr;
  T.DatabaseError = Lr;
  var Vr = class Vr {
    static {
      __name(this, "Vr");
    }
    constructor(e, t) {
      this.length = e, this.chunk = t, this.name = "copyData";
    }
  };
  a(Vr, "CopyDataMessage");
  var Fr = Vr;
  T.CopyDataMessage = Fr;
  var zr = class zr {
    static {
      __name(this, "zr");
    }
    constructor(e, t, n, i) {
      this.length = e, this.name = t, this.binary = n, this.columnTypes = new Array(i);
    }
  };
  a(zr, "CopyResponse");
  var kr = zr;
  T.CopyResponse = kr;
  var Kr = class Kr {
    static {
      __name(this, "Kr");
    }
    constructor(e, t, n, i, s, o, u) {
      this.name = e, this.tableID = t, this.columnID = n, this.dataTypeID = i, this.dataTypeSize = s, this.dataTypeModifier = o, this.format = u;
    }
  };
  a(Kr, "Field");
  var Mr = Kr;
  T.Field = Mr;
  var Yr = class Yr {
    static {
      __name(this, "Yr");
    }
    constructor(e, t) {
      this.length = e, this.fieldCount = t, this.name = "rowDescription", this.fields = new Array(this.fieldCount);
    }
  };
  a(Yr, "RowDescriptionMessage");
  var Ur = Yr;
  T.RowDescriptionMessage = Ur;
  var Zr = class Zr {
    static {
      __name(this, "Zr");
    }
    constructor(e, t) {
      this.length = e, this.parameterCount = t, this.name = "parameterDescription", this.dataTypeIDs = new Array(this.parameterCount);
    }
  };
  a(Zr, "ParameterDescriptionMessage");
  var Dr = Zr;
  T.ParameterDescriptionMessage = Dr;
  var Jr = class Jr {
    static {
      __name(this, "Jr");
    }
    constructor(e, t, n) {
      this.length = e, this.parameterName = t, this.parameterValue = n, this.name = "parameterStatus";
    }
  };
  a(Jr, "ParameterStatusMessage");
  var Or = Jr;
  T.ParameterStatusMessage = Or;
  var Xr = class Xr {
    static {
      __name(this, "Xr");
    }
    constructor(e, t) {
      this.length = e, this.salt = t, this.name = "authenticationMD5Password";
    }
  };
  a(Xr, "AuthenticationMD5Password");
  var qr = Xr;
  T.AuthenticationMD5Password = qr;
  var en = class en {
    static {
      __name(this, "en");
    }
    constructor(e, t, n) {
      this.length = e, this.processID = t, this.secretKey = n, this.name = "backendKeyData";
    }
  };
  a(en, "BackendKeyDataMessage");
  var Qr = en;
  T.BackendKeyDataMessage = Qr;
  var tn = class tn {
    static {
      __name(this, "tn");
    }
    constructor(e, t, n, i) {
      this.length = e, this.processId = t, this.channel = n, this.payload = i, this.name = "notification";
    }
  };
  a(tn, "NotificationResponseMessage");
  var Nr = tn;
  T.NotificationResponseMessage = Nr;
  var rn = class rn {
    static {
      __name(this, "rn");
    }
    constructor(e, t) {
      this.length = e, this.status = t, this.name = "readyForQuery";
    }
  };
  a(rn, "ReadyForQueryMessage");
  var jr = rn;
  T.ReadyForQueryMessage = jr;
  var nn = class nn {
    static {
      __name(this, "nn");
    }
    constructor(e, t) {
      this.length = e, this.text = t, this.name = "commandComplete";
    }
  };
  a(nn, "CommandCompleteMessage");
  var Wr = nn;
  T.CommandCompleteMessage = Wr;
  var sn = class sn {
    static {
      __name(this, "sn");
    }
    constructor(e, t) {
      this.length = e, this.fields = t, this.name = "dataRow", this.fieldCount = t.length;
    }
  };
  a(sn, "DataRowMessage");
  var Hr = sn;
  T.DataRowMessage = Hr;
  var on2 = class on {
    static {
      __name(this, "on");
    }
    constructor(e, t) {
      this.length = e, this.message = t, this.name = "notice";
    }
  };
  a(on2, "NoticeMessage");
  var $r = on2;
  T.NoticeMessage = $r;
});
var Os = I((Pt) => {
  "use strict";
  p();
  Object.defineProperty(Pt, "__esModule", { value: true });
  Pt.Writer = void 0;
  var cn = class cn {
    static {
      __name(this, "cn");
    }
    constructor(e = 256) {
      this.size = e, this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(e);
    }
    ensure(e) {
      var t = this.buffer.length - this.offset;
      if (t < e) {
        var n = this.buffer, i = n.length + (n.length >> 1) + e;
        this.buffer = d.allocUnsafe(i), n.copy(this.buffer);
      }
    }
    addInt32(e) {
      return this.ensure(4), this.buffer[this.offset++] = e >>> 24 & 255, this.buffer[this.offset++] = e >>> 16 & 255, this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
    }
    addInt16(e) {
      return this.ensure(2), this.buffer[this.offset++] = e >>> 8 & 255, this.buffer[this.offset++] = e >>> 0 & 255, this;
    }
    addCString(e) {
      if (!e) this.ensure(1);
      else {
        var t = d.byteLength(e);
        this.ensure(t + 1), this.buffer.write(e, this.offset, "utf-8"), this.offset += t;
      }
      return this.buffer[this.offset++] = 0, this;
    }
    addString(e = "") {
      var t = d.byteLength(e);
      return this.ensure(t), this.buffer.write(e, this.offset), this.offset += t, this;
    }
    add(e) {
      return this.ensure(
        e.length
      ), e.copy(this.buffer, this.offset), this.offset += e.length, this;
    }
    join(e) {
      if (e) {
        this.buffer[this.headerPosition] = e;
        let t = this.offset - (this.headerPosition + 1);
        this.buffer.writeInt32BE(t, this.headerPosition + 1);
      }
      return this.buffer.slice(e ? 0 : 5, this.offset);
    }
    flush(e) {
      var t = this.join(e);
      return this.offset = 5, this.headerPosition = 0, this.buffer = d.allocUnsafe(this.size), t;
    }
  };
  a(cn, "Writer");
  var un = cn;
  Pt.Writer = un;
});
var Qs = I((Bt) => {
  "use strict";
  p();
  Object.defineProperty(Bt, "__esModule", { value: true });
  Bt.serialize = void 0;
  var ln = Os(), k = new ln.Writer(), pc = a((r) => {
    k.addInt16(3).addInt16(0);
    for (let n of Object.keys(r)) k.addCString(
      n
    ).addCString(r[n]);
    k.addCString("client_encoding").addCString("UTF8");
    var e = k.addCString("").flush(), t = e.length + 4;
    return new ln.Writer().addInt32(t).add(e).flush();
  }, "startup"), dc = a(() => {
    let r = d.allocUnsafe(
      8
    );
    return r.writeInt32BE(8, 0), r.writeInt32BE(80877103, 4), r;
  }, "requestSsl"), yc = a((r) => k.addCString(r).flush(
    112
  ), "password"), mc = a(function(r, e) {
    return k.addCString(r).addInt32(d.byteLength(e)).addString(e), k.flush(112);
  }, "sendSASLInitialResponseMessage"), gc = a(function(r) {
    return k.addString(r).flush(112);
  }, "sendSCRAMClientFinalMessage"), wc = a((r) => k.addCString(r).flush(81), "query"), qs = [], bc = a((r) => {
    let e = r.name || "";
    e.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", e, e.length), console.error("This can cause conflicts and silent errors executing queries"));
    let t = r.types || qs;
    for (var n = t.length, i = k.addCString(e).addCString(r.text).addInt16(
      n
    ), s = 0; s < n; s++) i.addInt32(t[s]);
    return k.flush(80);
  }, "parse"), Oe = new ln.Writer(), vc = a(function(r, e) {
    for (let t = 0; t < r.length; t++) {
      let n = e ? e(r[t], t) : r[t];
      n == null ? (k.addInt16(0), Oe.addInt32(-1)) : n instanceof d ? (k.addInt16(
        1
      ), Oe.addInt32(n.length), Oe.add(n)) : (k.addInt16(0), Oe.addInt32(d.byteLength(n)), Oe.addString(n));
    }
  }, "writeValues"), xc = a((r = {}) => {
    let e = r.portal || "", t = r.statement || "", n = r.binary || false, i = r.values || qs, s = i.length;
    return k.addCString(e).addCString(t), k.addInt16(s), vc(i, r.valueMapper), k.addInt16(s), k.add(Oe.flush()), k.addInt16(n ? 1 : 0), k.flush(66);
  }, "bind"), Sc = d.from([69, 0, 0, 0, 9, 0, 0, 0, 0, 0]), Ec = a((r) => {
    if (!r || !r.portal && !r.rows) return Sc;
    let e = r.portal || "", t = r.rows || 0, n = d.byteLength(e), i = 4 + n + 1 + 4, s = d.allocUnsafe(1 + i);
    return s[0] = 69, s.writeInt32BE(i, 1), s.write(e, 5, "utf-8"), s[n + 5] = 0, s.writeUInt32BE(t, s.length - 4), s;
  }, "execute"), Ac = a(
    (r, e) => {
      let t = d.allocUnsafe(16);
      return t.writeInt32BE(16, 0), t.writeInt16BE(1234, 4), t.writeInt16BE(
        5678,
        6
      ), t.writeInt32BE(r, 8), t.writeInt32BE(e, 12), t;
    },
    "cancel"
  ), fn = a((r, e) => {
    let n = 4 + d.byteLength(e) + 1, i = d.allocUnsafe(1 + n);
    return i[0] = r, i.writeInt32BE(n, 1), i.write(e, 5, "utf-8"), i[n] = 0, i;
  }, "cstringMessage"), Cc = k.addCString("P").flush(68), _c = k.addCString("S").flush(68), Tc = a((r) => r.name ? fn(68, `${r.type}${r.name || ""}`) : r.type === "P" ? Cc : _c, "describe"), Ic = a((r) => {
    let e = `${r.type}${r.name || ""}`;
    return fn(67, e);
  }, "close"), Pc = a((r) => k.add(r).flush(100), "copyData"), Rc = a((r) => fn(102, r), "copyFail"), Rt = a((r) => d.from([r, 0, 0, 0, 4]), "codeOnlyBuffer"), Bc = Rt(72), Lc = Rt(83), Fc = Rt(88), kc = Rt(99), Mc = {
    startup: pc,
    password: yc,
    requestSsl: dc,
    sendSASLInitialResponseMessage: mc,
    sendSCRAMClientFinalMessage: gc,
    query: wc,
    parse: bc,
    bind: xc,
    execute: Ec,
    describe: Tc,
    close: Ic,
    flush: a(
      () => Bc,
      "flush"
    ),
    sync: a(() => Lc, "sync"),
    end: a(() => Fc, "end"),
    copyData: Pc,
    copyDone: a(() => kc, "copyDone"),
    copyFail: Rc,
    cancel: Ac
  };
  Bt.serialize = Mc;
});
var Ns = I((Lt) => {
  "use strict";
  p();
  Object.defineProperty(Lt, "__esModule", { value: true });
  Lt.BufferReader = void 0;
  var Uc = d.allocUnsafe(0), pn = class pn {
    static {
      __name(this, "pn");
    }
    constructor(e = 0) {
      this.offset = e, this.buffer = Uc, this.encoding = "utf-8";
    }
    setBuffer(e, t) {
      this.offset = e, this.buffer = t;
    }
    int16() {
      let e = this.buffer.readInt16BE(this.offset);
      return this.offset += 2, e;
    }
    byte() {
      let e = this.buffer[this.offset];
      return this.offset++, e;
    }
    int32() {
      let e = this.buffer.readInt32BE(
        this.offset
      );
      return this.offset += 4, e;
    }
    uint32() {
      let e = this.buffer.readUInt32BE(this.offset);
      return this.offset += 4, e;
    }
    string(e) {
      let t = this.buffer.toString(this.encoding, this.offset, this.offset + e);
      return this.offset += e, t;
    }
    cstring() {
      let e = this.offset, t = e;
      for (; this.buffer[t++] !== 0; ) ;
      return this.offset = t, this.buffer.toString(this.encoding, e, t - 1);
    }
    bytes(e) {
      let t = this.buffer.slice(this.offset, this.offset + e);
      return this.offset += e, t;
    }
  };
  a(pn, "BufferReader");
  var hn = pn;
  Lt.BufferReader = hn;
});
var Hs = I((Ft) => {
  "use strict";
  p();
  Object.defineProperty(Ft, "__esModule", { value: true });
  Ft.Parser = void 0;
  var M = an(), Dc = Ns(), dn = 1, Oc = 4, js = dn + Oc, Ws = d.allocUnsafe(0), mn = class mn {
    static {
      __name(this, "mn");
    }
    constructor(e) {
      if (this.buffer = Ws, this.bufferLength = 0, this.bufferOffset = 0, this.reader = new Dc.BufferReader(), e?.mode === "binary") throw new Error("Binary mode not supported yet");
      this.mode = e?.mode || "text";
    }
    parse(e, t) {
      this.mergeBuffer(e);
      let n = this.bufferOffset + this.bufferLength, i = this.bufferOffset;
      for (; i + js <= n; ) {
        let s = this.buffer[i], o = this.buffer.readUInt32BE(
          i + dn
        ), u = dn + o;
        if (u + i <= n) {
          let c = this.handlePacket(i + js, s, o, this.buffer);
          t(c), i += u;
        } else break;
      }
      i === n ? (this.buffer = Ws, this.bufferLength = 0, this.bufferOffset = 0) : (this.bufferLength = n - i, this.bufferOffset = i);
    }
    mergeBuffer(e) {
      if (this.bufferLength > 0) {
        let t = this.bufferLength + e.byteLength;
        if (t + this.bufferOffset > this.buffer.byteLength) {
          let i;
          if (t <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) i = this.buffer;
          else {
            let s = this.buffer.byteLength * 2;
            for (; t >= s; ) s *= 2;
            i = d.allocUnsafe(s);
          }
          this.buffer.copy(i, 0, this.bufferOffset, this.bufferOffset + this.bufferLength), this.buffer = i, this.bufferOffset = 0;
        }
        e.copy(this.buffer, this.bufferOffset + this.bufferLength), this.bufferLength = t;
      } else this.buffer = e, this.bufferOffset = 0, this.bufferLength = e.byteLength;
    }
    handlePacket(e, t, n, i) {
      switch (t) {
        case 50:
          return M.bindComplete;
        case 49:
          return M.parseComplete;
        case 51:
          return M.closeComplete;
        case 110:
          return M.noData;
        case 115:
          return M.portalSuspended;
        case 99:
          return M.copyDone;
        case 87:
          return M.replicationStart;
        case 73:
          return M.emptyQuery;
        case 68:
          return this.parseDataRowMessage(e, n, i);
        case 67:
          return this.parseCommandCompleteMessage(
            e,
            n,
            i
          );
        case 90:
          return this.parseReadyForQueryMessage(e, n, i);
        case 65:
          return this.parseNotificationMessage(
            e,
            n,
            i
          );
        case 82:
          return this.parseAuthenticationResponse(e, n, i);
        case 83:
          return this.parseParameterStatusMessage(
            e,
            n,
            i
          );
        case 75:
          return this.parseBackendKeyData(e, n, i);
        case 69:
          return this.parseErrorMessage(e, n, i, "error");
        case 78:
          return this.parseErrorMessage(e, n, i, "notice");
        case 84:
          return this.parseRowDescriptionMessage(
            e,
            n,
            i
          );
        case 116:
          return this.parseParameterDescriptionMessage(e, n, i);
        case 71:
          return this.parseCopyInMessage(
            e,
            n,
            i
          );
        case 72:
          return this.parseCopyOutMessage(e, n, i);
        case 100:
          return this.parseCopyData(e, n, i);
        default:
          return new M.DatabaseError("received invalid response: " + t.toString(16), n, "error");
      }
    }
    parseReadyForQueryMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.string(1);
      return new M.ReadyForQueryMessage(t, i);
    }
    parseCommandCompleteMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.cstring();
      return new M.CommandCompleteMessage(t, i);
    }
    parseCopyData(e, t, n) {
      let i = n.slice(e, e + (t - 4));
      return new M.CopyDataMessage(t, i);
    }
    parseCopyInMessage(e, t, n) {
      return this.parseCopyMessage(
        e,
        t,
        n,
        "copyInResponse"
      );
    }
    parseCopyOutMessage(e, t, n) {
      return this.parseCopyMessage(e, t, n, "copyOutResponse");
    }
    parseCopyMessage(e, t, n, i) {
      this.reader.setBuffer(e, n);
      let s = this.reader.byte() !== 0, o = this.reader.int16(), u = new M.CopyResponse(t, i, s, o);
      for (let c = 0; c < o; c++) u.columnTypes[c] = this.reader.int16();
      return u;
    }
    parseNotificationMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int32(), s = this.reader.cstring(), o = this.reader.cstring();
      return new M.NotificationResponseMessage(t, i, s, o);
    }
    parseRowDescriptionMessage(e, t, n) {
      this.reader.setBuffer(
        e,
        n
      );
      let i = this.reader.int16(), s = new M.RowDescriptionMessage(t, i);
      for (let o = 0; o < i; o++) s.fields[o] = this.parseField();
      return s;
    }
    parseField() {
      let e = this.reader.cstring(), t = this.reader.uint32(), n = this.reader.int16(), i = this.reader.uint32(), s = this.reader.int16(), o = this.reader.int32(), u = this.reader.int16() === 0 ? "text" : "binary";
      return new M.Field(e, t, n, i, s, o, u);
    }
    parseParameterDescriptionMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int16(), s = new M.ParameterDescriptionMessage(t, i);
      for (let o = 0; o < i; o++)
        s.dataTypeIDs[o] = this.reader.int32();
      return s;
    }
    parseDataRowMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int16(), s = new Array(i);
      for (let o = 0; o < i; o++) {
        let u = this.reader.int32();
        s[o] = u === -1 ? null : this.reader.string(u);
      }
      return new M.DataRowMessage(t, s);
    }
    parseParameterStatusMessage(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.cstring(), s = this.reader.cstring();
      return new M.ParameterStatusMessage(
        t,
        i,
        s
      );
    }
    parseBackendKeyData(e, t, n) {
      this.reader.setBuffer(e, n);
      let i = this.reader.int32(), s = this.reader.int32();
      return new M.BackendKeyDataMessage(t, i, s);
    }
    parseAuthenticationResponse(e, t, n) {
      this.reader.setBuffer(
        e,
        n
      );
      let i = this.reader.int32(), s = { name: "authenticationOk", length: t };
      switch (i) {
        case 0:
          break;
        case 3:
          s.length === 8 && (s.name = "authenticationCleartextPassword");
          break;
        case 5:
          if (s.length === 12) {
            s.name = "authenticationMD5Password";
            let u = this.reader.bytes(4);
            return new M.AuthenticationMD5Password(t, u);
          }
          break;
        case 10:
          s.name = "authenticationSASL", s.mechanisms = [];
          let o;
          do
            o = this.reader.cstring(), o && s.mechanisms.push(o);
          while (o);
          break;
        case 11:
          s.name = "authenticationSASLContinue", s.data = this.reader.string(t - 8);
          break;
        case 12:
          s.name = "authenticationSASLFinal", s.data = this.reader.string(t - 8);
          break;
        default:
          throw new Error("Unknown authenticationOk message type " + i);
      }
      return s;
    }
    parseErrorMessage(e, t, n, i) {
      this.reader.setBuffer(e, n);
      let s = {}, o = this.reader.string(1);
      for (; o !== "\0"; ) s[o] = this.reader.cstring(), o = this.reader.string(1);
      let u = s.M, c = i === "notice" ? new M.NoticeMessage(t, u) : new M.DatabaseError(u, t, i);
      return c.severity = s.S, c.code = s.C, c.detail = s.D, c.hint = s.H, c.position = s.P, c.internalPosition = s.p, c.internalQuery = s.q, c.where = s.W, c.schema = s.s, c.table = s.t, c.column = s.c, c.dataType = s.d, c.constraint = s.n, c.file = s.F, c.line = s.L, c.routine = s.R, c;
    }
  };
  a(mn, "Parser");
  var yn = mn;
  Ft.Parser = yn;
});
var gn = I((ve) => {
  "use strict";
  p();
  Object.defineProperty(ve, "__esModule", { value: true });
  ve.DatabaseError = ve.serialize = ve.parse = void 0;
  var qc = an();
  Object.defineProperty(ve, "DatabaseError", { enumerable: true, get: a(
    function() {
      return qc.DatabaseError;
    },
    "get"
  ) });
  var Qc = Qs();
  Object.defineProperty(ve, "serialize", {
    enumerable: true,
    get: a(function() {
      return Qc.serialize;
    }, "get")
  });
  var Nc = Hs();
  function jc(r, e) {
    let t = new Nc.Parser();
    return r.on("data", (n) => t.parse(n, e)), new Promise((n) => r.on("end", () => n()));
  }
  __name(jc, "jc");
  a(jc, "parse");
  ve.parse = jc;
});
var $s = {};
ne($s, { connect: /* @__PURE__ */ __name(() => Wc, "connect") });
function Wc({ socket: r, servername: e }) {
  return r.startTls(e), r;
}
__name(Wc, "Wc");
var Gs = z(
  () => {
    "use strict";
    p();
    a(Wc, "connect");
  }
);
var vn = I((Gh, Ks) => {
  "use strict";
  p();
  var Vs = (We(), D(yi)), Hc = me().EventEmitter, { parse: $c, serialize: q } = gn(), zs = q.flush(), Gc = q.sync(), Vc = q.end(), bn = class bn extends Hc {
    static {
      __name(this, "bn");
    }
    constructor(e) {
      super(), e = e || {}, this.stream = e.stream || new Vs.Socket(), this._keepAlive = e.keepAlive, this._keepAliveInitialDelayMillis = e.keepAliveInitialDelayMillis, this.lastBuffer = false, this.parsedStatements = {}, this.ssl = e.ssl || false, this._ending = false, this._emitMessage = false;
      var t = this;
      this.on("newListener", function(n) {
        n === "message" && (t._emitMessage = true);
      });
    }
    connect(e, t) {
      var n = this;
      this._connecting = true, this.stream.setNoDelay(true), this.stream.connect(e, t), this.stream.once("connect", function() {
        n._keepAlive && n.stream.setKeepAlive(true, n._keepAliveInitialDelayMillis), n.emit("connect");
      });
      let i = a(function(s) {
        n._ending && (s.code === "ECONNRESET" || s.code === "EPIPE") || n.emit("error", s);
      }, "reportStreamError");
      if (this.stream.on("error", i), this.stream.on("close", function() {
        n.emit("end");
      }), !this.ssl) return this.attachListeners(
        this.stream
      );
      this.stream.once("data", function(s) {
        var o = s.toString("utf8");
        switch (o) {
          case "S":
            break;
          case "N":
            return n.stream.end(), n.emit("error", new Error("The server does not support SSL connections"));
          default:
            return n.stream.end(), n.emit("error", new Error("There was an error establishing an SSL connection"));
        }
        var u = (Gs(), D($s));
        let c = { socket: n.stream };
        n.ssl !== true && (Object.assign(c, n.ssl), "key" in n.ssl && (c.key = n.ssl.key)), Vs.isIP(t) === 0 && (c.servername = t);
        try {
          n.stream = u.connect(c);
        } catch (l) {
          return n.emit(
            "error",
            l
          );
        }
        n.attachListeners(n.stream), n.stream.on("error", i), n.emit("sslconnect");
      });
    }
    attachListeners(e) {
      e.on(
        "end",
        () => {
          this.emit("end");
        }
      ), $c(e, (t) => {
        var n = t.name === "error" ? "errorMessage" : t.name;
        this._emitMessage && this.emit("message", t), this.emit(n, t);
      });
    }
    requestSsl() {
      this.stream.write(q.requestSsl());
    }
    startup(e) {
      this.stream.write(q.startup(e));
    }
    cancel(e, t) {
      this._send(q.cancel(e, t));
    }
    password(e) {
      this._send(q.password(e));
    }
    sendSASLInitialResponseMessage(e, t) {
      this._send(q.sendSASLInitialResponseMessage(e, t));
    }
    sendSCRAMClientFinalMessage(e) {
      this._send(q.sendSCRAMClientFinalMessage(
        e
      ));
    }
    _send(e) {
      return this.stream.writable ? this.stream.write(e) : false;
    }
    query(e) {
      this._send(q.query(e));
    }
    parse(e) {
      this._send(q.parse(e));
    }
    bind(e) {
      this._send(q.bind(e));
    }
    execute(e) {
      this._send(q.execute(e));
    }
    flush() {
      this.stream.writable && this.stream.write(zs);
    }
    sync() {
      this._ending = true, this._send(zs), this._send(Gc);
    }
    ref() {
      this.stream.ref();
    }
    unref() {
      this.stream.unref();
    }
    end() {
      if (this._ending = true, !this._connecting || !this.stream.writable) {
        this.stream.end();
        return;
      }
      return this.stream.write(Vc, () => {
        this.stream.end();
      });
    }
    close(e) {
      this._send(q.close(e));
    }
    describe(e) {
      this._send(q.describe(e));
    }
    sendCopyFromChunk(e) {
      this._send(q.copyData(e));
    }
    endCopyFrom() {
      this._send(q.copyDone());
    }
    sendCopyFail(e) {
      this._send(q.copyFail(e));
    }
  };
  a(bn, "Connection");
  var wn = bn;
  Ks.exports = wn;
});
var Js = I((Yh, Zs) => {
  "use strict";
  p();
  var zc = me().EventEmitter, Kh = (it(), D(nt)), Kc = rt(), xn = hs(), Yc = Es(), Zc = St(), Jc = It(), Ys = Ds(), Xc = tt(), el = vn(), Sn = class Sn extends zc {
    static {
      __name(this, "Sn");
    }
    constructor(e) {
      super(), this.connectionParameters = new Jc(e), this.user = this.connectionParameters.user, this.database = this.connectionParameters.database, this.port = this.connectionParameters.port, this.host = this.connectionParameters.host, Object.defineProperty(
        this,
        "password",
        { configurable: true, enumerable: false, writable: true, value: this.connectionParameters.password }
      ), this.replication = this.connectionParameters.replication;
      var t = e || {};
      this._Promise = t.Promise || w.Promise, this._types = new Zc(t.types), this._ending = false, this._connecting = false, this._connected = false, this._connectionError = false, this._queryable = true, this.connection = t.connection || new el({ stream: t.stream, ssl: this.connectionParameters.ssl, keepAlive: t.keepAlive || false, keepAliveInitialDelayMillis: t.keepAliveInitialDelayMillis || 0, encoding: this.connectionParameters.client_encoding || "utf8" }), this.queryQueue = [], this.binary = t.binary || Xc.binary, this.processID = null, this.secretKey = null, this.ssl = this.connectionParameters.ssl || false, this.ssl && this.ssl.key && Object.defineProperty(this.ssl, "key", { enumerable: false }), this._connectionTimeoutMillis = t.connectionTimeoutMillis || 0;
    }
    _errorAllQueries(e) {
      let t = a((n) => {
        m.nextTick(() => {
          n.handleError(e, this.connection);
        });
      }, "enqueueError");
      this.activeQuery && (t(this.activeQuery), this.activeQuery = null), this.queryQueue.forEach(t), this.queryQueue.length = 0;
    }
    _connect(e) {
      var t = this, n = this.connection;
      if (this._connectionCallback = e, this._connecting || this._connected) {
        let i = new Error("Client has already been connected. You cannot reuse a client.");
        m.nextTick(
          () => {
            e(i);
          }
        );
        return;
      }
      this._connecting = true, this.connectionTimeoutHandle, this._connectionTimeoutMillis > 0 && (this.connectionTimeoutHandle = setTimeout(() => {
        n._ending = true, n.stream.destroy(new Error("timeout expired"));
      }, this._connectionTimeoutMillis)), this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
        t.ssl ? n.requestSsl() : n.startup(t.getStartupConf());
      }), n.on("sslconnect", function() {
        n.startup(t.getStartupConf());
      }), this._attachListeners(
        n
      ), n.once("end", () => {
        let i = this._ending ? new Error("Connection terminated") : new Error("Connection terminated unexpectedly");
        clearTimeout(this.connectionTimeoutHandle), this._errorAllQueries(i), this._ending || (this._connecting && !this._connectionError ? this._connectionCallback ? this._connectionCallback(i) : this._handleErrorEvent(i) : this._connectionError || this._handleErrorEvent(i)), m.nextTick(() => {
          this.emit("end");
        });
      });
    }
    connect(e) {
      if (e) {
        this._connect(e);
        return;
      }
      return new this._Promise((t, n) => {
        this._connect((i) => {
          i ? n(i) : t();
        });
      });
    }
    _attachListeners(e) {
      e.on("authenticationCleartextPassword", this._handleAuthCleartextPassword.bind(this)), e.on("authenticationMD5Password", this._handleAuthMD5Password.bind(this)), e.on("authenticationSASL", this._handleAuthSASL.bind(this)), e.on("authenticationSASLContinue", this._handleAuthSASLContinue.bind(this)), e.on("authenticationSASLFinal", this._handleAuthSASLFinal.bind(this)), e.on("backendKeyData", this._handleBackendKeyData.bind(this)), e.on("error", this._handleErrorEvent.bind(this)), e.on("errorMessage", this._handleErrorMessage.bind(this)), e.on("readyForQuery", this._handleReadyForQuery.bind(this)), e.on("notice", this._handleNotice.bind(this)), e.on("rowDescription", this._handleRowDescription.bind(this)), e.on("dataRow", this._handleDataRow.bind(this)), e.on("portalSuspended", this._handlePortalSuspended.bind(
        this
      )), e.on("emptyQuery", this._handleEmptyQuery.bind(this)), e.on("commandComplete", this._handleCommandComplete.bind(this)), e.on("parseComplete", this._handleParseComplete.bind(this)), e.on("copyInResponse", this._handleCopyInResponse.bind(this)), e.on("copyData", this._handleCopyData.bind(this)), e.on("notification", this._handleNotification.bind(this));
    }
    _checkPgPass(e) {
      let t = this.connection;
      typeof this.password == "function" ? this._Promise.resolve().then(() => this.password()).then((n) => {
        if (n !== void 0) {
          if (typeof n != "string") {
            t.emit("error", new TypeError(
              "Password must be a string"
            ));
            return;
          }
          this.connectionParameters.password = this.password = n;
        } else this.connectionParameters.password = this.password = null;
        e();
      }).catch((n) => {
        t.emit("error", n);
      }) : this.password !== null ? e() : Yc(
        this.connectionParameters,
        (n) => {
          n !== void 0 && (this.connectionParameters.password = this.password = n), e();
        }
      );
    }
    _handleAuthCleartextPassword(e) {
      this._checkPgPass(() => {
        this.connection.password(this.password);
      });
    }
    _handleAuthMD5Password(e) {
      this._checkPgPass(
        () => {
          let t = Kc.postgresMd5PasswordHash(this.user, this.password, e.salt);
          this.connection.password(t);
        }
      );
    }
    _handleAuthSASL(e) {
      this._checkPgPass(() => {
        this.saslSession = xn.startSession(e.mechanisms), this.connection.sendSASLInitialResponseMessage(
          this.saslSession.mechanism,
          this.saslSession.response
        );
      });
    }
    _handleAuthSASLContinue(e) {
      xn.continueSession(
        this.saslSession,
        this.password,
        e.data
      ), this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
    }
    _handleAuthSASLFinal(e) {
      xn.finalizeSession(this.saslSession, e.data), this.saslSession = null;
    }
    _handleBackendKeyData(e) {
      this.processID = e.processID, this.secretKey = e.secretKey;
    }
    _handleReadyForQuery(e) {
      this._connecting && (this._connecting = false, this._connected = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback && (this._connectionCallback(null, this), this._connectionCallback = null), this.emit("connect"));
      let { activeQuery: t } = this;
      this.activeQuery = null, this.readyForQuery = true, t && t.handleReadyForQuery(this.connection), this._pulseQueryQueue();
    }
    _handleErrorWhileConnecting(e) {
      if (!this._connectionError) {
        if (this._connectionError = true, clearTimeout(this.connectionTimeoutHandle), this._connectionCallback) return this._connectionCallback(e);
        this.emit("error", e);
      }
    }
    _handleErrorEvent(e) {
      if (this._connecting) return this._handleErrorWhileConnecting(e);
      this._queryable = false, this._errorAllQueries(e), this.emit("error", e);
    }
    _handleErrorMessage(e) {
      if (this._connecting) return this._handleErrorWhileConnecting(e);
      let t = this.activeQuery;
      if (!t) {
        this._handleErrorEvent(e);
        return;
      }
      this.activeQuery = null, t.handleError(
        e,
        this.connection
      );
    }
    _handleRowDescription(e) {
      this.activeQuery.handleRowDescription(e);
    }
    _handleDataRow(e) {
      this.activeQuery.handleDataRow(e);
    }
    _handlePortalSuspended(e) {
      this.activeQuery.handlePortalSuspended(this.connection);
    }
    _handleEmptyQuery(e) {
      this.activeQuery.handleEmptyQuery(this.connection);
    }
    _handleCommandComplete(e) {
      this.activeQuery.handleCommandComplete(e, this.connection);
    }
    _handleParseComplete(e) {
      this.activeQuery.name && (this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text);
    }
    _handleCopyInResponse(e) {
      this.activeQuery.handleCopyInResponse(this.connection);
    }
    _handleCopyData(e) {
      this.activeQuery.handleCopyData(
        e,
        this.connection
      );
    }
    _handleNotification(e) {
      this.emit("notification", e);
    }
    _handleNotice(e) {
      this.emit("notice", e);
    }
    getStartupConf() {
      var e = this.connectionParameters, t = { user: e.user, database: e.database }, n = e.application_name || e.fallback_application_name;
      return n && (t.application_name = n), e.replication && (t.replication = "" + e.replication), e.statement_timeout && (t.statement_timeout = String(parseInt(e.statement_timeout, 10))), e.lock_timeout && (t.lock_timeout = String(parseInt(e.lock_timeout, 10))), e.idle_in_transaction_session_timeout && (t.idle_in_transaction_session_timeout = String(parseInt(e.idle_in_transaction_session_timeout, 10))), e.options && (t.options = e.options), t;
    }
    cancel(e, t) {
      if (e.activeQuery === t) {
        var n = this.connection;
        this.host && this.host.indexOf("/") === 0 ? n.connect(this.host + "/.s.PGSQL." + this.port) : n.connect(this.port, this.host), n.on("connect", function() {
          n.cancel(
            e.processID,
            e.secretKey
          );
        });
      } else e.queryQueue.indexOf(t) !== -1 && e.queryQueue.splice(e.queryQueue.indexOf(t), 1);
    }
    setTypeParser(e, t, n) {
      return this._types.setTypeParser(e, t, n);
    }
    getTypeParser(e, t) {
      return this._types.getTypeParser(e, t);
    }
    escapeIdentifier(e) {
      return '"' + e.replace(/"/g, '""') + '"';
    }
    escapeLiteral(e) {
      for (var t = false, n = "'", i = 0; i < e.length; i++) {
        var s = e[i];
        s === "'" ? n += s + s : s === "\\" ? (n += s + s, t = true) : n += s;
      }
      return n += "'", t === true && (n = " E" + n), n;
    }
    _pulseQueryQueue() {
      if (this.readyForQuery === true) if (this.activeQuery = this.queryQueue.shift(), this.activeQuery) {
        this.readyForQuery = false, this.hasExecuted = true;
        let e = this.activeQuery.submit(this.connection);
        e && m.nextTick(() => {
          this.activeQuery.handleError(e, this.connection), this.readyForQuery = true, this._pulseQueryQueue();
        });
      } else this.hasExecuted && (this.activeQuery = null, this.emit("drain"));
    }
    query(e, t, n) {
      var i, s, o, u, c;
      if (e == null) throw new TypeError(
        "Client was passed a null or undefined query"
      );
      return typeof e.submit == "function" ? (o = e.query_timeout || this.connectionParameters.query_timeout, s = i = e, typeof t == "function" && (i.callback = i.callback || t)) : (o = this.connectionParameters.query_timeout, i = new Ys(e, t, n), i.callback || (s = new this._Promise((l, f) => {
        i.callback = (y, g) => y ? f(y) : l(g);
      }))), o && (c = i.callback, u = setTimeout(() => {
        var l = new Error("Query read timeout");
        m.nextTick(
          () => {
            i.handleError(l, this.connection);
          }
        ), c(l), i.callback = () => {
        };
        var f = this.queryQueue.indexOf(i);
        f > -1 && this.queryQueue.splice(f, 1), this._pulseQueryQueue();
      }, o), i.callback = (l, f) => {
        clearTimeout(u), c(l, f);
      }), this.binary && !i.binary && (i.binary = true), i._result && !i._result._types && (i._result._types = this._types), this._queryable ? this._ending ? (m.nextTick(() => {
        i.handleError(new Error("Client was closed and is not queryable"), this.connection);
      }), s) : (this.queryQueue.push(i), this._pulseQueryQueue(), s) : (m.nextTick(() => {
        i.handleError(new Error("Client has encountered a connection error and is not queryable"), this.connection);
      }), s);
    }
    ref() {
      this.connection.ref();
    }
    unref() {
      this.connection.unref();
    }
    end(e) {
      if (this._ending = true, !this.connection._connecting) if (e) e();
      else return this._Promise.resolve();
      if (this.activeQuery || !this._queryable ? this.connection.stream.destroy() : this.connection.end(), e) this.connection.once("end", e);
      else return new this._Promise((t) => {
        this.connection.once("end", t);
      });
    }
  };
  a(Sn, "Client");
  var kt = Sn;
  kt.Query = Ys;
  Zs.exports = kt;
});
var ro = I((Xh, to) => {
  "use strict";
  p();
  var tl = me().EventEmitter, Xs = a(function() {
  }, "NOOP"), eo = a((r, e) => {
    let t = r.findIndex(e);
    return t === -1 ? void 0 : r.splice(t, 1)[0];
  }, "removeWhere"), Cn = class Cn {
    static {
      __name(this, "Cn");
    }
    constructor(e, t, n) {
      this.client = e, this.idleListener = t, this.timeoutId = n;
    }
  };
  a(Cn, "IdleItem");
  var En = Cn, _n = class _n {
    static {
      __name(this, "_n");
    }
    constructor(e) {
      this.callback = e;
    }
  };
  a(_n, "PendingItem");
  var qe = _n;
  function rl() {
    throw new Error("Release called on client which has already been released to the pool.");
  }
  __name(rl, "rl");
  a(rl, "throwOnDoubleRelease");
  function Mt(r, e) {
    if (e)
      return { callback: e, result: void 0 };
    let t, n, i = a(function(o, u) {
      o ? t(o) : n(u);
    }, "cb"), s = new r(function(o, u) {
      n = o, t = u;
    }).catch((o) => {
      throw Error.captureStackTrace(o), o;
    });
    return { callback: i, result: s };
  }
  __name(Mt, "Mt");
  a(Mt, "promisify");
  function nl(r, e) {
    return a(/* @__PURE__ */ __name(function t(n) {
      n.client = e, e.removeListener("error", t), e.on("error", () => {
        r.log(
          "additional client error after disconnection due to error",
          n
        );
      }), r._remove(e), r.emit("error", n, e);
    }, "t"), "idleListener");
  }
  __name(nl, "nl");
  a(nl, "makeIdleListener");
  var Tn = class Tn extends tl {
    static {
      __name(this, "Tn");
    }
    constructor(e, t) {
      super(), this.options = Object.assign({}, e), e != null && "password" in e && Object.defineProperty(this.options, "password", {
        configurable: true,
        enumerable: false,
        writable: true,
        value: e.password
      }), e != null && e.ssl && e.ssl.key && Object.defineProperty(this.options.ssl, "key", { enumerable: false }), this.options.max = this.options.max || this.options.poolSize || 10, this.options.maxUses = this.options.maxUses || 1 / 0, this.options.allowExitOnIdle = this.options.allowExitOnIdle || false, this.options.maxLifetimeSeconds = this.options.maxLifetimeSeconds || 0, this.log = this.options.log || function() {
      }, this.Client = this.options.Client || t || ot().Client, this.Promise = this.options.Promise || w.Promise, typeof this.options.idleTimeoutMillis > "u" && (this.options.idleTimeoutMillis = 1e4), this._clients = [], this._idle = [], this._expired = /* @__PURE__ */ new WeakSet(), this._pendingQueue = [], this._endCallback = void 0, this.ending = false, this.ended = false;
    }
    _isFull() {
      return this._clients.length >= this.options.max;
    }
    _pulseQueue() {
      if (this.log("pulse queue"), this.ended) {
        this.log("pulse queue ended");
        return;
      }
      if (this.ending) {
        this.log("pulse queue on ending"), this._idle.length && this._idle.slice().map((t) => {
          this._remove(t.client);
        }), this._clients.length || (this.ended = true, this._endCallback());
        return;
      }
      if (!this._pendingQueue.length) {
        this.log("no queued requests");
        return;
      }
      if (!this._idle.length && this._isFull()) return;
      let e = this._pendingQueue.shift();
      if (this._idle.length) {
        let t = this._idle.pop();
        clearTimeout(
          t.timeoutId
        );
        let n = t.client;
        n.ref && n.ref();
        let i = t.idleListener;
        return this._acquireClient(n, e, i, false);
      }
      if (!this._isFull()) return this.newClient(e);
      throw new Error("unexpected condition");
    }
    _remove(e) {
      let t = eo(
        this._idle,
        (n) => n.client === e
      );
      t !== void 0 && clearTimeout(t.timeoutId), this._clients = this._clients.filter(
        (n) => n !== e
      ), e.end(), this.emit("remove", e);
    }
    connect(e) {
      if (this.ending) {
        let i = new Error("Cannot use a pool after calling end on the pool");
        return e ? e(i) : this.Promise.reject(i);
      }
      let t = Mt(this.Promise, e), n = t.result;
      if (this._isFull() || this._idle.length) {
        if (this._idle.length && m.nextTick(() => this._pulseQueue()), !this.options.connectionTimeoutMillis) return this._pendingQueue.push(new qe(t.callback)), n;
        let i = a((u, c, l) => {
          clearTimeout(o), t.callback(u, c, l);
        }, "queueCallback"), s = new qe(i), o = setTimeout(() => {
          eo(
            this._pendingQueue,
            (u) => u.callback === i
          ), s.timedOut = true, t.callback(new Error("timeout exceeded when trying to connect"));
        }, this.options.connectionTimeoutMillis);
        return o.unref && o.unref(), this._pendingQueue.push(s), n;
      }
      return this.newClient(new qe(t.callback)), n;
    }
    newClient(e) {
      let t = new this.Client(this.options);
      this._clients.push(
        t
      );
      let n = nl(this, t);
      this.log("checking client timeout");
      let i, s = false;
      this.options.connectionTimeoutMillis && (i = setTimeout(() => {
        this.log("ending client due to timeout"), s = true, t.connection ? t.connection.stream.destroy() : t.end();
      }, this.options.connectionTimeoutMillis)), this.log("connecting new client"), t.connect((o) => {
        if (i && clearTimeout(i), t.on("error", n), o) this.log("client failed to connect", o), this._clients = this._clients.filter((u) => u !== t), s && (o = new Error("Connection terminated due to connection timeout", { cause: o })), this._pulseQueue(), e.timedOut || e.callback(o, void 0, Xs);
        else {
          if (this.log("new client connected"), this.options.maxLifetimeSeconds !== 0) {
            let u = setTimeout(() => {
              this.log("ending client due to expired lifetime"), this._expired.add(t), this._idle.findIndex((l) => l.client === t) !== -1 && this._acquireClient(
                t,
                new qe((l, f, y) => y()),
                n,
                false
              );
            }, this.options.maxLifetimeSeconds * 1e3);
            u.unref(), t.once("end", () => clearTimeout(u));
          }
          return this._acquireClient(t, e, n, true);
        }
      });
    }
    _acquireClient(e, t, n, i) {
      i && this.emit("connect", e), this.emit("acquire", e), e.release = this._releaseOnce(e, n), e.removeListener("error", n), t.timedOut ? i && this.options.verify ? this.options.verify(e, e.release) : e.release() : i && this.options.verify ? this.options.verify(e, (s) => {
        if (s) return e.release(s), t.callback(s, void 0, Xs);
        t.callback(void 0, e, e.release);
      }) : t.callback(void 0, e, e.release);
    }
    _releaseOnce(e, t) {
      let n = false;
      return (i) => {
        n && rl(), n = true, this._release(e, t, i);
      };
    }
    _release(e, t, n) {
      if (e.on("error", t), e._poolUseCount = (e._poolUseCount || 0) + 1, this.emit("release", n, e), n || this.ending || !e._queryable || e._ending || e._poolUseCount >= this.options.maxUses) {
        e._poolUseCount >= this.options.maxUses && this.log("remove expended client"), this._remove(e), this._pulseQueue();
        return;
      }
      if (this._expired.has(e)) {
        this.log("remove expired client"), this._expired.delete(e), this._remove(e), this._pulseQueue();
        return;
      }
      let s;
      this.options.idleTimeoutMillis && (s = setTimeout(() => {
        this.log("remove idle client"), this._remove(e);
      }, this.options.idleTimeoutMillis), this.options.allowExitOnIdle && s.unref()), this.options.allowExitOnIdle && e.unref(), this._idle.push(new En(
        e,
        t,
        s
      )), this._pulseQueue();
    }
    query(e, t, n) {
      if (typeof e == "function") {
        let s = Mt(this.Promise, e);
        return b(function() {
          return s.callback(new Error("Passing a function as the first parameter to pool.query is not supported"));
        }), s.result;
      }
      typeof t == "function" && (n = t, t = void 0);
      let i = Mt(this.Promise, n);
      return n = i.callback, this.connect((s, o) => {
        if (s) return n(s);
        let u = false, c = a((l) => {
          u || (u = true, o.release(l), n(l));
        }, "onError");
        o.once("error", c), this.log("dispatching query");
        try {
          o.query(e, t, (l, f) => {
            if (this.log("query dispatched"), o.removeListener(
              "error",
              c
            ), !u) return u = true, o.release(l), l ? n(l) : n(void 0, f);
          });
        } catch (l) {
          return o.release(l), n(l);
        }
      }), i.result;
    }
    end(e) {
      if (this.log("ending"), this.ending) {
        let n = new Error("Called end on pool more than once");
        return e ? e(n) : this.Promise.reject(n);
      }
      this.ending = true;
      let t = Mt(this.Promise, e);
      return this._endCallback = t.callback, this._pulseQueue(), t.result;
    }
    get waitingCount() {
      return this._pendingQueue.length;
    }
    get idleCount() {
      return this._idle.length;
    }
    get expiredCount() {
      return this._clients.reduce((e, t) => e + (this._expired.has(t) ? 1 : 0), 0);
    }
    get totalCount() {
      return this._clients.length;
    }
  };
  a(Tn, "Pool");
  var An = Tn;
  to.exports = An;
});
var no = {};
ne(no, { default: /* @__PURE__ */ __name(() => il, "default") });
var il;
var io = z(() => {
  "use strict";
  p();
  il = {};
});
var so = I((np, sl) => {
  sl.exports = { name: "pg", version: "8.8.0", description: "PostgreSQL client - pure javascript & libpq with the same API", keywords: [
    "database",
    "libpq",
    "pg",
    "postgre",
    "postgres",
    "postgresql",
    "rdbms"
  ], homepage: "https://github.com/brianc/node-postgres", repository: { type: "git", url: "git://github.com/brianc/node-postgres.git", directory: "packages/pg" }, author: "Brian Carlson <brian.m.carlson@gmail.com>", main: "./lib", dependencies: { "buffer-writer": "2.0.0", "packet-reader": "1.0.0", "pg-connection-string": "^2.5.0", "pg-pool": "^3.5.2", "pg-protocol": "^1.5.0", "pg-types": "^2.1.0", pgpass: "1.x" }, devDependencies: {
    async: "2.6.4",
    bluebird: "3.5.2",
    co: "4.6.0",
    "pg-copy-streams": "0.3.0"
  }, peerDependencies: { "pg-native": ">=3.0.1" }, peerDependenciesMeta: { "pg-native": { optional: true } }, scripts: { test: "make test-all" }, files: ["lib", "SPONSORS.md"], license: "MIT", engines: { node: ">= 8.0.0" }, gitHead: "c99fb2c127ddf8d712500db2c7b9a5491a178655" };
});
var uo = I((ip, ao) => {
  "use strict";
  p();
  var oo = me().EventEmitter, ol = (it(), D(nt)), In = rt(), Qe = ao.exports = function(r, e, t) {
    oo.call(this), r = In.normalizeQueryConfig(r, e, t), this.text = r.text, this.values = r.values, this.name = r.name, this.callback = r.callback, this.state = "new", this._arrayMode = r.rowMode === "array", this._emitRowEvents = false, this.on("newListener", function(n) {
      n === "row" && (this._emitRowEvents = true);
    }.bind(this));
  };
  ol.inherits(Qe, oo);
  var al = { sqlState: "code", statementPosition: "position", messagePrimary: "message", context: "where", schemaName: "schema", tableName: "table", columnName: "column", dataTypeName: "dataType", constraintName: "constraint", sourceFile: "file", sourceLine: "line", sourceFunction: "routine" };
  Qe.prototype.handleError = function(r) {
    var e = this.native.pq.resultErrorFields();
    if (e) for (var t in e) {
      var n = al[t] || t;
      r[n] = e[t];
    }
    this.callback ? this.callback(r) : this.emit("error", r), this.state = "error";
  };
  Qe.prototype.then = function(r, e) {
    return this._getPromise().then(
      r,
      e
    );
  };
  Qe.prototype.catch = function(r) {
    return this._getPromise().catch(r);
  };
  Qe.prototype._getPromise = function() {
    return this._promise ? this._promise : (this._promise = new Promise(function(r, e) {
      this._once("end", r), this._once("error", e);
    }.bind(this)), this._promise);
  };
  Qe.prototype.submit = function(r) {
    this.state = "running";
    var e = this;
    this.native = r.native, r.native.arrayMode = this._arrayMode;
    var t = a(function(s, o, u) {
      if (r.native.arrayMode = false, b(function() {
        e.emit("_done");
      }), s) return e.handleError(s);
      e._emitRowEvents && (u.length > 1 ? o.forEach(
        (c, l) => {
          c.forEach((f) => {
            e.emit("row", f, u[l]);
          });
        }
      ) : o.forEach(function(c) {
        e.emit("row", c, u);
      })), e.state = "end", e.emit("end", u), e.callback && e.callback(null, u);
    }, "after");
    if (m.domain && (t = m.domain.bind(t)), this.name) {
      this.name.length > 63 && (console.error("Warning! Postgres only supports 63 characters for query names."), console.error("You supplied %s (%s)", this.name, this.name.length), console.error("This can cause conflicts and silent errors executing queries"));
      var n = (this.values || []).map(In.prepareValue);
      if (r.namedQueries[this.name]) {
        if (this.text && r.namedQueries[this.name] !== this.text) {
          let s = new Error(`Prepared statements must be unique - '${this.name}' was used for a different statement`);
          return t(s);
        }
        return r.native.execute(this.name, n, t);
      }
      return r.native.prepare(this.name, this.text, n.length, function(s) {
        return s ? t(s) : (r.namedQueries[e.name] = e.text, e.native.execute(e.name, n, t));
      });
    } else if (this.values) {
      if (!Array.isArray(
        this.values
      )) {
        let s = new Error("Query values must be an array");
        return t(s);
      }
      var i = this.values.map(In.prepareValue);
      r.native.query(this.text, i, t);
    } else r.native.query(this.text, t);
  };
});
var ho = I((up, fo) => {
  "use strict";
  p();
  var ul = (io(), D(no)), cl = St(), ap = so(), co = me().EventEmitter, ll = (it(), D(nt)), fl = It(), lo = uo(), Z = fo.exports = function(r) {
    co.call(this), r = r || {}, this._Promise = r.Promise || w.Promise, this._types = new cl(r.types), this.native = new ul({ types: this._types }), this._queryQueue = [], this._ending = false, this._connecting = false, this._connected = false, this._queryable = true;
    var e = this.connectionParameters = new fl(r);
    this.user = e.user, Object.defineProperty(this, "password", { configurable: true, enumerable: false, writable: true, value: e.password }), this.database = e.database, this.host = e.host, this.port = e.port, this.namedQueries = {};
  };
  Z.Query = lo;
  ll.inherits(Z, co);
  Z.prototype._errorAllQueries = function(r) {
    let e = a((t) => {
      m.nextTick(() => {
        t.native = this.native, t.handleError(r);
      });
    }, "enqueueError");
    this._hasActiveQuery() && (e(this._activeQuery), this._activeQuery = null), this._queryQueue.forEach(e), this._queryQueue.length = 0;
  };
  Z.prototype._connect = function(r) {
    var e = this;
    if (this._connecting) {
      m.nextTick(() => r(new Error("Client has already been connected. You cannot reuse a client.")));
      return;
    }
    this._connecting = true, this.connectionParameters.getLibpqConnectionString(function(t, n) {
      if (t) return r(t);
      e.native.connect(n, function(i) {
        if (i) return e.native.end(), r(i);
        e._connected = true, e.native.on("error", function(s) {
          e._queryable = false, e._errorAllQueries(s), e.emit("error", s);
        }), e.native.on("notification", function(s) {
          e.emit("notification", { channel: s.relname, payload: s.extra });
        }), e.emit("connect"), e._pulseQueryQueue(true), r();
      });
    });
  };
  Z.prototype.connect = function(r) {
    if (r) {
      this._connect(r);
      return;
    }
    return new this._Promise((e, t) => {
      this._connect((n) => {
        n ? t(n) : e();
      });
    });
  };
  Z.prototype.query = function(r, e, t) {
    var n, i, s, o, u;
    if (r == null) throw new TypeError("Client was passed a null or undefined query");
    if (typeof r.submit == "function") s = r.query_timeout || this.connectionParameters.query_timeout, i = n = r, typeof e == "function" && (r.callback = e);
    else if (s = this.connectionParameters.query_timeout, n = new lo(r, e, t), !n.callback) {
      let c, l;
      i = new this._Promise((f, y) => {
        c = f, l = y;
      }), n.callback = (f, y) => f ? l(f) : c(y);
    }
    return s && (u = n.callback, o = setTimeout(() => {
      var c = new Error(
        "Query read timeout"
      );
      m.nextTick(() => {
        n.handleError(c, this.connection);
      }), u(c), n.callback = () => {
      };
      var l = this._queryQueue.indexOf(n);
      l > -1 && this._queryQueue.splice(l, 1), this._pulseQueryQueue();
    }, s), n.callback = (c, l) => {
      clearTimeout(o), u(c, l);
    }), this._queryable ? this._ending ? (n.native = this.native, m.nextTick(() => {
      n.handleError(
        new Error("Client was closed and is not queryable")
      );
    }), i) : (this._queryQueue.push(n), this._pulseQueryQueue(), i) : (n.native = this.native, m.nextTick(() => {
      n.handleError(new Error("Client has encountered a connection error and is not queryable"));
    }), i);
  };
  Z.prototype.end = function(r) {
    var e = this;
    this._ending = true, this._connected || this.once("connect", this.end.bind(this, r));
    var t;
    return r || (t = new this._Promise(function(n, i) {
      r = a((s) => s ? i(s) : n(), "cb");
    })), this.native.end(function() {
      e._errorAllQueries(new Error("Connection terminated")), m.nextTick(() => {
        e.emit("end"), r && r();
      });
    }), t;
  };
  Z.prototype._hasActiveQuery = function() {
    return this._activeQuery && this._activeQuery.state !== "error" && this._activeQuery.state !== "end";
  };
  Z.prototype._pulseQueryQueue = function(r) {
    if (this._connected && !this._hasActiveQuery()) {
      var e = this._queryQueue.shift();
      if (!e) {
        r || this.emit("drain");
        return;
      }
      this._activeQuery = e, e.submit(this);
      var t = this;
      e.once("_done", function() {
        t._pulseQueryQueue();
      });
    }
  };
  Z.prototype.cancel = function(r) {
    this._activeQuery === r ? this.native.cancel(function() {
    }) : this._queryQueue.indexOf(r) !== -1 && this._queryQueue.splice(this._queryQueue.indexOf(r), 1);
  };
  Z.prototype.ref = function() {
  };
  Z.prototype.unref = function() {
  };
  Z.prototype.setTypeParser = function(r, e, t) {
    return this._types.setTypeParser(
      r,
      e,
      t
    );
  };
  Z.prototype.getTypeParser = function(r, e) {
    return this._types.getTypeParser(r, e);
  };
});
var Pn = I((fp, po) => {
  "use strict";
  p();
  po.exports = ho();
});
var ot = I((pp, at) => {
  "use strict";
  p();
  var hl = Js(), pl = tt(), dl = vn(), yl = ro(), { DatabaseError: ml } = gn(), gl = a(
    (r) => {
      var e;
      return e = class extends yl {
        static {
          __name(this, "e");
        }
        constructor(n) {
          super(n, r);
        }
      }, a(e, "BoundPool"), e;
    },
    "poolFactory"
  ), Rn = a(
    function(r) {
      this.defaults = pl, this.Client = r, this.Query = this.Client.Query, this.Pool = gl(this.Client), this._pools = [], this.Connection = dl, this.types = Je(), this.DatabaseError = ml;
    },
    "PG"
  );
  typeof m.env.NODE_PG_FORCE_NATIVE < "u" ? at.exports = new Rn(Pn()) : (at.exports = new Rn(hl), Object.defineProperty(at.exports, "native", {
    configurable: true,
    enumerable: false,
    get() {
      var r = null;
      try {
        r = new Rn(Pn());
      } catch (e) {
        if (e.code !== "MODULE_NOT_FOUND") throw e;
      }
      return Object.defineProperty(at.exports, "native", { value: r }), r;
    }
  }));
});
p();
p();
We();
zt();
p();
var fa = Object.defineProperty;
var ha = Object.defineProperties;
var pa = Object.getOwnPropertyDescriptors;
var gi = Object.getOwnPropertySymbols;
var da = Object.prototype.hasOwnProperty;
var ya = Object.prototype.propertyIsEnumerable;
var wi = a(
  (r, e, t) => e in r ? fa(r, e, { enumerable: true, configurable: true, writable: true, value: t }) : r[e] = t,
  "__defNormalProp"
);
var ma = a((r, e) => {
  for (var t in e || (e = {})) da.call(e, t) && wi(r, t, e[t]);
  if (gi) for (var t of gi(e)) ya.call(e, t) && wi(r, t, e[t]);
  return r;
}, "__spreadValues");
var ga = a((r, e) => ha(r, pa(e)), "__spreadProps");
var wa = 1008e3;
var bi = new Uint8Array(
  new Uint16Array([258]).buffer
)[0] === 2;
var ba = new TextDecoder();
var Kt = new TextEncoder();
var dt = Kt.encode("0123456789abcdef");
var yt = Kt.encode("0123456789ABCDEF");
var va = Kt.encode("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
var vi = va.slice();
vi[62] = 45;
vi[63] = 95;
var He;
var mt;
function xa(r, { alphabet: e, scratchArr: t } = {}) {
  if (!He) if (He = new Uint16Array(256), mt = new Uint16Array(256), bi) for (let C = 0; C < 256; C++) He[C] = dt[C & 15] << 8 | dt[C >>> 4], mt[C] = yt[C & 15] << 8 | yt[C >>> 4];
  else for (let C = 0; C < 256; C++) He[C] = dt[C & 15] | dt[C >>> 4] << 8, mt[C] = yt[C & 15] | yt[C >>> 4] << 8;
  r.byteOffset % 4 !== 0 && (r = new Uint8Array(r));
  let n = r.length, i = n >>> 1, s = n >>> 2, o = t || new Uint16Array(n), u = new Uint32Array(
    r.buffer,
    r.byteOffset,
    s
  ), c = new Uint32Array(o.buffer, o.byteOffset, i), l = e === "upper" ? mt : He, f = 0, y = 0, g;
  if (bi)
    for (; f < s; ) g = u[f++], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255];
  else for (; f < s; )
    g = u[f++], c[y++] = l[g >>> 24] << 16 | l[g >>> 16 & 255], c[y++] = l[g >>> 8 & 255] << 16 | l[g & 255];
  for (f <<= 2; f < n; ) o[f] = l[r[f++]];
  return ba.decode(o.subarray(0, n));
}
__name(xa, "xa");
a(xa, "_toHex");
function Sa(r, e = {}) {
  let t = "", n = r.length, i = wa >>> 1, s = Math.ceil(n / i), o = new Uint16Array(s > 1 ? i : n);
  for (let u = 0; u < s; u++) {
    let c = u * i, l = c + i;
    t += xa(r.subarray(c, l), ga(ma(
      {},
      e
    ), { scratchArr: o }));
  }
  return t;
}
__name(Sa, "Sa");
a(Sa, "_toHexChunked");
function xi(r, e = {}) {
  return e.alphabet !== "upper" && typeof r.toHex == "function" ? r.toHex() : Sa(r, e);
}
__name(xi, "xi");
a(xi, "toHex");
p();
var gt = class gt2 {
  static {
    __name(this, "gt");
  }
  constructor(e, t) {
    this.strings = e;
    this.values = t;
  }
  toParameterizedQuery(e = { query: "", params: [] }) {
    let { strings: t, values: n } = this;
    for (let i = 0, s = t.length; i < s; i++) if (e.query += t[i], i < n.length) {
      let o = n[i];
      if (o instanceof Ge) e.query += o.sql;
      else if (o instanceof Ae) if (o.queryData instanceof gt2) o.queryData.toParameterizedQuery(
        e
      );
      else {
        if (o.queryData.params?.length) throw new Error("This query is not composable");
        e.query += o.queryData.query;
      }
      else {
        let { params: u } = e;
        u.push(o), e.query += "$" + u.length, (o instanceof d || ArrayBuffer.isView(o)) && (e.query += "::bytea");
      }
    }
    return e;
  }
};
a(gt, "SqlTemplate");
var $e = gt;
var Yt = class Yt2 {
  static {
    __name(this, "Yt");
  }
  constructor(e) {
    this.sql = e;
  }
};
a(Yt, "UnsafeRawSql");
var Ge = Yt;
var ss = xe(St());
var os = xe(rt());
var At = class At2 extends Error {
  static {
    __name(this, "At");
  }
  constructor(t) {
    super(t);
    E(this, "name", "NeonDbError");
    E(this, "severity");
    E(this, "code");
    E(this, "detail");
    E(this, "hint");
    E(this, "position");
    E(this, "internalPosition");
    E(
      this,
      "internalQuery"
    );
    E(this, "where");
    E(this, "schema");
    E(this, "table");
    E(this, "column");
    E(this, "dataType");
    E(this, "constraint");
    E(this, "file");
    E(this, "line");
    E(this, "routine");
    E(this, "sourceError");
    "captureStackTrace" in Error && typeof Error.captureStackTrace == "function" && Error.captureStackTrace(this, At2);
  }
};
a(
  At,
  "NeonDbError"
);
var we = At;
var rs = "transaction() expects an array of queries, or a function returning an array of queries";
var Pu = ["severity", "code", "detail", "hint", "position", "internalPosition", "internalQuery", "where", "schema", "table", "column", "dataType", "constraint", "file", "line", "routine"];
function Ru(r) {
  return r instanceof d ? "\\x" + xi(r) : r;
}
__name(Ru, "Ru");
a(Ru, "encodeBuffersAsBytea");
function ns(r) {
  let { query: e, params: t } = r instanceof $e ? r.toParameterizedQuery() : r;
  return { query: e, params: t.map((n) => Ru((0, os.prepareValue)(n))) };
}
__name(ns, "ns");
a(ns, "prepareQuery");
function as(r, {
  arrayMode: e,
  fullResults: t,
  fetchOptions: n,
  isolationLevel: i,
  readOnly: s,
  deferrable: o,
  authToken: u
} = {}) {
  if (!r) throw new Error("No database connection string was provided to `neon()`. Perhaps an environment variable has not been set?");
  let c;
  try {
    c = Vt(r);
  } catch {
    throw new Error("Database connection string provided to `neon()` is not a valid URL. Connection string: " + String(r));
  }
  let {
    protocol: l,
    username: f,
    hostname: y,
    port: g,
    pathname: A
  } = c;
  if (l !== "postgres:" && l !== "postgresql:" || !f || !y || !A) throw new Error(
    "Database connection string format for `neon()` should be: postgresql://user:password@host.tld/dbname?option=value"
  );
  function C(P, ...L) {
    if (!(Array.isArray(P) && Array.isArray(P.raw) && Array.isArray(L))) throw new Error(
      'This function can now be called only as a tagged-template function: sql`SELECT ${value}`, not sql("SELECT $1", [value], options). For a conventional function call with value placeholders ($1, $2, etc.), use sql.query("SELECT $1", [value], options).'
    );
    return new Ae(Q, new $e(P, L));
  }
  __name(C, "C");
  a(C, "templateFn"), C.query = (P, L, _) => new Ae(Q, { query: P, params: L ?? [] }, _), C.unsafe = (P) => new Ge(P), C.transaction = async (P, L) => {
    if (typeof P == "function" && (P = P(C)), !Array.isArray(P)) throw new Error(rs);
    P.forEach((H) => {
      if (!(H instanceof Ae)) throw new Error(
        rs
      );
    });
    let _ = P.map((H) => H.queryData), x = P.map((H) => H.opts ?? {});
    return Q(_, x, L);
  };
  async function Q(P, L, _) {
    let {
      fetchEndpoint: x,
      fetchFunction: H
    } = ge, le = Array.isArray(P) ? { queries: P.map((J) => ns(J)) } : ns(P), N = n ?? {}, ie = e ?? false, se = t ?? false, oe = i, B = s, $ = o;
    _ !== void 0 && (_.fetchOptions !== void 0 && (N = { ...N, ..._.fetchOptions }), _.arrayMode !== void 0 && (ie = _.arrayMode), _.fullResults !== void 0 && (se = _.fullResults), _.isolationLevel !== void 0 && (oe = _.isolationLevel), _.readOnly !== void 0 && (B = _.readOnly), _.deferrable !== void 0 && ($ = _.deferrable)), L !== void 0 && !Array.isArray(L) && L.fetchOptions !== void 0 && (N = { ...N, ...L.fetchOptions });
    let fe = u;
    !Array.isArray(L) && L?.authToken !== void 0 && (fe = L.authToken);
    let Ce = typeof x == "function" ? x(y, g, { jwtAuth: fe !== void 0 }) : x, he = {
      "Neon-Connection-String": r,
      "Neon-Raw-Text-Output": "true",
      "Neon-Array-Mode": "true"
    }, _e = await Bu(fe);
    _e && (he.Authorization = `Bearer ${_e}`), Array.isArray(P) && (oe !== void 0 && (he["Neon-Batch-Isolation-Level"] = oe), B !== void 0 && (he["Neon-Batch-Read-Only"] = String(B)), $ !== void 0 && (he["Neon-Batch-Deferrable"] = String(
      $
    )));
    let ae;
    try {
      ae = await (H ?? fetch)(Ce, { method: "POST", body: JSON.stringify(le), headers: he, ...N });
    } catch (J) {
      let j = new we(`Error connecting to database: ${J}`);
      throw j.sourceError = J, j;
    }
    if (ae.ok) {
      let J = await ae.json();
      if (Array.isArray(P)) {
        let j = J.results;
        if (!Array.isArray(j)) throw new we("Neon internal error: unexpected result format");
        return j.map((X, V) => {
          let Ne = L[V] ?? {}, wo = Ne.arrayMode ?? ie, bo = Ne.fullResults ?? se;
          return is(X, { arrayMode: wo, fullResults: bo, types: Ne.types });
        });
      } else {
        let j = L ?? {}, X = j.arrayMode ?? ie, V = j.fullResults ?? se;
        return is(J, { arrayMode: X, fullResults: V, types: j.types });
      }
    } else {
      let { status: J } = ae;
      if (J === 400) {
        let j = await ae.json(), X = new we(j.message);
        for (let V of Pu) X[V] = j[V] ?? void 0;
        throw X;
      } else {
        let j = await ae.text();
        throw new we(`Server error (HTTP status ${J}): ${j}`);
      }
    }
  }
  __name(Q, "Q");
  return a(Q, "execute"), C;
}
__name(as, "as");
a(as, "neon");
var fr = class fr2 {
  static {
    __name(this, "fr");
  }
  constructor(e, t, n) {
    this.execute = e;
    this.queryData = t;
    this.opts = n;
  }
  then(e, t) {
    return this.execute(this.queryData, this.opts).then(e, t);
  }
  catch(e) {
    return this.execute(this.queryData, this.opts).catch(
      e
    );
  }
  finally(e) {
    return this.execute(this.queryData, this.opts).finally(e);
  }
};
a(fr, "NeonQueryPromise");
var Ae = fr;
function is(r, { arrayMode: e, fullResults: t, types: n }) {
  let i = new ss.default(n), s = r.fields.map((c) => c.name), o = r.fields.map((c) => i.getTypeParser(c.dataTypeID)), u = e === true ? r.rows.map((c) => c.map((l, f) => l === null ? null : o[f](
    l
  ))) : r.rows.map((c) => Object.fromEntries(c.map((l, f) => [s[f], l === null ? null : o[f](l)])));
  return t ? (r.viaNeonFetch = true, r.rowAsArray = e, r.rows = u, r._parsers = o, r._types = i, r) : u;
}
__name(is, "is");
a(is, "processQueryResult");
async function Bu(r) {
  if (typeof r == "string") return r;
  if (typeof r == "function") try {
    return await Promise.resolve(r());
  } catch (e) {
    let t = new we("Error getting auth token.");
    throw e instanceof Error && (t = new we(`Error getting auth token: ${e.message}`)), t;
  }
}
__name(Bu, "Bu");
a(Bu, "getAuthToken");
p();
var mo = xe(ot());
p();
var yo = xe(ot());
var Bn = class Bn2 extends yo.Client {
  static {
    __name(this, "Bn");
  }
  constructor(t) {
    super(t);
    this.config = t;
  }
  get neonConfig() {
    return this.connection.stream;
  }
  connect(t) {
    let { neonConfig: n } = this;
    n.forceDisablePgSSL && (this.ssl = this.connection.ssl = false), this.ssl && n.useSecureWebSocket && console.warn("SSL is enabled for both Postgres (e.g. ?sslmode=require in the connection string + forceDisablePgSSL = false) and the WebSocket tunnel (useSecureWebSocket = true). Double encryption will increase latency and CPU usage. It may be appropriate to disable SSL in the Postgres connection parameters or set forceDisablePgSSL = true.");
    let i = typeof this.config != "string" && this.config?.host !== void 0 || typeof this.config != "string" && this.config?.connectionString !== void 0 || m.env.PGHOST !== void 0, s = m.env.USER ?? m.env.USERNAME;
    if (!i && this.host === "localhost" && this.user === s && this.database === s && this.password === null) throw new Error(`No database host or connection string was set, and key parameters have default values (host: localhost, user: ${s}, db: ${s}, password: null). Is an environment variable missing? Alternatively, if you intended to connect with these parameters, please set the host to 'localhost' explicitly.`);
    let o = super.connect(t), u = n.pipelineTLS && this.ssl, c = n.pipelineConnect === "password";
    if (!u && !n.pipelineConnect) return o;
    let l = this.connection;
    if (u && l.on(
      "connect",
      () => l.stream.emit("data", "S")
    ), c) {
      l.removeAllListeners("authenticationCleartextPassword"), l.removeAllListeners("readyForQuery"), l.once("readyForQuery", () => l.on("readyForQuery", this._handleReadyForQuery.bind(this)));
      let f = this.ssl ? "sslconnect" : "connect";
      l.on(f, () => {
        this._handleAuthCleartextPassword(), this._handleReadyForQuery();
      });
    }
    return o;
  }
  async _handleAuthSASLContinue(t) {
    if (typeof crypto > "u" || crypto.subtle === void 0 || crypto.subtle.importKey === void 0) throw new Error("Cannot use SASL auth when `crypto.subtle` is not defined");
    let n = crypto.subtle, i = this.saslSession, s = this.password, o = t.data;
    if (i.message !== "SASLInitialResponse" || typeof s != "string" || typeof o != "string") throw new Error("SASL: protocol error");
    let u = Object.fromEntries(o.split(",").map((X) => {
      if (!/^.=/.test(X)) throw new Error("SASL: Invalid attribute pair entry");
      let V = X[0], Ne = X.substring(2);
      return [V, Ne];
    })), c = u.r, l = u.s, f = u.i;
    if (!c || !/^[!-+--~]+$/.test(c)) throw new Error(
      "SASL: SCRAM-SERVER-FIRST-MESSAGE: nonce missing/unprintable"
    );
    if (!l || !/^(?:[a-zA-Z0-9+/]{4})*(?:[a-zA-Z0-9+/]{2}==|[a-zA-Z0-9+/]{3}=)?$/.test(l)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: salt missing/not base64");
    if (!f || !/^[1-9][0-9]*$/.test(f)) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: missing/invalid iteration count");
    if (!c.startsWith(
      i.clientNonce
    )) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce does not start with client nonce");
    if (c.length === i.clientNonce.length) throw new Error("SASL: SCRAM-SERVER-FIRST-MESSAGE: server nonce is too short");
    let y = parseInt(f, 10), g = d.from(l, "base64"), A = new TextEncoder(), C = A.encode(s), Q = await n.importKey("raw", C, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), P = new Uint8Array(await n.sign("HMAC", Q, d.concat([g, d.from([0, 0, 0, 1])]))), L = P;
    for (var _ = 0; _ < y - 1; _++) P = new Uint8Array(await n.sign(
      "HMAC",
      Q,
      P
    )), L = d.from(L.map((X, V) => L[V] ^ P[V]));
    let x = L, H = await n.importKey("raw", x, { name: "HMAC", hash: {
      name: "SHA-256"
    } }, false, ["sign"]), le = new Uint8Array(await n.sign("HMAC", H, A.encode("Client Key"))), N = await n.digest("SHA-256", le), ie = "n=*,r=" + i.clientNonce, se = "r=" + c + ",s=" + l + ",i=" + y, oe = "c=biws,r=" + c, B = ie + "," + se + "," + oe, $ = await n.importKey("raw", N, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var fe = new Uint8Array(
      await n.sign("HMAC", $, A.encode(B))
    ), Ce = d.from(le.map((X, V) => le[V] ^ fe[V])), he = Ce.toString("base64");
    let _e = await n.importKey("raw", x, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]), ae = await n.sign("HMAC", _e, A.encode(
      "Server Key"
    )), J = await n.importKey("raw", ae, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
    var j = d.from(await n.sign("HMAC", J, A.encode(B)));
    i.message = "SASLResponse", i.serverSignature = j.toString("base64"), i.response = oe + ",p=" + he, this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);
  }
};
a(Bn, "NeonClient");
var ut = Bn;
We();
var go = xe(It());
function wl(r, e) {
  if (e) return { callback: e, result: void 0 };
  let t, n, i = a(function(o, u) {
    o ? t(o) : n(u);
  }, "cb"), s = new r(function(o, u) {
    n = o, t = u;
  });
  return { callback: i, result: s };
}
__name(wl, "wl");
a(wl, "promisify");
var Fn = class Fn2 extends mo.Pool {
  static {
    __name(this, "Fn");
  }
  constructor() {
    super(...arguments);
    E(this, "Client", ut);
    E(this, "hasFetchUnsupportedListeners", false);
    E(this, "addListener", this.on);
  }
  on(t, n) {
    return t !== "error" && (this.hasFetchUnsupportedListeners = true), super.on(t, n);
  }
  query(t, n, i) {
    if (!ge.poolQueryViaFetch || this.hasFetchUnsupportedListeners || typeof t == "function") return super.query(
      t,
      n,
      i
    );
    typeof n == "function" && (i = n, n = void 0);
    let s = wl(this.Promise, i);
    i = s.callback;
    try {
      let o = new go.default(
        this.options
      ), u = encodeURIComponent, c = encodeURI, l = `postgresql://${u(o.user)}:${u(o.password)}@${u(o.host)}/${c(o.database)}`, f = typeof t == "string" ? t : t.text, y = n ?? t.values ?? [];
      as(l, { fullResults: true, arrayMode: t.rowMode === "array" }).query(f, y, { types: t.types ?? this.options?.types }).then((A) => i(void 0, A)).catch((A) => i(
        A
      ));
    } catch (o) {
      i(o);
    }
    return s.result;
  }
};
a(Fn, "NeonPool");
var Ln = Fn;
We();
var kn = xe(ot());
var export_DatabaseError = kn.DatabaseError;
var export_defaults = kn.defaults;
var export_types = kn.types;

// api/routes/packages.js
async function handlePackages(request3) {
  const corsHeaders = {
    "Access-Control-Allow-Origin": "*",
    "Access-Control-Allow-Headers": "Content-Type",
    "Access-Control-Allow-Methods": "GET, POST, OPTIONS"
  };
  const pool = new Ln({
    connectionString: "postgresql://traveltours_owner:BaZU9hmKqH8k@ep-cold-base-a53m37xe.us-east-2.aws.neon.tech/traveltours?sslmode=require"
  });
  try {
    if (request3.method === "GET") {
      const { rows } = await pool.query("SELECT * FROM packages");
      return new Response(JSON.stringify(rows), {
        status: 200,
        headers: corsHeaders
        // Remove if not needed for CORS
      });
    }
    return new Response("Not found", { status: 404, headers: corsHeaders });
  } catch (err) {
    return new Response(
      JSON.stringify({ error: "Internal Server Error", details: err.message }),
      {
        status: 500,
        headers: corsHeaders
      }
    );
  } finally {
    await pool.end();
  }
}
__name(handlePackages, "handlePackages");

// api/routes/auth.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();

// node_modules/firebase-admin/lib/esm/app/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_app = __toESM(require_app(), 1);
var AppErrorCodes = import_app.default.AppErrorCodes;
var FirebaseAppError = import_app.default.FirebaseAppError;
var SDK_VERSION = import_app.default.SDK_VERSION;
var applicationDefault = import_app.default.applicationDefault;
var cert = import_app.default.cert;
var deleteApp = import_app.default.deleteApp;
var getApp = import_app.default.getApp;
var getApps = import_app.default.getApps;
var initializeApp = import_app.default.initializeApp;
var refreshToken = import_app.default.refreshToken;

// node_modules/firebase-admin/lib/esm/auth/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_auth = __toESM(require_auth2(), 1);
var Auth = import_auth.default.Auth;
var AuthClientErrorCode = import_auth.default.AuthClientErrorCode;
var BaseAuth = import_auth.default.BaseAuth;
var FirebaseAuthError = import_auth.default.FirebaseAuthError;
var MultiFactorInfo = import_auth.default.MultiFactorInfo;
var MultiFactorSettings = import_auth.default.MultiFactorSettings;
var PhoneMultiFactorInfo = import_auth.default.PhoneMultiFactorInfo;
var ProjectConfig = import_auth.default.ProjectConfig;
var ProjectConfigManager = import_auth.default.ProjectConfigManager;
var Tenant = import_auth.default.Tenant;
var TenantAwareAuth = import_auth.default.TenantAwareAuth;
var TenantManager = import_auth.default.TenantManager;
var UserInfo = import_auth.default.UserInfo;
var UserMetadata = import_auth.default.UserMetadata;
var UserRecord = import_auth.default.UserRecord;
var getAuth = import_auth.default.getAuth;

// node_modules/firebase-admin/lib/esm/database/index.js
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var import_database = __toESM(require_database2(), 1);
var FirebaseDatabaseError = import_database.default.FirebaseDatabaseError;
var ServerValue = import_database.default.ServerValue;
var enableLogging = import_database.default.enableLogging;
var getDatabase = import_database.default.getDatabase;
var getDatabaseWithUrl = import_database.default.getDatabaseWithUrl;

// api/routes/auth.js
var firebaseAdminApp = initializeApp({
  credential: cert({
    projectId: process.env.FIREBASE_PROJECT_ID,
    clientEmail: process.env.FIREBASE_CLIENT_EMAIL,
    privateKey: process.env.FIREBASE_PRIVATE_KEY.replace(/\\n/g, "\n")
  }),
  databaseURL: `https://jelvintour-default-rtdb.firebaseio.com/`
});
var auth_default = {
  async fetch(request3, env2, ctx) {
    if (request3.method !== "POST") {
      return new Response("Method Not Allowed", { status: 405 });
    }
    try {
      const { idToken } = await request3.json();
      if (!idToken) {
        return new Response(JSON.stringify({ error: "Missing idToken" }), { status: 400 });
      }
      const decoded = await getAuth(firebaseAdminApp).verifyIdToken(idToken);
      const { uid, email, name, picture } = decoded;
      const db = getDatabase(firebaseAdminApp);
      const userRef = db.ref(`users/${uid}`);
      await userRef.update({
        email,
        name,
        picture,
        lastLogin: Date.now()
      });
      const sessionToken = JSON.stringify({ uid, email });
      return new Response(JSON.stringify({ user: { uid, email, name, picture } }), {
        status: 200,
        headers: {
          "Set-Cookie": `token=${encodeURIComponent(sessionToken)}; Path=/; HttpOnly; Secure; SameSite=Strict`,
          "Content-Type": "application/json"
        }
      });
    } catch (err) {
      return new Response(JSON.stringify({ error: err.message }), { status: 401 });
    }
  }
};

// api/index.js
var api_default = {
  async fetch(request3) {
    const url = new URL(request3.url);
    if (request3.method === "OPTIONS") {
      return new Response(null, {
        status: 204,
        headers: {
          "Access-Control-Allow-Origin": "*",
          // Allow all origins (replace '*' with your frontend domain in production)
          "Access-Control-Allow-Methods": "GET, POST, PUT, OPTIONS",
          // Allowed methods
          "Access-Control-Allow-Headers": "x-admin-token, Content-Type"
          // "Access-Control-Allow-Headers": "Content-Type", 
        }
      });
    }
    if (url.pathname.startsWith("/api/packages")) {
      return handlePackages(request3);
    }
    if (url.pathname.startsWith("/api/auth")) {
      return auth_default.fetch(request3);
    }
    return new Response("Not Found", { status: 404 });
  }
};

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/templates/middleware/middleware-ensure-req-body-drained.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var drainBody = /* @__PURE__ */ __name(async (request3, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request3, env2);
  } finally {
    try {
      if (request3.body !== null && !request3.bodyUsed) {
        const reader = request3.body.getReader();
        while (!(await reader.read()).done) {
        }
      }
    } catch (e) {
      console.error("Failed to drain the unused request body.", e);
    }
  }
}, "drainBody");
var middleware_ensure_req_body_drained_default = drainBody;

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/templates/middleware/middleware-miniflare3-json-error.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
function reduceError(e) {
  return {
    name: e?.name,
    message: e?.message ?? String(e),
    stack: e?.stack,
    cause: e?.cause === void 0 ? void 0 : reduceError(e.cause)
  };
}
__name(reduceError, "reduceError");
var jsonError = /* @__PURE__ */ __name(async (request3, env2, _ctx, middlewareCtx) => {
  try {
    return await middlewareCtx.next(request3, env2);
  } catch (e) {
    const error3 = reduceError(e);
    return Response.json(error3, {
      status: 500,
      headers: { "MF-Experimental-Error-Stack": "true" }
    });
  }
}, "jsonError");
var middleware_miniflare3_json_error_default = jsonError;

// .wrangler/tmp/bundle-JHzrC7/middleware-insertion-facade.js
var __INTERNAL_WRANGLER_MIDDLEWARE__ = [
  middleware_ensure_req_body_drained_default,
  middleware_miniflare3_json_error_default
];
var middleware_insertion_facade_default = api_default;

// ../../../../../../opt/homebrew/lib/node_modules/wrangler/templates/middleware/common.ts
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_process();
init_virtual_unenv_global_polyfill_cloudflare_unenv_preset_node_console();
init_performance2();
var __facade_middleware__ = [];
function __facade_register__(...args) {
  __facade_middleware__.push(...args.flat());
}
__name(__facade_register__, "__facade_register__");
function __facade_invokeChain__(request3, env2, ctx, dispatch, middlewareChain) {
  const [head, ...tail] = middlewareChain;
  const middlewareCtx = {
    dispatch,
    next(newRequest, newEnv) {
      return __facade_invokeChain__(newRequest, newEnv, ctx, dispatch, tail);
    }
  };
  return head(request3, env2, ctx, middlewareCtx);
}
__name(__facade_invokeChain__, "__facade_invokeChain__");
function __facade_invoke__(request3, env2, ctx, dispatch, finalMiddleware) {
  return __facade_invokeChain__(request3, env2, ctx, dispatch, [
    ...__facade_middleware__,
    finalMiddleware
  ]);
}
__name(__facade_invoke__, "__facade_invoke__");

// .wrangler/tmp/bundle-JHzrC7/middleware-loader.entry.ts
var __Facade_ScheduledController__ = class ___Facade_ScheduledController__ {
  constructor(scheduledTime, cron, noRetry) {
    this.scheduledTime = scheduledTime;
    this.cron = cron;
    this.#noRetry = noRetry;
  }
  static {
    __name(this, "__Facade_ScheduledController__");
  }
  #noRetry;
  noRetry() {
    if (!(this instanceof ___Facade_ScheduledController__)) {
      throw new TypeError("Illegal invocation");
    }
    this.#noRetry();
  }
};
function wrapExportedHandler(worker) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return worker;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  const fetchDispatcher = /* @__PURE__ */ __name(function(request3, env2, ctx) {
    if (worker.fetch === void 0) {
      throw new Error("Handler does not export a fetch() function.");
    }
    return worker.fetch(request3, env2, ctx);
  }, "fetchDispatcher");
  return {
    ...worker,
    fetch(request3, env2, ctx) {
      const dispatcher = /* @__PURE__ */ __name(function(type2, init) {
        if (type2 === "scheduled" && worker.scheduled !== void 0) {
          const controller = new __Facade_ScheduledController__(
            Date.now(),
            init.cron ?? "",
            () => {
            }
          );
          return worker.scheduled(controller, env2, ctx);
        }
      }, "dispatcher");
      return __facade_invoke__(request3, env2, ctx, dispatcher, fetchDispatcher);
    }
  };
}
__name(wrapExportedHandler, "wrapExportedHandler");
function wrapWorkerEntrypoint(klass) {
  if (__INTERNAL_WRANGLER_MIDDLEWARE__ === void 0 || __INTERNAL_WRANGLER_MIDDLEWARE__.length === 0) {
    return klass;
  }
  for (const middleware of __INTERNAL_WRANGLER_MIDDLEWARE__) {
    __facade_register__(middleware);
  }
  return class extends klass {
    #fetchDispatcher = /* @__PURE__ */ __name((request3, env2, ctx) => {
      this.env = env2;
      this.ctx = ctx;
      if (super.fetch === void 0) {
        throw new Error("Entrypoint class does not define a fetch() function.");
      }
      return super.fetch(request3);
    }, "#fetchDispatcher");
    #dispatcher = /* @__PURE__ */ __name((type2, init) => {
      if (type2 === "scheduled" && super.scheduled !== void 0) {
        const controller = new __Facade_ScheduledController__(
          Date.now(),
          init.cron ?? "",
          () => {
          }
        );
        return super.scheduled(controller);
      }
    }, "#dispatcher");
    fetch(request3) {
      return __facade_invoke__(
        request3,
        this.env,
        this.ctx,
        this.#dispatcher,
        this.#fetchDispatcher
      );
    }
  };
}
__name(wrapWorkerEntrypoint, "wrapWorkerEntrypoint");
var WRAPPED_ENTRY;
if (typeof middleware_insertion_facade_default === "object") {
  WRAPPED_ENTRY = wrapExportedHandler(middleware_insertion_facade_default);
} else if (typeof middleware_insertion_facade_default === "function") {
  WRAPPED_ENTRY = wrapWorkerEntrypoint(middleware_insertion_facade_default);
}
var middleware_loader_entry_default = WRAPPED_ENTRY;
export {
  __INTERNAL_WRANGLER_MIDDLEWARE__,
  middleware_loader_entry_default as default
};
/*! Bundled license information:

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

firebase-admin/lib/utils/deep-copy.js:
firebase-admin/lib/utils/error.js:
firebase-admin/lib/utils/validator.js:
firebase-admin/lib/utils/index.js:
firebase-admin/lib/app/firebase-app.js:
firebase-admin/lib/utils/api-request.js:
firebase-admin/lib/auth/auth-api-request.js:
firebase-admin/lib/auth/token-generator.js:
firebase-admin/lib/auth/user-record.js:
firebase-admin/lib/auth/auth.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/credential-internal.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * @license
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/app/lifecycle.js:
firebase-admin/lib/app/credential-factory.js:
firebase-admin/lib/app/index.js:
firebase-admin/lib/utils/crypto-signer.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/user-import-builder.js:
firebase-admin/lib/auth/action-code-settings-builder.js:
firebase-admin/lib/auth/auth-config.js:
firebase-admin/lib/auth/token-verifier.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/tenant.js:
firebase-admin/lib/auth/tenant-manager.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * Copyright 2019 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/identifier.js:
firebase-admin/lib/auth/index.js:
firebase-admin/lib/database/database.js:
firebase-admin/lib/database/index.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/project-config.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * Copyright 2022 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/jwt.js:
firebase-admin/lib/auth/base-auth.js:
  (*! firebase-admin v13.0.1 *)
  (*!
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/project-config-manager.js:
  (*! firebase-admin v13.0.1 *)

@firebase/util/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2022 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/logger/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/component/dist/index.cjs.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/database-compat/dist/index.standalone.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2023 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@neondatabase/serverless/index.mjs:
  (*! Bundled license information:
  
  ieee754/index.js:
    (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  
  buffer/index.js:
    (*!
     * The buffer module from node.js, for the browser.
     *
     * @author   Feross Aboukhadijeh <https://feross.org>
     * @license  MIT
     *)
  *)
*/
//# sourceMappingURL=index.js.map
